- en: Chapter 5. Exploiting Services with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。用Python利用服务
- en: One of the big misconceptions with penetration testing and exploitation of services
    today, is the prevalence of exploitable **Remote Code Execution** (**RCE**) vulnerabilities.
    The reality is that, the days of finding hundreds of easily exploitable services
    that only required an **Internet Protocol** (**IP**) address to be plugged into
    a tool are pretty much gone. You will still find vulnerabilities that can be exploited
    by overflowing the stack or heap, they are just significantly reduced or more
    complex. We will explain the reasons why, these are more difficult to exploit
    in today's software in [Chapter 8](ch08.html "Chapter 8. Exploit Development with
    Python, Metasploit, and Immunity"), *Exploit Development with Python, Metasploit,
    and Immunity*, don't worry we will get to that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天渗透测试和利用服务的一个重要误解是，可利用的**远程代码执行**（**RCE**）漏洞的普遍存在。现实是，找到数百个易受攻击的服务，只需要将**Internet
    Protocol**（**IP**）地址插入工具中即可利用的日子已经基本结束了。你仍然会发现可以通过溢出堆栈或堆来利用的漏洞，只是数量大大减少或更加复杂。我们将解释为什么在今天的软件中这些漏洞更难利用，在[第8章](ch08.html
    "第8章。用Python、Metasploit和Immunity进行利用开发")中，*用Python、Metasploit和Immunity进行利用开发*，别担心，我们会讲到的。
- en: So if you are expecting to walk into a network every time and exploit Microsoft
    Security Bulletins MS08-067, MS03-024, or MS06-40 to get your foothold, you are
    sorely mistaken. Do not fret, they are still out there, but instead of finding
    it on every host, there might be one system in the network with it. Worse yet,
    for us as simulated malicious actors, it may not even provide us access to a box
    that would allow us to move forward in our engagement. Usually, it turns out to
    be a legacy system or a vendor product that is not even attached to the Domain
    with different credential sets. Now, that is not to say, this is always the case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你期望每次进入网络并利用Microsoft Security Bulletins MS08-067、MS03-024或MS06-40来立足，那你大错特错了。不要担心，它们仍然存在，但不是在每台主机上都能找到，可能只有网络中的一台系统有这些漏洞。更糟糕的是，对于我们作为模拟恶意行为者来说，它甚至可能无法让我们访问一个允许我们在参与中前进的盒子。通常情况下，它可能是一个遗留系统或一个甚至没有连接到不同凭证集的域的供应商产品。当然，并不是总是这种情况。
- en: The number of RCE vulnerabilities that will be found completely depends on the
    organization's security maturity. This has nothing to do with size or budget,
    but instead the strategy in which their security program is implemented. Organizations
    with a weak security strategy and newly founded programs will have more vulnerabilities
    like these, and organizations with a better strategy will have less. An additional
    factor many new penetration testers overlook, is the talent; the company may have
    employed on the defensive side, and this can significantly impact their ability
    to operate in an environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的RCE漏洞数量完全取决于组织的安全成熟度。这与规模或预算无关，而是与他们的安全计划实施策略有关。安全策略薄弱且新成立的程序的组织将有更多这样的漏洞，而安全策略更好的组织将有更少。许多新的渗透测试人员忽视的另一个因素是人才；公司可能在防御方面雇佣的人员，这可能会显著影响他们在环境中的操作能力。
- en: Even if an organization has a weak security strategy, it may still have a pretty
    tough tactical security posture, if it has hired highly skilled engineers and
    administrators. At a tactical level, really smart technical staff means, strong
    controls may be put in place, but if there is no overarching security strategy,
    devices may be missed and gaps in a relevant strong technical posture could be
    identified. An additional risk comes from when those skilled members leave the
    organization, or worse if they go rogue.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个组织有一个薄弱的安全策略，如果它雇佣了高技能的工程师和管理员，它可能仍然拥有一个相当强大的战术安全姿态。在战术层面上，非常聪明的技术人员意味着可以制定强有力的控制措施，但如果没有一个全面的安全策略，设备可能会被忽视，相关强大的技术姿态中可能存在漏洞。另一个风险是当这些技能成员离开组织，或者更糟糕的是，如果他们变得叛逆。
- en: Either way, any strong security controls could now be considered compromised
    at that point, if there are no established processes and procedures in place.
    Additionally, holistic and validated implementation of controls may not be possible.
    The reason this is important to you as a penetration tester, is so that you can
    understand the ebb and flow of an organization's information security program
    and common causes. The management will be looking to you for answers to some of
    these questions, and the indicators you see will help you diagnose the problems
    and identify root causes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果没有建立的流程和程序，任何强大的安全控制在那一点都可能被认为已经受到了损害。此外，全面和验证的控制实施可能是不可能的。作为渗透测试人员，这对你来说很重要，因为你可以理解组织信息安全计划的起伏和流动以及常见原因。管理层将寻求你对这些问题的答案，你所看到的指标将帮助你诊断问题并确定根本原因。
- en: Understanding the new age of service exploitation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务利用的新时代。
- en: Throughout the previous chapters, there has been a preparation to show you a
    simulated example of new age exploitation. This means, we are taking advantage
    of misconfigurations, default settings, bad practices, and a lack of security
    awareness. Instead of control gaps being found in the developed code, it is instead
    within the implementation in an environment to include training of its people.
    The specific manner of entering or moving through a network will depend on the
    network, and attack vectors change, instead of memorizing a specific vector, focus
    on building a mind-set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，已经做好了准备，向你展示了一个新时代利用的模拟示例。这意味着，我们正在利用配置错误、默认设置、不良实践和安全意识的缺乏。与其在开发的代码中找到控制差距，不如在环境中包括人员培训的实施中找到。进入或穿越网络的特定方式将取决于网络，攻击向量会发生变化，而不是记住特定的向量，要专注于建立一种思维方式。
- en: Exploitation today means the identification of already present accesses, and
    stealing a component of that access, compromising systems with that access level,
    capturing details on those systems, and moving laterally till you identify critical
    data or new levels of access. Once you identify access into a system, you are
    going to try and find details that will allow you to move and access other systems.
    This means configuration files with usernames and passwords in them, stored username
    and passwords, or mounted shares. Each of these components will provide you information
    to gain access to other hosts. The benefit to attacking systems in this manner
    is that it is much quieter than exploiting RCE's and uploading payloads; you move
    within the bounds of the requisite protocols, and you do a better job of simulating
    real malicious actors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的剥削意味着识别已经存在的访问权限，并窃取该访问权限的一部分，通过该访问级别来妥协系统，捕获这些系统的详细信息，并横向移动，直到识别出关键数据或新的访问级别。一旦你确定了对系统的访问权限，你将尝试查找允许你移动和访问其他系统的详细信息。这意味着配置文件中包含用户名和密码、存储的用户名和密码，或者挂载的共享文件。这些组件中的每一个都将为您提供信息，以获取对其他主机的访问权限。以这种方式攻击系统的好处在于它比利用RCE和上传有效载荷要安静得多；你在必要协议的范围内移动，并且你更好地模拟了真正的恶意行为者。
- en: To establish a consistent language, you move from one host to another, at the
    same privilege level which is called the lateral movement. When you find a higher
    level of privilege such as **Domain Administrator (DA)**, this is considered as
    a vertical movement or privilege escalation. When you use access to a host or
    network area to gain access to the systems that you could not see before, because
    of access controls or network segregation, this is called pivoting. Now that you
    understand the concepts and the terms, let us pop some boxes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立一种一致的语言，你从一个主机移动到另一个主机，以相同的特权级别，这被称为横向移动。当你找到更高级别的特权，比如**域管理员（DA）**，这被认为是垂直移动或特权升级。当你利用对主机或网络区域的访问权限来获取以前无法看到的系统的访问权限，因为访问控制或网络隔离，这被称为枢纽。现在你理解了这些概念和术语，让我们来弹出一些框。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To simulate this example, we are going to use a combination of Windows XP Mode
    and Metasploitable, both free to use. Details about setting up Metasploitable
    have already been provided. Details for Windows XP Mode can be found in the following
    two **Uniform Resource Locators** (**URLs**) [https://zeltser.com/windows-xp-mode-for-vmware-virtualization/](https://zeltser.com/windows-xp-mode-for-vmware-virtualization/)
    and [https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/](https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/).
    Remember to execute as many of these exploits the Windows machine may have, to
    get its Administrative Shares enabled. In a real Domain, this is common because
    they are often used to manage remote systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个例子，我们将使用Windows XP模式和Metasploitable的组合，这两者都是免费使用的。有关设置Metasploitable的详细信息已经提供。Windows
    XP模式的详细信息可以在以下两个**统一资源定位符**（**URL**）中找到[https://zeltser.com/windows-xp-mode-for-vmware-virtualization/](https://zeltser.com/windows-xp-mode-for-vmware-virtualization/)和[https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/](https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/)。记住要执行Windows机器可能有的尽可能多的这些漏洞，以启用其管理共享。在真实的域中，这是很常见的，因为它们经常用于管理远程系统。
- en: Understanding the chaining of exploits
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解利用的链接
- en: In the [Chapter 4](ch04.html "Chapter 4. Executing Credential Attacks with Python"),
    *Executing Credential Attacks with Python*, we showed how to identify legitimate
    accounts on a system or in an environment. Metasploitable is well documented,
    but the concepts to gain access to the system are identical to real life. Additionally,
    using exploitable boxes like these provides a fantastic training environment,
    with little risk to you, as a tester from both an availability perspective and
    a legal perspective. In the previous chapter, we verified the account `msfadmin`
    was present on the target system, and by default in Metasploitable, this account
    has the same password as the username.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。用Python执行凭据攻击")中，*用Python执行凭据攻击*，我们展示了如何在系统或环境中识别合法帐户。Metasploitable有很好的文档，但是获取对系统的访问权限的概念与现实生活中是相同的。此外，像这样的易受攻击的框提供了一个很棒的培训环境，对你来说，从可用性和法律角度来看，风险很小。在上一章中，我们验证了目标系统上存在`msfadmin`帐户，并且在Metasploitable中，默认情况下，该帐户的密码与用户名相同。
- en: Just like real environments, we research through websites and configuration
    channels to determine, what the default account and settings are, then use those
    to intelligently exploit the boxes. To validate these weaknesses, we are going
    to execute a password spray attack. This attack uses one password for many usernames,
    which prevents account lockout. It hinges on the principle of password reuse in
    an environment, or common passwords used by users in the region of the world you
    are in.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像真实环境一样，我们通过网站和配置渠道进行研究，以确定默认帐户和设置是什么，然后使用这些信息智能地利用这些框。为了验证这些弱点，我们将执行密码喷洒攻击。这种攻击使用一个密码对应多个用户名，这可以防止帐户锁定。它依赖于环境中密码重用的原则，或者用户在所在地区常用的密码。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most common passwords you will find used in the U.S. are Password1, Password123,
    the Season and the Year such as Summer2015, and some manipulation of the company
    name or username you are testing. To this day, I have found some form or shape
    of weak or default password on every engagement. If you watch or read about any
    of the major breaches, weak, default, or known passwords were a component of all
    of them. Also, note that all of these passwords would meet the Windows Active
    Directory password complexity requirements as shown here at [https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx](https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，你会发现最常用的密码是Password1、Password123，以及季节和年份，比如Summer2015，还有一些与公司名称或测试的用户名有关的密码。直到今天，我在每次参与的项目中都发现了某种形式的弱密码或默认密码。如果你观看或阅读任何一次重大的数据泄露，你会发现弱密码、默认密码或已知密码是其中的一个组成部分。另外，请注意，所有这些密码都符合Windows
    Active Directory密码复杂性要求，如[https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx](https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx)所示。
- en: Checking for weak, default, or known passwords
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查弱密码、默认密码或已知密码
- en: Execute a password spray against Metasploitable with the known username `msfadmin`,
    using a password that is the same as the username. We scan the target host for
    open services that we could test the credentials against.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已知用户名`msfadmin`执行对Metasploitable的密码喷洒攻击，使用与用户名相同的密码。我们扫描目标主机以查找我们可以测试凭据的开放服务。
- en: '![Checking for weak, default, or known passwords](img/B04315_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![检查弱密码、默认密码或已知密码](img/B04315_05_01.jpg)'
- en: We can then note that the **Secure Shell** (**SSH**) service is open, so that
    would be a great service to target. The compromise of this service would provide
    interactive access to the host. As an example we can launch Hydra against the
    SSH service to test for this specific weakness on the target box. As you can see
    in the following figure, we have validated the username and password combination
    that provides access to the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以注意到**Secure Shell** (**SSH**)服务是开放的，因此这将是一个很好的目标服务。攻击这项服务将提供对主机的交互式访问。例如，我们可以对SSH服务启动Hydra，以测试目标主机上的这个特定弱点。如下图所示，我们已经验证了提供对系统访问权限的用户名和密码组合。
- en: '![Checking for weak, default, or known passwords](img/B04315_05_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![检查弱密码、默认密码或已知密码](img/B04315_05_02.jpg)'
- en: Now, many new assessors would have just used Metasploit to execute this attack
    train as shown in [Chapter 3](ch03.html "Chapter 3. Identifying Targets with Nmap,
    Scapy, and Python"), *Physics Engine Integration*. The problem with that is, you
    cannot interact with the service, instead you have to work through a command shell
    verses a terminal access. To bypass this limitation, we will use the SSH client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多新的评估者可能会只使用Metasploit来执行这个攻击训练，如[第3章](ch03.html "第3章。使用Nmap、Scapy和Python识别目标")所示，*物理引擎集成*。问题在于，你无法与服务进行交互，而是必须通过命令行而不是终端访问。为了绕过这个限制，我们将使用SSH客户端。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A command shell does not allow for the use of interactive commands, where a
    terminal does. Exploitation of the SSH service via a SSH client provides terminal
    access, while the Metasploit module `ssh_login` provides command shell access.
    So, a terminal is preferred when possible as in the following example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行不允许使用交互式命令，而终端可以。通过SSH客户端利用SSH服务提供终端访问，而Metasploit模块`ssh_login`提供命令行访问。因此，在可能的情况下，终端是首选的，如下例所示。
- en: Gaining root access to the system
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取系统的root访问权限
- en: 'Now that we know the username and password combination to access this system,
    we can attempt to get access to the host and identify other details on the system.
    Specifically, we want to identify other username and passwords that might provide
    us access to other systems. To do this, we need to see if we can gain access to
    the `/etc/passwd` and `/etc/shadow` files on the target host. The combination
    of these two files will provide usernames on the host and the associated passwords.
    SSH into the system with the username and password: `msfadmin`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了访问该系统的用户名和密码组合，我们可以尝试访问主机并识别系统上的其他细节。具体来说，我们想要识别可能为我们提供访问其他系统的其他用户名和密码。为了做到这一点，我们需要查看是否可以访问目标主机上的`/etc/passwd`和`/etc/shadow`文件。这两个文件的组合将提供主机上的用户名和相关密码。使用用户名和密码`msfadmin`通过SSH登录系统。
- en: '![Gaining root access to the system](img/B04315_05_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![获取系统的root访问权限](img/B04315_05_03.jpg)'
- en: 'Now, we verify that we can access the `/etc/passwd` file, then we copy the
    file onto our Kali host using **Secure Copy** (**SCP**). The following successful
    copy shows that we have access to the file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们验证我们是否可以访问`/etc/passwd`文件，然后使用**Secure Copy** (**SCP**)将文件复制到我们的Kali主机上。以下成功的复制显示我们已经访问了该文件：
- en: '![Gaining root access to the system](img/B04315_05_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: 获取系统的root访问权限
- en: We then attempt to access `/etc/shadow` with our current access, and determine
    that it is not possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试使用当前访问权限访问`/etc/shadow`，并确定这是不可能的。
- en: '![Gaining root access to the system](img/B04315_05_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![获取系统的root访问权限](img/B04315_05_05.jpg)'
- en: This means we need to elevate our privileges locally to gain access to the file;
    in Linux this can be done in one of the four primary ways. The easiest way is
    to find stored usernames and passwords on the host, which is very common on Linux
    or UNIX servers. The second way, which requires no exploits to be brought into
    the system is by manipulating files, inputs, and outputs that have improper use
    of Sticky bits, **Set User Identifier** (**SUID**), and **Globally Unique Identifier**
    (**GUID**). The third is by exploiting a vulnerable version of the Kernel.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要提升本地权限以访问该文件；在Linux中，可以通过四种主要方式之一来实现。最简单的方法是找到主机上存储的用户名和密码，这在Linux或UNIX服务器上非常常见。第二种方法，不需要引入漏洞到系统中，是通过操纵文件、输入和输出，这些文件、输入和输出使用了Sticky位、**Set
    User Identifier** (**SUID**)和**Globally Unique Identifier** (**GUID**)的不当用法。第三种方法是利用内核的一个易受攻击的版本。
- en: 'The fourth method is the most overlooked manner to gain access to these files,
    and that is by `misconfigured sudo` access. All you have to do is execute `sudo
    su -`, which instantiates a session as root. The following shows that this as
    an example of simply gaining root access to a system:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方法是获得对这些文件的访问权限最容易被忽视的方式，即通过`misconfigured sudo`访问。您只需执行`sudo su -`，这将实例化一个作为root的会话。以下显示了这是一个简单获得系统根访问权限的例子：
- en: '![Gaining root access to the system](img/B04315_05_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_06.jpg)'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Technically, there is a fifth method, but that means exploiting a different
    service that may provide root access directly. This is available in Metasploitable,
    but less common in real environments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，还有第五种方法，但这意味着利用可能直接提供根访问权限的不同服务。这在Metasploitable中可用，但在真实环境中不太常见。
- en: Now keep in mind, that at this point we could easily grab both files and copy
    them off. To provide a more realistic example instead, we are going to highlight
    exploit research validation and execution against the Kernel. So, we need to verify
    the version of the Kernel on the system and see if it is vulnerable using the
    command `uname -a`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请记住，此时我们可以轻松地获取这两个文件并将它们复制出来。为了提供一个更真实的例子，我们将突出显示对内核的利用研究验证和执行。因此，我们需要验证系统上的内核版本，并使用命令`uname
    -a`来查看它是否容易受到攻击。
- en: '![Gaining root access to the system](img/B04315_05_07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_07.jpg)'
- en: The system is running the Kernel version 2.6.24, which is outdated and known
    to be vulnerable. This can be researched in a number of locations to include one
    of the most popular [http://www.cvedetails.com/](http://www.cvedetails.com/),
    which not only references vulnerabilities, it also points to locations where exploits
    can be found.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 系统正在运行内核版本2.6.24，这是过时的并且已知容易受到攻击。这可以在许多地方进行研究，包括最受欢迎的[http://www.cvedetails.com/](http://www.cvedetails.com/)之一，它不仅引用漏洞，还指出可以找到利用程序的位置。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never download an exploit from the Internet and directly exploit it on a system.
    Instead, always test in a lab environment, on a segregated system that has no
    connection to any other system or device. While testing it, make sure to run network
    taps and other monitoring tools to verify what activity might be run in the background.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要从互联网上下载利用程序并直接在系统上利用它。相反，始终在实验室环境中进行测试，在一个与任何其他系统或设备都没有连接的隔离系统上进行测试。在测试时，确保运行网络监听和其他监控工具，以验证可能在后台运行的活动。
- en: From the **Gotogle** page, you can search for the vulnerability directly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Gotogle**页面，您可以直接搜索漏洞。
- en: '![Gaining root access to the system](img/B04315_05_08.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_08.jpg)'
- en: The results are a copious amount of vulnerabilities for this Kernel. We are
    looking for a specific vulnerability that would allow us to execute privilege
    escalation with a known exploit. So, we navigate to the itemized vulnerabilities
    found under the **Vulnerabilities (324)**, which represents the number of vulnerabilities
    found at the time of this book's writing, for this specific Kernel version.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这个内核有大量的漏洞。我们正在寻找一个特定的漏洞，它将允许我们使用已知的利用程序进行特权升级。因此，我们导航到**漏洞（324）**下找到的列出的漏洞，这代表了在撰写本书时发现的特定内核版本的漏洞数量。
- en: '![Gaining root access to the system](img/B04315_05_09.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_09.jpg)'
- en: We organize the vulnerabilities by **Number Of Exploits Descending**, to find
    exploitable vulnerabilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按**Exploits数量降序**组织漏洞，以找到可利用的漏洞。
- en: '![Gaining root access to the system](img/B04315_05_10.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_10.jpg)'
- en: Then, we look for each vulnerability that has a red number in the "# of Exploits"
    column and a **+Priv** in the **Vulnerability Types** column to identify useful
    exploits. This signifies the number of available exploits distributed to the public,
    and what exploitation of the vulnerability would actually return, in this case
    escalated privileges.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们寻找每个在“# of Exploits”列中有红色数字和在**Vulnerability Types**列中有**+Priv**的漏洞，以识别有用的利用程序。这表示公开可用的利用程序数量，以及在这种情况下利用漏洞会返回什么，即提升的权限。
- en: '![Gaining root access to the system](img/B04315_05_11.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_11.jpg)'
- en: CVE-2010-1146 is a really good candidate, as shown in the following example.
    A publically available exploit can now be found at [http://www.exploit-db.com/exploits/12130](http://www.exploit-db.com/exploits/12130)
    as referenced by [http://www.cvedetails.com/](http://www.cvedetails.com/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2010-1146是一个非常好的候选项，如下例所示。现在可以在[http://www.exploit-db.com/exploits/12130](http://www.exploit-db.com/exploits/12130)找到一个公开可用的利用程序，由[http://www.cvedetails.com/](http://www.cvedetails.com/)引用。
- en: '![Gaining root access to the system](img/B04315_05_12.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_12.jpg)'
- en: Now, before you go downloading the exploit and running it, you should check,
    and see if the system is even vulnerable to this exploit. The basic requirements
    is a **Reiser File System** (**ReiserFS**) mounted with **extended attributes**
    (**xattr**). So, we need to check and see if there is a ReiserFS xattr on our
    Metasploitable instance by using a combination of built in commands. First, we
    need to identify the partitions with `fdisk -l`, then we identify the file system
    types with `df -T`, and then we can look at each ReiserFS partition if necessary.
    Any output from `fdisk -l` with the identifier of 83 is a potential candidate
    for ReiserFS mount.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您下载利用程序并运行之前，您应该检查并查看系统是否甚至容易受到此利用程序的攻击。基本要求是挂载了**Reiser文件系统**（**ReiserFS**）并带有**扩展属性**（**xattr**）。因此，我们需要使用内置命令的组合来检查并查看我们的Metasploitable实例中是否有ReiserFS
    xattr。首先，我们需要使用`fdisk -l`来识别分区，然后使用`df -T`来识别文件系统类型，然后必要时可以查看每个ReiserFS分区。`fdisk
    -l`的任何输出，带有标识符83的都有可能是ReiserFS挂载的候选项。
- en: '![Gaining root access to the system](img/B04315_05_13.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的根访问权限](img/B04315_05_13.jpg)'
- en: As you can see above the device, `/dev/sda1` has an identifier of 83, so there
    is potential for that mount to be a ReiserFS; this can be verified with `df -T`.
    Once the command has been run, we see that the device is an EXT3 file system,
    which means it is not a ReiserFS, so we do not need to check and see if the file
    system even has extended attributes enabled.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，设备`/dev/sda1`的标识符为83，因此该挂载点有可能是ReiserFS；可以使用`df -T`来验证。运行命令后，我们看到该设备是一个EXT3文件系统，这意味着它不是ReiserFS，因此我们不需要检查文件系统是否启用了扩展属性。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also check `/etc/fstab` to see if the partition was properly defined
    for xattr and reiserfs. Remember, this will not detect manual mounts potentially
    on the system though and as such you may miss attack vectors. Keep in mind though,
    `/etc/fstab` may also have clear text credentials in it, or references to mount
    files that contain credentials. So, it is still a great place to check for items
    that will allow you to move forward.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查`/etc/fstab`，看看分区是否已正确定义为xattr和reiserfs。请记住，这不会检测系统上潜在的手动挂载，因此可能会错过攻击向量。但请记住，`/etc/fstab`中可能还包含明文凭据，或者包含凭据的挂载文件的引用。因此，这仍然是一个检查允许您继续前进的项目的好地方。
- en: '![Gaining root access to the system](img/B04315_05_14.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的root访问权限](img/B04315_05_14.jpg)'
- en: So, the Kernel is theoretically vulnerable to this exploit, but this host's
    current configuration is not susceptible to the specific exploit. Now we know
    this specific privilege exploitation will not work even before executing it. That
    means, we need to go back to [http://www.cvedetails.com/](http://www.cvedetails.com/)
    and try and identify other viable exploits. A potentially viable vulnerability
    deals with CVE-2009-1185, with an exploit on milw0rm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内核在理论上对这种exploit是有漏洞的，但是该主机的当前配置对特定的exploit不易受攻击。现在我们知道，即使在执行之前，这种特定的特权利用也不会起作用。这意味着，我们需要回到[http://www.cvedetails.com/](http://www.cvedetails.com/)，并尝试识别其他可行的exploit。一个潜在的可行漏洞涉及CVE-2009-1185，有一个在milw0rm上的exploit。
- en: '![Gaining root access to the system](img/B04315_05_15.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的root访问权限](img/B04315_05_15.jpg)'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any references to exploits that used to point to [http://www.milw0rm.com](http://www.milw0rm.com)
    are now located at [http://www.exploit-db.com/](http://www.exploit-db.com/). The
    `milw0rm` database was moved to `expoloit-db` when the Offensive Security group
    took it over. So, just adjust the relevant URLs and you will find the same details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何指向[http://www.milw0rm.com](http://www.milw0rm.com)的exploit的引用现在位于[http://www.exploit-db.com/](http://www.exploit-db.com/)。当Offensive
    Security团队接管`milw0rm`数据库时，`milw0rm`数据库被移动到`exploit-db`。因此，只需调整相关的URL，您将找到相同的详细信息。
- en: 'Now you can download the exploit from the website and transfer it over to the
    system, or we can cheat and complete it from the command line. Just run the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以从网站下载exploit并将其传输到系统，或者我们可以通过命令行作弊并完成它。只需运行以下命令：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This downloads the exploit and saves it as a `code` to be compiled and executed
    on the local host.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载exploit并将其保存为`code`，以便在本地主机上编译和执行。
- en: '![Gaining root access to the system](img/B04315_05_16.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的root访问权限](img/B04315_05_16.jpg)'
- en: We need to locate the `gcc` compiler and verify that it is in our path for easy
    execution and then compile the code, on the target system. This can be done as
    follows, which `gcc` and then the code can be compiled into an exploit with `gcc`
    with the following command `gcc escalate.c -o escalate`. This outputs the new
    executable binary called `escalate`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到`gcc`编译器，并验证它是否在我们的路径中，以便轻松执行，然后在目标系统上编译代码。可以按照以下步骤完成，使用`gcc`和以下命令将代码编译为exploit：`gcc
    escalate.c -o escalate`。这将输出名为`escalate`的新可执行二进制文件。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When executing this on real systems don't name a file `exploit`, `escalate`,
    `shell`, `pwned` or anything of the like. These are common names many security
    tools scan for, and as such they could be flagged by them prior to execution.
    For purposes of this example, it does not matter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实系统上执行时，不要将文件命名为`exploit`、`escalate`、`shell`、`pwned`或类似的名称。这些是许多安全工具扫描的常见名称，因此它们在执行之前可能会被标记。对于本例来说，这并不重要。
- en: 'Now the compiled exploit is called `escalate`, and can be run once we determine
    some other informational components. This exploit takes advantage of the udevd
    netlink socket process, so we need to identify the process and pass the exploit
    to the **Process Identifier** (**PID**). This can be found in a file that references
    the service `/proc/net/netlink`. You can identify the details by executing the
    following command `cat /proc/net/netlink`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译的exploit被称为`escalate`，一旦我们确定了一些其他信息组件，就可以运行。这个exploit利用了udevd netlink套接字进程，因此我们需要识别该进程并将exploit传递给**进程标识符**（**PID**）。这可以在引用服务`/proc/net/netlink`的文件中找到。您可以通过执行以下命令来识别详细信息：`cat
    /proc/net/netlink`。
- en: '![Gaining root access to the system](img/B04315_05_17.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![获得系统的root访问权限](img/B04315_05_17.jpg)'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind, your PID will likely be different.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的PID可能会有所不同。
- en: 'This exploit, specifically executes a script with commands in it that are written
    to the file `/tmp/run`. So let us copy the `/etc/shadow` file to `/tmp`, since
    we are trying to gain access to that data in the first place. We also need to
    verify if the copied file is the same as the original; we can do this easily by
    taking a **Message Digest 5** (**MD5**) of each file and putting the results in
    another file in `/tmp` called `hashes`. Create a file in `/tmp` called run and
    add the following contents:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个exploit特别执行一个包含命令的脚本，写入文件`/tmp/run`。因此，让我们将`/etc/shadow`文件复制到`/tmp`，因为我们首先要访问的就是这些数据。我们还需要验证复制的文件是否与原始文件相同；我们可以通过对每个文件进行**消息摘要5**（**MD5**）并将结果放入`/tmp`中的另一个文件`hashes`来轻松地完成这一点。在`/tmp`中创建一个名为run的文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, run the exploit with the argument for the specific process you are trying
    to take advantage of. The following figure shows the identification of the `gcc`
    compiler, the compiling of the exploit, the execution, and proof of the results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用特定进程的参数运行漏洞利用。下图显示了`gcc`编译器的识别、漏洞利用的编译、执行和结果的证明：
- en: '![Gaining root access to the system](img/B04315_05_18.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![获取系统的root访问权限](img/B04315_05_18.jpg)'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to directly offload the file and not move and then copy it, but
    typically, you are not going to write the username and password of your system
    to a file on an exploited box, as you never know who is already on it. Additionally,
    this example was designed with the mind-set that simple port redirection tools
    like `netcat` may not be present on the system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接卸载文件，而不是移动和复制它，但通常情况下，你不会将系统的用户名和密码写入被利用的盒子上的文件，因为你永远不知道谁已经在上面。此外，这个例子是设计为简单的端口重定向工具，如`netcat`可能不在系统上。
- en: We then validate that the contents of the copied file are the same as the `/etc/shadow`
    file by comparing the MD5 hashes of both files and writing it to the `/tmp/hashes`
    file. The newly copied file can then be copied off the system onto the attack
    box.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过比较两个文件的MD5哈希值，并将其写入`/tmp/hashes`文件，验证复制文件的内容与`/etc/shadow`文件相同。然后可以将新复制的文件从系统上复制到攻击盒上。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always be very cautious in real environments, when you copy `passwd` or shadow
    files over, you can break the target system. So, make sure not to delete, rename,
    or move the originals. If you make a copy in other locations on the target system,
    remove it as not to help the real attackers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实环境中一定要非常谨慎，当你复制`passwd`或shadow文件时，可能会破坏目标系统。因此，请确保不要删除、重命名或移动原始文件。如果在目标系统的其他位置复制了文件，请删除它，以免帮助真正的攻击者。
- en: Also, remember that Kernel exploits have one of three outputs and they can range
    from not working each time you execute them (so try again), they can crash the
    specific host, or provide the desired results. If you are executing these types
    of attacks, always work with your client before executing, to ensure it is not
    a critical system. A simple reboot usually fixes a crash, but these types of attacks
    are always safer to execute on workstations than servers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，记住内核漏洞利用有三种输出，它们可能每次执行时都不起作用（所以再试一次），它们可能会使特定主机崩溃，或者提供所需的结果。如果你执行这些类型的攻击，一定要在执行之前与客户一起工作，以确保它不是关键系统。简单的重启通常可以解决崩溃问题，但这些类型的攻击总是比在服务器上执行更安全。
- en: '![Gaining root access to the system](img/B04315_05_19.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![获取系统的root访问权限](img/B04315_05_19.jpg)'
- en: Understanding the cracking of Linux hashes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Linux哈希破解
- en: Now, create a directory to handle all the cracking data on the Kali box and
    move the shadow and `passwd` files over.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Kali盒上创建一个目录来处理所有破解数据，并将shadow和`passwd`文件移动过去。
- en: '![Understanding the cracking of Linux hashes](img/B04315_05_20.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![理解Linux哈希破解](img/B04315_05_20.jpg)'
- en: Then, use John to combine the files with the `unshadow` command, and then begin
    the default cracking attempt.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用John来使用`unshadow`命令组合文件，然后开始默认的破解尝试。
- en: '![Understanding the cracking of Linux hashes](img/B04315_05_21.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![理解Linux哈希破解](img/B04315_05_21.jpg)'
- en: Testing for the synchronization of account credentials
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试账户凭据的同步
- en: 'With these results, we can determine if any of these credentials are reused
    in the network. We know there are Windows hosts primarily in the target network,
    but we need to identify which ones have port `445` open. We can then try and determine,
    which accounts might grant us access, when the following command is run:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些结果，我们可以确定这些凭据是否在网络中被重用。我们知道目标网络中主要是Windows主机，但我们需要确定哪些主机开放了端口`445`。然后我们可以尝试确定，当运行以下命令时，哪些帐户可能授予我们访问权限：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, parse the results for open ports with the following command, which will
    provide a file of target hosts with **Server Message Block (SMB)** enabled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令解析开放端口的结果，这将提供一个启用**Server Message Block (SMB)**的目标主机文件。
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The passwords can be extracted directly from John and written as a password
    file that can be used for follow-on service attacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 密码可以直接从John中提取，并写成一个密码文件，用于后续的服务攻击。
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always test on a single host the first time you run this type of attack. In
    this example, we are using the sys account, but it is more common to use the root
    account or similar administrative accounts to test password reuse (synchronization)
    in an environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行这种类型的攻击时，一定要在单个主机上进行测试。在这个例子中，我们使用了sys帐户，但更常见的是使用root帐户或类似的管理帐户来测试密码重用（同步）在一个环境中。
- en: The following attack using `auxiliary/scanner/smb/smb_enumusers_domain` will
    check for two things. It will identify what systems this account has access to,
    and the relevant users that are currently logged into the system. In the second
    portion of this example, we will highlight how to identify the accounts that are
    actually privileged and part of the Domain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auxiliary/scanner/smb/smb_enumusers_domain`进行的以下攻击将检查两件事。它将确定此帐户可以访问哪些系统，以及当前登录到系统的相关用户。在此示例的第二部分中，我们将重点介绍如何识别实际特权帐户和域的一部分。
- en: There are good points and bad points about the `smb_enumusers_domain` module.
    The bad points are that you cannot load multiple usernames and passwords into
    it. That capability is reserved for the `smb_login` module. The problem with `smb_login`
    is that it is extremely noisy, as many signature detection tools flag on this
    method of testing for logins. The third module `smb_enumusers`, which can be used,
    but it only provides details related to locale users as it identifies users based
    on the **Security Accounts Manager** (**SAM**) file contents. So, if a user has
    a Domain account and has logged into the box, the `smb_enumusers` module will
    not identify them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`smb_enumusers_domain`模块有好坏之分。坏的一面是您无法将多个用户名和密码加载到其中。这种能力是为`smb_login`模块保留的。`smb_login`的问题在于它非常嘈杂，因为许多签名检测工具会对这种测试登录的方法进行标记。第三个模块`smb_enumusers`可以使用，但它只提供与本地用户相关的详细信息，因为它根据安全账户管理器（SAM）文件内容识别用户。因此，如果用户有域账户并且已登录到该系统，`smb_enumusers`模块将无法识别他们。'
- en: So, understand each module and its limitations when identifying targets to laterally
    move. We are going to highlight how to configure the `smb_enumusers_domain` module
    and execute it. This will show an example of gaining access to a vulnerable host
    and then verifying DA account membership. This information can then be used to
    identify where a DA is located so that Mimikatz can be used to extract credentials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在确定横向移动的目标时，要了解每个模块及其限制。我们将重点介绍如何配置`smb_enumusers_domain`模块并执行它。这将展示一个获得对易受攻击主机访问权限的示例，然后验证DA账户成员资格。然后可以使用这些信息来确定DA的位置，以便使用Mimikatz提取凭据。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this example, we are going to use a custom exploit using Veil as well, to
    attempt to bypass a resident **Host Intrusion Prevention System** (**HIPS**).
    More information about Veil can be found at [https://github.com/Veil-Framework/Veil-Evasion.git](https://github.com/Veil-Framework/Veil-Evasion.git).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用Veil作为自定义利用程序，尝试绕过主机入侵防护系统（HIPS）。有关Veil的更多信息可以在[https://github.com/Veil-Framework/Veil-Evasion.git](https://github.com/Veil-Framework/Veil-Evasion.git)找到。
- en: 'So, we configure the module to use the password `batman`, and we target the
    local administrator account on the system. This can be changed, but often the
    default is used. Since it is the local administrator, the Domain is set to `WORKGROUP`.
    The following figure shows the configuration of the module:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们配置模块使用密码`batman`，并且目标是系统上的本地管理员账户。这可以更改，但通常使用默认值。由于它是本地管理员，域设置为`WORKGROUP`。下图显示了模块的配置：
- en: '![Testing for the synchronization of account credentials](img/B04315_05_22.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![测试账户凭据同步](img/B04315_05_22.jpg)'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before running commands such as these, make sure to use spool, to output the
    results to a log file so you can go back and review the results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令之前，请确保使用spool将结果输出到日志文件中，以便您可以返回并查看结果。
- en: As you can see in the following figure, the account provided details about who
    was logged into the system. This means that there are logged in users relevant
    to the returned account names and that the local administrator account will work
    on that system. This means this system is ripe for compromise by a **Pass-the-Hash
    attack** (**PtH**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下图中所看到的，该账户提供了有关谁登录到系统的详细信息。这意味着返回的账户名称中有相关的已登录用户，并且本地管理员账户将在该系统上起作用。这意味着这个系统很容易受到“传递哈希攻击”（PtH）的威胁。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_23.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![测试账户凭据同步](img/B04315_05_23.jpg)'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `psexec` module allows you to either pass the extracted **Local Area Network
    Manager (LM)**: **New Technology LM (NTLM)** hash and username combination or
    just the username password pair to get access.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`psexec`模块允许您传递提取的本地区域网络管理器（LM）：新技术LM（NTLM）哈希和用户名组合，或者只是用户名密码对来获取访问权限。'
- en: To begin with, we setup a custom multi/handler to catch the custom exploit we
    generated by Veil as in the following example. Keep in mind, I used `443` for
    the local port because it bypasses most HIPS and the local host will change depending
    on your host.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一个自定义的multi/handler来捕获Veil生成的自定义利用程序，如下例所示。请记住，我使用`443`作为本地端口，因为它可以绕过大多数HIPS，而本地主机将根据您的主机而变化。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_24.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![测试账户凭据同步](img/B04315_05_24.jpg)'
- en: Now, we need to generate custom payloads with Veil to be used with the `psexec`
    module. You can do this by navigating to the `Veil-Evasion` installation directory
    and running it with `python Veil-Evasion.py`. Veil has a good number of payloads
    that can be generated with a variety of obfuscation or protection mechanisms,
    to see the specific payload you want to use, to execute the `list` command. You
    can select the payload by typing in the number of the payload or the name. As
    an example, run the following commands to generate a C Sharp stager that does
    not use shell code, keep in mind this requires specific versions of .NET on the
    target box to work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用Veil生成自定义有效载荷，以便与`psexec`模块一起使用。您可以通过导航到`Veil-Evasion`安装目录并使用`python
    Veil-Evasion.py`来执行此操作。Veil有许多有效载荷，可以使用各种混淆或保护机制生成，要查看要使用的特定有效载荷，执行`list`命令。您可以通过输入有效载荷的编号或名称来选择有效载荷。例如，运行以下命令生成一个不使用shell代码的C#分段器，但请记住，这需要目标计算机上特定版本的.NET才能工作。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two components to a typical payload, the stager and the stage. A stager
    sets up the network connection between the attacker and the victim. Payloads that
    often use native system languages can be purely stager. The second part is the
    stage, which are the components that are downloaded by the stager. These can include
    things like your Meterpreter. If both items are combined, they are called a single;
    think about when you create your malicious **Universal Serial Bus** (**USB**)
    drives, these are often singles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 典型有效载荷有两个组成部分，分别是分段器和阶段。分段器在攻击者和受害者之间建立网络连接。通常使用本地系统语言的有效载荷可以是纯粹的分段器。第二部分是阶段，这些是由分段器下载的组件。这些可以包括像Meterpreter这样的东西。如果两个项目结合在一起，它们被称为单个；想想当你创建你的恶意**通用串行总线**（**USB**）驱动器时，这些通常是单个。
- en: The output will be an executable, that will spawn an encrypted reverse **HyperText
    Transfer Protocol Secure (HTTPS**) Meterpreter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个可执行文件，将生成一个加密的反向**超文本传输安全协议（HTTPS）** Meterpreter。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_25.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![测试帐户凭据的同步](img/B04315_05_25.jpg)'
- en: The payload can be tested with the script `checkvt`, which safely verifies if
    the payload would be picked up by most HIPS solutions. It does this without uploading
    it to Virus Total, and in turn does not add the payload to the database, which
    many HIPS providers pull from. Instead, it compares the hash of the payload to
    those already in the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷可以使用脚本`checkvt`进行测试，该脚本可以安全地验证有效载荷是否会被大多数HIPS解决方案拾取。它可以在不上传到Virus Total的情况下进行此操作，也不会将有效载荷添加到数据库中，许多HIPS提供商都会从中提取。相反，它会将有效载荷的哈希与数据库中已有的哈希进行比较。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_26.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![测试帐户凭据的同步](img/B04315_05_26.jpg)'
- en: Now, we can setup the `psexec` module to reference the custom payload for execution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置`psexec`模块以引用自定义有效载荷进行执行。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_27.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![测试帐户凭据的同步](img/B04315_05_27.jpg)'
- en: 'Update the `psexec` module, so that it uses the custom payload generated by
    `Veil-Evasion`, via set `EXE::Custom` and disable the automatic payload handler
    with set `DisablePayloadHandler true`, as shown following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`psexec`模块，使其使用由`Veil-Evasion`生成的自定义有效载荷，通过设置`EXE::Custom`并使用`set DisablePayloadHandler
    true`禁用自动有效载荷处理程序，如下所示：
- en: '![Testing for the synchronization of account credentials](img/B04315_05_28.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![测试帐户凭据的同步](img/B04315_05_28.jpg)'
- en: 'Exploit the target box, and then attempt to identify who the DAs are in the
    Domain. This can be done in one of two ways, either by using the `post/windows/gather/enum_domain_group_users`
    module or the following command from shell access:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 利用目标机器，然后尝试确定域中的DA是谁。这可以通过两种方式之一完成，即使用`post/windows/gather/enum_domain_group_users`模块或通过shell访问使用以下命令：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then `Grep` through the spooled output file from the previously run
    module to locate relevant systems that might have these DAs logged into. When
    gaining access to one of those systems, there would likely be DA tokens or credentials
    in memory, which can be extracted and reused. The following command is an example
    of how to analyze the log file for these types of entries:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过先前运行的模块的输出文件进行`Grep`，以定位可能已登录这些DA的相关系统。当访问这些系统中的一个时，内存中可能会有DA令牌或凭据，这些可以被提取和重复使用。以下命令是分析这些类型条目的日志文件的示例：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, this very simple exploit path allows you to identify where the
    DAs are. Once you are on the system all you have to do is `load mimikatz` and
    extract the credentials typically with the `wdigest` command from the established
    Meterpreter session. Of course, this means the system has to be newer than Windows
    2000, and have active credentials in memory. If not, it will take additional effort
    and research to move forward. To highlight this, we use our established session
    to extract credentials with `Mimikatz` as you can see in the following example.
    The credentials are in memory and since the target box was the Windows XP machine,
    we have no conflicts and no additional research is required.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这条非常简单的利用路径可以让您确定DA的位置。一旦您进入系统，您只需`load mimikatz`并从已建立的Meterpreter会话中使用`wdigest`命令提取凭据。当然，这意味着系统必须比Windows
    2000更新，并且在内存中有活动凭据。如果没有，将需要额外的努力和研究来继续前进。为了强调这一点，我们使用我们已建立的会话来提取凭据，如下例所示。凭据在内存中，由于目标机器是Windows
    XP，所以没有冲突，也不需要额外的研究。
- en: '![Testing for the synchronization of account credentials](img/B04315_05_29.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![测试帐户凭据的同步](img/B04315_05_29.jpg)'
- en: In addition to the intelligence we have gathered from extracting the active
    DA list from the system, we now have another set of confirmed credentials that
    can be used. Rinsing and repeating this method of attack allows you to quickly
    move laterally around the network till you identify viable targets.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从系统中提取活动DA列表所获得的情报外，我们现在还有另一组确认的凭据可供使用。重复使用这种攻击方法可以让您快速在网络中移动，直到找到可行的目标。
- en: Automating the exploit train with Python
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python自动化利用列车
- en: This exploit train is relatively simple, but we can automate a portion of this
    with the **Metasploit Remote Procedure Call** (**MSFRPC**). This script will use
    the `nmap` library to scan for active ports of `445`, then generate a list of
    targets to test using a username and password passed via argument to the script.
    The script will use the same `smb_enumusers_domain` module to identify boxes that
    have the credentials reused and other viable users logged into them. First, we
    need to install `SpiderLabs msfrpc` library for Python. This library can be found
    at [https://github.com/SpiderLabs/msfrpc.git](https://github.com/SpiderLabs/msfrpc.git).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个利用火车相对简单，但我们可以使用**Metasploit远程过程调用**（**MSFRPC**）自动化部分内容。此脚本将使用`nmap`库扫描端口`445`的活动端口，然后生成一个目标列表，以便使用通过参数传递给脚本的用户名和密码进行测试。脚本将使用相同的`smb_enumusers_domain`模块来识别具有重复凭据和其他可用用户登录的框。首先，我们需要安装Python的`SpiderLabs
    msfrpc`库。这个库可以在[https://github.com/SpiderLabs/msfrpc.git](https://github.com/SpiderLabs/msfrpc.git)找到。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A github repository for the book can be found at [https://github.com/funkandwagnalls/pythonpentest](https://github.com/funkandwagnalls/pythonpentest)
    and within it is a setup file that can be run to install all the necessary packages,
    libraries, and resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的GitHub存储库可以在[https://github.com/funkandwagnalls/pythonpentest](https://github.com/funkandwagnalls/pythonpentest)找到，并且其中有一个设置文件，可以运行以安装所有必要的软件包、库和资源。
- en: The script we are creating uses the `netifaces` library to identify which interface
    IP addresses belong to your host. It then scans for port `445` the SMB port on
    the IP address, range, or the **Classes Inter Domain Routing** (**CIDR**) address.
    It eliminates any IP addresses that belong to your interface and then tests the
    credentials using the Metasploit module `auxiliary/scanner/smb/smb_enumusers_domain`.
    At the same time, it verifies what users are logged onto the system. The outputs
    of this script in addition to real time response are two files, a log file that
    contains all the responses, and a file that holds the IP addresses for all the
    hosts that have SMB services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的脚本使用`netifaces`库来识别哪个接口IP地址属于您的主机。然后，它扫描端口`445`，即IP地址、范围或**类间域路由**（**CIDR**）地址上的SMB端口。它消除了属于您接口的任何IP地址，然后使用Metasploit模块`auxiliary/scanner/smb/smb_enumusers_domain`来测试凭据。同时，它验证了系统上登录的用户。除了实时响应之外，此脚本的输出还包括两个文件，一个包含所有响应的日志文件，以及一个保存具有SMB服务的所有主机的IP地址的文件。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This Metasploit module takes advantage of RPCDCE, which does not run on port
    `445`, but we are verifying that the service is available for follow-on exploitation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Metasploit模块利用了RPCDCE，它不在端口`445`上运行，但我们正在验证该服务是否可用以进行后续利用。
- en: '![Automating the exploit train with Python](img/B04315_05_30.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![用Python自动化利用火车](img/B04315_05_30.jpg)'
- en: 'This file could then be fed back into the script, if you as an attacker find
    other credential sets to test as shown in the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果作为攻击者发现其他凭据集进行测试，可以将此文件馈送回脚本，如下所示：
- en: '![Automating the exploit train with Python](img/B04315_05_31.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![用Python自动化利用火车](img/B04315_05_31.jpg)'
- en: 'Lastly, the script can be passed hashes directly just like the Metasploit module
    as shown in the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本可以直接传递哈希，就像Metasploit模块中所示的那样：
- en: '![Automating the exploit train with Python](img/B04315_05_32.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: 自动化利用Python的利用火车
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The output will be slightly different for each running of the script, depending
    on the console identifier you grab to execute the command. The only real difference
    will be the additional banner items typical with a Metasploit console initiation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行脚本时，输出都会略有不同，这取决于你获取的控制台标识符来执行命令。唯一的真正区别将是与Metasploit控制台启动典型的附加横幅项目。
- en: Now there are a couple things that have to be stated, yes you could just generate
    a resource file, but when you start getting into organizations that have millions
    of IP addresses, this becomes unmanageable. Also the MSFRPC can have resource
    files fed directly into it as well, but it can significantly slow the process.
    If you want to compare, rewrite this script to do the same test as the previous
    `ssh_login.py` script you wrote, but with direct MSFRPC integration.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几件事情必须说明，是的，你可以只生成一个资源文件，但是当你开始涉及拥有数百万个IP地址的组织时，这变得难以管理。此外，MSFRPC也可以直接将资源文件馈送到其中，但这可能会显著减慢过程。如果你想进行比较，请重写此脚本，以执行与你之前编写的`ssh_login.py`脚本相同的测试，但直接集成MSFRPC。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most important item going forward is that many of the future scripts in
    the book are going to be very large with additional error checking. As you have
    had your skills built from the ground up, already stated concepts will not be
    repeated. Instead, the entire script can be downloaded from GitHub, to identify
    the nuances of the scripts. This script does use the previous `netifaces` functions
    used in the `ssh_login.py` script, but we are not going to replicate it here in
    this chapter for brevity. You can download the full script here at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 未来书中最重要的事项是，许多未来的脚本将非常庞大，并具有额外的错误检查。由于你的技能是从零开始建立的，已经说明的概念将不会被重复。相反，整个脚本可以从GitHub下载，以识别脚本的细微差别。此脚本确实使用了`ssh_login.py`脚本中使用的先前的`netifaces`函数，但出于简洁起见，我们不会在本章中复制它。你可以在这里下载完整的脚本[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py)。
- en: 'Like all scripts libraries are needed to be established, most of these you
    are already familiar with, the newest one relates to the MSFRPC by `SpiderLabs`.
    The required libraries for this script can be seen as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有脚本一样，需要建立库，其中大部分你已经熟悉，最新的一个与MSFRPC相关的库是由`SpiderLabs`提供的。此脚本所需的库如下所示：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We then build a module, to identify relevant targets that are going to have
    the auxiliary module run against it. First, we set up the constructors and the
    passed parameters. Notice that we have two service names to test against for this
    script, `microsoft-ds` and `netbios-ssn`, as either one could represent port 445
    based on the `nmap` results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建一个模块，以识别将针对其运行辅助模块的相关目标。首先，我们设置构造函数和传递的参数。请注意，对于此脚本，我们有两个要测试的服务名称，`microsoft-ds`和`netbios-ssn`，因为根据`nmap`的结果，任何一个都可能代表端口445。
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After which, we configure the nmap scanner to scan for details either by file
    or by command line. Notice that the `hostlist` is a string of all the addresses
    loaded by the file, and they are separated by spaces. The `ipfile` is opened and
    read and then all new lines are replaced with spaces as they are loaded into the
    string. This is a requirement for the specific `hosts` argument of the nmap library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们配置nmap扫描程序以通过文件或命令行扫描详细信息。请注意，`hostlist`是由文件加载的所有地址的字符串，并且它们用空格分隔。打开并读取`ipfile`，然后将所有新行替换为空格，因为它们被加载到字符串中。这是nmap库的特定`hosts`参数的要求。
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The IP addresses for all of the interfaces on the attack system are removed
    from the test pool.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击系统上所有接口的IP地址都从测试池中删除。
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, the details are then written to the relevant output file and Python
    lists, and then returned to the original call origin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，详细信息被写入相关的输出文件和Python列表，然后返回到原始调用来源。
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next function creates the actual command that will be executed; this function
    will be called for each host the scan returned back as a potential target.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的函数创建将要执行的实际命令；对于扫描返回的每个主机，将调用此函数作为潜在目标。
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last function actually initiates the connection with the MSFRPC and executes
    the relevant command per specific host.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的函数实际上启动了与MSFRPC的连接，并针对特定主机执行相关命令。
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The script creates a connection with the MSFRPC and creates console then tracks
    it by a specific `console_id`. Do not forget, the `msfconsole` can have multiple
    sessions, and as such we have to track our session to a `console_id`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本与MSFRPC建立连接，然后创建控制台，然后通过特定的`console_id`跟踪它。不要忘记，`msfconsole`可以有多个会话，因此我们必须将我们的会话跟踪到`console_id`。
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script then iterates over the list of IP addresses that were confirmed to
    have an active SMB service. The script then creates the necessary commands for
    each of those IP addresses.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本遍历了已确认具有活动SMB服务的IP地址列表。然后，脚本为每个IP地址创建了必要的命令。
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The command is then written to the console and we wait for the results.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将命令写入控制台，并等待结果。
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We await the results for each command execution and verify the data that has
    been returned and that the console is not still running. If it is, we delay the
    reading of the data. Once it has completed, the results are written in the specified
    output file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待每个命令执行的结果，并验证返回的数据以及控制台是否仍在运行。如果是，我们延迟读取数据。一旦完成，结果将被写入指定的输出文件。
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We close the file and destroy the console to clean up the work we had done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关闭文件并销毁控制台，以清理我们所做的工作。
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final pieces of the script are related to setting up the arguments, setting
    up the constructors and calling the modules. These components are similar to previous
    scripts and have not been included here for the sake of space, but the details
    can be found at the previously mentioned location on GitHub. The last requirement
    is loading of the `msgrpc` at the `msfconsole` with the specific password that
    we want. So launch the `msfconsole` and then execute the following within it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后部分涉及设置参数、设置构造函数和调用模块。这些组件与以前的脚本类似，这里没有包括，但详细信息可以在GitHub上的先前提到的位置找到。最后的要求是在`msfconsole`中加载`msgrpc`，并使用我们想要的特定密码。因此，启动`msfconsole`，然后在其中执行以下操作：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The command was not mistyped, Metasploit has moved to `msgrpc` verses `msfrpc`,
    but everyone still refers to it as `msfrpc`. The big difference is the `msgrpc`
    library uses POST requests to send data while `msfrpc` used **eXtensible Markup
    Language** (**XML**). All of this can be automated with resource files to set
    up the service.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 命令没有输入错误，Metasploit已经转移到`msgrpc`而不是`msfrpc`，但每个人仍然称其为`msfrpc`。最大的区别是`msgrpc`库使用POST请求发送数据，而`msfrpc`使用**可扩展标记语言**（**XML**）。所有这些都可以通过资源文件自动化设置服务。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we highlighted a method in which you can move through a sample
    environment. Specifically, how to exploit a relative box, escalate privileges,
    and extract additional credentials. From that position, we identified other viable
    hosts we could laterally move into and the users who were currently logged into
    them. We generated custom payloads with the Veil Framework to bypass HIPS, and
    executed a PtH attack. This allowed us to extract other credentials from memory
    with the tool Mimikatz. We then automated the identification of viable secondary
    targets and the users logged into them with Python and MSFRPC. Much of this may
    seem very surprising, either in complexity or lack thereof, depending on what
    you were expecting. Keep in mind, it will all depend on your environment and how
    much work it will take to actually crack it. This chapter provided a lot of details
    related to exploit network and system based resources, the next chapter highlights
    a different angle, web assessments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点介绍了一种在样本环境中移动的方法。具体来说，如何利用相关框，提升权限并提取额外的凭据。从这个位置，我们确定了其他可行的主机，我们可以横向移动到这些主机，并且目前登录到这些主机的用户。我们使用Veil
    Framework生成自定义有效载荷来绕过HIPS，并执行了PtH攻击。这使我们能够使用Mimikatz工具从内存中提取其他凭据。然后，我们使用Python和MSFRPC自动识别了可行的次要目标和登录到这些目标的用户。这些内容可能会让人感到非常惊讶，无论是复杂性还是缺乏复杂性，这取决于你的期望。请记住，这将完全取决于你的环境以及实际破解所需的工作量。本章提供了许多与利用网络和基于系统的资源相关的细节，下一章将突出不同的角度，即Web评估。
