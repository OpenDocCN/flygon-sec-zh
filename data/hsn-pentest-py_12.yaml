- en: Reverse Engineering Windows Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程Windows应用程序
- en: 'In this chapter, we will look at how to perform reverse engineering with Windows
    applications. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何对Windows应用程序进行逆向工程。在本章中，我们将涵盖以下主题：
- en: Fuzzing Windows applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fuzzing Windows应用程序
- en: Windows and assembly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows和汇编
- en: Windows and stack buffer overflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows和堆缓冲区溢出
- en: Windows and heap buffer overflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows和堆缓冲区溢出
- en: Formatting string bugs in Windows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows中的格式化字符串漏洞
- en: Debuggers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试器
- en: 'Let''s take a look at the debuggers that we are going to cover in this chapter
    for Windows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将在本章中涵盖的Windows调试器：
- en: '**Immunity debugger**: This is one of the best known debuggers that runs in
    a Windows environment and debugs Windows applications. It can be downloaded from
    [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/) and
    comes as an executable that can be run directly:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Immunity debugger**：这是一个在Windows环境中运行并调试Windows应用程序的最著名的调试器之一。它可以从[https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/)下载，并且作为可执行文件直接运行：'
- en: '![](img/99762647-1633-411f-ac78-d433260892d0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99762647-1633-411f-ac78-d433260892d0.png)'
- en: '**Olly debugger**: It is possible to simply download the Olly debugger from [http://www.ollydbg.de/](http://www.ollydbg.de/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Olly debugger**：可以直接从[http://www.ollydbg.de/](http://www.ollydbg.de/)下载Olly调试器。'
- en: '![](img/eac337e6-ad53-400d-8625-9dcf12a1a868.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac337e6-ad53-400d-8625-9dcf12a1a868.png)'
- en: Fuzzing Windows applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fuzzing Windows应用程序
- en: Fuzzing, as we discussed in the previous chapter, is a technique used to discover
    bugs in applications that make the application crash when presented with an input
    that was not anticipated by the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的那样，Fuzzing是一种用于发现应用程序中的错误的技术，当应用程序遇到未预料到的输入时，会导致应用程序崩溃。
- en: To start off this exercise, let's set up VirtualBox, and use Windows as the
    operating system. In the lab Windows 7 machine, let's go ahead and install vulnerable
    software called **vulnserver**. If you do a Google search for `vulnserver download`,
    you will get the link to the vulnerable server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个练习，让我们设置VirtualBox，并使用Windows作为操作系统。在实验室的Windows 7机器上，让我们继续安装名为**vulnserver**的易受攻击的软件。如果你在Google上搜索`vulnserver
    download`，你会得到易受攻击的服务器的链接。
- en: 'Let''s now load the `vulnserver` in VirtualBox and run it as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在VirtualBox中加载`vulnserver`并运行它，如下所示：
- en: '![](img/c12c1857-6eba-469b-9e71-647f37d9a26a.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c12c1857-6eba-469b-9e71-647f37d9a26a.png)'
- en: Let's now try to connect the Linux host machine to the Windows machine to connect
    to the `vul` server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将Linux主机连接到Windows机器，以连接到`vul`服务器。
- en: 'The tool we can use for fuzzing is zzuf, which can be used with Linux-based
    systems. To check whether the tool is available, run the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用于Fuzzing的工具是zzuf，它可以与基于Linux的系统一起使用。要检查工具是否可用，请运行以下命令：
- en: '![](img/86e76679-2f8b-4fae-9c56-6463fd0cbc19.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86e76679-2f8b-4fae-9c56-6463fd0cbc19.png)'
- en: 'Let''s see whether it crashes when we enter a long string. We can check this
    by passing the `aaaaaa` string to the code and can see that it does not break.
    The other way is to run the `help` command, where we pass the `help` command and
    return back to the Terminal, so that we can recursively do it in a loop. This
    is shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们输入一个长字符串时是否会崩溃。我们可以通过将`aaaaaa`字符串传递给代码来检查这一点，并且可以看到它不会崩溃。另一种方法是运行`help`命令，我们传递`help`命令并返回到终端，这样我们可以递归地在循环中执行它。如下所示：
- en: '![](img/e6521c01-c09e-4271-bbb6-9824e5795647.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6521c01-c09e-4271-bbb6-9824e5795647.png)'
- en: It should be noted that if we wish to execute a command with `echo`, we can
    put that command in backticks `<command>` and the output of that command will
    be appended to the `echo` print string, for example: `echo 'hello' `python -c
    'print "a"*5'``.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，如果我们希望使用`echo`执行命令，我们可以将该命令放在反引号`<command>`中，该命令的输出将附加到`echo`打印字符串，例如：`echo
    'hello' `python -c 'print "a"*5'``。
- en: 'We will use this technique in order to crash the target server, as the output
    of the command executed will be appended to the output of `echo`, and the output
    of `echo` goes as an input to the server through Netcat. We will execute the following
    code to see whether the vulnerable server crashes for a really long string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种技术来崩溃目标服务器，因为执行的命令的输出将附加到`echo`的输出，并且`echo`的输出通过Netcat作为输入发送到服务器。我们将执行以下代码，看看易受攻击的服务器是否会因为一个非常长的字符串而崩溃：
- en: '![](img/ec17126b-0386-4e18-b98d-1c3de47f8959.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec17126b-0386-4e18-b98d-1c3de47f8959.png)'
- en: We can clearly see that on executing the preceding command, the program prints `UNKNOWN
    COMMAND`. Basically, what's happening here is that `aaaaaa` is getting split across
    multiple lines and the input is sent to Netcat as follows: `echo hello aaaaaaaaaaaaaaaaaaa
    | nc …`. In the next line, the remaining `aaaa` are printed, which throws the
    `UNKNOWN COMMAND` error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，在执行上述命令时，程序打印出`UNKNOWN COMMAND`。基本上，这里发生的是`aaaaaa`被分割成多行，并且输入被发送到Netcat，如下所示：`echo
    hello aaaaaaaaaaaaaaaaaaa | nc …`。在下一行，剩下的`aaaa`被打印出来，这就引发了`UNKNOWN COMMAND`错误。
- en: Let's try to redirect the printed output to some text file and then use `zzuf`
    with it to actually crash or fuzz the target vulnerable software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将打印输出重定向到一些文本文件，然后使用`zzuf`来实际崩溃或模糊目标易受攻击的软件。
- en: 'Zzuf is a tool that takes a large string as an input, such as `aaaaaaaaaaaaaaaaaaaaaaaaa`.
    It randomly places special characters at various places in the string and produces
    an output such as `?aaaa@??aaaaaaaaaaa$$`. We can specify as a percentage how
    much of the input should be modified, for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Zzuf是一个工具，它以大字符串作为输入，例如`aaaaaaaaaaaaaaaaaaaaaaaaa`。它在字符串的各个位置随机放置特殊字符，并产生输出，例如`?aaaa@??aaaaaaaaaaa$$`。我们可以指定百分比来修改输入的多少，例如：
- en: '![](img/e77287d6-a6db-4f9b-9814-a89371ca0ec6.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e77287d6-a6db-4f9b-9814-a89371ca0ec6.png)'
- en: 'Let''s use zzuf with the produced file, `fuzz.txt`, and see what the outcome
    is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用生成的文件`fuzz.txt`和zzuf，看看结果如何：
- en: '![](img/00792288-d705-4522-9d70-d9ab6f5f43b7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00792288-d705-4522-9d70-d9ab6f5f43b7.png)'
- en: 'We can specify the percentage as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式指定百分比：
- en: '![](img/8fea92e7-e1db-413b-9a2d-3ddeccc488b9.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fea92e7-e1db-413b-9a2d-3ddeccc488b9.png)'
- en: 'Note that it is not the `HELP` command of the `vul` server that is vulnerable,
    it is the `GMON ./:/` command. We don''t want our zzuf tool to change the `GMON
    ./:/` part of the command, so we specify `-b` (the bytes option) with `zzuf` to
    tell it to skip the initial 12 bytes as shown in the following screenshots:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`vul`服务器的`HELP`命令不容易受攻击，而是`GMON ./:/`命令。我们不希望zzuf工具更改命令的`GMON ./:/`部分，因此我们使用`zzuf`指定`-b`（字节选项）告诉它跳过初始的12个字节，如下面的屏幕截图所示：
- en: '![](img/ab127506-ea8d-4e19-85d0-de7d0b4d4c69.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab127506-ea8d-4e19-85d0-de7d0b4d4c69.png)'
- en: '![](img/5684510c-3909-4bd3-8855-e2dc5271c612.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5684510c-3909-4bd3-8855-e2dc5271c612.png)'
- en: 'Let''s try to give this file content as an input to the `vul` server and see
    what happens:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将此文件内容作为输入提供给`vul`服务器，看看会发生什么：
- en: '![](img/a6f43126-e85a-47f9-874e-366b1855cefc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6f43126-e85a-47f9-874e-366b1855cefc.png)'
- en: 'It can be seen that the output produced by the zzuf tool crashed the `vul`
    server at the other end. Note that the special characters that the zzuf tool generates
    are well known attack payload characters that are commonly used for fuzzing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，zzuf工具生成的输出使`vul`服务器崩溃了。请注意，zzuf工具生成的特殊字符是常用于模糊测试的众所周知的攻击有效载荷字符：
- en: '![](img/91d27170-f32e-4500-89d4-6962b22a6a94.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91d27170-f32e-4500-89d4-6962b22a6a94.png)'
- en: We will now see how can we use a script in order to try to crash the `vul` server.
    We will also use the Olly debugger on our Windows machine in order to see where
    exactly the code breaks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何使用脚本来尝试使`vul`服务器崩溃。我们还将在Windows机器上使用Olly调试器，以查看代码在哪里中断。
- en: 'Start the Olly debugger as admin, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以管理员身份启动Olly调试器，如下所示：
- en: '![](img/be9ca5ad-d1f8-408e-9068-d261fbf7c751.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9ca5ad-d1f8-408e-9068-d261fbf7c751.png)'
- en: 'We will now attach the running server with the Olly debugger. Go to **File** | **Attach**.
    This will open all the running processes. We must go to vulnserver and attach
    it. Once we click on **Attach**, we get the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Olly调试器附加正在运行的服务器。转到**文件**|**附加**。这将打开所有正在运行的进程。我们必须转到vulnserver并将其附加。一旦单击**附加**，我们会得到以下内容：
- en: '![](img/a4ddecbe-9433-4c8d-bd23-3c7f9abe1bdb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4ddecbe-9433-4c8d-bd23-3c7f9abe1bdb.png)'
- en: 'Now, let''s go back to the Linux machine and launch the script that we created:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到Linux机器并启动我们创建的脚本：
- en: '![](img/4f39af92-7721-4d49-87fc-5355ab0041da.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f39af92-7721-4d49-87fc-5355ab0041da.png)'
- en: The moment we execute the `python fuzz.py` command, we don't see anything on
    the Python console.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`python fuzz.py`命令时，Python控制台上没有任何输出。
- en: 'However, in the attached process in the Olly debugger, at the bottom right,
    we see a yellow message saying **Paused**, which means that the execution of the
    attached process/server is paused:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Olly调试器中附加的进程中，右下角显示一个黄色消息，上面写着**暂停**，这意味着附加的进程/服务器的执行已暂停：
- en: '![](img/b043dd4b-bc84-4577-8bd6-3aacb6b09c24.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b043dd4b-bc84-4577-8bd6-3aacb6b09c24.png)'
- en: 'Let''s click on the play button. This executes some code and pauses at another
    breakpoint:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击播放按钮。这会执行一些代码，并在另一个断点处暂停：
- en: '![](img/44e51191-f652-473a-9c36-af5544e1c72e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44e51191-f652-473a-9c36-af5544e1c72e.png)'
- en: 'It should be noted that at the bottom of the screen it says `Access violation` when
    writing to the location `017Dxxxx`. This means that an exception was encountered
    and the program crashed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在屏幕底部写着`Access violation`，写入位置为`017Dxxxx`。这意味着遇到了异常，程序崩溃了：
- en: '![](img/3f876ff5-c42a-4090-a78f-cb3c2fbfb632.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f876ff5-c42a-4090-a78f-cb3c2fbfb632.png)'
- en: Windows and assembly
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows和汇编
- en: In this section, we will learn about assembly language. Our objective is to
    take C code, translate it to an assembly language, and take a look at what happens.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习汇编语言。我们的目标是将C代码转换为汇编语言，并查看发生了什么。
- en: 'The following is the sample C code that we will be loading and using in order
    to learn about assembly language:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将加载和使用的示例C代码，以便学习汇编语言：
- en: '![](img/ec412315-e82b-4950-a83e-dd05899c8c9c.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec412315-e82b-4950-a83e-dd05899c8c9c.png)'
- en: 'We will run this piece of code in the immunity debugger, compiling it to a
    file called `Bufferoverflow.exe`. Let''s start by opening it with the immunity
    debugger:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在immunity调试器中运行这段代码，将其编译为名为`Bufferoverflow.exe`的文件。让我们首先用immunity调试器打开它：
- en: '![](img/dedae68a-edbc-4c52-bb80-0be7935c88bd.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dedae68a-edbc-4c52-bb80-0be7935c88bd.png)'
- en: Note that at the top right, we have a **Registers** section. The first register,
    `EAX`, is the accumulator. In a computer's CPU, an accumulator is a register in
    which the intermediate arithmetic and the logic results are stored. In the top
    left, we have the actual assembly code, while in the bottom left, we get the memory
    dump used by the program. The bottom right contains the stack area of the program
    that we are inspecting.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，右上角有一个**寄存器**部分。第一个寄存器`EAX`是累加器。在计算机的CPU中，累加器是存储中间算术和逻辑结果的寄存器。在左上角，我们有实际的汇编代码，而在左下角，我们得到程序使用的内存转储。右下角包含我们正在检查的程序的堆栈区域。
- en: 'If we scroll down to position `00401290`, we can see the `PUSH` command. We
    can also see the ASCII string `Functionfunction`, then the integer hexadecimal
    value. This is in reverse order, as the processor here is an Intel processor which
    uses little -endian notation, whereby  the lower order byte comes first:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们滚动到位置`00401290`，我们可以看到`PUSH`命令。我们还可以看到ASCII字符串`Functionfunction`，然后是整数十六进制值。这是逆序的，因为这里的处理器是使用小端记法的英特尔处理器，即低序字节先出现：
- en: '![](img/7685ab34-35c9-432e-b8fb-990695805168.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7685ab34-35c9-432e-b8fb-990695805168.png)'
- en: The previous screenshot shows the stack/code part of our `functionFunction` function,
    and each statement of this segment represents a statement of the original code
    that we had.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了我们的`functionFunction`函数的堆栈/代码部分，该部分的每个语句代表我们原始代码的一个语句。
- en: 'If we scroll down a little further, we will see the actual main method and
    the function calls made from there. This is shown next. In the highlighted area
    is the function call to the actual `functionFunction` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再往下滚动一点，我们将看到实际的主方法和从那里进行的函数调用。如下所示。在突出显示的区域是对实际`functionFunction`函数的函数调用：
- en: '![](img/006a8325-644a-4a05-a991-c7789f5231f4.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/006a8325-644a-4a05-a991-c7789f5231f4.png)'
- en: The main function returns `0`, which is what is shown by the assembly-level
    language as we are moving `0` to the EAX register. Similarly, in the previous
    screenshot, we were moving the value `1` to EAX.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数返回`0`，这正如汇编级语言所示，我们将`0`移动到EAX寄存器中。同样，在上一张截图中，我们将值`1`移动到EAX中。
- en: 'Let''s now go to **Debug** and click on **Arguments**. From here, we will supply
    the command-line argument to the assembly code so that we can run it without any
    errors in the debugger:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到**调试**并点击**参数**。从这里，我们将向汇编代码提供命令行参数，以便我们可以在调试器中运行而不会出现任何错误：
- en: '![](img/0c0c4eff-0555-4690-9ca6-7d9ee59b87ab.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c0c4eff-0555-4690-9ca6-7d9ee59b87ab.png)'
- en: 'We then need to set certain break points to understand the debugger, the program
    control, and the sequence flow more thoroughly. We will put a break point at the
    beginning of the main method, as specified by the code shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要设置某些断点，以更彻底地了解调试器、程序控制和顺序流。我们将在主方法的开头设置一个断点，如下所示：
- en: '![](img/14b61521-7705-4085-9954-4908e5bd2df1.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14b61521-7705-4085-9954-4908e5bd2df1.png)'
- en: 'The break point is highlighted in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 断点在以下截图中突出显示：
- en: '![](img/283ce7e7-f565-4c01-8c3d-80c8e1cda940.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/283ce7e7-f565-4c01-8c3d-80c8e1cda940.png)'
- en: 'Note that once we run the application, the code actually stops when it hits
    this line. This is what is meant by a break point:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦我们运行应用程序，当它遇到这一行时，代码实际上会停止。这就是所谓的断点：
- en: '![](img/4d24053f-ca57-4ae1-8400-5a36bc0727d1.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d24053f-ca57-4ae1-8400-5a36bc0727d1.png)'
- en: 'At the bottom right of the screen, the area we see is the stack area. As we
    know, every method has a dedicated area of execution, where all the local parameters
    are stored and where the code is executed. This is the area that we define as
    a stack. The first statement of the stack points towards the place where the program
    control is supposed to return after the successful execution of the whole method
    block. Note that we have four options on the top of the screen, which are **Step
    over**, **Step onto**, **Trace onto**, and **Trace over**. We will explore these
    options as we progress. Let''s go ahead and call step into, and see what happens
    with the stack and the debuggers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕右下方，我们看到的区域是堆栈区域。正如我们所知，每个方法都有一个专用的执行区域，其中存储所有本地参数并执行代码。这就是我们定义为堆栈的区域。堆栈的第一条语句指向程序控制在成功执行整个方法块后应该返回的位置。请注意，屏幕顶部有四个选项，分别是**跨过**、**跨入**、**跟踪进入**和**跟踪覆盖**。随着我们的进展，我们将探索这些选项。让我们继续调用step
    into，并看看堆栈和调试器会发生什么：
- en: '![](img/019fc4a9-d704-463e-a17a-b851c86f8b1a.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/019fc4a9-d704-463e-a17a-b851c86f8b1a.png)'
- en: 'Calling the step into function actually took the control to next line on the
    debugger. While that is happening, different values are added to the program variables.
    Note that the following line is going to call the `functionFunction` function, as
    specified:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 调用step into函数实际上将控制权转移到调试器上的下一行。在这种情况下，不同的值被添加到程序变量中。请注意，以下一行将调用`functionFunction`函数：
- en: '![](img/26d70cf9-0526-4014-a425-4ed9b5e09afc.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26d70cf9-0526-4014-a425-4ed9b5e09afc.png)'
- en: 'Notice that the previous address at which the function call from the main function
    to the `functionFunction` function will happen is from the `004012EA` memory address
    of the main function. When the function is called, the stack allocated to `functionFunction`
    must contain the return address, such that once it finishes its execution, it
    knows where exactly it is supposed to return:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从主函数到`functionFunction`函数的函数调用将发生在主函数的`004012EA`内存地址处。当调用函数时，分配给`functionFunction`的堆栈必须包含返回地址，以便一旦完成执行，它就知道自己应该返回到哪里：
- en: '![](img/62ecee8e-890e-4d8f-b73d-7a639f83808f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62ecee8e-890e-4d8f-b73d-7a639f83808f.png)'
- en: 'It can be seen on the right that the EIP register is holding the `00401EA` address.
    Note that at the bottom right, the address of the statement itself is `0060FD0`
    over on the stack. Let''s hit next and see what happens:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到右侧的EIP寄存器保存着`00401EA`地址。请注意，在右下方，语句本身的地址是堆栈上的`0060FD0`。让我们点击下一步，看看会发生什么：
- en: '![](img/e49153f7-9453-48e4-b7f2-5b2702c2008d.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e49153f7-9453-48e4-b7f2-5b2702c2008d.png)'
- en: It can be seen that the moment the function is called, its stack gets updated
    and says that the code should return to the `004012EF` address after the execution.
    The `004012EF` address is the next instruction address of the main function, `functionFunction`.
    Note that since the IP contains the address of the next instruction to be executed,
    it now contains the `00401290` address, which is the starting address of the `Functionfunction` function.
    Once it finishes its execution, the contents from the top of the stack will be
    popped (`004012EF`) and the IP will be updated with this address so that the program
    execution is retrieved from where it stopped last.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，一旦调用函数，它的堆栈就会更新，并且指示代码在执行后应该返回到`004012EF`地址。`004012EF`地址是主函数`functionFunction`函数的下一条指令地址。由于IP包含下一条要执行的指令的地址，它现在包含`00401290`地址，这是`Functionfunction`函数的起始地址。一旦完成执行，堆栈顶部的内容将被弹出（`004012EF`），IP将被更新为此地址，以便程序执行从上次停止的地方恢复。
- en: 'After clicking on next twice, we see that the first statement, assigning the
    integer value to a variable in our `functionFunction` method, will get executed.
    Finally, when we hit or reach the return statement or the end of the `functionFunction` method, we
    will see that the stack top will contain the return address shown in the following
    screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点击两次下一步后，我们看到在我们的`functionFunction`方法中将整数值分配给变量的第一条语句将被执行。最后，当我们达到`functionFunction`方法的返回语句或结束时，我们将看到堆栈顶部将包含下面屏幕截图中显示的返回地址：
- en: '![](img/b174c3f3-eb3e-4d45-9b7e-0f3449d97f9f.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b174c3f3-eb3e-4d45-9b7e-0f3449d97f9f.png)'
- en: We can hit next until the program exits from the main method. This is how the
    program will execute under normal circumstances, which we call behaved execution.
    In the next section, we'll see how to make the program misbehave.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击下一步直到程序退出主方法。这是程序在正常情况下执行的方式，我们称之为行为执行。在下一节中，我们将看到如何使程序行为异常。
- en: 'Let''s see what would happen at the code level of the assembly language when
    we overflow the buffer by providing an argument that exceeds the expected length.
    We''ll add more than nine characters in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们通过提供超出预期长度的参数来溢出缓冲区时，汇编语言的代码级别会发生什么。我们将在以下代码中添加超过九个字符：
- en: '![](img/dfb45afc-5ddf-49ca-99f2-a21e634b21e6.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfb45afc-5ddf-49ca-99f2-a21e634b21e6.png)'
- en: 'We will now keep the break point at the main method, as we had earlier. We
    will reach the break point when we run the code, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将保持在主方法中的断点，就像之前一样。当我们运行代码时，我们将到达断点，如下所示：
- en: '![](img/9e1655f4-5874-4245-9063-16bfd0c25041.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e1655f4-5874-4245-9063-16bfd0c25041.png)'
- en: 'In the next line, we will copy the value `112233` to the local variable. We
    will then call the `Functionfunction` function where the `bufferoverflow` actually takes
    place when we do a `strcpy` on the supplied argument to a local buffer of a size
    of `10`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们将把值`112233`复制到局部变量中。然后我们将调用`Functionfunction`函数，在这里`bufferoverflow`实际发生，当我们对大小为`10`的本地缓冲区执行`strcpy`时：
- en: '![](img/84c7b8df-c026-4f13-a0b9-2c19c423372a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84c7b8df-c026-4f13-a0b9-2c19c423372a.png)'
- en: 'As shown in the preceding screenshot, the string that we passed is placed in
    the register and will be passed to `functionFunction`. The line after the highlighted
    line is the actual function call:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们传递的字符串被放置在寄存器中，并将传递给`functionFunction`。突出显示行后的行是实际的函数调用：
- en: '![](img/b204e0a1-d9ea-4fd5-8aca-4b4359b41e8d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b204e0a1-d9ea-4fd5-8aca-4b4359b41e8d.png)'
- en: 'It can be seen in the highlighted line that the operation being executed is `strcpy(Localstring2,param)`,
    which means the value of the EAX register will be moved to the location `SS:[EBP
    +8]`. The moment we execute the preceding command, we will notice that the large
    value we gave will be loaded at the stack. We can see this at the bottom right of
    the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到在突出显示的行中，正在执行的操作是`strcpy(Localstring2,param)`，这意味着EAX寄存器的值将被移动到位置`SS:[EBP
    +8]`。一旦执行前面的命令，我们将注意到我们给出的大值将加载到堆栈中。我们可以在下面的屏幕截图的右下角看到这一点：
- en: '![](img/f17604eb-d2ec-41d6-ab96-4b3d5c18b114.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f17604eb-d2ec-41d6-ab96-4b3d5c18b114.png)'
- en: 'Now, the next line that will be executed will be the `strcpy` function after
    the one that is currently highlighted. We can see the stack of the `strcpy` function
    at the bottom right:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将执行的下一行将是当前突出显示的`strcpy`函数之后的`strcpy`函数。我们可以在右下角看到`strcpy`函数的堆栈：
- en: '![](img/0532e48f-9ac2-4ff6-9970-b31eebf5c0b5.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0532e48f-9ac2-4ff6-9970-b31eebf5c0b5.png)'
- en: 'There are a few buffers and memory locations in the `strcpy` function. When
    we write the value to a buffer of a length of 10, the buffer overflows and the
    remainder of the value gets spilled and written to the other memory locations
    of the stack. In other words, the other memory locations in the stack get overwritten
    by the spilled content. In this case, the memory location that contained the return
    address of the stack (once the execution was finished) would get overwritten and
    thus the code will end with an exception. This is what actually happens behind
    the scenes, as demonstrated in the following screenshot. At the bottom of the
    screenshot, we can see the access violation exception depicting this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`strcpy`函数中有一些缓冲区和内存位置。当我们将值写入长度为10的缓冲区时，缓冲区溢出，剩余的值会溢出并写入堆栈的其他内存位置。换句话说，堆栈中的其他内存位置将被溢出的内容覆盖。在这种情况下，一旦执行完成，包含堆栈返回地址的内存位置将被覆盖，因此代码将以异常结束。这实际上是发生在幕后的情况，如下面的屏幕截图所示。在屏幕截图的底部，我们可以看到访问冲突异常：
- en: '![](img/0eda79ff-2c5e-4825-befd-6ea37550331b.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0eda79ff-2c5e-4825-befd-6ea37550331b.png)'
- en: Exploiting buffer overflows in Windows
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows中利用缓冲区溢出
- en: 'There is a known buffer overflow vulnerability in the SLMail 5.5.0 Mail Server
    software. Let''s download the application (from the following URL: [https://slmail.software.informer.com/5.5/](https://slmail.software.informer.com/5.5/))
    and install it in Windows by double-clicking the `exe` installer. Once installed,
    run it inside a Windows 7 VM, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在SLMail 5.5.0邮件服务器软件中存在已知的缓冲区溢出漏洞。让我们从以下网址下载应用程序（https://slmail.software.informer.com/5.5/）并通过双击`exe`安装程序在Windows中安装它。安装完成后，在Windows
    7虚拟机中运行它，如下所示：
- en: '![](img/1b3cc5c9-fa3d-492f-bb14-f3f26c4efb78.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b3cc5c9-fa3d-492f-bb14-f3f26c4efb78.png)'
- en: 'Let''s now attach our running program to an immunity debugger and use a simple
    Python fuzzer to crash the program, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们运行的程序附加到一个immunity调试器，并使用一个简单的Python模糊器来使程序崩溃，如下所示：
- en: '![](img/2a6d93c9-123a-44da-9484-57645bbd470e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a6d93c9-123a-44da-9484-57645bbd470e.png)'
- en: 'The following screenshot depicts the loaded code once we have clicked on **Attach**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了一旦我们点击**附加**后加载的代码：
- en: '![](img/a17119b9-b04d-4bdb-9d6e-6f4c97a88845.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a17119b9-b04d-4bdb-9d6e-6f4c97a88845.png)'
- en: 'Let''s use a simple fuzzer written in Python to try to break this code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Python编写的简单模糊器来尝试破坏这段代码：
- en: '![](img/b13b2a87-5990-4d56-93e6-edb8c4aa22d9.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b13b2a87-5990-4d56-93e6-edb8c4aa22d9.png)'
- en: 'Now, let''s run the code to see where it breaks the email application and what
    the buffer values at the time of the crash are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行代码，看看它是如何破坏电子邮件应用程序的，以及在崩溃时缓冲区的值是多少：
- en: '![](img/44567dfa-40c1-4020-99a1-351cc20bd4dc.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44567dfa-40c1-4020-99a1-351cc20bd4dc.png)'
- en: It can be seen that somewhere between byte number `2700` and `2900` the access
    violation exception occurs. At this point, the values of the EIP instruction register
    are overwritten by a passed string of `A`, whose hexadecimal value is `41414141`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，在第`2700`和`2900`字节之间发生了访问冲突异常。在这一点上，EIP指令寄存器的值被传递的字符串`A`覆盖，其十六进制值为`41414141`。
- en: 'In order for us to figure out the exact location within a payload of `2900`
    bytes, we will make use of the Metasploit `generate.rb` module as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出`2900`字节内的有效负载的确切位置，我们将使用Metasploit的`generate.rb`模块，如下所示：
- en: '![](img/a689b76b-126d-4efd-b167-a5697760fdd0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a689b76b-126d-4efd-b167-a5697760fdd0.png)'
- en: 'Let''s place this uniquely generated string in a piece of Python code to rerun
    the exploit for us so that we can see the unique value inside the EIP at the time
    of the crash:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个唯一生成的字符串放在一段Python代码中，以便为我们重新运行利用程序，以便我们可以看到崩溃时EIP内的唯一值：
- en: '![](img/1f3f607c-b515-479d-8fa6-842091349b33.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f3f607c-b515-479d-8fa6-842091349b33.png)'
- en: 'Let''s restart the service in Windows and attach it to the debugger again.
    Finally, we will run our Python code to exploit it as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新启动Windows中的服务，并再次将其附加到调试器上。最后，我们将运行我们的Python代码来利用它，如下所示：
- en: '![](img/29672b62-2de3-4c45-95ae-f0fd5ca467a2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29672b62-2de3-4c45-95ae-f0fd5ca467a2.png)'
- en: 'It can clearly be seen that at the time of the crash, the value inside the
    EIP register is `39694438`. This will be the address that can tell us the offset
    of the payload, which can be computed as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以清楚地看到，在崩溃时，EIP寄存器内的值为`39694438`。这将是告诉我们有效负载偏移量的地址，可以按照这里所示进行计算：
- en: '![](img/6f6255f2-c601-4e7d-b6ac-15805a5046d6.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f6255f2-c601-4e7d-b6ac-15805a5046d6.png)'
- en: It can be seen that the exact offset that causes the crash happens to be at
    `2606`. At the time of the crash, all the values passed are stored in the ESP register,
    which makes ESP a potential candidate to hold our payload. If we send a payload
    up to 2600 bytes and then try to inject an instruction in EIP that makes a jump
    to the ESP, it will be the payload that will get executed. There are two methods
    to do this. We know that the EIP holds the address of the next instruction to
    be executed and as can be seen, the address of the ESP register at the time of
    the crash is `01C8A128`. The thought that would intuitively come to our mind is
    to simply place this address after 2600 bytes, but due to **Address space layout
    randomization** (**ASLR**), which is a memory protection process for operating
    systems that guards against buffer overflow attacks by randomizing the location
    where system executables are loaded into the memory, this straightforward technique
    will not work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，导致崩溃的确切偏移量是`2606`。在崩溃时，所有传递的值都存储在ESP寄存器中，这使得ESP成为保存我们有效负载的潜在候选者。如果我们发送多达2600字节的有效负载，然后尝试在EIP中注入一条指令，使其跳转到ESP，那么将执行有效负载。有两种方法可以做到这一点。我们知道EIP保存着要执行的下一条指令的地址，正如所见，崩溃时ESP寄存器的地址为`01C8A128`。直觉上会想到的是简单地在2600字节之后放置这个地址，但由于地址空间布局随机化（ASLR），这是一种用于操作系统的内存保护过程，通过使系统可执行文件加载到内存中的位置随机化，防范缓冲区溢出攻击，这种直接的技术将不起作用。
- en: 'Instead, let''s look for a memory address that will have an instruction such
    as JMP ESP. Since this location is outside the stack, it will not be impacted
    by ASLR whenever the program crashes. We will be using the `mona` script, which
    comes with an immunity debugger as a Python module and is used to search throughout
    the DLL process for any instructions, which in our case would be the hexadecimal
    equivalent of `jmp esp`. The mona script can be downloaded from [https://github.com/corelan/mona](https://github.com/corelan/mona),
    and can be directly placed at the following path within Windows: `C:\Program Files\Immunity
    Inc\Immunity Debugger\PyCommands`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们寻找一个内存地址，其中将有一个指令，比如`JMP ESP`。由于这个位置在堆栈之外，每当程序崩溃时，它都不会受到ASLR的影响。我们将使用mona脚本，它作为immunity调试器的Python模块随附，并用于在整个DLL进程中搜索任何指令，这在我们的情况下将是`jmp
    esp`的十六进制等价物。mona脚本可以从[https://github.com/corelan/mona](https://github.com/corelan/mona)下载，并可以直接放置在Windows的以下路径中：`C:\Program
    Files\Immunity Inc\Immunity Debugger\PyCommands`。
- en: 'Let''s compute the hexadecimal equivalent of `jmp esp` using a Metasploit Ruby
    script as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Metasploit的Ruby脚本计算`jmp esp`的十六进制等价物，如下所示：
- en: '![](img/1170644b-80eb-4e22-b683-1adc9806c0db.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1170644b-80eb-4e22-b683-1adc9806c0db.png)'
- en: 'We will therefore be searching for `\xff\xe4` within the immunity debugger
    and the `mona` script to find the `jmp` location as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在immunity调试器和mona脚本中搜索`\xff\xe4`，以找到`jmp`位置，如下所示：
- en: '![](img/cb4986e8-b335-494e-ba8a-d0f9695698f3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb4986e8-b335-494e-ba8a-d0f9695698f3.png)'
- en: 'We get many hits, but let''s take the first one, which is `0x5f4a358f`. The
    next step would be to generate the exploit code to give us a reverse shell on
    our machine and place that exploit code in a custom Python script to send the
    payload to the server. It should be noted that while generating the exploit code,
    we are going to encode it and escape certain bad characters to ensure it works
    properly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了很多命中，但让我们选择第一个，即`0x5f4a358f`。下一步将是生成利用代码，在我们的机器上给我们一个反向shell，并将该利用代码放在一个自定义的Python脚本中，以将有效负载发送到服务器。应当注意，在生成利用代码时，我们将对其进行编码并转义某些不良字符，以确保其正常工作：
- en: '![](img/14470d44-58b2-42d9-abc7-8b9eb0678fee.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14470d44-58b2-42d9-abc7-8b9eb0678fee.png)'
- en: 'With the preceding payload generated, let''s create a Python script that will
    cause the exploit. We will use our previously discovered location for `jmp esp`
    via the `mona` script. It should also be noted that since the payload is encoded,
    a few bytes will be used for decoding and a few bytes will be used for padding:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面生成的有效负载，让我们创建一个Python脚本来引发利用。我们将使用之前发现的`jmp esp`的位置，通过`mona`脚本。还应该注意，由于有效负载已编码，将用于解码的几个字节，还将用于填充的几个字节：
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, when we attach the running instance of the service or the process to our
    debugger and execute the script we created, we get the reverse shell from the
    victim machine that has `bufferoverflow`. This is depicted here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们将服务或进程的运行实例附加到我们的调试器并执行我们创建的脚本时，我们就可以从具有`bufferoverflow`的受害者机器获得反向shell。如图所示：
- en: '![](img/e2d10261-b3b6-4e64-950e-bf039f7395ba.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2d10261-b3b6-4e64-950e-bf039f7395ba.png)'
- en: This is how we exploit buffer overflow vulnerabilities in Windows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何利用Windows中的缓冲区溢出漏洞。
- en: If we go ahead and compile the program (given in the heap buffer overflow section
    of the previous chapter) in a native Windows environment and run it with a long
    argument, we can then exploit heap buffer overflow in Windows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续在本地Windows环境中编译程序（在上一章的堆缓冲区溢出部分中给出），并使用一个长参数运行它，我们就可以利用Windows中的堆缓冲区溢出。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We demonstrated the same steps here as in the previous chapter, but in a Windows
    environment. The concepts are largely the same between Windows and Linux environments,
    but the implementation of stacks and registers may vary a little. For this reason,
    it is important to be well versed in exploitation in both environments. In the
    next chapter, we will develop exploits in Python and also in Ruby to extend the
    capabilities of the Metasploit framework.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示了与上一章相同的步骤，但在Windows环境中。 Windows和Linux环境之间的概念基本相同，但堆栈和寄存器的实现可能会有所不同。因此，重要的是要熟练掌握两种环境中的利用。在下一章中，我们将开发Python和Ruby中的利用以扩展Metasploit框架的功能。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we automate the process of exploiting buffer overflow vulnerabilities
    in Windows?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动化利用Windows中的缓冲区溢出漏洞的过程？
- en: What can we do to avoid advanced protections being imposed by operating systems,
    such as disabling code execution on a stack in Windows?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以采取什么措施来避免操作系统施加的高级保护，例如在Windows中禁用堆栈上的代码执行？
- en: Why are registers different in Windows and in Red Hat?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Windows和Red Hat中的寄存器不同？
- en: Further reading
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Stack buffer overflow SLmail: [https://www.exploit-db.com/exploits/638/](https://www.exploit-db.com/exploits/638/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈缓冲区溢出SLmail：[https://www.exploit-db.com/exploits/638/](https://www.exploit-db.com/exploits/638/)
- en: 'Heap buffer overflow: [https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html](https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆缓冲区溢出：[https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html](https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html)
- en: 'String format vulnerabilities: [https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式漏洞：[https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)
