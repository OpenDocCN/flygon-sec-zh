- en: Chapter 5. Web Header Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 网页头部操作
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing HTTP methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试HTTP方法
- en: Fingerprinting servers through HTTP headers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP标头对服务器进行指纹识别
- en: Testing for insecure headers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试不安全的标头
- en: Brute forcing login through the Authorization header
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过授权标头进行暴力登录
- en: Testing for clickjacking vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试点击劫持漏洞
- en: Identifying alternative sites by spoofing user agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过欺骗用户代理标识替代站点
- en: Testing for insecure cookie flags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试不安全的cookie标志
- en: Session fixation through a cookie injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过cookie注入进行会话固定
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A key area of penetration testing web servers is to focus in deep on the server's
    ability to handle requests and serve responses. If you're penetration testing
    a standard web server deployment, for example Apache or Nginx, then you will want
    to concentrate on breaking the configuration that's been deployed and enumerating/manipulating
    the content of the site. If it's a custom web server that you're penetration testing,
    then it's a good idea to have a copy of the HTTP RFC handy (available at [http://tools.ietf.org/html/rfc7231](http://tools.ietf.org/html/rfc7231))
    and to additionally test how the web server handles corrupted packets or unexpected
    requests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试Web服务器的一个关键领域是深入研究服务器处理请求和提供响应的能力。如果你正在渗透测试标准的Web服务器部署，例如Apache或Nginx，那么你将希望集中精力打破已部署的配置并枚举/操作站点的内容。如果你正在渗透测试自定义的Web服务器，那么最好随身携带HTTP
    RFC的副本（可在[http://tools.ietf.org/html/rfc7231](http://tools.ietf.org/html/rfc7231)获取），并额外测试Web服务器如何处理损坏的数据包或意外请求。
- en: This chapter will focus on creating recipes that manipulate requests in a way
    that should uncover the underlying web technologies and parse responses to highlight
    common issues or key areas for further testing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍创建配方，以便以揭示底层Web技术并解析响应以突出显示常见问题或进一步测试的关键领域的方式操作请求。
- en: Testing HTTP methods
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试HTTP方法
- en: A good place to start with testing web servers is at the beginning of the `HTTP`
    request, by enumerating the `HTTP` methods. The `HTTP` method is sent by the client
    and indicates to the web server the type of action that the client is expecting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Web服务器的一个很好的起点是在`HTTP`请求的开始处，通过枚举`HTTP`方法。`HTTP`方法由客户端发送，并指示Web服务器客户端期望的操作类型。
- en: As specified in RFC 7231, all web servers must support `GET` and `HEAD` methods,
    and all other methods are optional. As there are a lot of common methods beyond
    the initial `GET` and `HEAD` methods, this makes it a good place to focus testing
    on, as each server will be written to handle requests and send responses in a
    different way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 7231的规定，所有Web服务器必须支持`GET`和`HEAD`方法，所有其他方法都是可选的。由于除了最初的`GET`和`HEAD`方法之外还有很多常见的方法，这使得它成为测试的一个重点，因为每个服务器都将被编写以以不同的方式处理请求和发送响应。
- en: An interesting `HTTP` method to look out for is `TRACE`, as its availability
    leads to **Cross Site Tracing** (**XST**). TRACE is a loop-back test and basically
    echoes the request it receives back to the user. This means it can be used for
    Cross-site scripting attacks (called in this case Cross Site Tracing). To do this,
    the attacker gets a victim to send a `TRACE` request, with a JavaScript payload
    in the body, which would then get executed locally when returned. Modern browsers
    now have defenses built-in to protect the user from these attacks by blocking
    TRACE requests made through JavaScript, so this technique now only works against
    old browsers or when leveraging other technologies such as Java or Flash.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的`HTTP`方法是`TRACE`，因为其可用性导致**跨站点跟踪**（**XST**）。TRACE是一个回环测试，基本上会将其接收到的请求回显给用户。这意味着它可以用于跨站点脚本攻击（在这种情况下称为跨站点跟踪）。为此，攻击者让受害者发送一个带有JavaScript有效载荷的`TRACE`请求，然后在返回时在本地执行。现代浏览器现在内置了防御措施，通过阻止通过JavaScript发出的TRACE请求来保护用户免受这些攻击，因此这种技术现在只对旧浏览器有效，或者在利用其他技术（如Java或Flash）时才有效。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to connect to the target web server and attempt
    to enumerate the various `HTTP` methods available. We shall also be looking for
    the presence of the `TRACE` method and highlighting it, if available:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将连接到目标Web服务器，并尝试枚举各种可用的`HTTP`方法。我们还将寻找`TRACE`方法的存在，并在可能的情况下进行突出显示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The first line imports the requests library; this will be used a lot in this
    section:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了requests库；在本节中将经常使用它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next line creates an array of the `HTTP` methods we are going to send.
    Notice the standard ones—`GET`, `POST`, `PUT`, `HEAD`, `DELETE,` and `OPTIONS`—followed
    by a non-standard `TEST` method. This has been added to check how the server handles
    input that it''s not expecting. Some web frameworks treat a non-standard verb
    as a `GET` request and respond accordingly. This can be a good way to bypass firewalls,
    as they may have a strict list of methods to match against and not process requests
    from unexpected methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建了一个我们将发送的`HTTP`方法数组。请注意标准方法——`GET`、`POST`、`PUT`、`HEAD`、`DELETE`和`OPTIONS`——后面是一个非标准的`TEST`方法。这是为了检查服务器如何处理它不期望的输入。一些Web框架将非标准动词视为`GET`请求并相应地响应。这可以是绕过防火墙的一种好方法，因为它们可能有一个严格的方法列表来匹配，并且不处理来自意外方法的请求：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next is the main loop of the script. This part sends the HTTP packet; in this
    case, to the target `http://packtpub.com` web server. It prints out the method
    and the response status code and reason:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是脚本的主循环。这部分发送HTTP数据包；在这种情况下，发送到目标`http://packtpub.com` Web服务器。它打印出方法和响应状态代码和原因：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, there is a section of code to specifically test for XST:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一段代码专门用于测试XST：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code checks the server response when sending a `TRACE` call, checking to
    see if the response contains the request text.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在发送`TRACE`调用时检查服务器响应，检查响应是否包含请求文本。
- en: 'Running the script gives the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本会得到以下输出：
- en: '![How it works…](img/B04044_05_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04044_05_01.jpg)'
- en: Here, we can see that the web server is correctly handling the first five requests,
    returning a `200 OK` response for all these methods. The `TRACE` response returns
    `405 Not Allowed`, showing that this has been explicitly denied by the web server.
    One interesting thing with the target server here is that it returns a `200 OK`
    response for the `TEST` method. This means that the server is processing the `TEST`
    request as a different method; for example, it's treating it as a `GET` request.
    As earlier mentioned, this makes a good way to bypass some firewalls, as they
    may not process the unexpected `TEST` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Web服务器正确处理了前五个请求，对所有这些方法返回`200 OK`响应。`TRACE`响应返回`405 Not Allowed`，显示这已被Web服务器明确拒绝。这里目标服务器的一个有趣之处是，它对`TEST`方法返回`200
    OK`响应。这意味着服务器将`TEST`请求处理为不同的方法；例如，它将其视为`GET`请求。正如前面提到的，这是绕过一些防火墙的好方法，因为它们可能不会处理意外的`TEST`方法。
- en: There's more…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we've shown how to test a target web server for the XST vulnerability
    and test how it handles various `HTTP` methods. This script could be extended
    further by expanding the example `HTTP` method array to include various other
    valid and invalid data values; perhaps you could try sending Unicode data to test
    how the web server handles unexpected character sets or send a very long HTTP
    method and to test for buffer overflows in custom web servers. A good resource
    for this data is to check back to the fuzzing scripts in [Chapter 3](ch03.html
    "Chapter 3. Vulnerability Identification"), *Vulnerability Identification*, for
    example, using payloads from Mozilla's FuzzDB.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了如何测试目标Web服务器的XST漏洞，并测试它如何处理各种`HTTP`方法。这个脚本可以通过扩展示例`HTTP`方法数组来进一步扩展，以包括各种其他有效和无效的数据值；也许您可以尝试发送Unicode数据来测试Web服务器如何处理意外的字符集，或者发送一个非常长的HTTP方法来测试自定义Web服务器中的缓冲区溢出。这些数据的一个很好的资源是回到[第3章](ch03.html
    "第3章。漏洞识别")中的模糊脚本，*漏洞识别*，例如，使用来自Mozilla的FuzzDB的有效载荷。
- en: Fingerprinting servers through HTTP headers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP头指纹识别服务器
- en: The next part of the HTTP protocol that we will be concentrating on are the
    HTTP headers. Found in both the requests and responses from the web server, these
    carry extra information between the client and server. Any area with extra data
    makes a great place to parse information about the servers and to look for potential
    issues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将集中关注的HTTP协议的下一部分是HTTP头部。这些头部在Web服务器的请求和响应中都可以找到，它们在客户端和服务器之间携带额外的信息。任何带有额外数据的区域都是解析服务器信息和寻找潜在问题的好地方。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a simple header grabbing script that will parse the response
    headers in an attempt to identify the web server technology in use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的抓取头部的脚本，它将解析响应头，试图识别正在使用的Web服务器技术：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first part of the script makes a simple `GET` request to the target web
    server, through the familiar `requests` library:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一部分通过熟悉的`requests`库向目标Web服务器发出简单的`GET`请求：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we generate an array of headers to look out for:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们生成一个要查找的头部数组：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this script, we have used a try/except block around the main code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们在主要代码周围使用了try/except块：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need this error handling because headers are not mandatory; therefore, if
    we tried to retrieve a key from the array for a header that didn't exist, Python
    would raise an exception. To overcome this, we simply print out `Not found` if
    the specified header wasn't present in the response.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这种错误处理，因为头部不是强制的；因此，如果我们尝试从数组中检索不存在的头部的键，Python将引发异常。为了克服这个问题，如果响应中指定的头部不存在，我们只需打印`Not
    found`。
- en: 'The following is a screenshot of the output from running the script against
    the target server in this example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是针对此示例中目标服务器运行脚本的输出的屏幕截图：
- en: '![How it works…](img/B04044_05_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_05_02.jpg)'
- en: The first output line show the `Server` header, which displays the underlying
    web server technology. This is a great place for finding vulnerable web server
    versions, but be aware that it is possible to disable and also spoof this header,
    so don't explicitly rely on this for guessing the target server platform.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输出显示了`Server`头，显示了底层Web服务器技术。这是查找易受攻击的Web服务器版本的好地方，但请注意，可能可以禁用并伪装这个头部，因此不要仅仅依赖这一点来猜测目标服务器平台。
- en: The `Date` header contains useful information that can be used to guess where
    the server is located. For example, you can figure out the time difference relative
    to your local time zone to give a rough indication of where it is.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`头包含有用的信息，可以用来猜测服务器的位置。例如，您可以计算相对于您的本地时区的时间差，以粗略地指示它的位置。'
- en: The `Via` header is used by proxies, both outgoing and incoming, and will display
    the proxy name, in this case `1.1 varnish`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Via`头部被代理服务器（出站和入站）使用，并将显示代理名称，在本例中为`1.1 varnish`。'
- en: The `X-Powered-By` is a standard header used in common web frameworks such as
    PHP. A default PHP installation will respond with PHP and the version number,
    making it another great target for reconnaissance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Powered-By`是常见Web框架中使用的标准头部，例如PHP。默认的PHP安装将以PHP和版本号作出响应，使其成为另一个很好的侦察目标。'
- en: The final line prints the `X-Country-Code` short code, another useful piece
    of information to identify where the server is located.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行打印`X-Country-Code`短代码，另一个有用的信息，用于确定服务器的位置。
- en: Be aware that all these headers can be set or overridden on the server side,
    so do not rely on this information explicitly and be wary of parsing data directly
    from remote servers; even these headers could contain malicious values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些头部都可以在服务器端设置或覆盖，因此不要仅仅依赖这些信息，并谨慎地解析来自远程服务器的数据；即使这些头部也可能包含恶意值。
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This script currently contain the version of the server, but it could then be
    extended further to query online CVE databases, such as [https://cve.mitre.org/cve/](https://cve.mitre.org/cve/),
    looking for vulnerabilities affecting the web server version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本当前包含服务器的版本，但可以进一步扩展以查询在线CVE数据库，例如[https://cve.mitre.org/cve/](https://cve.mitre.org/cve/)，查找影响Web服务器版本的漏洞。
- en: Another technique that can be used to increase the confidence of fingerprinting
    is to check the order of the response headers. For example, Microsoft IIS returns
    the `Server` header before the `Date` header, whereas Apache returns `Date` and
    then `Server`. This slightly different ordering can be used to verify any server
    versions that you may have deduced from the header values in this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用另一种技术来增加指纹识别的准确性，即检查响应标头的顺序。例如，Microsoft IIS在`Server`标头之前返回`Date`标头，而Apache先返回`Date`然后是`Server`。这种略有不同的顺序可用于验证您可能已经从此示例中的标头值推断出的任何服务器版本。
- en: Testing for insecure headers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试不安全的标头
- en: We've previously seen how the HTTP responses can be a great source of information
    for enumerating the underlying web framework in place. We are now going to take
    this to the next level by using the `HTTP` header information to test for insecure
    web server configurations and flagging up anything that can lead to a vulnerability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到HTTP响应可以成为枚举底层Web框架信息的重要来源。现在，我们将利用`HTTP`标头信息将其提升到下一个级别，以测试不安全的Web服务器配置并标记可能导致漏洞的任何内容。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a list of URLs that you want to test for insecure
    headers. Save these into a text file called `urls.txt`, with each URL on a new
    line, alongside your recipe.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，您需要一个要测试不安全标头的URL列表。将这些保存到名为`urls.txt`的文本文件中，每个URL占一行，与您的示例一起。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following code will highlight any vulnerable headers received in the HTTP
    response from each of the target URLs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将突出显示从每个目标URL接收的任何易受攻击的标头：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'This recipe is configured for testing many sites, so the first part reads in
    the URLs from the text file and prints out the current target:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例配置为测试许多站点，因此第一部分从文本文件中读取URL并打印出当前目标：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each header is then tested inside a try/except block. This is similar to the
    previous recipe in which this coding style is needed because the headers are not
    mandatory. If we attempted to reference a key for a header that doesn't exist,
    Python would raise an exception.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在try/except块中测试每个标头。这类似于先前的示例，因为标头不是强制性的，所以需要这种编码风格。如果我们尝试引用不存在的标头的键，Python将引发异常。
- en: 'The first `X-XSS-Protection` header should be set to `1; mode=block` to enable
    XSS protection in the browser. The script prints out a warning if the header does
    not explicitly match that format or if it''s not set:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`X-XSS-Protection`标头应设置为`1; mode=block`以在浏览器中启用XSS保护。如果标头未明确匹配该格式或未设置，则脚本将打印警告：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next `X-Content-Type-Options` header should be set to `nosniff` to prevent
    MIME type confusion. A MIME type specifies the content of the target resource,
    for example, text/plain means the remote resource should be a text file. Some
    web browsers attempt to guess the MIME type of a resource if it''s not specified.
    This can lead to Cross-site scripting attacks; if a resource contains a malicious
    script, but it only indicates to be a plain text file, it may bypass content filters
    and be executed. This check will print a warning if the header is not set or if
    the response does not explicitly match to `nosniff`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`X-Content-Type-Options`标头应设置为`nosniff`，以防止MIME类型混淆。 MIME类型指定目标资源的内容，例如，text/plain表示远程资源应为文本文件。一些Web浏览器会尝试猜测资源的MIME类型，如果未指定，则可能导致跨站脚本攻击；如果资源包含恶意脚本，但仅指示为纯文本文件，则可能绕过内容过滤器并执行。如果未设置标头或响应未明确匹配到`nosniff`，此检查将打印警告：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next `Strict-Transport-Security` header is used to force communication
    over a HTTPS channel, to prevent **man in the middle** (**MITM**) attacks. The
    lack of this header means that the communication channel could be downgraded to
    HTTP by an MITM attack:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`Strict-Transport-Security`标头用于强制通过HTTPS通道进行通信，以防止中间人攻击。缺少此标头意味着通信通道可能会被中间人攻击降级为HTTP：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final `Content-Security-Policy` header is used to restrict the type of
    resources that can load on the web page, for example, restricting where JavaScript
    can run:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`Content-Security-Policy`标头用于限制可以在网页上加载的资源类型，例如，限制JavaScript可以运行的位置：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output from the recipe is shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的输出显示在以下屏幕截图中：
- en: '![How it works…](img/B04044_05_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04044_05_03.jpg)'
- en: Brute forcing login through the Authorization header
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Authorization标头暴力破解登录
- en: Many websites use HTTP basic authentication to restrict access to content. This
    is especially prevalent in embedded devices such as routers. The Python `requests`
    library has built-in support for basic authentication, making an easy way to create
    an authentication brute force script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站使用HTTP基本身份验证来限制对内容的访问。这在嵌入式设备（如路由器）中尤其普遍。Python的`requests`库内置支持基本身份验证，可以轻松创建身份验证暴力破解脚本的方法。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before creating this recipe, you're going to need a list of passwords to attempt
    to authenticate with. Create a local text file called `passwords.txt`, with each
    password on a new line. Check out Brute forcing passwords in [Chapter 2](ch02.html
    "Chapter 2. Enumeration"), *Enumeration*, for password lists from online resources.
    Also, spend some time to scope out the target server as you're going to need to
    know how it responds to a failed login request, so that we can differentiate when
    the brute force works or not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此示例之前，您需要一个密码列表来尝试进行身份验证。创建一个名为`passwords.txt`的本地文本文件，每个密码占一行。查看[第2章](ch02.html
    "第2章。枚举")中的在线资源中的密码列表，了解如何暴力破解密码。此外，花一些时间来勘察目标服务器，因为您需要知道它对失败的登录请求做出何种响应，以便我们可以区分暴力破解是否成功。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code will attempt to brute force entry to website through basic
    authentication:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将尝试通过基本身份验证暴力破解网站的入口：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first part of this script reads in the password list, line by line. Then,
    it sends an HTTP `GET` request to the login page:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的第一部分逐行读取密码列表，然后发送一个HTTP `GET`请求到登录页面：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This request has an additional `auth` parameter, which contains the username
    `admin` and the `password` read from the `passwords.txt` file. When sending an
    HTTP request with a basic `Authorization` header, the raw data looks like the
    following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求有一个额外的`auth`参数，其中包含了用户名`admin`和从`passwords.txt`文件中读取的`password`。当发送带有基本`Authorization`头的HTTP请求时，原始数据看起来像下面这样：
- en: '![How it works…](img/B04044_05_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04044_05_04.jpg)'
- en: 'Notice that in the `Authorization` header the data is sent in an encoded format,
    such as `YWRtaW46cGFzc3dvcmQx`. This is the username and password in a `base64`
    encoded form of `username:password`; the `requests.auth.HTTPBasicAuth` class just
    does this conversion for us. This can be verified by using the `base64` library,
    as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`Authorization`头中，数据以编码格式发送，比如`YWRtaW46cGFzc3dvcmQx`。这是用户名和密码以`base64`编码形式的`username:password`；`requests.auth.HTTPBasicAuth`类只是为我们做了这个转换。这可以通过使用`base64`库来验证，如下面的截图所示：
- en: '![How it works…](img/B04044_05_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04044_05_05.jpg)'
- en: Knowing this information means that you could still get the script to run without
    the external requests library; instead, it crafts an `Authorization` header manually
    using the `base64` default library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些信息意味着你仍然可以让脚本在没有外部请求库的情况下运行；相反，它使用`base64`默认库手动创建`Authorization`头。
- en: 'The following is a screenshot of the brute force script in action:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是暴力破解脚本运行的截图：
- en: '![How it works…](img/B04044_05_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04044_05_06.jpg)'
- en: There's more…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we've used a fixed username of admin in the authorization request,
    as this was known. If this is unknown, you could create a `username.txt` text
    file and loop through each of those lines too, just as we've done with the password
    text file. Note that this is a much slower process and creates a lot of HTTP requests
    to the target site, which is likely to get you blacklisted, unless you implement
    rate limiting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在授权请求中使用了一个固定的用户名admin，因为这是已知的。如果这是未知的，你可以创建一个`username.txt`文本文件，并循环遍历每一行，就像我们对密码文本文件所做的那样。请注意，这是一个更慢的过程，并且会创建大量的HTTP请求到目标站点，这很可能会使你被列入黑名单，除非你实现速率限制。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Check out the *Checking username validity* and *Brute forcing usernames* recipes
    in [Chapter 2](ch02.html "Chapter 2. Enumeration"), *Enumeration*, for further
    ideas on username and password combinations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[第2章](ch02.html "第2章 枚举")中的*检查用户名有效性*和*暴力破解用户名*的示例，以获取有关用户名和密码组合的更多想法。
- en: Testing for clickjacking vulnerabilities
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试点击劫持漏洞
- en: Clickjacking is a technique used to trick users into performing actions on a
    target site without them realizing. This is done by a malicious user placing a
    hidden overlay on top of a legitimate website, so when the victim thinks they
    are interacting with the legitimate site, they are really clicking on hidden items
    on the hidden top overlay. This attack can be crafted in such a way that it causes
    the victim to type in credentials or click and drag on items without realizing
    they are being attacked. These attacks can be used against banking sites to trick
    victims into transferring funds and were also common among social networking sites
    in an attempt to gain more followers or likes, although most have defensive measures
    in place now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击劫持是一种用于欺骗用户在不知情的情况下在目标站点上执行操作的技术。这是通过恶意用户在合法网站上放置一个隐藏的覆盖层来实现的，因此当受害者认为他们正在与合法网站进行交互时，实际上他们点击的是隐藏在顶部覆盖层上的隐藏项目。这种攻击可以被设计成使受害者在不知情的情况下输入凭据或点击和拖动项目。这些攻击可以用于针对银行网站，以诱使受害者转账，也常见于社交网络站点，以试图获得更多的关注或点赞，尽管现在大多数站点都有了防御措施。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are two main ways websites can prevent clickjacking: either by setting
    an `X-FRAME-OPTIONS` header, which tells the browser not to render the site if
    it''s inside a frame, or by using JavaScript to escape out of frames (commonly
    known as frame-busting). This recipe will show you how to detect both defenses
    so that you can identify websites that have neither:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 网站可以防止点击劫持的两种主要方法：一种是设置`X-FRAME-OPTIONS`头，告诉浏览器如果它在一个框架内就不要渲染该站点，另一种是使用JavaScript来跳出框架（通常称为破框）。这个示例将向你展示如何检测这两种防御，以便你可以识别那些没有这两种防御的网站。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first part of this script checks for the first clickjacking defense, the
    `X-FRAME-OPTIONS` header, in a similar fashion as we''ve seen in the previous
    recipe. `X-FRAME-OPTIONS` takes three values: `DENY`, `SAMEORIGIN`, or `ALLOW-FROM
    <url>`. Each of these values give a different level of protection against clickjacking,
    so, in this recipe, we are attempting to detect the lack of any:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的第一部分检查了第一个点击劫持防御，即`X-FRAME-OPTIONS`头，方式与前面的示例类似。`X-FRAME-OPTIONS`有三个值：`DENY`、`SAMEORIGIN`或`ALLOW-FROM
    <url>`。每个值都提供了不同级别的点击劫持保护，因此，在这个示例中，我们尝试检测是否缺少任何一个：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next part of the code creates a local html `clickjack.html` file, containing
    a few very simple lines of HTML code, and saves them into a local `clickjack.html`
    file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分创建了一个本地的html `clickjack.html`文件，其中包含了一些非常简单的HTML代码，并将它们保存到一个本地的`clickjack.html`文件中：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This HTML code creates an iframe with the source set to the target website.
    The HTML file will be loaded into ghost in an attempt to render the website and
    detect if the target site is loaded in the iframe. Ghost is a WebKit rendering
    engine, so it should be similar to what would happen if the site is loaded in
    a Chrome browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段HTML代码创建了一个iframe，其源设置为目标网站。HTML文件将被加载到ghost中，以尝试渲染网站并检测目标站点是否加载在iframe中。Ghost是一个WebKit渲染引擎，所以它应该类似于在Chrome浏览器中加载站点时会发生的情况。
- en: 'The next part sets up ghost logging to redirect to a local log file (the default
    is printing to `stdout`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分设置ghost日志记录以重定向到本地日志文件（默认情况下是打印到`stdout`）：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next line renders the local HTML page in ghost and contain any extra resources
    that were requested by the target page:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一行在ghost中呈现本地HTML页面，并包含目标页面请求的任何额外资源：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then open the log file and check for the `X-FRAME-OPTIONS` error:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打开日志文件并检查`X-FRAME-OPTIONS`错误：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next part of the script checks for framebusting; if the iframe has JavaScript
    code to detect it''s being loaded inside an iframe it will break out of the frame,
    causing the page to redirect to the target website. We can detect this by executing
    JavaScript in ghost with `ghost.evaluate` and reading the current location:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一部分检查了框架破坏；如果iframe中有JavaScript代码来检测它正在被加载到iframe中，它将会跳出框架，导致页面重定向到目标网站。我们可以通过在ghost中执行JavaScript并读取当前位置来检测这一点：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final part of code is for clean-up, closing any open files or any open
    logging handlers, and deleting the temporary HTML and log files:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分是清理，关闭任何打开的文件或任何打开的日志处理程序，并删除临时HTML和日志文件：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the script outputs `Frame busting not detected, page is likely vulnerable
    to clickjacking`, then the target website can be rendered inside a hidden iframe
    and used in a clickjacking attack. An example of the log from a vulnerable site
    is shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本输出`未检测到框架破坏，页面可能容易受到clickjacking攻击`，那么目标网站可以在隐藏的iframe中呈现，并用于clickjacking攻击。下面的截图显示了一个易受攻击网站的日志示例：
- en: '![How it works…](img/B04044_05_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_05_07.jpg)'
- en: 'If you view the generating clickjack.html file in a web browser, it will confirm
    that the target web server can be loaded in an iframe and is therefore susceptible
    to clickjacking, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在web浏览器中查看生成的clickjack.html文件，它将确认目标web服务器可以在iframe中加载，因此容易受到clickjacking的攻击，如下面的截图所示：
- en: '![How it works…](img/B04044_05_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_05_08.jpg)'
- en: Identifying alternative sites by spoofing user agents
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过欺骗用户代理标识替代站点
- en: Some websites restrict access or display different content-based on the browser
    or device you're using to view it. For example, a web site may show a mobile-oriented
    theme for users browsing from an iPhone or display a warning to users with an
    old and vulnerable version of Internet Explorer. This can be a good place to find
    vulnerabilities because these might have been tested less rigorously or even forgotten
    about by the developers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站限制访问或根据您用于查看它的浏览器或设备显示不同的内容。例如，一个网站可能会为从iPhone浏览的用户显示移动定向主题，或者为使用旧版本且容易受攻击的Internet
    Explorer的用户显示警告。这可能是发现漏洞的好地方，因为这些可能没有经过严格测试，甚至被开发人员遗忘了。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will show you how to spoof your user agent, so you appear
    to the website as if you''re using a different device in an attempt to uncover
    alternative content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将向您展示如何欺骗您的用户代理，以便您看起来像是在使用不同的设备，以尝试发现替代内容：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We first set up an array of user agents, with a friendly name assigned to each
    key:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置了一个用户代理数组，为每个键分配了友好的名称：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are four user agents here: Chrome on Windows 8.1, Safari on iOS, Internet
    Explorer 6 on Windows XP, and finally, the Googlebot. This gives a wide range
    of browsers and examples of which you would expect to find different content behind
    each request. The final user agent in the list, Googlebot, is the crawler that
    Google sends when spidering data for their search engine.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有四个用户代理：Windows 8.1上的Chrome，iOS上的Safari，Windows XP上的Internet Explorer 6，最后是Googlebot。这提供了各种浏览器和示例，你会期望在每个请求后面找到不同的内容。列表中的最后一个用户代理，Googlebot，是Google在为他们的搜索引擎爬取数据时发送的爬虫。
- en: 'The next part loops through each of the user agents and sets the `User-Agent`
    header in the request:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分循环遍历每个用户代理，并在请求中设置`User-Agent`标头：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next section sends the HTTP request, using the familiar requests library,
    and stores each response in the responses array, using the user friendly name
    as the key:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分发送HTTP请求，使用熟悉的requests库，并将每个响应存储在响应数组中，使用友好的用户名作为键：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next part of the code creates an `md5s` array and then iterates through
    the responses, grabbing the `response.text` file. From this, it generates an `md5`
    hash of the response content and stores it into the `md5s` array:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分创建了一个`md5s`数组，然后遍历响应，抓取`response.text`文件。从中生成响应内容的`md5`哈希，并将其存储到`md5s`数组中：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final part of the code iterates through the `md5s` array and compares each
    item to the original baseline request, in this recipe `Chrome on Windows 8.1`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分遍历`md5s`数组，并将每个项目与原始基线请求进行比较，在这个示例中是`Chrome on Windows 8.1`：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We hashed the response text so that it keeps the resulting array small, thus
    reducing the memory footprint. You could compare each response directly by its
    content, but this would be slower and use more memory to process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对响应文本进行了哈希处理，以使生成的数组保持较小，从而减少内存占用。你可以通过其内容直接比较每个响应，但这样会更慢，并且会使用更多内存来处理。
- en: 'This script will print out the user agent friendly name if the response from
    the web server is different from the Chrome on Windows 8.1 baseline response,
    as seen in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果来自Web服务器的响应与Chrome on Windows 8.1基线响应不同，脚本将打印出用户代理友好的名称，如下面的截图所示：
- en: '![How it works…](img/B04044_05_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_05_09.jpg)'
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe is based upon being able to manipulate headers in the HTTP requests.
    Check out *Header-based Cross-site scripting* and *Shellshock checking* sections
    in [Chapter 3](ch03.html "Chapter 3. Vulnerability Identification"), *Vulnerability
    Identification*, for more examples of data that can be passed into the headers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是基于能够操纵HTTP请求中的标头。查看[第3章](ch03.html "第3章.漏洞识别")中的*基于标头的跨站脚本*和*Shellshock检查*部分，了解更多可以传递到标头中的数据示例。
- en: Testing for insecure cookie flags
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试不安全的cookie标志
- en: The next topic of interest from the HTTP protocol is cookies. As HTTP is a stateless
    protocol, cookies provide a way to store persistent data on the client side. This
    allows a web server to have session management by persisting data to the cookie
    for the length of the session.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议的下一个感兴趣的主题是cookie。由于HTTP是一个无状态协议，cookie提供了一种在客户端存储持久数据的方式。这允许Web服务器通过将数据持久化到cookie中来进行会话管理，以便在会话期间保持数据。
- en: Cookies are set from the web server in the HTTP response using a `Set-Cookie`
    header. They are then sent back to the server through the `Cookie` header. This
    recipe will look at ways to audit the cookies being set by a website to verify
    if they have secure attributes or not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies是通过HTTP响应中的`Set-Cookie`头从Web服务器设置的。然后它们通过`Cookie`头发送回服务器。这个教程将介绍审核网站设置的cookie的方法，以验证它们是否具有安全属性。
- en: How to do it…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following is a recipe to enumerate through each of the cookies set on a
    target site and flag any insecure settings that are present:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个枚举目标站点上设置的每个cookie并标记任何存在的不安全设置的教程：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We enumerate each cookie sent from the web server and check their attributes.
    The first two attributes are the `name` and `value` of the cookie:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们枚举从Web服务器发送的每个cookie并检查它们的属性。前两个属性是cookie的`name`和`value`：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then check for the `secure` flag on the cookie:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查cookie的`secure`标志：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Secure` flag on a cookies means it is only sent over HTTPS. This is good
    for cookies used for authentication because it means they can't be sniffed over
    the wire if, for example, someone is monitoring open network traffic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Secure`标志表示cookie只能通过HTTPS发送。对于用于身份验证的cookie来说，这是很好的，因为这意味着如果有人监视开放网络流量，它们无法被窃听。'
- en: Also note that the `\x1b[31m` code is a special ANSI escape code used to change
    the color of the terminal font. Here, we've highlighted the headers that are insecure
    in red. The `\x1b[39;49m` code resets the color back to default. See the Wikipedia
    page on ANSI for more information at [http://en.wikipedia.org/wiki/ANSI_escape_code](http://en.wikipedia.org/wiki/ANSI_escape_code).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`\x1b[31m`代码是一种特殊的ANSI转义代码，用于更改终端字体的颜色。在这里，我们用红色突出显示了不安全的标头。`\x1b[39;49m`代码将颜色重置为默认值。请参阅维基百科关于ANSI的更多信息[http://en.wikipedia.org/wiki/ANSI_escape_code](http://en.wikipedia.org/wiki/ANSI_escape_code)。
- en: 'The next check is for the `httponly` attribute:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个检查是`httponly`属性：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If this is set to `True`, it means JavaScript cannot access the contents of
    the cookie, and it is sent to the browser and can only be read by the browser.
    This is used to mitigate against XSS attempts, so when penetration testing, the
    lack of this cookie attribute is a good thing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置为`True`，这意味着JavaScript无法访问cookie的内容，它被发送到浏览器，只能被浏览器读取。这用于防止XSS攻击，因此在渗透测试时，缺少此cookie属性是一件好事。
- en: 'We finally check for the domain in the cookie, to see if it starts with a dot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查cookie中的域，看它是否以点开头：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the `domain` attribute of the cookie starts with a dot, it indicates the
    cookie is used across all subdomains and therefore possibly visible beyond the
    intended scope.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果cookie的`domain`属性以点开头，表示cookie用于所有子域，因此可能在预期范围之外可见。
- en: 'The following screenshot shows how the insecure flags are highlighted in red
    for the target website:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了目标网站中不安全标志以红色突出显示：
- en: '![How it works…](img/B04044_05_10.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04044_05_10.jpg)'
- en: There's more…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We've previously seen how to enumerate the technologies used to serve a website
    by extracting the headers. Certain frameworks also store information in the cookie,
    for example, PHP creates a cookies called **PHPSESSION** , which is used to store
    session data. Therefore, the presence of this data indicates the use of PHP, and
    the server can then be enumerated further in an attempt to test it for known PHP
    vulnerabilities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到如何通过提取标头来枚举用于提供网站的技术。某些框架还在cookie中存储信息，例如，PHP创建一个名为**PHPSESSION**的cookie，用于存储会话数据。因此，这些数据的存在表明使用了PHP，然后可以进一步枚举服务器以尝试测试其是否存在已知的PHP漏洞。
- en: Session fixation through a cookie injection
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过cookie注入进行会话固定
- en: Session fixation is a vulnerability that relies on re-use of a session ID. First,
    the attacker must be able to force the victim to use a specific session ID by
    setting a cookie on their client or by already knowing the value of the victim's
    session ID. Then, when the victim authenticates, the cookies remain the same on
    the client. Therefore, the attacker knows the session ID and now has access to
    the victim's session.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 会话固定是一种依赖于会话ID的漏洞。首先，攻击者必须能够强制受害者使用特定的会话ID，方法是在其客户端上设置一个cookie或已经知道受害者会话ID的值。然后，当受害者进行身份验证时，cookie在客户端保持不变。因此，攻击者知道会话ID，现在可以访问受害者的会话。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will require some initial reconnaissance performed against the target
    site to identify how it's performs authentication, for example through data in
    the `POST` requests or through basic `auth`. It will also require a valid user
    account to authenticate with.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将需要对目标站点执行一些初始的侦察，以确定它是如何进行身份验证的，例如通过`POST`请求中的数据或通过基本的`auth`。它还将需要一个有效的用户帐户进行身份验证。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This recipe will be testing for session fixation through a cookie injection:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将测试通过cookie注入进行会话固定：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'This script has two stages; the first step is sending an initial `get` request
    to the target website and then displaying the cookies received:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有两个阶段；第一步是向目标网站发送初始的`get`请求，然后显示接收到的cookie：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second stage of the script sends another request to the target site, this
    time authenticating with valid user credentials:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第二阶段向目标站点发送另一个请求，这次使用有效的用户凭据进行身份验证：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice here that we set the request cookies to the cookies that we received
    in the initial `GET` request earlier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们将请求cookie设置为之前在初始`GET`请求中收到的cookie。
- en: 'The script ends by printing out the final cookie state and printing a warning
    if the authenticated cookies match the cookies that were sent in the initial request:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本最后通过打印最终的 cookie 状态并在经过身份验证的 cookie 与初始请求中发送的 cookie 匹配时打印警告来结束：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Cookies are another data source that is user-controlled and parsed by the web
    server. Similar to headers, this makes it a great place to test for XSS vulnerabilities.
    Try adding XSS payloads to cookie data and sending it to the target server to
    see how it handles the data. Remember that cookies may be read in from the web
    server backend or may be printed out to the logs, and therefore XSS might be possible
    against the log reader (if, for example, it's later read by an admin).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie 是另一个由用户控制并由 Web 服务器解析的数据源。与标头类似，这使得它成为测试 XSS 漏洞的绝佳位置。尝试向 cookie 数据添加
    XSS 负载并将其发送到目标服务器，以查看它如何处理数据。请记住，cookie 可能会从 Web 服务器后端读取，也可能会被打印到日志中，因此可能会针对日志读取器进行
    XSS 攻击（例如，如果后来由管理员读取）。
