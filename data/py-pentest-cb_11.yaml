- en: TCP/IP Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP攻击
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: IP spoofing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP欺骗
- en: SYN flooding
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN洪泛
- en: Password sniffer with Python over LAN
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python在局域网中进行密码嗅探
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The transport layer is the layer that provides data delivery, flow control,
    and error recovery services. The two main transport layer protocols are the TCP
    and the UDP. In this chapter, we will discuss some common attacks in the transport
    layer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层是提供数据传递、流量控制和错误恢复服务的层。两个主要的传输层协议是TCP和UDP。在本章中，我们将讨论传输层中一些常见的攻击。
- en: IP spoofing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP欺骗
- en: With Scapy, we can simply craft packets and send them. So, if we spoof the source
    address and send it, the network accepts and returns the response to the spoofed
    address. Now, we can create a script to ping a system with a spoofed IP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scapy，我们可以简单地制作数据包并发送它们。因此，如果我们伪造源地址并发送它，网络将接受并将响应返回到伪造的地址。现在，我们可以创建一个脚本来使用伪造的IP对系统进行ping。
- en: How to do it...
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Here are the steps to create a script for sending ping requests with spoofed
    IP:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建发送伪造IP的ping请求脚本的步骤：
- en: Create an `ip-spoof-ping.py` file and open it in your editor.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ip-spoof-ping.py`文件并在编辑器中打开它。
- en: 'Then, we have to import the required modules:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须导入所需的模块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now declare the variables for the script:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为脚本声明变量：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a function to send ICMP packets:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来发送ICMP数据包：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will create the following packet and start a send/receive loop:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下数据包并开始发送/接收循环：
- en: '![](img/00062.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: 'Start sending the spoofed packets:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始发送伪造的数据包：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, run the script with required permission:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以所需的权限运行脚本：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can try to send a spoofed DNS query. For that, create another function, `dnsQuery()`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试发送伪造的DNS查询。为此，创建另一个名为`dnsQuery()`的函数。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create the following packet, and start sending in a send/receive
    loop:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下数据包，并开始在发送/接收循环中发送：
- en: '![](img/00063.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: 'Then send the DNS query by calling this method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过调用此方法发送DNS查询：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we can monitor the victim's `tcpdump`, we can see the DNS responses.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们可以监视受害者的`tcpdump`，我们可以看到DNS响应。
- en: SYN flooding
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SYN洪泛
- en: SYN flooding is a type of DOS attack that makes the service unavailable for
    legitimate users. A SYN flood attack makes use of the TCP protocol's *three-way
    handshake*, where a client sends a TCP SYN packet to start a connection to the
    server, and the server replies with a TCP SYN-ACK packet. Then, in a normal operation,
    the client will send an ACK packet followed by the data. This will keep the connection
    open with a `SYN_RECV` state. But, if the client does not respond with an ACK
    packet, the connection will be in a half-opened state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SYN洪泛是一种使服务对合法用户不可用的DOS攻击类型。SYN洪泛攻击利用了TCP协议的*三次握手*，其中客户端发送TCP SYN数据包以开始与服务器的连接，服务器回复TCP
    SYN-ACK数据包。然后，在正常操作中，客户端将发送一个ACK数据包，然后是数据。这将保持连接处于`SYN_RECV`状态。但是，如果客户端不用ACK数据包回应，连接将处于半开放状态。
- en: 'If multiple attackers or systems opened many such half-opened connections to
    the target server, it could fill the server''s SYN buffer and may stop it receiving
    more SYN packets to cause a **Denial-of-Service** (**DoS**) attack:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个攻击者或系统向目标服务器打开了许多这样的半开放连接，它可能填满服务器的SYN缓冲区，并且可能停止接收更多的SYN数据包，从而导致**拒绝服务**（DoS）攻击：
- en: '![](img/00064.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: We can generate SYN flood packets with Scapy for the testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Scapy生成SYN洪泛数据包进行测试。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Here are the steps to create a script to generate a SYN flooding attack:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建生成SYN洪泛攻击脚本的步骤：
- en: Create a `syn-flooding.py` file and open it in your editor.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`syn-flooding.py`文件并在编辑器中打开它。
- en: 'Then, we have to import the required modules:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须导入所需的模块：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, declare the variables:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，声明变量：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a function to create and send SYN flooding packets:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来创建和发送SYN洪泛数据包：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, random values are used to set TTLs and IDs in the packets. This will help
    to obfuscate the identify in case any intrusion detection system is present in
    the server. Also, the source port is a random value created by the `randshort()`
    function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，随机值用于设置数据包中的TTL和ID。这将有助于混淆服务器中存在的任何入侵检测系统。此外，源端口是由`randshort()`函数创建的随机值。
- en: 'Here is a created sample packet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建的示例数据包：
- en: '![](img/00065.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: 'Now send the packets:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在发送数据包：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run this script with required permission:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行此脚本：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Password sniffer with Python over LAN
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python在局域网中进行密码嗅探
- en: We have already learned how to sniff packets with Scapy in the previous recipes.
    Now we can use Scapy to sniff and extract the content in the packets. This can
    be used to get the details of many protocols. We can try to get the credentials
    from these sniffed packets. We can bind this sniffer with our ARP poisoning attack
    to get the details from other machines on the network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在之前的示例中使用Scapy来嗅探数据包。现在我们可以使用Scapy来嗅探和提取数据包中的内容。这可以用来获取许多协议的细节。我们可以尝试从这些嗅探到的数据包中获取凭据。我们可以将这个嗅探器绑定到我们的ARP欺骗攻击中，以从网络上的其他计算机获取详细信息。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Here are the steps to write a password sniffer over LAN:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是编写局域网密码嗅探器的步骤：
- en: Create a `pass-sniffer.py` file and open it in your editor.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pass-sniffer.py`文件并在编辑器中打开它。
- en: 'Import the required modules:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now declare the variables for the interface:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为接口声明变量：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a method to check the username and password in the sniffed content:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来检查嗅探到的内容中的用户名和密码：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we search with the keywords in the data, and extract the username and
    passwords, if present in the payload
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用数据中的关键字进行搜索，并提取用户名和密码（如果存在）。
- en: 'Now, create a function to parse the packets sniffed:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个函数来解析嗅探到的数据包：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we will ignore the raw packets without the IP layer. Then we get the
    IP layer and extract the payload and pass it to the `get_login_pass()` method
    to extract the credentials.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将忽略没有IP层的原始数据包。然后我们获取IP层并提取有效载荷，并将其传递给`get_login_pass()`方法来提取凭据。
- en: 'Now, start sniffing the packets in the provided interface:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始在提供的接口中嗅探数据包：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, run the script with required permission:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以所需的权限运行脚本：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can update this script to extract FTP credentials with little modifications:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过少量修改来更新这个脚本以提取FTP凭据：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will print the FTP data. We could run a regex match on this to get the
    username and password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印FTP数据。我们可以对其进行正则匹配以获取用户名和密码。
