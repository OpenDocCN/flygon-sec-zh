- en: Malware Detection with Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用深度学习进行恶意软件检测
- en: The human mind is a fascinating entity. The power of our subconscious and unconscious
    mind is incredible. What makes this power real is our ability to continuously
    self-learn and adapt quickly. This amazing gift of nature can calculate billions
    of tasks before you even realize what it does. For decades, scientists have been
    trying to build machines that are able to do simultaneous tasks like the human
    mind does—in other words, systems that are able to perform a huge number of tasks
    efficiently and at incredible speeds. A subfield of machine learning called **Deep
    Learning (DL)** arose to help us build algorithms that work like the human mind
    and are inspired by its structure. Information security professionals are also
    intrigued by such techniques, as they have provided promising results in defending
    against major cyber threats and attacks. One of the best-suited candidates for
    the implementation of DL is malware analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人类大脑是一个迷人的实体。我们的潜意识和无意识思维的力量是不可思议的。使这种力量变得真实的是我们不断自学和快速适应的能力。这种自然的惊人天赋可以在你意识到之前计算数十亿个任务。几十年来，科学家一直在努力构建能够像人类大脑一样同时执行任务的机器，换句话说，能够高效地以令人难以置信的速度执行大量任务的系统。一个名为**深度学习（DL）**的机器学习子领域应运而生，帮助我们构建像人类大脑一样工作并受其结构启发的算法。信息安全专业人员也对这些技术感兴趣，因为它们在防御重大网络威胁和攻击方面取得了有希望的结果。深度学习的最佳实施候选之一是恶意软件分析。
- en: 'In this chapter, we are going to discover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现：
- en: 'Artificial neural networks: an in-depth overview'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工神经网络：深入概述
- en: How to build your first neural network with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python构建你的第一个神经网络
- en: How to build a malware detector with multi-layer perceptrons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用多层感知器构建恶意软件检测器
- en: Malware visualization techniques and how to build a malware classifier with
    convolutional neural networks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件可视化技术以及如何使用卷积神经网络构建恶意软件分类器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Basically, in this chapter, we are going to use the same Python libraries that
    we have already installed. Generally, we are going to use those libraries during
    most chapters of the book. So, we spent the first chapter teaching you how to
    install all the required libraries that we are going to use in most chapters and
    projects. Find the code files at this link: [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在本章中，我们将使用已经安装的相同的Python库。通常情况下，我们将在本书的大多数章节中使用这些库。因此，我们在第一章花了时间教你如何安装我们在大多数章节和项目中将要使用的所有必需库。在此链接找到代码文件：[https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04)。
- en: Artificial neural network overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工神经网络概述
- en: 'Our brains perform many complex functions in the blink of an eye. Thus, in
    order to build algorithms that perform and learn using the same techniques as
    the human mind, it is essential for us to learn how the brain works. By acquiring
    a fair understanding about how the human mind functions, we will have better understanding
    of deep learning. The three major distinctive mind functions are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大脑在眨眼之间执行许多复杂的功能。因此，为了构建能够执行和学习使用与人类思维相同的技术的算法，我们必须了解大脑的工作原理是至关重要的。通过对人类大脑功能的公平理解，我们将更好地理解深度学习。三个主要的独特的大脑功能是：
- en: Thinking (analyzing, comparing, and judging)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考（分析、比较和判断）
- en: Feeling (happiness, sadness, and excitement)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情感（快乐、悲伤和兴奋）
- en: Wanting (motives, desires, and goals)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渴望（动机、欲望和目标）
- en: These three functions are continuously interacting in a dynamic process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个功能在一个动态的过程中不断地相互作用。
- en: 'The brain is mainly composed of three components: the **cerebrum**, which is
    the largest part of the brain and controls higher functions, such as vision, hearing,
    and tasting; the **cerebellum**, which is the entity responsible for coordinating
    muscle movements and the general posture of the human body, including its balance;
    and the third part is called the **brainstem**, which connects the two previous
    parts and control many other tasks, including sneezing, coughing, and digesting.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大脑主要由三个部分组成：**大脑皮层**，它是大脑的最大部分，控制着视觉、听觉和味觉等高级功能；**小脑**，它负责协调肌肉运动和人体的一般姿势，包括平衡；第三部分称为**脑干**，它连接了前两部分并控制许多其他任务，包括打喷嚏、咳嗽和消化。
- en: The brain performs complex operations thanks to its different parts. Logically,
    the anatomy of the human brain is composed of many regions, so each region works
    based on a specific algorithm. Although each part of the brain works using its
    own algorithm, surprisingly, the human brain uses essentially the same algorithm
    to understand many different input modalities. This hypothesis is called the **one
    learning algorithm** hypothesis. Many studies done by *Roe et al.* in 1992 proved
    it, especially ferret experiments, in which the input for vision was plugged into
    auditory part of the ferret's brain, and the auditory cortex learned how to see.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大脑通过其不同的部分执行复杂的操作。从逻辑上讲，人类大脑的解剖结构由许多区域组成，因此每个区域都基于特定的算法工作。尽管大脑的每个部分都使用自己的算法工作，但令人惊讶的是，人类大脑基本上使用相同的算法来理解许多不同的输入模式。这个假设被称为**一个学习算法**假设。1992年*Roe等人*进行的许多研究证明了这一点，特别是雪貂实验，其中视觉输入被插入到雪貂大脑的听觉部分，听觉皮层学会了如何看。
- en: 'The following diagram describes the relationship between **Artificial Intelligence
    (AI)**, **Machine Learning (ML)**, and **Deep Learning (DL)**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了**人工智能（AI）**、**机器学习（ML）**和**深度学习（DL）**之间的关系：
- en: '![](img/00099.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: 'Biologically, the human brain is composed of billions of small organs called
    neurons. Neurons are units that process and transfer information through electrical
    and chemical signals. These nerve cells are mainly composed of:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从生物学上讲，人类大脑由数十亿个称为神经元的小器官组成。神经元是通过电信号和化学信号处理和传递信息的单位。这些神经细胞主要由以下组成：
- en: Dendrites
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树突
- en: Axons
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轴突
- en: Synapses
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突触
- en: Cell body
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细胞体
- en: Nucleus
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细胞核
- en: 'The following diagram illustrates the different components of a biological
    neuron:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了生物神经元的不同组成部分：
- en: '![](img/00100.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'The analogical representation of a biological neuron is called a **perceptron**.
    The perceptron can be broken down into:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 生物神经元的类比表示被称为**感知器**。感知器可以分解为：
- en: Inputs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入
- en: Weights
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重
- en: Net input function
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 净输入函数
- en: Activation function
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活函数
- en: Output
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出
- en: The analogy between a perceptron and a human neuron is not totally correct.
    It is used just to give a glimpse into how a perceptron works. The human mind
    is far more complicated than artificial neural networks. There are a few similarities
    but a direct comparison between the mind and neural networks is not appropriate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 感知器和人类神经元之间的类比并不完全正确。它只是用来让人们对感知器的工作有所了解。人类大脑比人工神经网络复杂得多。有一些相似之处，但直接将大脑和神经网络进行比较是不合适的。
- en: Implementing neural networks in Python
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现神经网络
- en: 'Classic computer programs are great when it comes to compute operations based
    on a sequence of instructions and arithmetic, but they face difficulties and challenges
    in many other cases; for example, handwriting-recognition. As a warm up, let''s
    build a handwritten digit recognizer to take the opportunity to install the Python
    libraries needed in the next sections and learn how to build and implement our
    first neural network in Python. To train the model, we need to feed it with data.
    In our implementation, we are going to use the MNIST dataset:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的计算机程序在基于一系列指令和算术的计算操作方面表现出色，但在许多其他情况下都面临困难和挑战；例如，手写识别。作为热身，让我们构建一个手写数字识别器，以便有机会安装下一节中所需的Python库，并学习如何在Python中构建和实现我们的第一个神经网络。要训练模型，我们需要用数据来喂养它。在我们的实现中，我们将使用MNIST数据集：
- en: '![](img/00101.gif)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.gif)'
- en: 'First, let''s install the `keras` library using the `pip install` command,
    as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`pip install`命令安装`keras`库，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/00102.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: 'Then, install TensorFlow (`tensorflow`) using the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装TensorFlow（`tensorflow`）：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/00103.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: 'And finally, install `np_utils`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装`np_utils`：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00104.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Open the Python command-line interface and import the following modules using
    the import commands as shown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Python命令行界面，并使用导入命令导入以下模块：
- en: The `mnist` dataset
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnist` 数据集'
- en: The `Sequential` model
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sequential` 模型'
- en: The `Dense` and `Dropout` layers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dense` 和 `Dropout` 层'
- en: The `np_utils` module
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np_utils` 模块'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following diagram illustrates the preceding code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了前面的代码：
- en: '![](img/00105.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: 'Seed is used because we want repeatable results. `numpy.random.seed(seed)`
    is used to seed the generator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用种子是因为我们希望结果是可重复的。`numpy.random.seed(seed)`用于给生成器设定种子：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Download data from [https://s3.amazonaws.com/img-datasets/mnist.pkl.gz](https://s3.amazonaws.com/img-datasets/mnist.pkl.gz):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://s3.amazonaws.com/img-datasets/mnist.pkl.gz](https://s3.amazonaws.com/img-datasets/mnist.pkl.gz)下载数据：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, `.astype()` is used to convert the variables and `.reshape()` is used
    to give the array a new shape without changing the data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`.astype()`用于转换变量，`.reshape()`用于给数组一个新的形状而不改变数据：
- en: '![](img/00106.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.gif)'
- en: The accuracy of our handwritten digit classifier is 99.8%, which is an amazing
    result. Now we have learned how to build our first neural network program, it
    is time to leverage our skills and get hands-on experience in how to build malware
    classifiers using artificial neural networks, especially DL networks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手写数字分类器的准确率为99.8%，这是一个惊人的结果。现在我们已经学会了如何构建我们的第一个神经网络程序，是时候利用我们的技能并亲自体验如何使用人工神经网络构建恶意软件分类器，特别是DL网络了。
- en: Deep learning model using PE headers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PE头构建深度学习模型
- en: With the concepts we've learned, we are going to build a malware detector with
    artificial neural networks. Let's begin by identifying our dataset. By now, you
    are familiar with the steps required to build a machine learning models. For this
    model, we are going to use the **Portable Executable** (**PE**) files as feeding
    data. As you noticed in the previous chapter, we installed a Python library called
    `pefile`. It is time to use it in this model. Once we install `pefile` with the
    Python package installation manager PIP, we can start using `pefile` to extract
    information from any PE file. In order to gather information from a PE file, import
    the `os` and `pefile` libraries. The `os` library allows you to interface with
    the underlying operating system that Python is running on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们学到的概念，我们将使用人工神经网络构建一个恶意软件检测器。让我们从识别我们的数据集开始。到目前为止，您已经熟悉了构建机器学习模型所需的步骤。对于这个模型，我们将使用**可移植可执行文件**（**PE**）文件作为输入数据。正如您在上一章中注意到的，我们安装了一个名为`pefile`的Python库。现在是时候在这个模型中使用它了。一旦我们使用Python包安装管理器PIP安装了`pefile`，我们就可以开始使用`pefile`从任何PE文件中提取信息。为了从PE文件中收集信息，导入`os`和`pefile`库。`os`库允许您与Python正在运行的底层操作系统进行交互。
- en: 'As a demonstration, we are going to download a malware PE file delivered by
    Palo Alto networks for experimental purposes. Download it with the `wget` command
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们将下载由Palo Alto网络提供的用于实验目的的恶意软件PE文件。使用`wget`命令下载如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the PE file is installed, open the Python environment and import the required
    libraries, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装PE文件后，打开Python环境并导入所需的库，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Load the file using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令加载文件：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we are able to extract `PE_HEADER_OPTIONAL` information from the PE file,
    including `MajorLinkerVersion`, `MajorLinkerVersion`, `SizeOfImage`, and `DllCharacteristics`.
    You can find the full list by checking the Microsoft documentation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从PE文件中提取`PE_HEADER_OPTIONAL`信息，包括`MajorLinkerVersion`、`MajorLinkerVersion`、`SizeOfImage`和`DllCharacteristics`。您可以通过查看微软文档找到完整的列表：
- en: '![](img/00107.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'In the following script, I have extracted information about:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本中，我提取了关于的信息：
- en: '`LinkerVersion`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkerVersion`'
- en: '`NumberOfSections`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberOfSections`'
- en: '`ImageVersion`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageVersion`'
- en: '![](img/00108.gif)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.gif)'
- en: 'We know that training the model is a high-consumption task when it comes to
    computing. Thus, processing and feeding the model with all the header information
    is not a wise decision. So, we need to feature engineer them. Selecting the good
    features is a skill needed in every data science mission. A research study called
    *Selecting Features to Classify Malware* by Karthik Raman from the **Product Security
    Incident Response Team** (**PSIRT**), Adobe Systems, made a proposal to solve
    that issue by suggesting the most important PE headers that we need to select;
    they are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，训练模型在计算方面是一个高消耗的任务。因此，处理和提供所有头信息给模型并不是一个明智的决定。因此，我们需要对其进行特征工程。选择好的特征是每个数据科学任务中需要的技能。Adobe
    Systems的**产品安全事件响应团队**（**PSIRT**）的Karthik Raman进行的一项名为*选择用于分类恶意软件的特征*的研究提出了解决这个问题的建议，建议我们选择最重要的PE头部，它们如下：
- en: '`DebugSize`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugSize`'
- en: '`DebugRVA`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugRVA`'
- en: '`ImageVersion`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageVersion`'
- en: '`OperatingSystemVersion`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperatingSystemVersion`'
- en: '`SizeOfStackReserve`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SizeOfStackReserve`'
- en: '`LinkerVersion`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkerVersion`'
- en: '`DllCharacteristics`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DllCharacteristics`'
- en: '`IatRVA`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IatRVA`'
- en: '`ExportSize`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExportSize`'
- en: '`ExportRVA`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExportRVA`'
- en: '`ExportNameLen`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExportNameLen`'
- en: '`ResourceSize`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceSize`'
- en: '`ExportFunctionsCount`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExportFunctionsCount`'
- en: 'To extract them, you can use the imported `PEfile` module like we did previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取它们，您可以像之前一样使用导入的`PEfile`模块：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/00109.gif)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.gif)'
- en: 'To train the model, there are many publicly available sources. You can download
    different types of file (clean and malicious) from a large list of organizations
    and educational institutions, such as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练模型，有许多公开可用的来源。您可以从大量的组织和教育机构的列表中下载不同类型的文件（清洁和恶意）：
- en: '**ViruSign**: [http://www.virusign.com/](http://www.virusign.com/)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViruSign**: [http://www.virusign.com/](http://www.virusign.com/)'
- en: '**MalShare**: [http://malshare.com/](http://malshare.com/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MalShare**: [http://malshare.com/](http://malshare.com/)'
- en: '**Malware DB**: [http://ytisf.github.io/theZoo/](http://ytisf.github.io/theZoo/)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Malware DB**: [http://ytisf.github.io/theZoo/](http://ytisf.github.io/theZoo/)'
- en: '**Endgame Malware BEnchmark for Research (EMBER)**: One of the largest datasets,
    this contains 1.1 million SHA256 hashes from PE files that were scanned sometime
    in 2017\. I highly recommend you download it and try to build your models using
    it. You can download it from [https://pubdata.endgame.com/ember/ember_dataset.tar.bz2](https://pubdata.endgame.com/ember/ember_dataset.tar.bz2)
    (1.6 GB, expands to 9.2 GB):'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Endgame Malware BEnchmark for Research (EMBER)**：这是最大的数据集之一，包含2017年某个时候扫描的1.1百万个PE文件的SHA256哈希值。我强烈建议您下载并尝试使用它构建您的模型。您可以从[https://pubdata.endgame.com/ember/ember_dataset.tar.bz2](https://pubdata.endgame.com/ember/ember_dataset.tar.bz2)下载（1.6
    GB，扩展到9.2 GB）：'
- en: '![](img/00110.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: 'Your dataset should contain two categories of PE files: **clean** and **malicious
    files**. We need at least 10,000 files to train the model. You will have to start
    extracting header information using the previous scripts. You can automate the
    task by developing an automation script by yourself. Feel free to use any programming
    language. The best way is to export the selected features of all the files to
    CSV files so we can use what we learned in the previous chapters, and so we can
    later load them using pandas:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据集应包含两类PE文件：**清洁**和**恶意文件**。我们需要至少10,000个文件来训练模型。您将需要开始使用先前的脚本提取头信息。您可以通过自己开发自动化脚本来自动化任务。可以使用任何编程语言。最好的方法是将所有文件的选定特征导出到CSV文件中，这样我们可以使用前几章学到的知识，以后可以使用pandas加载它们：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After preparing the features, we need to merge the two types of data into one.
    For example, we can use `pd.concat` to merge the two files. To train the model,
    we need to import the required modules:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好特征后，我们需要将两种类型的数据合并为一种。例如，我们可以使用`pd.concat`来合并这两个文件。为了训练模型，我们需要导入所需的模块：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For data preparation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This line is for splitting, as we did in the other models:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这行是用于分割，就像我们在其他模型中做的那样：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For better prediction, we can use `StandScaler()`; it is used for standardizing
    features by removing the mean and scaling to unit variance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的预测，我们可以使用`StandScaler()`；它用于通过去除均值和缩放到单位方差来标准化特征：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After preparing and feature engineering the data, we have to build the **Multi-Layer
    Perceptron** (**MLP**) network:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 准备和特征工程数据后，我们必须构建**多层感知器**（**MLP**）网络：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, `12` is the number of layers and the number of features. Let''s train
    the model and compute the predictions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`12`是层数和特征数。让我们训练模型并计算预测：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To check the evaluation metrics, add the following line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查评估指标，请添加以下行：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`ravel()` is used here to return a contiguous flattened array. It is equivalent
    to `reshape(-1, order=order)`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`ravel()`返回一个连续的扁平数组。它相当于`reshape(-1, order=order)`：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deep learning model with convolutional neural networks and malware visualization
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卷积神经网络和恶意软件可视化的深度学习模型
- en: The previous section was a real-world implementation of MLP networks for detecting
    malware. Now, we are going to explore other artificial network architectures and
    we are also going to learn how to use one of them to help malware analysts and
    information security professionals to detect and classify malicious code. Before
    diving into the technical details and the steps for the practical implementation
    of the DL method, it is essential to learn and discover the other different architectures
    of artificial neural networks. We discussed some of them briefly in [Chapter 1](part0021.html#K0RQ0-49a67f1d6e7843d3b2296f38e3fe05f5),
    *Introduction to Machine Learning in Pentesting*. The major artificial neural
    networks are discussed now.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节是用MLP网络来检测恶意软件的真实实现。现在，我们将探索其他人工网络架构，并学习如何使用其中之一来帮助恶意软件分析师和信息安全专业人员检测和分类恶意代码。在深入技术细节和DL方法的实际实施步骤之前，了解和发现其他不同的人工神经网络架构是至关重要的。我们在[第1章](part0021.html#K0RQ0-49a67f1d6e7843d3b2296f38e3fe05f5)中简要讨论了其中一些。现在讨论主要的人工神经网络。
- en: Convolutional Neural Networks (CNNs)
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷积神经网络（CNN）
- en: '**Convolutional Neural Networks** (**CNNs**) are a deep learning approach to
    tackle the image classification problem, or what we call computer vision problems,
    because classic computer programs face many challenges and difficulties to identify
    objects for many reasons, including lighting, viewpoint, deformation, and segmentation.
    This technique is inspired by how the eye works, especially the visual cortex
    function algorithm in animals. In CNN are arranged in three-dimensional structures
    with width, height, and depth as characteristics. In the case of images, the height
    is the image height, the width is the image width, and the depth is RGB channels.
    To build a CNN, we need three main types of layer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷积神经网络**（**CNNs**）是解决图像分类问题的深度学习方法，或者我们称之为计算机视觉问题，因为经典的计算机程序面临许多挑战和困难，无法识别对象，包括光照，视角，变形和分割。这种技术受到了眼睛工作的启发，特别是动物视觉皮层功能算法。在CNN中，以宽度，高度和深度为特征排列成三维结构。对于图像，高度是图像高度，宽度是图像宽度，深度是RGB通道。要构建CNN，我们需要三种主要类型的层：'
- en: '**Convolutional layer**: A convolutional operation refers to extracting features
    from the input image and multiplying the values in the filter with the original
    pixel values'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷积层**：卷积操作是指从输入图像中提取特征，并将滤波器中的值与原始像素值相乘'
- en: '**Pooling layer**: The pooling operation reduces the dimensionality of each
    feature map'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**池化层**：池化操作减少每个特征图的维度'
- en: '**Fully-connected layer**: The fully-connected layer is a classic multi-layer
    perceptrons with a softmax activation function in the output layer'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全连接层**：全连接层是具有softmax激活函数的经典多层感知器'
- en: 'To implement a CNN with Python, you can use the following Python script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python实现CNN，可以使用以下Python脚本：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Recurrent Neural Networks (RNNs)
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环神经网络（RNNs）
- en: '**Recurrent Neural Networks** (**RNNs**) are artificial neural networks where
    we can make use of sequential information, such as sentences. In other words,
    RNNs perform the same task for every element of a sequence, with the output depending
    on the previous computations. RNNs are widely used in language modeling and text
    generation (machine translation, speech recognition, and many other applications).
    RNNs do not remember things for a long time.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环神经网络**（**RNNs**）是人工神经网络，我们可以利用序列信息，例如句子。换句话说，RNN对序列的每个元素执行相同的任务，输出取决于先前的计算。RNN广泛用于语言建模和文本生成（机器翻译，语音识别等许多应用）。RNN不能长时间记住事情。'
- en: Long Short Term Memory networks
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长短期记忆网络
- en: '**Long Short Term Memory** (**LSTM**) solves the short memory issue in recurrent
    neural networks by building a memory block. This block sometimes is called a **memory
    cell**.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**长短期记忆**（**LSTM**）通过构建一个记忆块来解决循环神经网络中的短期记忆问题。这个块有时被称为**记忆单元**。'
- en: Hopfield networks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hopfield网络
- en: 'Hopfield networks were developed by John Hopfield in 1982\. The main goal of
    Hopfield networks is auto-association and optimization. We have two categories
    of Hopfield network: **discrete** and **continuous**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Hopfield网络是由John Hopfield于1982年开发的。Hopfield网络的主要目标是自动关联和优化。我们有两类Hopfield网络：**离散**和**连续**。
- en: Boltzmann machine networks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玻尔兹曼机网络
- en: Boltzmann machine networks use recurrent structures and they use only locally
    available information. They were developed by Geoffrey Hinton and Terry Sejnowski
    in 1985\. Also, the goal of a Boltzmann machine is optimizing the solutions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 玻尔兹曼机网络使用循环结构，只使用局部可用信息。它们是由Geoffrey Hinton和Terry Sejnowski于1985年开发的。此外，玻尔兹曼机的目标是优化解决方案。
- en: Malware detection with CNNs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CNN进行恶意软件检测
- en: 'For this new model, we are going to discover how to build a malware classifier
    with CNNs. But I bet you are wondering how we can do that while CNNs are taking
    images as inputs. The answer is really simple, the trick here is converting malware
    into an image. Is this possible? Yes, it is. Malware visualization is one of many
    research topics during the past few years. One of the proposed solutions has came
    from a research study called *Malware Images: Visualization and Automatic Classification*
    by *Lakshmanan Nataraj* from the Vision Research Lab, University of California,
    Santa Barbara.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个新模型，我们将探讨如何使用CNN构建恶意软件分类器。但我敢打赌，你一定想知道我们如何做到这一点，因为CNN是以图像作为输入的。答案很简单，这里的诀窍是将恶意软件转换为图像。这可能吗？是的，是可能的。在过去几年中，恶意软件可视化是许多研究课题之一。其中一种提出的解决方案来自一项名为*Malware
    Images: Visualization and Automatic Classification*的研究，作者是加州大学圣巴巴拉分校的Vision Research
    Lab的*Lakshmanan Nataraj*。'
- en: 'The following diagram details how to convert malware into an image:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表详细说明了如何将恶意软件转换为图像：
- en: '![](img/00111.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: 'The following is an image of the **Alueron.gen!J** malware:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**Alueron.gen!J**恶意软件的图像：
- en: '![](img/00112.gif)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.gif)'
- en: 'This technique also gives us the ability to visualize malware sections in a
    detailed way:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术还使我们能够以详细的方式可视化恶意软件部分：
- en: '![](img/00113.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: 'By solving the issue of how to feed malware machine learning classifiers that
    use CNNs by images, information security professionals can use the power of CNNs
    to train models. One of the malware datasets most often used to feed CNNs is the
    **Malimg dataset**. This malware dataset contains 9,339 malware samples from 25
    different malware families. You can download it from Kaggle (a platform for predictive
    modeling and analytics competitions) by visiting this link: [https://www.kaggle.com/afagarap/malimg-dataset/data](https://www.kaggle.com/afagarap/malimg-dataset/data).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决如何通过图像为使用CNN的恶意软件机器学习分类器提供数据的问题，信息安全专业人员可以利用CNN的力量来训练模型。最经常用来为CNN提供数据的恶意软件数据集之一是**Malimg数据集**。这个恶意软件数据集包含来自25个不同恶意软件家族的9,339个恶意软件样本。您可以从Kaggle（一个用于预测建模和分析竞赛的平台）下载它，访问以下链接：[https://www.kaggle.com/afagarap/malimg-dataset/data](https://www.kaggle.com/afagarap/malimg-dataset/data)。
- en: 'These are the malware families:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是恶意软件家族：
- en: Allaple.L
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Allaple.L
- en: Allaple.A
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Allaple.A
- en: Yuner.A
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yuner.A
- en: Lolyda.AA 1
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lolyda.AA 1
- en: Lolyda.AA 2
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lolyda.AA 2
- en: Lolyda.AA 3
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lolyda.AA 3
- en: C2Lop.P
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C2Lop.P
- en: C2Lop.gen!G
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C2Lop.gen!G
- en: Instant access
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即时访问
- en: Swizzor.gen!I
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swizzor.gen!I
- en: Swizzor.gen!E
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swizzor.gen!E
- en: VB.AT
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VB.AT
- en: Fakerean
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fakerean
- en: Alueron.gen!J
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alueron.gen!J
- en: Malex.gen!J
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Malex.gen!J
- en: Lolyda.AT
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lolyda.AT
- en: Adialer.C
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adialer.C
- en: Wintrim.BX
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wintrim.BX
- en: Dialplatform.B
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dialplatform.B
- en: Dontovo.A
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dontovo.A
- en: Obfuscator.AD
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Obfuscator.AD
- en: Agent.FYI
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Agent.FYI
- en: Autorun.K
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autorun.K
- en: Rbot!gen
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rbot!gen
- en: Skintrim.N
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skintrim.N
- en: 'After converting malware into grayscale images, you can get the following malware
    representation so you can use them later to feed the machine learning model:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意软件转换为灰度图像后，您可以获得以下恶意软件表示，以便以后用于为机器学习模型提供数据：
- en: '![](img/00114.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: 'The conversion of each malware to a grayscale image can be done using the following
    Python script:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个恶意软件转换为灰度图像可以使用以下Python脚本完成：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For feature selection, you can extract or use any image characteristics, such
    as the texture pattern, frequencies in image, intensity, or color features, using
    different techniques such as **Euclidean distance**, or mean and standard deviation,
    to generate later feature vectors. In our case, we can use algorithms such as
    a color layout descriptor, homogeneous texture descriptor, or **global image descriptors**
    (**GIST**). Let''s suppose that we selected the GIST; `pyleargist` is a great
    Python library to compute it. To install it, use PIP as usual:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特征选择，您可以提取或使用任何图像特征，比如纹理模式、图像中的频率、强度或颜色特征，使用不同的技术，比如**欧几里得距离**，或者均值和标准差，以后生成特征向量。在我们的情况下，我们可以使用诸如颜色布局描述符、均匀纹理描述符或**全局图像描述符**（**GIST**）等算法。假设我们选择了GIST；`pyleargist`是一个很棒的Python库来计算它。要安装它，像往常一样使用PIP：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a use case, to compute a GIST, you can use the following Python script:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个用例，要计算GIST，您可以使用以下Python脚本：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `320` refers to the first `320` values while we are using grayscale images.
    Don't forget to save them as *NumPy arrays* to use them later to train the model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，“320”指的是我们使用灰度图像时的前“320”个值。不要忘记将它们保存为*NumPy数组*，以便以后用于训练模型。
- en: After getting the feature vectors, we can train many different models, including
    SVM, k-means, and artificial neural networks. One of the useful algorithms is
    that of the CNN.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得特征向量之后，我们可以训练许多不同的模型，包括SVM、k-means和人工神经网络。其中一个有用的算法是CNN的算法。
- en: Once the feature selection and engineering is done, we can build a CNN. For
    our model, for example, we will build a convolutional network with two convolutional
    layers, with *32 * 32* inputs. To build the model using Python libraries, we can
    implement it with the previously installed TensorFlow and utils libraries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 特征选择和工程完成后，我们可以构建CNN。例如，对于我们的模型，我们将构建一个具有两个卷积层的卷积网络，输入为*32 * 32*。使用Python库构建模型时，我们可以使用之前安装的TensorFlow和utils库来实现它。
- en: 'So the overall CNN architecture will be as in the following diagram:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整体的CNN架构将如下图所示：
- en: '![](img/00115.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: This CNN architecture is not the only proposal to build the model, but at the
    moment we are going to use it for the implementation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种CNN架构不是构建模型的唯一提议，但目前我们将用它来实现。
- en: 'To build the model and CNN in general, I highly recommend Keras. The required
    imports are the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建模型和一般的CNN，我强烈推荐Keras。所需的导入如下：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we discussed before, the grayscale image has pixel values that range from
    0 to 255, and we need to feed the net with *32 * 32 * 1* dimension images as a
    result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，灰度图像的像素值范围从0到255，我们需要将*32 * 32 * 1*维度的图像作为结果输入到网络中：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will train our network with these parameters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下参数训练我们的网络：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To build the architecture, with regards to its format, use the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建架构，关于其格式，使用以下内容：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To compile the model, use the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译模型，使用以下内容：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Fit and train the model:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 适应并训练模型：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you noticed, we are respecting the flow of training a neural network that
    was discussed in previous chapters. To evaluate the model, use the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您注意到的，我们尊重了在前几章中讨论的训练神经网络的流程。要评估模型，使用以下代码：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Promises and challenges in applying deep learning to malware detection
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将深度学习应用于恶意软件检测的承诺和挑战
- en: Many different deep network architectures were proposed by machine learning
    practitioners and malware analysts to detect both known and unknown malware; some
    of the proposed architectures include restricted Boltzmann machines and hybrid
    methods. You can check some of them in the *Further reading* section. Novel approaches
    to detect malware and malicious software show many promising results. However,
    there are many challenges that malware analysts face when it comes to detecting
    malware using deep learning networks, especially when analyzing PE files because
    to analyze a PE file, we take each byte as an input unit, so we deal with classifying
    sequences with millions of steps, in addition to the need of keeping complicated
    spatial correlation across functions due to function calls and jump commands.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习从业者和恶意软件分析师提出了许多不同的深度网络架构，用于检测已知和未知的恶意软件；一些提出的架构包括受限玻尔兹曼机和混合方法。您可以在*进一步阅读*部分中查看其中一些。检测恶意软件和恶意软件的新方法显示出许多有希望的结果。然而，恶意软件分析师在使用深度学习网络检测恶意软件时面临许多挑战，特别是在分析PE文件时，因为要分析PE文件，我们将每个字节作为一个输入单元，因此我们需要处理包含数百万步的序列分类，另外还需要保持由于函数调用和跳转命令而产生的复杂的空间相关性。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Malware is a nightmare for every modern organization. Attackers and cyber criminals
    are always coming up with new malicious software to attack their targets. Security
    vendors are doing their best to defend against malware attacks but, unfortunately,
    with millions of malwares discovered monthly, they cannot achieve that. Thus,
    novel approaches are needed, which are exactly what we looked at in this and the
    previous chapter. We discovered how to build malware detectors using different
    machine learning algorithms, especially using the power of deep learning techniques.
    In the next chapter, we will learn how to detect botnets by building and developing
    robust intelligent systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件对每个现代组织来说都是一场噩梦。攻击者和网络犯罪分子总是想出新的恶意软件来攻击他们的目标。安全供应商正在尽力防御恶意软件攻击，但不幸的是，每月发现数百万种恶意软件，他们无法做到。因此，需要新的方法，这正是我们在本章和上一章中研究的内容。我们发现了如何使用不同的机器学习算法构建恶意软件检测器，特别是利用深度学习技术的力量。在下一章中，我们将学习如何通过构建和开发强大的智能系统来检测僵尸网络。
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between MLP networks and deep learning networks?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MLP网络和深度学习网络之间有什么区别？
- en: Why DL recently is taking off?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么最近DL开始起飞？
- en: Why do we need to iterate multiple times through different models?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要通过不同的模型进行多次迭代？
- en: What type of DL needed to translate English to French language?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译英语到法语语言需要哪种DL类型？
- en: Why malware visualization is a good method to classify malware?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么恶意软件可视化是分类恶意软件的好方法？
- en: What is the role of an activation function?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活函数的作用是什么？
- en: Can you mention three DL architectures?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能提到三种DL架构吗？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Blog posts**:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**博客文章**：'
- en: 'Keras Tutorial: Deep Learning in Python ([https://www.datacamp.com/community/tutorials/deep-learning-python](https://www.datacamp.com/community/tutorials/deep-learning-python))'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras教程：Python中的深度学习（[https://www.datacamp.com/community/tutorials/deep-learning-python](https://www.datacamp.com/community/tutorials/deep-learning-python)）
- en: Develop Your First Neural Network in Python With Keras Step-By-Step ([https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/](https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/))
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Keras逐步在Python中开发您的第一个神经网络（[https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/](https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/)）
- en: THE MNIST Database of handwritten digits ([http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist)/)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手写数字的MNIST数据库（[http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist)/）
- en: '**Papers and presentations**:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**论文和演示**：'
- en: High dimensional visualization of malware families ([https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf](https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf))
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件家族的高维可视化（[https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf](https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf)）
- en: A Hybrid Malicious Code Detection Method based on Deep Learning ([http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf)
    )
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于深度学习的混合恶意代码检测方法（[http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf)）
- en: A Multi-task Learning Model for Malware Classification with Useful File Access
    Pattern from API Call Sequence ([http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf)
    )
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API调用序列中有用的文件访问模式的恶意软件分类的多任务学习模型（[http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf)
    )
- en: Combining Restricted Boltzmann Machine and One Side Perceptron for Malware Detection
    ([http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf)
    )
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将受限玻尔兹曼机和单侧感知器结合用于恶意软件检测（[http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf)）
- en: Convolutional Neural Networks for Malware Classification- Thesis ([http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf](http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf)
    )
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于恶意软件分类的卷积神经网络-论文（[http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf](http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf)）
- en: Deep Learning for Classification of Malware System Call Sequences ([http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf)
    )
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于恶意软件系统调用序列分类的深度学习（[http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf)）
- en: Deep Neural Network Based Malware Detection using Two Dimensional Binary Program
    Features ([http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf)
    )
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于二维二进制程序特征的深度神经网络恶意软件检测（[http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf)）
- en: 'DL4MD: A Deep Learning Framework for Intelligent Malware Detection ([http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf)
    )'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DL4MD：智能恶意软件检测的深度学习框架（[http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf)）
- en: 'Droid-Sec: Deep Learning in Android Malware Detection ([http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf)
    )'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Droid-Sec：Android恶意软件检测中的深度学习（[http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf)）
- en: 'HADM: Hybrid Analysis for Detection of Malware ([http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf](http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf)
    )'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HADM：混合分析用于恶意软件检测（[http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf](http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf)）
- en: Malware Classification with Recurrent Networks ([http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf](http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf)
    )
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环网络进行恶意软件分类（[http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf](http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf)）
