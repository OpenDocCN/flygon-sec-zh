- en: Intercepting HTTP Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截HTTP请求
- en: 'In this chapter, we''re going to learn about HTTP proxies and how we can intercept
    and manipulate HTTP requests. We are going to look at:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于HTTP代理以及如何拦截和操纵HTTP请求。我们将看：
- en: HTTP proxy anatomy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP代理解剖
- en: An introduction to mitmproxy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mitmproxy简介
- en: Manipulating HTTP requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵HTTP请求
- en: Automating SQLi in mitmproxy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在mitmproxy中自动化SQLi
- en: HTTP proxy anatomy
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP代理解剖
- en: In this section, we're going to learn what an HTTP proxy is, why proxies are
    needed and used, and what types of HTTP proxy exist.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习什么是HTTP代理，为什么需要和使用代理，以及存在哪些类型的HTTP代理。
- en: What is an HTTP proxy?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是HTTP代理？
- en: 'An HTTP proxy is a server that acts as an intermediary between two communication
    parties. There is no direct communication between the client and the server. Instead,
    the client connects to the proxy and sends a request to it. Then the proxy will
    fetch the resources from the remote server, and finally return the response back
    to the client:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代理是一个充当两个通信方之间中介的服务器。客户端和服务器之间没有直接通信。相反，客户端连接到代理并向其发送请求。然后代理将从远程服务器获取资源，最后将响应返回给客户端：
- en: '![](img/00080.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: Why do we need a proxy?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要代理？
- en: 'We need a proxy for the following reasons:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要代理的原因如下：
- en: '**Privacy**: When we don''t want the service to know where we''re coming from
    or who we are.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私：当我们不希望服务知道我们来自哪里或者我们是谁时。
- en: '**Bypassing filters and censorship**: In countries where internet censorship
    is common and services are blocked, proxies can help us to get around this block.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过过滤和审查：在互联网审查普遍且服务被屏蔽的国家，代理可以帮助我们绕过这种屏蔽。
- en: '**Logging and eavesdropping**: Many companies implement proxies in order to
    log what employees are browsing and to eavesdrop on their communications.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和窃听：许多公司实施代理以记录员工浏览的内容并窃听他们的通信。
- en: '**Caching**: Companies who utilize caching use proxies in order to cache content
    and speed up communications.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存：利用缓存的公司使用代理来缓存内容并加快通信速度。
- en: '**Filtering and blocking**: Companies may directly want to block and limit
    what services an employee can visit.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和阻止：公司可能直接想要阻止和限制员工可以访问的服务。
- en: '**Manipulating and modifying traffic**: As security testers, we are interested
    in intercepting communications between browsers and web applications in order
    to analyze and manipulate requests and responses in order to identify vulnerabilities
    and also debug problems.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵和修改流量：作为安全测试人员，我们对拦截浏览器和Web应用程序之间的通信感兴趣，以便分析和操纵请求和响应，以识别漏洞并调试问题。
- en: Types of HTTP proxy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP代理类型
- en: 'When it comes to HTTP proxies, there are a few different distinctions that
    we should make:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到HTTP代理时，我们应该做出一些不同的区分：
- en: '**Forward proxies**: This is the most common example of proxies. It is the
    example we used in the explanation of what a proxy is. Forward proxies are the
    ones where the client sends a request to the proxy and the proxy fetches the resource
    on their behalf. In this case, the user chooses to, or is forced to, use a proxy
    in a company. The user knows that a proxy is being used, but the server doesn''t:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转发代理：这是代理的最常见例子。这是我们在解释代理是什么时使用的例子。转发代理是客户端向代理发送请求，代理代表他们获取资源。在这种情况下，用户选择或被迫在公司使用代理。用户知道正在使用代理，但服务器不知道：
- en: '![](img/00081.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: '**Reverse proxies**: These are proxies used by companies in order to hide behind
    network architecture or when they need to distribute the load between real servers.
    The user thinks they are connecting to the real server, but they are connecting
    to a proxy that will handle the request:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向代理：这些是公司用来隐藏在网络架构后面或者在需要在真实服务器之间分发负载时使用的代理。用户认为他们正在连接到真实服务器，但实际上他们正在连接到一个将处理请求的代理：
- en: '![](img/00082.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: '**Transparent proxies**: These intercept normal communications at the network
    layer without requiring any configuration on the client side. Usually, clients
    do not know they are using a transparent proxy. Transparent proxies usually do
    not modify requests and responses. They are commonly used by ISPs in order to
    provide faster responses to their customers. The proxy acts as a router or gateway:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明代理：这些在网络层拦截正常通信而无需在客户端进行任何配置。通常，客户端不知道他们在使用透明代理。透明代理通常不修改请求和响应。它们通常被ISP用来为客户提供更快的响应。代理充当路由器或网关：
- en: '![](img/00083.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: Introduction to mitmproxy
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mitmproxy简介
- en: In this section, we're going to take a look at why we work with mitmproxy, how
    to use the basic HTTP proxy feature in mitmproxy, and a brief introduction to
    mitmproxy inline scripts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看为什么要使用mitmproxy，如何在mitmproxy中使用基本的HTTP代理功能，以及对mitmproxy内联脚本的简要介绍。
- en: Why mitmproxy?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用mitmproxy？
- en: Mitmproxy is an interactive console program that allows traffic flows to be
    intercepted, inspected, modified, and replayed. After researching for this section,
    I decided that the easiest and most complete way to learn about HTTP proxies in
    Python is by using mitmproxy. Any other attempt is more complex and limited than
    mitmproxy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mitmproxy是一个交互式控制台程序，允许拦截、检查、修改和重放流量。在研究了这一部分之后，我决定学习Python中关于HTTP代理的最简单和最完整的方法是使用mitmproxy。任何其他尝试都比mitmproxy更复杂和有限。
- en: Mitmproxy is developed in Python and allows users to extend it via their inline
    scripts. It supports SSL out of the box, unlike other alternatives out there that
    support only HTTP.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Mitmproxy是用Python开发的，允许用户通过内联脚本来扩展它。它支持SSL，不像其他只支持HTTP的替代方案。
- en: 'Let''s see how mitmproxy works using a simple example. If we go to the Terminal
    and type `mitmproxy`, we get an mitmproxy console listening at port `8080`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看mitmproxy如何使用一个简单的例子。如果我们去终端并输入`mitmproxy`，我们会得到一个监听端口`8080`的mitmproxy控制台：
- en: '![](img/00084.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: If we change our browser settings to use proxy for HTTP connections, and we
    fire up a request such as [http://www.edge-security.com/](http://www.edge-security.com/),
    we will see all the requests in the console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改浏览器设置以便使用代理进行HTTP连接，并发出一个请求，比如[http://www.edge-security.com/](http://www.edge-security.com/)，我们将在控制台中看到所有的请求。
- en: 'Let''s click on the Open menu icon on the right-hand side of the browser and
    go to Preferences | Advanced | Network | Connection | Settings... | Manual proxy
    configuration. Set the HTTP Proxy as `127.0.0.1`  and the Port as `8080` and hit
    OK:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击浏览器右侧的打开菜单图标，然后进入首选项 | 高级 | 网络 | 连接 | 设置... | 手动代理配置。将HTTP代理设置为`127.0.0.1`，端口设置为`8080`，然后点击确定：
- en: '![](img/00085.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: 'Let''s load [http://www.edge-security.com/](http://www.edge-security.com/)
    in the browser now; you can see the request history in the console:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在浏览器中加载[http://www.edge-security.com/](http://www.edge-security.com/)；你可以在控制台中看到请求历史记录：
- en: '![](img/00086.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: Now, if you select a request and press *Enter*, you will see the details for
    that request, the response, the headers, and the connection details. If you want
    to edit the request, press *E*. When done, you can send it by pressing *R*. This
    is the basic usage of mitmproxy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你选择一个请求并按*Enter*，你将看到该请求的详细信息，响应，标头和连接详情。如果你想编辑请求，按*E*。完成后，你可以按*R*发送它。这是mitmproxy的基本用法。
- en: I encourage you to learn about all you can do with mitmproxy at [https://mitmproxy.org/](https://mitmproxy.org/).
    It is really well documented. There are multiple examples, and you will find all
    the necessary information about it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你去了解mitmproxy的所有功能，网址是[https://mitmproxy.org/](https://mitmproxy.org/)。它有非常好的文档。有多个示例，你会找到所有必要的信息。
- en: 'Just to remind you how proxies work, in this particular case I have set up
    my browser to connect to mitmproxy on the localhost in port `8080`. The browser
    and the proxy are on the same machine:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了提醒你代理是如何工作的，在这种特殊情况下，我已经设置了我的浏览器连接到本地端口`8080`上的mitmproxy。浏览器和代理在同一台机器上：
- en: '![](img/00087.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'Mitmproxy has a powerful scripting API that will let us access requests on
    the fly to manipulate them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Mitmproxy有一个强大的脚本API，可以让我们在请求过程中访问并操纵它们：
- en: '![](img/00088.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: The mitm scripting API is event-driven and its script is simply a Python module
    that exposes a set of event methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: mitm脚本API是事件驱动的，其脚本只是一个暴露一组事件方法的Python模块。
- en: We can see in the screenshot an example of a simple inline script that will
    add a new header to every HTTP response before it is returned to the client. That
    is all the code needed for the script. In the next section, we're going to learn
    how to write a script to manipulate requests in mitmproxy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在截图中看到一个简单的内联脚本的例子，它将在返回给客户端之前为每个HTTP响应添加一个新的标头。这就是脚本所需的所有代码。在下一节中，我们将学习如何编写一个脚本来操纵mitmproxy中的请求。
- en: Manipulating HTTP requests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵HTTP请求
- en: In this section, we're going to learn more about inline scripts, and we're going
    to see an example of how to intercept requests and access their different parts
    of it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习更多关于内联脚本的知识，并且我们将看到一个拦截请求并访问请求不同部分的例子。
- en: Inline scripts
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联脚本
- en: 'In the previous section, we defined a simple inline script in order to access
    the response from a request. Other parts of the communication, the mitmproxy,
    let us access the response via handlers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分，我们定义了一个简单的内联脚本，以便访问请求的响应。通信的其他部分，mitmproxy，让我们通过处理程序访问响应：
- en: '`start`: This is called once the script starts up, before any other events'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 当脚本启动后，但在任何其他事件之前调用'
- en: '`clientconnect` : This is called when a client initiates a connection to the
    proxy'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientconnect` : 当客户端启动与代理的连接时调用'
- en: A connection can correspond to multiple HTTP requests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接可以对应多个HTTP请求。
- en: '`request`: This is called when a client request has been received'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`: 当客户端请求被接收时调用'
- en: '`serverconnect` : This is called when the proxy initiates a connection to the
    target server'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverconnect` : 当代理启动与目标服务器的连接时调用'
- en: '`responseheaders`: This is called when the `responseheaders` for a server response
    have been received, but the response body has not been processed'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseheaders`: 当服务器响应的`responseheaders`被接收到，但响应主体尚未被处理时调用'
- en: '`response`: This is called when a server response has been received'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`: 当服务器响应被接收时调用'
- en: '`error`: This is called when a flow error has occurred'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 当发生流错误时调用'
- en: '`clientdisconnect`: This is called when a client disconnects from the proxy'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientdisconnect`: 当客户端从代理断开连接时调用'
- en: '`done`: This is called when the script shuts down after all other events'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`: 在所有其他事件之后，脚本关闭时调用'
- en: So now that we know what handlers are available to us, let's look at an example
    where we access a request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有哪些处理程序可供我们使用，让我们看一个访问请求的例子。
- en: Let's open the `mitm-0.py` script, located in the source code for `Section-7`, in
    the editor. This script will basically log every request that the proxy receives
    from the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在编辑器中打开`Section-7`源代码中的`mitm-0.py`脚本。这个脚本基本上会记录代理从客户端接收到的每个请求。
- en: 'We can see that this script is very simple:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个脚本非常简单：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have the handler for the `request`, with the mandatory first parameter called
    `context` and the second being `flow`. `flow`, as the name suggests, holds all
    the information about the communication. In the function, we open the `httplogs.txt`
    file, then we write `flow.request.url`, which is the URL requested by the client,
    and we finally close the `f` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`request`的处理程序，第一个参数是`context`，第二个是`flow`。`flow`，顾名思义，包含了通信的所有信息。在函数中，我们打开`httplogs.txt`文件，然后写入`flow.request.url`，这是客户端请求的URL，最后关闭`f`文件。
- en: 'Let''s go back to the Terminal in the `Section-7` directory. Type `mitmproxy
    -s mitm-0.py` and the mitmproxy console will come up. Then, we will open our browser
    and change the proxy configuration so it points to localhost `8080`. Click on
    the Open menu icon at the right-hand side of the browser and go to Preferences
    | Advanced | Network | Connection | Settings... | Manual proxy configuration.
    Set the Port as `8080`. Remove `localhost` and `127.0.0.1` from No Proxy for:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Section-7`目录中的终端。键入`mitmproxy -s mitm-0.py`，mitmproxy控制台将出现。然后，我们将打开我们的浏览器并更改代理配置，使其指向本地主机`8080`。单击浏览器右侧的打开菜单图标，转到首选项|高级|网络|连接|设置...|手动代理配置。将端口设置为`8080`。从“不代理”中删除`localhost`和`127.0.0.1`：
- en: '![](img/00089.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: 'Let''s load `www.scruffybank.com` in the browser. You can see all the requests
    in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中加载`www.scruffybank.com`。您可以在控制台中看到所有请求：
- en: '![](img/00090.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: 'Let''s close the console and view the `httplogs.txt` file. We can open it with
    the editor. We can see all URLs requested in the session:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭控制台并查看`httplogs.txt`文件。我们可以用编辑器打开它。我们可以看到会话中请求的所有URL：
- en: '![](img/00091.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: Excellent work!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！
- en: 'Now, let''s add a filter to log unique URLs to avoid storing duplicate URLs.
    Open the `mitm-1.py` file in the editor. In order to prevent duplicates, let''s
    create a global variable in the script called `history`; then, in the function,
    we just check that the URL is not in the history:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个过滤器以记录唯一的URL，以避免存储重复的URL。在编辑器中打开`mitm-1.py`文件。为了防止重复，让我们在脚本中创建一个名为`history`的全局变量；然后，在函数中，我们只需检查URL是否不在历史记录中：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If not present, we log it and then we add it to the `history`. Let's try it
    again and see if it works. First, we can remove the `httplogs.txt` file by right-clicking
    on it and selecting the Delete option. Run `mitmproxy -s mitm-1.py`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，我们将其记录下来，然后将其添加到`history`中。让我们再试一次，看看是否有效。首先，我们可以通过右键单击`httplogs.txt`文件并选择“删除”选项来删除它。运行`mitmproxy
    -s mitm-1.py`。
- en: 'Let''s go back to the browser and open `www.scruffybank.com/login.php` and
    refresh it several times. Close the proxy console, and open the results again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到浏览器，打开`www.scruffybank.com/login.php`并刷新几次。关闭代理控制台，然后再次打开结果：
- en: '![](img/00092.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: Great! No duplicates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！没有重复。
- en: Now that we know how to access requests, let's see how we can add a query string
    parameter to every request. You may ask why. Well, we need to add certain parameters
    in a request in order to access certain information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何访问请求，让我们看看如何向每个请求添加查询字符串参数。您可能会问为什么。好吧，我们需要在请求中添加某些参数，以便访问某些信息。
- en: 'Let''s open `mitm-2.py` in the editor. Now, what we''re doing is getting the
    query string with `flow.request.get_query()`, and then we''re checking whether
    the query string has some content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在编辑器中打开`mitm-2.py`。现在，我们正在使用`flow.request.get_query()`获取查询字符串，然后我们正在检查查询字符串是否有一些内容：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If there is content, we add a new parameter called `isadmin` with the value
    `True`. And finally, we update the request query string with `flow.request.set_query(q)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有内容，我们将添加一个名为`isadmin`的新参数，其值为`True`。最后，我们使用`flow.request.set_query(q)`更新请求查询字符串。
- en: Let's try it in the command line. Let's launch `mitm-2.py` by typing `mitmproxy
    -s mitm-2.py`. In the browser, click on the Learn More link, which has parameters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在命令行中尝试一下。键入`mitmproxy -s mitm-2.py`启动`mitm-2.py`。在浏览器中，单击具有参数的“了解更多”链接。
- en: 'In the mitmproxy console, you can see that mitmproxy is adding the `isadmin`
    query string parameter with the `True` value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在mitmproxy控制台中，您可以看到mitmproxy正在添加带有`True`值的`isadmin`查询字符串参数：
- en: '![](img/00093.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: In this case, it won't do anything, but it is a warm-up for the next section
    where we're going to learn how to do something more complex such as testing SQLi
    for every parameter we see in the proxy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它不会做任何事情，但这是下一节的热身，我们将学习如何做一些更复杂的事情，比如测试代理中看到的每个参数的SQLi。
- en: Automating SQLi in mitmproxy
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在mitmproxy中自动化SQLi
- en: In this section, we are going to learn how we can automate a test case for SQL
    injection in mitmproxy, creating an inline script that we use, the request handler,
    and some of the things we learned in the previous sections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在mitmproxy中自动化SQL注入的测试用例，创建一个我们使用的内联脚本，请求处理程序以及我们在前几节中学到的一些东西。
- en: SQLi process
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLi过程
- en: 'The objective of this section is to create an inline script for an mitmproxy,
    which will allow us to test SQL injection in every URL that has a parameter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是为mitmproxy创建一个内联脚本，这将允许我们在具有参数的每个URL中测试SQL注入：
- en: '![](img/00094.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: So the process is that, for every URL that has parameters, we need to replace
    each parameter value with FUZZ while conserving the rest of the parameter values.
    We do this instead of replacing all the values with FUZZ at once. Then, we replace
    the FUZZ string in each URL with each value in the injections array.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个具有参数的URL，我们需要将每个参数值替换为FUZZ，同时保留其他参数值。我们这样做，而不是一次替换所有值为FUZZ。然后，我们将每个URL中的FUZZ字符串替换为`injections`数组中的每个值。
- en: 'We then execute the request a match to results content with MySQL errors in
    the errors array. Let''s see the code. Let''s go to the editor and open the `mitm-3.py` file.
    We have a few new imports:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行请求，将结果内容与`errors`数组中的MySQL错误进行匹配。让我们看看代码。让我们转到编辑器并打开`mitm-3.py`文件。我们有一些新的导入：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`copy` from `deepcopy`, we need the highlighted code from the preceding code
    to copy objects and `urlparse`, which will help parse the URLs.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`从`deepcopy`中复制，我们需要从前面的代码中复制对象和`urlparse`，它将帮助解析URL。'
- en: Then we have the `request` handler function. Whenever there is a `query` string,
    it will call the `injector` function. The `injector` function has the arrays of
    `errors` and the `injections` array, similar to the ones we used in the SQLi scripts.
    Then, we open a file to log the results, and we use `urlparse` to get the `query`
    string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`request`处理程序函数。每当有一个`query`字符串时，它将调用`injector`函数。`injector`函数具有`errors`数组和`injections`数组，类似于我们在SQLi脚本中使用的数组。然后，我们打开一个文件来记录结果，并使用`urlparse`来获取`query`字符串。
- en: We need to split it with `&` and obtain the length as to how many parameters
    we have. Once we know the length, we do a `while` loop. For each iteration, we
    are going to do a `deepcopy` of the object `query` in order to preserve the original
    and work in a new copy. We then replace the value of the `qlen-1` parameter with
    the `FUZZ` string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用`&`分割它，并获取参数的长度。一旦我们知道长度，我们就会进行`while`循环。对于每次迭代，我们将对对象`query`进行`deepcopy`，以保留原始对象并在新副本中工作。然后我们用`FUZZ`字符串替换`qlen-1`参数的值。
- en: In `url_to_test`, we rebuild the URL. Then, we cycle through injections and
    replace `FUZZ` with the injection string. Finally, we check the resulting content and
    the content in the `errors` array. If we have a match, we write the logs and that's
    it. We have a basic SQL injection capability included in mitmproxy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`url_to_test`中，我们重建URL。然后，我们循环进行注入，并用注入字符串替换`FUZZ`。最后，我们检查结果内容和`errors`数组中的内容。如果匹配，我们写入日志，就这样。我们在mitmproxy中包含了基本的SQL注入功能。
- en: 'Let''s go to the Terminal, run `mitmproxy -s mitm-3.py`, then browse around
    in the application. Finally, go to `www.scruffybank.com/users.php`. We know that
    this page is vulnerable to SQLi from previous exercises, for example, by typing
    `1` in USER ID, and that should be enough for this demo. Close mitmproxy and check
    the `sqlinjection_results.txt file` log in the editor:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去终端，运行`mitmproxy -s mitm-3.py`，然后在应用程序中浏览。最后，转到`www.scruffybank.com/users.php`。我们知道这个页面在之前的练习中容易受到SQLi攻击，例如，通过在用户ID中输入`1`，这对于演示来说应该足够了。关闭mitmproxy并在编辑器中检查`sqlinjection_results.txt`文件日志。
- en: '![](img/00095.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: Great, we can see which URL is vulnerable to SQLi. And we can see the parameter
    with the injection that generated the error. From this point, you can continue
    using the SQL injector script we created before. Now you have a basis on which
    to build your own script to cover your needs and test custom scenarios.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们可以看到哪个URL容易受到SQLi攻击。我们可以看到带有生成错误的注入的参数。从这一点上，您可以继续使用我们之前创建的SQL注入器脚本。现在您有了一个基础，可以构建自己的脚本来满足您的需求并测试自定义场景。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how mitmproxy works and learnt how to create inline scripts to
    extend the proxy and manipulate communication. We have learnt to add a vulnerability
    scanner function to the HTTP proxy to assist us during web application penetration
    tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了mitmproxy的工作原理，并学会了创建内联脚本来扩展代理并操纵通信。我们已经学会了在HTTP代理中添加漏洞扫描器功能，以帮助我们进行Web应用程序渗透测试。
- en: We provided you with the basic knowledge and skills to help you in the future
    when creating your own custom tools. If you are starting your journey as a pentester,
    this will give you a solid foundation on which to build your custom tools for
    every situation, and will allow you to modify and extend existing tools.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为您提供了基本的知识和技能，以帮助您在未来创建自己的定制工具。如果您正在作为渗透测试人员开始您的旅程，这将为您打下坚实的基础，以便为每种情况构建自定义工具，并允许您修改和扩展现有工具。
- en: 'Now that you know the basics, you can continue your journey, improving your
    skills and putting them into practice. In order to do so, I recommend the following
    resources:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了基础知识，可以继续您的学习之旅，提高您的技能并付诸实践。为了做到这一点，我推荐以下资源：
- en: OWASP WebGoat ([https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project](https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project)).
    This is a training course provided on the form of a VM. This training focuses
    on the OWASP top 10 vulnerabilities.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP WebGoat ([https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project](https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project))。这是一个以VM形式提供的培训课程。该培训课程侧重于OWASP前10名漏洞。
- en: Pentester Lab ([https://www.pentesterlab.com/](https://www.pentesterlab.com/))
    provides vulnerable applications that can be used to test and understand vulnerabilities.
    Also, you can test your skills in other vulnerable apps, like the ones you can
    find in the project.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pentester Lab ([https://www.pentesterlab.com/](https://www.pentesterlab.com/))提供了可以用来测试和理解漏洞的易受攻击的应用程序。此外，您还可以在项目中找到其他易受攻击的应用程序来测试您的技能。
- en: OWASP-WADP ([https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project](https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project)),
    a collection of vulnerable apps to provide environments close to reality.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP-WADP ([https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project](https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project))，一个提供接近现实环境的易受攻击应用程序的集合。
- en: And that is it. Thank you very much for choosing this book, and I hope you have
    enjoyed learning about web application testing with Python.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。非常感谢您选择这本书，希望您喜欢用Python学习Web应用程序测试。
