- en: Interacting with Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Web应用程序交互
- en: 'In the previous chapter, we learned about the web application security process
    and why it is important to test application security. In this chapter, we''ll
    take a look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Web应用程序安全流程以及为什么测试应用程序安全性很重要。在本章中，我们将看一下以下主题：
- en: HTTP protocol basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP协议基础知识
- en: Anatomy of an HTTP request
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求的解剖
- en: Interacting with a web app using the requests library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用requests库与Web应用程序交互
- en: Analyzing HTTP responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析HTTP响应
- en: HTTP protocol basics
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP协议基础知识
- en: In this section, we'll learn about the HTTP protocol, how it works, and the
    security aspects of it and which methods are supported when performing a request.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习HTTP协议，它是如何工作的，以及它的安全方面，以及在执行请求时支持哪些方法。
- en: This will provide you with the basic knowledge of HTTP, which is important to
    understand how to build tools and test for security issues in web applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供HTTP的基本知识，这对于理解如何构建工具并测试Web应用程序中的安全问题非常重要。
- en: What is HTTP and how it works?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP是什么以及它是如何工作的？
- en: HTTP was designed to enable communication between clients and servers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP旨在实现客户端和服务器之间的通信。
- en: HTTP is a TCP/IP-based communication protocol operating in the application layer.
    Normally, we use a web browser to interact with web applications but in this training,
    we will leave the browser behind and use Python to talk with web applications.
    This protocol is media independent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是基于TCP/IP的通信协议，运行在应用层。通常，我们使用Web浏览器与Web应用程序进行交互，但在这个培训中，我们将放下浏览器，使用Python与Web应用程序进行交流。这个协议是媒体独立的。
- en: This means that any type of data can be sent via HTTP as long as the client
    and server know how to handle the data content. And it is stateless, which means
    that the HTTP server and the clients are aware of each other during the request
    to transaction only. Due to this characteristic, neither the client or the server
    retain information between requests, which will later be helpful when you perform
    some attacks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只要客户端和服务器知道如何处理数据内容，就可以通过HTTP发送任何类型的数据。它是无状态的，这意味着在请求到事务期间，HTTP服务器和客户端只是彼此知道对方的存在。由于这个特性，客户端和服务器都不会在请求之间保留信息，这在进行一些攻击时会有所帮助。
- en: 'The HTTP protocol is available in two different versions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议有两个不同的版本：
- en: '**HTTP/1.0**: This uses a new connection for each request/response transaction'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/1.0**：这为每个请求/响应事务使用一个新连接'
- en: '**HTTP/1.1**: This is where the connection can be used by one or more request
    response transactions'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/1.1**：这是连接可以被一个或多个请求响应事务使用的地方'
- en: HTTP is not a secure protocol, which means that all communication is clear text,
    which is susceptible to interception and tampering.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP不是一个安全协议，这意味着所有通信都是明文的，容易被拦截和篡改。
- en: 'Generally, HTTP is being served on port `80`. The following is an example of
    what a simple transaction looks like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTTP是在端口`80`上提供的。以下是一个简单交易的示例：
- en: '![](img/00008.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: On the left, we have the client, which sends an HTTP `GET` request to the server
    asking for the resource `test.html`. The server returns an HTTP response with
    a `200 OK` code, some header, and the content `test.html` if it exists on the
    server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有客户端，它向服务器发送一个HTTP `GET`请求，请求资源`test.html`。如果服务器上存在`test.html`，服务器将返回一个带有`200
    OK`代码、一些标头和内容`test.html`的HTTP响应。
- en: If it does not exist, it will return a `404 Not Found` response code. This represents
    the most basic `GET` request in the web application world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，它将返回`404 Not Found`响应代码。这代表了Web应用程序世界中最基本的`GET`请求。
- en: In 1994, HTTPS was introduced to add security on top of HTTP. HTTPS is not a
    protocol itself, but the result of layering HTTP on top of **Secure Socket Layer**
    (**SSL**) or **Transport Layer Security** (**TLS**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，引入了HTTPS以在HTTP之上增加安全性。HTTPS本身不是一个协议，而是在**安全套接字层**（**SSL**）或**传输层安全性**（**TLS**）之上叠加HTTP的结果。
- en: HTTPS creates a secure channel over an insecure network. This ensures reasonable
    protection from eavesdroppers and man-in-the-middle attacks provided that adequate
    cipher suites are used and that the service certificate is verified and trusted.
    So, whenever the application handles sensitive information, such as banking payments,
    shopping websites, login pages, and profile pages, it should use HTTPS. Basically,
    if we handle processes or store customer data, it should use HTTPS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS在不安全的网络上创建了一个安全通道。这确保了合理的保护，使窃听者和中间人攻击者无法轻易窃取信息，前提是使用了足够的密码套件，并且服务证书经过验证和受信任。因此，每当应用程序处理敏感信息，如银行支付、购物网站、登录页面和个人资料页面时，应该使用HTTPS。基本上，如果我们处理流程或存储客户数据，应该使用HTTPS。
- en: 'In HTTP, methods indicate the desired action to be performed on the chosen
    resource, also known as HTTP verbs. HTTP/1.0 defines three methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP中，方法表示对所选资源执行的期望操作，也称为HTTP动词。HTTP/1.0定义了三种方法：
- en: '`HEAD`: This will only return the headers and the status code without its content'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：这将只返回标头和状态代码，不包括内容'
- en: '`GET`: This is the standard method used to retrieve resource content given
    a URI'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这是用于检索资源内容的标准方法，给定一个URI'
- en: '`POST`: This is a method used to submit content to the server, form data, files,
    and so on'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这是一种用于向服务器提交内容的方法，包括表单数据、文件等'
- en: 'Then, HTTP/1.1 introduced the following methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，HTTP/1.1引入了以下方法：
- en: '`OPTIONS`: This provides the communication options for the target resource'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：这为目标资源提供通信选项'
- en: '`PUT`: This requests to store a resource identified by the given URI'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这请求存储由给定URI标识的资源'
- en: '`DELETE`: This removes all representations of the target resource identified
    by the given URI'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这将删除由给定URI标识的目标资源的所有表示'
- en: '`TRACE`: This method echoes the received request so that the client can see
    what changes or editions have been made by intermediate servers'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：这个方法回显接收到的请求，以便客户端可以看到中间服务器所做的更改或编辑'
- en: '`CONNECT`: This establishes a tunnel to the server identified by a given URI
    used by HTTPS'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONNECT`：这建立了一个由HTTPS使用的给定URI标识的服务器的隧道'
- en: '`PATCH`: This method applies partial modifications to a resource'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：此方法对资源应用部分修改'
- en: '`HEAD`, `GET`, `OPTIONS`, and `TRACE` are by convention defined as safe, which
    means they are intended only for information retrieval and should not change the
    state of the server.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`，`GET`，`OPTIONS`和`TRACE`按照惯例被定义为安全的，这意味着它们仅用于信息检索，不应改变服务器的状态。'
- en: On the other hand, methods such as `POST`, `PUT`, `DELETE`, and `PATCH` are
    intended for actions that may cause side effects either on the server or external
    side effects. There are more methods than these. I encourage you to explore them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，诸如`POST`，`PUT`，`DELETE`和`PATCH`之类的方法旨在执行可能在服务器或外部产生副作用的操作。除了这些方法还有更多。我鼓励你去探索它们。
- en: We have seen that HTTP is a client server protocol, which is stateless.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到HTTP是一种无状态的客户端服务器协议。
- en: This protocol doesn't provide any security and hence HTTPS was created to add
    a secure layer on top of HTTP. We also learned that there are some different methods
    that will instruct the server to perform different actions on the chosen resources.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议不提供任何安全性，因此HTTPS被创建用于在HTTP之上添加一个安全层。我们还了解到有一些不同的方法，它们将指示服务器对所选资源执行不同的操作。
- en: Anatomy of an HTTP request
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求的解剖
- en: In this section, we'll take a look at the structure of a URL, the request and
    response headers, and an example of `GET` requests using Telnet to understand
    how it works at a low level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下URL的结构、请求和响应标头，并使用Telnet对`GET`请求进行示例，以了解它在低级别上是如何工作的。
- en: 'I bet you have seen thousands of URLs by now. It''s now time to stop and think
    about the URL structure. Let''s see what each part means:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我打赌你现在已经看过成千上万个URL了。现在是停下来思考URL结构的时候了。让我们看看每个部分的含义：
- en: '![](img/00009.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: The first part is the protocol in web applications. The two protocols used are
    HTTP and HTTPS. When using HTTP, the port that will be used is `80`, and when
    using HTTPS, the port will be `443`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是Web应用程序中的协议。使用的两种协议是HTTP和HTTPS。使用HTTP时，将使用端口`80`，使用HTTPS时，端口将是`443`。
- en: The next part is the host we want to contact. Next, we can see the resource
    or the file location in that server. In this example, the directory is `content`
    and the resource is `section`. Then, we have the question mark symbol that indicates
    what's to come is the query string. These are the parameters that will be passed
    to the section of the page for processing purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们要联系的主机。接下来，我们可以看到该服务器中的资源或文件位置。在这个例子中，目录是`content`，资源是`section`。然后，我们有问号符号，表示接下来要来的是查询字符串。这些是将传递给页面部分进行处理的参数。
- en: There are some alternatives such as adding username and password for authentication
    before the host, or explicitly defining the port for cases where the web server
    is not listening in the standard `80` or `443` ports.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些替代方案，例如在主机之前添加用户名和密码进行身份验证，或者明确定义端口，以防Web服务器未在标准`80`或`443`端口上监听。
- en: HTTP headers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP标头
- en: Now, let's talk about headers. Headers are a core part of HTTP requests and
    responses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈标头。标头是HTTP请求和响应的核心部分。
- en: 'They describe how the client and the server talk to each other and also provide
    information about the transaction. We have client-side headers, which are sent
    by the browser. Some examples are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它们描述了客户端和服务器之间的通信方式，并提供了有关交易的信息。我们有客户端标头，这些标头由浏览器发送。一些示例如下：
- en: '**User-agent**: This informs the server what type of OS, browser, and plugins
    the users have.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**User-agent**：这通知服务器用户使用的操作系统、浏览器和插件类型。'
- en: '**Accept-encoding**: This defines which encoding the browser supports, which
    is usually GZip or Deflate. This will compress the content and reduce the bandwidth
    time for every transaction.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Accept-encoding**：这定义了浏览器支持的编码，通常是GZip或Deflate。这将压缩内容并减少每次交易的带宽时间。'
- en: '**Referer**: This contains the referer URL, basically from which page you clicked
    that link.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Referer**：这包含了引用URL，基本上是你从哪个页面点击了该链接。'
- en: '**Cookie**: If our browser has cookies for its site, it will add them in the
    Cookie header. We also have server-side headers, which are set by the web server.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie**：如果我们的浏览器对其站点有cookie，它将在Cookie标头中添加它们。我们还有服务器端标头，这些标头是由Web服务器设置的。'
- en: '**Cache-Control**: This defines the directives, which must be obeyed by all
    caching mechanisms along the chain.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cache-Control**：这定义了所有缓存机制必须遵守的指令。'
- en: '**Location**: This is used for re-directions. Whenever there is a `301` or
    `302` response, the server must send this header.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：这用于重定向。每当有`301`或`302`响应时，服务器必须发送此标头。'
- en: '**Set-Cookie**: This is a header used to set a cookie in the user''s browser.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Set-Cookie**：这是用于在用户浏览器中设置cookie的标头。'
- en: '**WWW-Authenticate**: This header is used by the server to request authentication.
    When the browser sees this header, it will open a login window asking for the
    username and password.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WWW-Authenticate**：服务器使用此标头请求身份验证。当浏览器看到此标头时，它将打开一个登录窗口，要求输入用户名和密码。'
- en: 'This is an example of what a response header looks like when making a `GET`
    request to [https://www.packtpub.com/](https://www.packtpub.com/):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在对[https://www.packtpub.com/](https://www.packtpub.com/)进行`GET`请求时响应标头的示例：
- en: '![](img/00010.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: We have mentioned some of them here such as `cache-control`, `content-encoding`,
    and `content-type`. I suggest you get familiar with all of them. Every time you
    find a new header, read about it to learn its functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到了一些，比如`cache-control`，`content-encoding`和`content-type`。我建议你熟悉所有这些。每当你发现一个新的标头时，都要了解它的功能。
- en: GET request
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET请求
- en: After reviewing the URL structure and the headers, let's try a `GET` request
    on a real server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查URL结构和标头之后，让我们尝试在真实服务器上进行`GET`请求。
- en: In order to do so, I will use the Terminal and `telnet` command to send a raw
    `GET` request to the server. This is our attempt at simulating a browser by typing
    in the Telnet connection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我将使用终端和`telnet`命令向服务器发送原始的`GET`请求。这是我们尝试通过输入Telnet连接来模拟浏览器的方式。
- en: 'Perform the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Let''s switch to our VM and open up the Terminal and type the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换到我们的虚拟机，打开终端并键入以下内容：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`80` is the port we want Telnet to connect to. `httpbin.org` is a website that
    provides an HTTP request and response service that is useful to test tools.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`80`是我们希望Telnet连接的端口。`httpbin.org`是一个提供HTTP请求和响应服务的网站，对于测试工具非常有用。'
- en: Hit *Enter*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*。
- en: 'Once we connect, we will see the following message:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接，我们将看到以下消息：
- en: '![](img/00011.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: This means the connection is established.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着连接已建立。
- en: 'Next, let''s type `GET /ip HTTP/1.0` and hit *Enter* twice. This is us telling
    the server that we are using `GET` to request the resource called `/ip`. Then,
    we specify the `HTTP/1.0` protocol followed by pressing *Enter* twice. As a result,
    we get our first response from the server:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们键入`GET /ip HTTP/1.0`并按*Enter*两次。这是我们告诉服务器，我们正在使用`GET`请求名为`/ip`的资源。然后，我们指定`HTTP/1.0`协议，然后按两次*Enter*。结果，我们从服务器得到了第一个响应：
- en: '![](img/00012.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: Notice that we haven't used any headers at all in the request, but we received
    many headers from the server, plus the content of the resource IP.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在请求中没有使用任何标头，但是我们从服务器接收了许多标头，以及资源IP的内容。
- en: In this case, the content is the IP address of the machine making the request.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，内容是发出请求的机器的IP地址。
- en: Now, let's take another example, but this time requesting a URL that has a parameter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们举一个例子，但这次请求一个带有参数的URL。
- en: 'Open up the Terminal and type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并键入：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, we used `GET`, but this time we are requesting the resource redirect
    to with the parameter URL in the query string with the value [http://www.bing.com](http://www.bing.com):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用了`GET`，但这次我们请求将资源重定向到查询字符串中的URL参数的值[http://www.bing.com](http://www.bing.com)：
- en: '![](img/00013.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: In this case, the server basically redirects the browser to the URL provided,
    using the location header and returning a `302` redirection code. In this case,
    nothing happens, as Telnet doesn't interpret that header. Remember, this is a
    rule connection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器基本上将浏览器重定向到提供的URL，使用位置标头并返回`302`重定向代码。在这种情况下，什么也不会发生，因为Telnet不解释该标头。请记住，这是一个规则连接。
- en: Interacting with a web app using the requests library
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用requests库与Web应用程序进行交互
- en: In this section, we'll start to write Python code to perform HTTP requests using
    the requests library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始编写Python代码，使用requests库执行HTTP请求。
- en: Requests library
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求库
- en: Requests is an Apache 2 licensed HTTP library written in Python. It was created
    to reduce the complexity and work needed when using `urllib2` and other HTTP libraries
    available at the moment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Requests是一个在Python中编写的Apache 2许可的HTTP库。它旨在减少使用`urllib2`和其他当前可用的HTTP库时所需的复杂性和工作。
- en: 'This is an example of the code needed to perform a request to `api.github.com`
    using authentication when using the `urllib2` library:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`urllib2`库进行对`api.github.com`进行身份验证请求所需的代码示例：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the same function but using the `requests` library:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`requests`库的相同函数：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The simplicity is pretty evident. It really facilitates our job when coding
    scripts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单性非常明显。编写脚本时，它确实简化了我们的工作。
- en: Our first script
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个脚本
- en: 'Let''s start programming in Python. In this first example, we''ll perform a
    `GET` request using Python and the `requests` library:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始用Python编程。在这个第一个示例中，我们将使用Python和`requests`库执行`GET`请求：
- en: Let's open the Atom editor in the Virtual Machine and create a new file by navigating
    to File | New File.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在虚拟机中打开Atom编辑器，并通过导航到`File | New File`来创建一个新文件。
- en: We'll import the `requests` library to start with. This can be done by typing
    `import requests`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入`requests`库开始。这可以通过键入`import requests`来完成。
- en: 'Now, we need to create a variable R, where we''ll instantiate a requests object
    with the `GET` method, and the target URL in this case is `httpbin.org/ip`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为R的变量，其中我们将使用`GET`方法实例化一个requests对象，并且目标URL在这种情况下是`httpbin.org/ip`：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we print the content of the response using `print r.text`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`print r.text`打印响应的内容。
- en: Save the file in the `/Examples/Section-2` folder as `Chapter-3.py`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存在`/Examples/Section-2`文件夹中，命名为`Chapter-3.py`。
- en: 'Let''s run it on the Terminal. Open the Terminal and change the directory to
    `/Example/Section-2` with the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在终端上运行它。打开终端，并使用以下命令将目录更改为`/Example/Section-2`：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we run it with the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令运行它：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see the response body, where we can once again see my IP:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到响应主体，我们可以再次看到我的IP：
- en: '![](img/00014.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Remember that `/ip` returns the caller IP in the body.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`/ip`在主体中返回调用者IP。
- en: That was our first script using the `requests` library. Congratulations, you
    are communicating with the web application using Python!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用`requests`库的第一个脚本。恭喜，您正在使用Python与Web应用程序进行通信！
- en: 'Now, let''s add a query string in the `GET` request:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`GET`请求中添加一个查询字符串：
- en: In order to do so, we'll add a variable called **payload** with a dictionary,
    where each key is the parameter name and the value will be the value of that parameter.
    In this case, the parameter is the URL and the value will be `http://www.edge-security.com`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将添加一个名为**payload**的变量，其中包含一个字典，其中每个键是参数名称，值将是该参数的值。在这种情况下，参数是URL，值将是`http://www.edge-security.com`。
- en: Then, we'll change the resource to `/redirect-to` instead of IP. This resource
    is expecting the parameter URL with a valid URL, which will redirect us.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将把资源更改为`/redirect-to`而不是IP。该资源期望带有有效URL的参数URL，这将重定向我们。
- en: 'We also need to add the payload as a value for `params` in the request, `params=payload`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将有效载荷作为请求中`params`的值添加，`params=payload`：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we'll save it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将保存它。
- en: Now, if we run the script, we will see the content of the redirected page in
    the `python Chapter-3.py` Terminal. There you go.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行脚本，我们将在`python Chapter-3.py`终端中看到重定向页面的内容。就是这样。
- en: 'Here, we have all the content of `www.edge-security.com` in the Terminal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在终端中有`www.edge-security.com`的所有内容：
- en: '![](img/00015.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: That is how we add parameters to the query string.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何向查询字符串添加参数。
- en: 'What if we want to see the return code from the server? We need to add the
    following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查看服务器返回的返回代码怎么办？我们需要添加以下代码：
- en: Let's print some title by typing `print "Status code:"`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过输入`print "Status code:"`来打印一些标题。
- en: 'Then, we can print some formatting using the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令打印一些格式：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can remove `print r.text` to obtain a cleaner response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除`print r.text`以获得更清晰的响应。
- en: 'We''ll save it and run it in the Terminal with Python and the name of the script.
    We can see the status `200` as a result, which means the request was valid:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保存它，并在终端中用Python和脚本的名称运行它。我们可以看到状态`200`，这意味着请求是有效的：
- en: '![](img/00016.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: We'll now see how to get access to the headers of the response.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何访问响应的头部。
- en: We'll go back to the editor in the virtual machine and open the file `Video-3-headers.py`,
    which is ready to save some typing. This script is using the resource/IP again.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将返回虚拟机中的编辑器并打开`Video-3-headers.py`文件，这样可以节省一些打字。这个脚本再次使用资源/IP。
- en: In order to access the response headers, we use the method headers of the request
    object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问响应头，我们使用请求对象的headers方法。
- en: In order to print them line by line, we can do a loop and unpack the key and
    values from `r.headers:`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐行打印它们，我们可以做一个循环并从`r.headers`中解压键和值。
- en: Let's try and run this in the Terminal.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在终端中运行这个。
- en: We'll use Python and the script filename. You can see the different headers
    returned by the server plus the response code and the response body content.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用Python和脚本文件名。您可以看到服务器返回的不同头部，以及响应代码和响应体内容。
- en: What if we want to request only the headers to save bandwidth and accelerate
    the reg response transaction times? We go back to the editor and we change the
    `get` method by the `head` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想要请求头部以节省带宽并加快返回响应事务时间，我们回到编辑器并将`get`方法改为`head`方法。
- en: 'We save the script, then move to the console and run it. We can see that the
    status code is `200` and we''re getting back the headers, but we don''t have the
    response body content anymore:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存脚本，然后转到控制台运行它。我们可以看到状态代码是`200`，我们得到了头部，但我们不再有响应体内容：
- en: '![](img/00017.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: This is because the method used is `head` and we only get the headers from the
    server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为使用的方法是`head`，我们只从服务器得到了头部。
- en: Setting headers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置头部
- en: Now, we'll see how to set the headers of the request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何设置请求的头部。
- en: Why would we want to do that? Because we may need to add custom headers that
    are expected by the application. We want to fake our user agent to trick the server
    into thinking that we are a mobile device. We may want to change the `post` header
    to trick the server or load balances, or we may want to brute force or tamper
    with a header value and see how the application handles it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这样做？因为我们可能需要添加应用程序所期望的自定义头部。我们想要伪装我们的用户代理，以使服务器误以为我们是一个移动设备。我们可能想要更改`post`头部以欺骗服务器或负载平衡，或者我们可能想要暴力破解或篡改头部值并查看应用程序如何处理它。
- en: 'Let''s try to set a header:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试设置一个标题：
- en: 'Go back to the script in the editor. We''ll modify the request, changing the
    method back to `get` and the resource from `ip` to `headers`. This will make `http://bin.org` send
    us back the climb headers it received in the body of the response for debugging
    purposes:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器中的脚本。我们将修改请求，将方法改回`get`，将资源从`ip`改为`headers`。这将使`http://bin.org`将我们发送的爬行头部作为响应体返回，以进行调试：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save it and then run it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存它，然后运行它。
- en: We can see that the user agent, the `requests` library, sends `python-requests` with
    every request.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到用户代理`requests`库在每个请求中都发送`python-requests`。
- en: 'Now, let''s go back to the editor and set the `user-agent` header to a random
    test value. We need to add a dictionary called `myheaders` with a key name, user
    agent, and the test value `Iphone 6`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们返回编辑器并将`user-agent`头部设置为一个随机测试值。我们需要添加一个名为`myheaders`的字典，其中包含一个键名，用户代理，和测试值`Iphone
    6`：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to add the request, a parameter called headers with the value
    `myheaders`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加请求，一个名为headers的参数，值为`myheaders`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's run it again in the console.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在控制台中再次运行它。
- en: 'We can see that the server received our modified user agent faking an `Iphone
    6`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到服务器接收到我们修改后的用户代理伪装成`Iphone 6`：
- en: '![](img/00018.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Now, you know how to manipulate headers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何操作头部了。
- en: 'Now that we saw a `get` and a `head` request, let''s take a look at a `post`
    request, where we''ll send the form parameters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`get`和`head`请求，让我们来看看`post`请求，我们将发送表单参数：
- en: Go back to the Atom editor and replace the `get` method with the `post`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Atom编辑器并用`post`替换`get`方法。
- en: We'll also change the URL. This time, we'll use the post resource `http://bin.org/post` and
    add the data dictionary.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将更改URL。这次，我们将使用post资源`http://bin.org/post`并添加数据字典。
- en: This is typically the form data you see in a web application. In this case,
    we add one parameter in a data dictionary with a key code name and the value `packt`.
    We save it and then run the script in the console. Perfect; we can see in the
    results that we have the dictionary form with the values we have submitted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是你在Web应用程序中看到的表单数据。在这种情况下，我们在数据字典中添加一个参数，键名为code，值为`packt`。我们保存它，然后在控制台中运行脚本。完美；我们可以在结果中看到我们提交的值的字典形式。
- en: Congratulations, you now know how to perform different HTTP requests using Python!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，现在你知道如何使用Python执行不同的HTTP请求了！
- en: Analyzing HTTP responses
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析HTTP响应
- en: In this section, we will learn about the different HTTP response status codes
    and different classes of HTTP response codes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习不同的HTTP响应状态代码和不同类别的HTTP响应代码。
- en: Then, we'll write examples to see successful responses or errors, and finally,
    we'll see a redirection example.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写示例来查看成功的响应或错误，最后，我们将看到一个重定向示例。
- en: HTTP codes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP代码
- en: 'The HTTP protocol defines five classes of response codes to indicate the status
    of a request:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议定义了五类响应代码，用于指示请求的状态：
- en: '**1XX-Informational**: The 100 range codes are used for informational purposes.
    It is only present in HTTP/1.1.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1XX-信息**：100范围的代码用于信息目的。它仅存在于HTTP/1.1中。'
- en: '**2XX-Success**: The 200 range of codes are used to indicate that the action
    requested by the client was received, understood, accepted, and processed. The
    most common is `200 OK`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2XX-成功**：200范围的代码用于指示客户端请求的操作已收到、理解、接受和处理。最常见的是`200 OK`。'
- en: '**3XX-Redirection**: The 300 range indicates the client that must take additional
    actions to complete the request. Most of these codes are used in URL redirection.
    The most common of this group is the `302 Found` code.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3XX-重定向**：300范围指示客户端必须采取其他操作才能完成请求。这些代码中的大多数用于URL重定向。这个组中最常见的是`302 Found`代码。'
- en: '**4XX-Client-side error**: The 400 range are used to indicate that the client
    has had an error. The most common is `404 Not Found`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4XX-客户端错误**：400范围用于指示客户端发生错误。最常见的是`404 Not Found`。'
- en: '**5XX-Server-side error**: The range 500 is used to indicate an error on the
    server side. The most common is `500 Internal Server Error`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5XX-服务器端错误**：500范围用于指示服务器端发生错误。最常见的是`500 Internal Server Error`。'
- en: 'We suggest you learn the different codes in each group here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在这里学习每个组中的不同代码：
- en: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
- en: 'Let''s write some code. Let''s open our editor in the virtual machine and create
    a new file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码。让我们在虚拟机中打开我们的编辑器并创建一个新文件：
- en: First, we import the `requests` library by typing `import requests`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过输入`import requests`来导入`requests`库。
- en: 'We will create a variable for our target URL. We''ll use `httpbin.org` again
    and type:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们的目标URL创建一个变量。我们将再次使用`httpbin.org`并输入：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we''ll print the response code with `req.status _code`. We do this by
    entering the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`req.status _code`打印响应代码。我们通过输入以下内容来执行此操作：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Print the response code for the `req.status_code` string. This can be done
    as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`req.status_code`字符串的响应代码。可以这样做：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it! We'll save the file in `/Example/Section-2` as `Video-4.py` and switch
    to the Terminal to run the script.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！我们将文件保存在`/Example/Section-2`中，命名为`Video-4.py`，然后切换到终端运行脚本。
- en: Use `python Video-4.py`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python Video-4.py`。
- en: 'You should see a `200` status code in the response, which means that our request
    was successful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在响应中看到`200`状态代码，这意味着我们的请求成功：
- en: '![](img/00019.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: Well done, let's move on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，让我们继续。
- en: 'Let''s go back to the editor:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编辑器：
- en: 'Now, let''s change the target URL to something that does not exist. In order
    to see an error code, we''ll change the URL and write `fail`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将目标URL更改为不存在的内容。为了看到错误代码，我们将更改URL并写入`fail`：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's save it and run this script in the Terminal again.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保存并再次在终端中运行此脚本。
- en: 'Now, when we run the server, it will return a `404` status code, which means
    that the resource was not found on the server:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行服务器时，它将返回`404`状态代码，这意味着服务器上找不到资源：
- en: '![](img/00020.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: So, now we know that we can ask the server for a list of directories and files
    and find which ones exist and which ones do not. Interesting, right?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们知道我们可以向服务器请求目录和文件列表，并找出哪些存在，哪些不存在。有趣，对吧？
- en: 'Now, let''s see how we deal with redirections. We''ll use an example page that
    will take a parameter URL and redirect us to that defined URL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理重定向。我们将使用一个示例页面，该页面将获取一个参数URL并将我们重定向到该定义的URL：
- en: Let's go back to our script and modify it in order to get a new directory called
    `payload`, which will contain the URL where we want to be redirected to.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的脚本，并修改它以获取一个名为`payload`的新目录，其中将包含我们要重定向到的URL。
- en: 'We''ll use `payload=''url''` to be redirected to `www.bing.com`. We can do
    this as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`payload='url'`来重定向到`www.bing.com`。我们可以这样做：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we'll use this, the resource redirect-to and add the `params` parameter
    and set it to the `payload`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个资源`redirect-to`并添加`params`参数，并将其设置为`payload`。
- en: 'Finally, we''ll print the content with `print req.text`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`print req.text`打印内容：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll save it and run it again.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存并再次运行它。
- en: 'What do we get now? A `200` code and the content of [https://www.bing.com/](https://www.bing.com/):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到了什么？一个`200`代码和[https://www.bing.com/](https://www.bing.com/)的内容：
- en: '![](img/00021.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: The code should be `302`, right? We need to access the history of the request
    to see the redirects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该是`302`，对吧？我们需要访问请求的历史记录以查看重定向。
- en: Let's add `print r.history`. The history is a list of all the responses in the
    redirection chain. We will print the URL and the response code for each URL with
    this loop to our script.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`print r.history`。历史记录是重定向链中所有响应的列表。我们将使用此循环将每个URL的URL和响应代码打印到我们的脚本中。
- en: 'For `x in req.history`, print this status code concatenated with the URL:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`x in req.history`，打印此状态代码与URL连接：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save it and run it:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行：
- en: '![](img/00022.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: Now, we can see that before the `200`, there was a `302` redirection code sending
    our browser to [www.bing.com](http://www.bing.com).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到在`200`之前，有一个`302`重定向代码将我们的浏览器发送到[www.bing.com](http://www.bing.com)。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a brief introduction to HTTP, and we saw a basic `GET`
    request example. We also saw the different HTTP methods available that we can
    use to interact with web applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了HTTP，并看到了一个基本的`GET`请求示例。我们还看到了可用的不同HTTP方法，可以用来与Web应用程序进行交互。
- en: We also learned about HTTP requests. We learned how to interact with a web application
    using Python and the `requests` library. We further learned about the HTTP request
    anatomy and the different HTTP methods and response code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于HTTP请求。我们学习了如何使用Python和`requests`库与Web应用程序进行交互。我们进一步了解了HTTP请求解剖和不同的HTTP方法和响应代码。
- en: In [Chapter 3](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80), *Web
    Crawling with Scrapy - Mapping the Application*, we'll learn how to write a Web
    Crawler, use Spider using Python, and how to use the Scrappy library.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80)中，*使用Scrapy进行网络爬虫-映射应用程序*，我们将学习如何编写网络爬虫，使用Python编写Spider，以及如何使用Scrappy库。
