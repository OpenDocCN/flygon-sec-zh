- en: Other Wonders of Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的其他奇迹
- en: 'Cyber security is a vast and dynamically growing field. So far in this book,
    we have discussed various use cases in which Python comes in handy. The reader
    can utilize this knowledge to explore further scenarios in which Python can be
    applied in the cyber security domain. In this concluding chapter, we will try
    to cover a few other ways in which we can use Python. We will look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全是一个广阔而不断增长的领域。到目前为止，在本书中，我们已经讨论了Python在其中发挥作用的各种用例。读者可以利用这些知识来探索Python可以在网络安全领域中应用的更多场景。在本章的结束部分，我们将尝试介绍一些其他可以使用Python的方式。我们将看看以下内容：
- en: Parsing Nessus and Nmap reports with Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python解析Nessus和Nmap报告
- en: Writing custom Linux- and Windows-based keyloggers in Python and sharing logs
    across the network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中编写自定义的Linux和Windows键盘记录器，并在网络上共享日志
- en: Parsing Tweeter tweets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析推特推文
- en: Extracting browser-saved passwords
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取浏览器保存的密码
- en: Antivirus-free persistence shells
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需防病毒持久性外壳
- en: Bypassing host-based firewalls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过基于主机的防火墙
- en: Report parsers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告解析器
- en: A **report parser** is a piece of code written in order to parse a report or
    a file. The files under discussion in this case are Nessus and Nmap files. The
    detailed description and functionality of each are covered in the following sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告解析器**是为了解析报告或文件而编写的一段代码。在这种情况下讨论的文件是Nessus和Nmap文件。每个的详细描述和功能在以下部分中都有涵盖。'
- en: Nmap parser
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nmap解析器
- en: 'Nmap produces outputs in various formats (text, CSV, and XML). In this section,
    we are going to learn how we can quickly and easily parse Nmap report files in
    XML format. There are two approaches we can use to do this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap以各种格式（文本、CSV和XML）生成输出。在本节中，我们将学习如何快速轻松地解析XML格式的Nmap报告文件。我们可以使用两种方法来做到这一点：
- en: The first approach is to build a parser from scratch and employ the same concepts
    that we discussed in [Chapter 4](a102c7fe-a6cb-41de-9a5c-392fd05f828a.xhtml),
    *Advanced Python Modules*, which focused on XML parsing.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是从头开始构建解析器，并使用我们在[第4章](a102c7fe-a6cb-41de-9a5c-392fd05f828a.xhtml)中讨论的相同概念，即XML解析。
- en: 'The second and recommended approach is to avoid re-inventing the wheel. Always
    make it a habit to search on the internet before developing any automation solutions
    in Python. Python has got amazing community support and there are many different
    modules that offer out-of-the-box solutions not only in the cyber security domain,
    but also for other more general use cases. Let''s use one of these pre-built Python
    modules. We will install the `libnmap` Python module, as shown here:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种推荐的方法是避免重复造轮子。在开发Python的任何自动化解决方案之前，养成在互联网上搜索的习惯。Python拥有令人惊叹的社区支持，有许多不仅在网络安全领域，而且在其他更一般的用例中提供现成解决方案的不同模块。让我们使用其中一个预先构建的Python模块。我们将安装`libnmap`
    Python模块，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create a file called `nmap_parser.py` and place the following code in
    it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`nmap_parser.py`的文件，并将以下代码放入其中：
- en: '![](img/954b1411-cf2f-4281-b696-c940a034cfcf.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/954b1411-cf2f-4281-b696-c940a034cfcf.png)'
- en: The preceding code is pretty self-explanatory. What we are doing is creating
    a class and calling it `nmap_parser`. In the constructor of the class, we are
    initializing a `self.report_file` instance variable with the file path including
    the name of the report, which the user should pass as the first argument to the
    script.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常容易理解。我们正在创建一个类并将其命名为`nmap_parser`。在类的构造函数中，我们使用文件路径初始化了一个`self.report_file`实例变量，其中包括报告的名称，用户应该将其作为脚本的第一个参数传递。
- en: In line 9, we initialize the instance of the `NmapParser` class and pass the
    path of the file that we wish to parse. It returns `NmapObject`, which we will
    further iterate on to get the results. In line 11, we extract the list of `hosts()`
    from the `NmapObject` we created earlier, which is called `report` in the preceding
    code. It should be noted that although `NmapObject ` returns a list, each list
    element is an object of the `host()` class, which the module creates internally
    by mapping the host tags from the file appropriately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9行，我们初始化了`NmapParser`类的实例，并传递了我们希望解析的文件的路径。它返回`NmapObject`，我们将进一步迭代以获得结果。在第11行，我们从先前创建的`NmapObject`中提取`hosts()`列表，之前的代码中称为`report`。值得注意的是，虽然`NmapObject`返回一个列表，但每个列表元素都是`host()`类的对象，该模块通过适当地映射文件中的主机标签来内部创建。
- en: In line 13, we check if the host currently being iterated over is alive using
    the `is_up()` method. In line 15, we extract all the open ports for a host. The
    method returns a list that we iterate over in line 18\. The internal format it
    uses is `[(``"22","ssh"),("21","ftp"``)]`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行，我们使用`is_up()`方法检查当前正在迭代的主机是否存活。在第15行，我们提取主机的所有开放端口。该方法返回一个列表，在第18行我们对其进行迭代。它使用的内部格式是`[("22","ssh"),("21","ftp")]`。
- en: In line 20, we invoke a `host.get_service` method , which returns the instance
    of the service class. It expects the port and name of the service to be passed
    as arguments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第20行，我们调用了`host.get_service`方法，该方法返回服务类的实例。它期望传递端口和服务名称作为参数。
- en: Finally, between lines 21 and 26, we print all the relevant information by invoking
    appropriate instance variables and instance methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第21行和第26行之间，通过调用适当的实例变量和实例方法打印所有相关信息。
- en: 'The complete API documentation of this module can be found on the official
    website: [https://libnmap.readthedocs.io/en/latest/index.html](https://libnmap.readthedocs.io/en/latest/index.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的完整API文档可以在官方网站上找到：[https://libnmap.readthedocs.io/en/latest/index.html](https://libnmap.readthedocs.io/en/latest/index.html)。
- en: Running the code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run the code, we need to invoke it as a normal Python script. However, we
    also need to pass the path/name of the Nmap file that we wish to parse as an argument.
    I have taken a sample file, `nmap.xml`, which lies on the same path as our parser
    code. The file contains a scan report conducted against multiple hosts. The `nmap`
    command used to produce the output file is shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，我们需要将其作为普通的Python脚本调用。但是，我们还需要传递我们希望解析的Nmap文件的路径/名称作为参数。我已经取了一个样本文件`nmap.xml`，它位于与我们的解析器代码相同的路径上。该文件包含针对多个主机进行的扫描报告。用于生成输出文件的`nmap`命令如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A screenshot of the report is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的截图如下：
- en: '![](img/f43b44ef-438e-410f-9889-2332ea9491eb.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f43b44ef-438e-410f-9889-2332ea9491eb.png)'
- en: 'Let''s run the parser code using the following command to see the output it
    produces:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行解析器代码，看看它产生的输出：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`nmap.xml` is the name of the file placed in the same folder as the parser
    code. If your `report` file is at a different path, provide the absolute path
    as an argument to the script.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap.xml`是放置在与解析器代码相同文件夹中的文件的名称。如果您的`report`文件位于不同的路径，请将绝对路径作为脚本的参数。'
- en: 'The output obtained is shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所获得的输出如下所示：
- en: '![](img/1a0201a5-cc04-4a1e-aa2c-6e5dbd2d81e1.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a0201a5-cc04-4a1e-aa2c-6e5dbd2d81e1.png)'
- en: Nessus parser
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nessus解析器
- en: 'Nessus also produces output in various formats (CSV, XML, DB-file, JSON, HTML,
    and so on). In this section, we are going to understand how we can quickly and
    easily parse Nessus report files of XML format. Again, we can either create a
    custom parser manually, or get the job done with an out-of-the-box Python module,
    which makes life very easy for us. Install the required module as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus还以各种格式（CSV、XML、DB文件、JSON、HTML等）生成输出。在本节中，我们将了解如何快速轻松地解析XML格式的Nessus报告文件。同样，我们可以手动创建自定义解析器，也可以使用现成的Python模块来完成工作，这对我们来说非常方便。按照以下所示安装所需的模块：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create a file called `Nessus_parser.py` and place the following code
    in it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`Nessus_parser.py`的文件，并将以下代码放入其中：
- en: '![](img/0e49a40e-4f72-42a2-9c38-4dcbfe9a4a3c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e49a40e-4f72-42a2-9c38-4dcbfe9a4a3c.png)'
- en: The preceding code is pretty self-explanatory. What we are doing is creating
    a class and calling it `Nessus_parser`. In the constructor of the class, we are
    initializing an instance variable called `self.n_file` with the file path including
    the name of the report, which the user should pass as the first argument to the
    script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常容易理解。我们正在创建一个名为`Nessus_parser`的类，并调用它。在类的构造函数中，我们正在用包括报告名称在内的文件路径初始化一个实例变量`self.n_file`，用户应该将其作为脚本的第一个参数传递。
- en: In line 30, we initialize the instance of the `NessusParser` class and pass
    the path of the file that we wish to parse. It returns `NessusObject`, which we
    will further iterate on to get the results. In line 35, we simply invoke the `demo_print()`
    method and pass the `NessusObject()` instance to it, which contains a list of
    hosts that we wish to iterate over. Between lines 12 and 25, we simply iterate
    over Nessus Host instances and print the relevant information. The Nessus parser
    is very similar to the Nmap parser we discussed earlier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第30行，我们初始化了`NessusParser`类的实例，并传递了我们希望解析的文件的路径。它返回`NessusObject`，我们将进一步迭代以获得结果。在第35行，我们简单地调用`demo_print()`方法，并将`NessusObject()`实例传递给它，其中包含我们希望迭代的主机列表。在第12行和第25行之间，我们简单地迭代Nessus主机实例并打印相关信息。Nessus解析器与我们之前讨论的Nmap解析器非常相似。
- en: The complete API details of the class can be found at the official website: [https://libnessus.readthedocs.io/en/stable/](https://libnessus.readthedocs.io/en/stable/.).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的完整API详细信息可以在官方网站找到：[https://libnessus.readthedocs.io/en/stable/](https://libnessus.readthedocs.io/en/stable/.)
- en: Running the code
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代码
- en: To run the code, we need to invoke it as a normal Python script, but we also
    need to pass the path/name of the Nessus file that we wish to parse as an argument.
    I have taken a sample file, `report.nessus`, which lies on the same path as our
    parser code. The file contains a scan report conducted against multiple hosts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，我们需要将其作为普通的Python脚本调用，但是我们还需要传递我们希望解析的Nessus文件的路径/名称作为参数。我已经取了一个样本文件`report.nessus`，它位于与我们的解析器代码相同的路径上。该文件包含针对多个主机进行的扫描报告。
- en: 'A screenshot of the report is shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的截图如下所示：
- en: '![](img/08d0bb26-b71e-46f8-80cf-be3666180d24.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08d0bb26-b71e-46f8-80cf-be3666180d24.png)'
- en: 'Let''s run the parser code using the following command to see the output it
    produces:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行解析器代码，看看它产生的输出：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`report.nessus` is the name of the file placed in the same folder as the parser
    code. If your report file is at a different path, provide the absolute path as
    an argument to the script.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`report.nessus`是放置在与解析器代码相同文件夹中的文件的名称。如果您的报告文件位于不同的路径，请将绝对路径作为脚本的参数。'
- en: 'The output obtained is shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所获得的输出如下所示：
- en: '![](img/8e85e498-7fb9-46b0-9297-c4defe64369c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e85e498-7fb9-46b0-9297-c4defe64369c.png)'
- en: The need to have custom parsers
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要自定义解析器
- en: A typical use case where I have found these custom parsers very handy is during
    client engagements. After every typical pen test, a pen tester will usually consolidate
    all the Nessus report findings, Nmap output, and POCs generated by manual exploitation
    and put them in a custom Excel template created by the client, or use the companies
    report generating portal to produce a consolidated report. The approach discussed
    previously can be used to automate this process. Using the concepts we discussed,
    I would recommend that the reader make a general-purpose report generating module
    that would consolidate the findings from Nmap and Nessus and that would also take
    custom POC screenshots into account to generate Excel and PDF format reports.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这些自定义解析器非常方便的一个典型用例是在客户参与过程中。在每次典型的渗透测试之后，渗透测试人员通常会整合所有Nessus报告发现、Nmap输出以及手动利用生成的POC，并将它们放入客户创建的自定义Excel模板中，或者使用公司的报告生成门户来生成一个综合报告。前面讨论的方法可以用来自动化这个过程。使用我们讨论过的概念，我建议读者制作一个通用的报告生成模块，该模块将整合来自Nmap和Nessus的发现，并且还将考虑自定义POC截图以生成Excel和PDF格式的报告。
- en: Keylogger and exfiltration via sockets
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘记录器和通过套接字的外泄
- en: A **keylogger** is a notorious piece of software that records all keystrokes
    the user presses. It silently runs as an operating system process in the background.
    They are capable of recording user passwords, browsing history, confidential data,
    and much more. There are many keyloggers freely available and ready to use out
    of the box. In this section, we are going to see how we can create a powerful
    custom keylogger in Python. A custom keylogger is always better, as we can tailor
    it according to our needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**键盘记录器**是一种臭名昭著的软件，记录用户按下的所有按键。它在后台作为操作系统进程静默运行。它们能够记录用户密码、浏览历史、机密数据等等。有许多免费可用的键盘记录器，可以立即使用。在本节中，我们将看到如何在Python中创建一个强大的自定义键盘记录器。自定义键盘记录器总是更好的，因为我们可以根据自己的需求进行定制。'
- en: Python comes with a very powerful module known as pyHook for Windows and there
    is a modification on top of this module to support Linux-based systems, called
    `pyxhook`. There are tons of tutorials out on the internet on the usage of the `pyhook` Windows-based
    Python keylogger, but there aren't as many tutorials concerning  the Linux version.
    In this section, we will focus on the Linux-based keylogger. I will also provide
    a simple code snippet that works for the Windows module as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带一个非常强大的模块，称为pyHook，适用于Windows，还有一个在此模块基础上进行修改以支持基于Linux的系统的模块，称为`pyxhook`。互联网上有大量关于`pyhook`基于Windows的Python键盘记录器用法的教程，但关于Linux版本的教程并不多。在本节中，我们将专注于基于Linux的键盘记录器。我还将提供一个适用于Windows模块的简单代码片段。
- en: The objective of this section is to simulate a real-world attack scenario, so
    our keylogger will not only save the keystrokes in a file, but also send the generated
    logs to the attacker machine at specific time intervals. We will explore how the concepts
    to do with socket programming that we looked at previously will come in very handy
    here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是模拟真实的攻击场景，因此我们的键盘记录器不仅会将按键保存在文件中，还会在特定时间间隔内将生成的日志发送到攻击者机器。我们将探讨我们之前所看到的与套接字编程相关的概念在这里是如何非常有用的。
- en: 'Let''s install the Linux version of the keylogger module from the GitHub repository:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从GitHub存储库中安装键盘记录器模块的Linux版本：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to install the Windows version of the Python keylogger and you
    are working in the Windows environment, this can be achieved using `pip`, as shown
    here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想安装Python键盘记录器的Windows版本，并且您在Windows环境中工作，可以使用`pip`来实现，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: pyxhook – a Linux based Keylogger
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pyxhook - 基于Linux的键盘记录器
- en: 'Assuming we have successfully cloned the GitHub repository of `pyxhook`, let''s
    run a `cd` command in the directory of the downloaded repository and create a
    file called `key_logg.py` with the following contents:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功克隆了`pyxhook`的GitHub存储库，让我们在下载的存储库目录中运行`cd`命令，并创建一个名为`key_logg.py`的文件，其中包含以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The keylogger makes use of the downloaded `pyxhook` repository module. As can
    be seen in line 2, we are importing the `pyxhook` module. The following code creates
    a custom class file called `Mylogger`. It defines a method, `startlogin()`, in
    which the central logic triggers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘记录器使用了下载的`pyxhook`存储库模块。如第2行所示，我们正在导入`pyxhook`模块。以下代码创建了一个名为`Mylogger`的自定义类文件。它定义了一个方法`startlogin()`，其中包含触发中心逻辑：
- en: '![](img/a1a84b24-c818-4bb2-83e1-a1bd6566eea7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1a84b24-c818-4bb2-83e1-a1bd6566eea7.png)'
- en: Now, within our `my_event` custom method, we get the key pressed by invoking
    the current keyboard event. In line 20, we check if the user has pressed the spacebar,
    the ASCII key code of which is 32\. If this is the case, we replace the `space`
    keyword with an empty space string, `" "`. In line 22, we update our `self.log_string` instance
    variable, and append to it whatever the user has pressed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`my_event`自定义方法中，我们通过调用当前键盘事件来获取按下的键。在第20行，我们检查用户是否按下了空格键，其ASCII键码为32。如果是这种情况，我们将`space`关键字替换为一个空格字符串`"
    "`。在第22行，我们更新我们的`self.log_string`实例变量，并附加用户按下的任何内容。
- en: In line 23, we check for the keylogger termination condition, which is determined
    by checking if the user has entered the `quitkhan` string. That will set `self.running
    flag=False` and will stop the keylogger. If the user has not entered this string,
    the keylogger will keep updating the `self.log_string` string, and after every
    5 seconds it will send `log_string` to the attacker machine using sockets. This
    is handled by lines 25–30\. The method that is used to send `log_string` to attacker
    machine is the `send_to_attacker()` method, the definition of which starts from
    line 8.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第23行，我们检查键盘记录器的终止条件，这是通过检查用户是否输入了`quitkhan`字符串来确定的。这将设置`self.running flag=False`并停止键盘记录器。如果用户没有输入此字符串，键盘记录器将继续更新`self.log_string`字符串，并在每5秒发送`log_string`到攻击者机器上。这由第25-30行处理。用于将`log_string`发送到攻击者机器的方法是`send_to_attacker()`方法，其定义从第8行开始。
- en: In line 32, we create an instance of the `pyxhook` module called `hm`. Once
    it is created, we bind the `hm` instance with a custom method called `self.my_event`.
    This triggers the `my_event` method when a key is pressed. In line 33, we bind
    the `hm` instance with the keyboard of the computer, which means that whenever
    any key is pressed on the keyboard, the `keyDown` action is invoked, which is
    bound to our `my_event` custom method. In line 34, we have an infinite loop that
    will keep running till until the `self.running` flag is set to `True`. This means
    that the `my_event` method will be invoked after every millisecond and the pressed
    keystroke will be recorded.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第32行，我们创建了一个名为`hm`的`pyxhook`模块的实例。一旦创建，我们将`hm`实例绑定到一个名为`self.my_event`的自定义方法。当按下键时，这将触发`my_event`方法。在第33行，我们将`hm`实例绑定到计算机的键盘，这意味着每当键盘上按下任何键时，都会调用`keyDown`操作，该操作绑定到我们的`my_event`自定义方法。在第34行，我们有一个无限循环，它将一直运行，直到`self.running`标志设置为`True`。这意味着`my_event`方法将在每毫秒后被调用，并记录按下的按键。
- en: 'It should be noted that the attacker IP and port can be changed as appropriate.
    At the attacker end, we have a socket server that keeps listening on port `8080` and
    accepts connections from clients. Whenever it receives any data, it places it
    in the `log_file` log file. The code snippet that implements the attacker server
    is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，攻击者的IP和端口可以根据需要更改。在攻击者端，我们有一个套接字服务器，它在端口`8080`上保持监听并接受来自客户端的连接。每当它接收到任何数据时，它都会将其放入`log_file`日志文件中。实现攻击者服务器的代码片段如下：
- en: '![](img/bf648c25-0961-4214-b183-986f2431c796.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf648c25-0961-4214-b183-986f2431c796.png)'
- en: The preceding code is straightforward and has been discussed in detail in the
    socket programming section of the *Advanced Python Modules* chapter. It simply
    opens a socket and listens to client connections. When it receives data, it places
    it in a log file. Let's run the server and the keylogger and see which keystrokes
    will be recorded.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单，并且在*高级Python模块*章节的套接字编程部分中已经详细讨论过。它只是打开一个套接字并监听客户端连接。当它接收到数据时，它将其放入一个日志文件中。让我们运行服务器和键盘记录器，看看将记录哪些按键。
- en: 'Let''s start the processes in the following sequence:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下顺序开始进程：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot is the Terminal output produced by the logger while
    we were typing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是我们在输入时记录器产生的终端输出：
- en: '![](img/7dd3a5df-2bff-4826-ba4f-6ff13c3eae41.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dd3a5df-2bff-4826-ba4f-6ff13c3eae41.png)'
- en: 'Meanwhile, we opened the browser and typed [www.google.com](http://www.google.com).
    We can also pass the current window to the attacker, on which the data has been
    typed. Refer to the example shared on the GitHub repository, `example.py`: [https://github.com/JeffHoogland/pyxhook/blob/master/example.py](https://github.com/JeffHoogland/pyxhook/blob/master/example.py).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们打开浏览器并输入[www.google.com](http://www.google.com)。我们还可以将当前窗口传递给攻击者，上面已经输入了数据。参考GitHub存储库上分享的例子，`example.py`：[https://github.com/JeffHoogland/pyxhook/blob/master/example.py](https://github.com/JeffHoogland/pyxhook/blob/master/example.py)。
- en: 'Let''s see the log file generated at the server and analyze what it captured:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务器生成的日志文件，并分析它捕获了什么：
- en: '![](img/989e2309-1b7c-4f1f-b531-cb4f0390c954.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/989e2309-1b7c-4f1f-b531-cb4f0390c954.png)'
- en: Bingo! It can be seen from the preceding screenshot that the logger was successfully
    able to capture all the keystrokes. Feel free to explore this further; it is a
    very powerful and destructive utility.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！从上面的截图可以看出，记录器成功地捕获了所有按键。请随意进一步探索；这是一个非常强大和破坏性的实用程序。
- en: pyhook – a Windows-based keylogger
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pyhook - 基于Windows的键盘记录器
- en: 'The following is the code snippet to get started with the Windows-based keylogger:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于启动基于Windows的键盘记录器的代码片段：
- en: '![](img/bff0f153-913c-4103-b72f-e1d5e87770ab.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bff0f153-913c-4103-b72f-e1d5e87770ab.png)'
- en: As can be seen from the preceding screenshot, the code is identical to that
    we discussed previously in the Linux use case. The preceding code simply logs
    all the keystrokes in a file called `mylog.txt`. It does not, however, send it
    across to the attacker. With this, we come to the end of the keylogger section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码与我们之前在Linux用例中讨论的代码相同。上述代码简单地将所有按键记录在一个名为`mylog.txt`的文件中。然而，它不会将其发送给攻击者。通过这个，我们结束了键盘记录器部分。
- en: Parsing Twitter tweets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析Twitter推文
- en: Being in the offensive security domain, we might wonder why we need to parse
    Twitter tweets. This question is valid, as this use case is more suited to defensive
    security. It may help, however, to uncover a good amount of information if we
    are targeting a specific individual or a specific organization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击性安全领域的一员，我们可能会想为什么需要解析Twitter推文。这个问题是合理的，因为这个用例更适合于防御性安全。然而，如果我们针对特定个人或特定组织，它可能有助于揭示大量信息。
- en: 'As mentioned earlier, Twitter-tweet-parsing can be used by cyber intelligence
    teams to see if any defamation or sensitive content has been posted under the
    organization''s name. Let''s take a look at the following example that explains
    Twitter tweet parsing. First, we need to install the Python module as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Twitter推文解析可以被网络情报团队用来查看是否有诽谤或敏感内容是以组织的名义发布的。让我们来看下面的例子，解释了Twitter推文解析。首先，我们需要按照以下步骤安装Python模块：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our example takes a Twitter feed as an input JSON file and parses all tweets
    to produce the output. Let''s create a file called `sample.py` as shown:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子将Twitter动态作为输入JSON文件，并解析所有推文以生成输出。让我们创建一个名为`sample.py`的文件，如下所示：
- en: '![](img/21d15e30-a1a9-4039-9ce1-c7af89368645.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21d15e30-a1a9-4039-9ce1-c7af89368645.png)'
- en: 'Let''s use a sample Twitter feed file called `exp.json` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个名为`exp.json`的示例Twitter动态文件，如下所示：
- en: '![](img/d8a5306b-b979-40f8-92d0-0b6b2f55024a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8a5306b-b979-40f8-92d0-0b6b2f55024a.png)'
- en: 'Next, run the code to print all the tweets as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行代码以打印所有推文如下：
- en: '![](img/039b2d62-486f-45ee-abdc-85ea2a4925f0.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/039b2d62-486f-45ee-abdc-85ea2a4925f0.png)'
- en: 'The Twitter class object created in line 14, `tweet=Tweet(tweet_dict)`,has
    many other methods and variables that can give granular information about tweets
    such as the date, time, likes, and retweets. The different supported methods can
    be obtained by running `dir(tweet)`, the output of which is given as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第14行创建的Twitter类对象，`tweet=Tweet(tweet_dict)`，有许多其他方法和变量，可以提供有关推文的详细信息，如日期、时间、喜欢和转发。可以通过运行`dir(tweet)`来获取不同支持的方法，其输出如下：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Stealing browser passwords with Python
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Python窃取浏览器密码
- en: 'Python is a very powerful language when it comes to cyber security. There are
    tons of amazing offensive and defensive security tools written in Python and its
    very easy to customize and modify them to serve our needs. In this section, we
    will see how we can use Python in order to steal passwords that are stored in
    browser. Again, since we have so many amazing tools already available and out
    of the box ready to use, we will not be reinventing the wheel, but instead reusing
    what is already out there. Let''s download the GitHub repository as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python在网络安全方面是一种非常强大的语言。有大量令人惊叹的攻击性和防御性安全工具是用Python编写的，而且很容易定制和修改以满足我们的需求。在本节中，我们将看到如何使用Python来窃取存储在浏览器中的密码。同样，由于我们已经有了许多令人惊叹的工具可供使用，我们不会重复造轮子，而是重复利用已有的工具。让我们按照以下步骤下载GitHub存储库：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, simply run the tool to see the browser passwords as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只需运行该工具以查看浏览器密码，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This tool is very handy. It doesn''t just extract browser passwords, it is
    also capable of extracting passwords from the following locations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具非常方便。它不仅可以提取浏览器密码，还可以从以下位置提取密码：
- en: '`sysadmin`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`系统管理员`'
- en: '`all`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`全部`'
- en: '`memory`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内存`'
- en: '`wallet`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`钱包`'
- en: '`chats`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`聊天`'
- en: '`mails`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`邮件`'
- en: '`databases`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据库`'
- en: '`WiFi`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WiFi`'
- en: '`browsers`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浏览器`'
- en: Python for antivirus-free persistence shells
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python用于无杀毒软件持久性shell
- en: As we know, one of the finest techniques to evade antivirus software is to write
    custom exploits. If the exploit is written from scratch, there is very little
    chance for the antivirus engine to match the code signature against the known
    malicious signatures. In this section, we will write a custom shell that returns
    a reverse shell from the victim's machine and see how many AV engines can detect
    it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，规避杀毒软件的最佳技术之一是编写自定义的利用程序。如果利用程序是从头开始编写的，杀毒引擎几乎没有机会将代码签名与已知的恶意签名匹配。在本节中，我们将编写一个自定义shell，从受害者的机器返回一个反向shell，并查看有多少AV引擎可以检测到它。
- en: 'Let''s write a custom exploit, name it `my_car.py`, and place the following
    code in it :'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个自定义的利用程序，命名为`my_car.py`，并将以下代码放入其中：
- en: '![](img/e17adf32-3de2-4d59-b1a3-b997ee0c56f2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e17adf32-3de2-4d59-b1a3-b997ee0c56f2.png)'
- en: 'If we observe the preceding code, we can see that it is an adaption of a Python
    code to spawn a reverse shell to an attacker''s IP address. We are importing the
    Python modules and assigning an alias to the imported modules locally. The AV
    engines mostly work on the signature approach, and the known signatures, such
    as `subprocess.call["/bin/sh","-i"''\]`, are likely to be detected. In this case,
    we are playing around with local variables to ensure to ensure the attacker IP,
    the port number, the OS modules, and other Python modules are not detected. The
    original code that the preceding code is adapted from is shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察前述代码，我们会发现它是一个Python代码的改编，用于将反向shell生成到攻击者的IP地址。我们正在导入Python模块，并在本地为导入的模块分配别名。杀毒引擎主要是基于签名方法工作的，已知的签名，如`subprocess.call["/bin/sh","-i"'\]`，可能会被检测到。在这种情况下，我们正在玩弄本地变量，以确保攻击者IP、端口号、OS模块和其他Python模块不被检测到。前述代码改编自的原始代码如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now run the code to see if we get the shell. We will use a Netcat listener
    to receive the shell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行代码以查看是否获得shell。我们将使用Netcat监听器接收shell：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command when implemented produces the output shown in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实施前述命令后，会产生以下截图中显示的输出：
- en: '![](img/005f4f32-081f-49bf-a68e-694f61a4c0cb.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/005f4f32-081f-49bf-a68e-694f61a4c0cb.png)'
- en: 'We can see that the preceding code works pretty well. It''s important for us
    to see if this would be picked up by any AV engine. Let''s check it using the
    VirusTotal tool, as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到前述代码运行得相当好。重要的是我们要看看这是否会被任何杀毒引擎检测到。让我们使用VirusTotal工具进行检查，如下所示：
- en: '![](img/1310a260-8cd5-4e90-aece-b03f27f315b8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1310a260-8cd5-4e90-aece-b03f27f315b8.png)'
- en: 'Let''s now see whether we were detected by any of the scanning engines:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们是否被任何扫描引擎检测到了：
- en: '![](img/4ab459e3-fec5-4f28-9eb0-ca9379387868.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ab459e3-fec5-4f28-9eb0-ca9379387868.png)'
- en: As we can see, none of the 57 scanning engines tested detected the file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，57个扫描引擎中没有一个检测到这个文件。
- en: It should be noted that we had zero detection results on the day this chapter
    was written and prepared. There is a possibility that over time readers might
    upload more samples and the backend team may update the signatures based on the
    code sample, as I have already uploaded it. Static analysis by the backend human
    team will mark it as malicious. However, with a slight modification, it will be
    able to avoid detection again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这一章节写作和准备的当天我们没有检测结果。随着时间的推移，读者可能会上传更多的样本，后端团队可能会根据代码样本更新签名，因为我已经上传了它。后端人员的静态分析将标记为恶意。然而，稍作修改后，它将能够再次避免被检测。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about developing custom exploits that are able to
    avoid antivirus software. We have also studied how to develop a custom Linux-based
    key logger that sends keystrokes across the network to the remote attacker. We
    also explored various concepts to do with parsing Nessus and Nmap reports. We
    came to understand how to extract browser passwords with Python utilities and
    how to go about parsing Twitter feeds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了开发能够规避杀毒软件的自定义利用程序。我们还学习了如何开发一个能够将按键记录发送到远程攻击者的自定义基于Linux的键盘记录器。我们还探讨了与解析Nessus和Nmap报告有关的各种概念。我们了解了如何使用Python工具提取浏览器密码，以及如何解析Twitter信息。
- en: This chapter marks the conclusion of this book. I would recommend you explore
    more about Python and apply it more often in offensive security. A good place
    to start would be to take all the examples, use cases, and exploits discussed
    in this book and to make them as general as possible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章标志着本书的结束。我建议您更多地了解Python，并在攻击性安全方面更经常地应用它。一个很好的开始是将本书中讨论的所有示例、用例和利用程序尽可能地泛化。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can we send the keylogger strokes through email?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能通过电子邮件发送键盘记录吗？
- en: How can we improve the keylogger code?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何改进键盘记录代码？
- en: How can we improve the persistent shell exploit code?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何改进持久性shell漏洞利用代码？
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Python keylogger: [https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python键盘记录器：[https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)
- en: Python exploit development assistance: [https://github.com/longld/peda](https://github.com/longld/peda)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python漏洞开发辅助：[https://github.com/longld/peda](https://github.com/longld/peda)
- en: 'Veil: [https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面纱：[https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)
