- en: Scanning Pentesting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描渗透测试
- en: Network scanning refers to a set of procedures that investigate a live host,
    the type of host, open ports, and the type of services running on the host. Network
    scanning is a part of intelligence gathering by virtue of which an attacker can
    create a profile of the target organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络扫描是指一组程序，用于调查活动主机、主机类型、开放端口和主机上运行的服务类型。网络扫描是情报收集的一部分，攻击者可以通过它创建目标组织的概况。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to check live systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检查活动系统
- en: Ping sweep
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ping扫描
- en: TCP scanner
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP扫描程序
- en: How to create an efficient IP scanner
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个高效的IP扫描程序
- en: Services running on the target machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在目标机器上的服务
- en: The concept of a port scanner
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口扫描的概念
- en: How to create an efficient port scanner
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个高效的端口扫描程序
- en: You should have a basic knowledge of the TCP/IP layer communication. Before
    proceeding further, the concept of the **protocol data unit** (**PDU**) should
    be clear.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对TCP/IP层通信有基本的了解。在进一步进行之前，应清楚**协议数据单元**（**PDU**）的概念。
- en: 'PDU is a unit of data specified in the protocol. It is the generic term for
    data at each layer:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PDU是协议中指定的数据单元。这是每一层的数据的通用术语：
- en: For the application layer, PDU indicates data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于应用层，PDU表示数据
- en: For the transport layer, PDU indicates a segment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于传输层，PDU表示一个段
- en: For the internet or the network layer, PDU indicates a packet
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于互联网或网络层，PDU表示一个数据包
- en: For the data link layer or network access layer, PDU indicates a frame
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据链路层或网络访问层，PDU表示帧
- en: For the physical layer, that is, physical transmission, PDU indicates bits
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于物理层，即物理传输，PDU表示位
- en: How to check live systems in a network and the concept of a live system
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何检查网络中的活动系统以及活动系统的概念
- en: 'A ping scan involves sending an **ICMP ECHO Request** to a host. If a host
    is live, it will return an **ICMP ECHO Reply**, as shown in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ping扫描涉及向主机发送**ICMP ECHO请求**。如果主机活动，它将返回**ICMP ECHO回复**，如下图所示：
- en: '![](img/1d0e92cb-1eae-4d31-bf75-948ace2b3865.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d0e92cb-1eae-4d31-bf75-948ace2b3865.png)'
- en: ICMP request and reply
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP请求和回复
- en: The operating system's `ping` command provides the facility to check whether
    the host is live or not. Consider a situation where you have to test a full list
    of IP addresses. In this situation, if you test the IP addresses one by one, it
    will take a lot of time and effort. In order to handle this situation, we use
    ping sweep.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的“ping”命令提供了检查主机是否活动的功能。考虑一种情况，您必须测试完整的IP地址列表。在这种情况下，如果您逐个测试IP地址，将需要大量的时间和精力。为了处理这种情况，我们使用ping扫描。
- en: Ping sweep
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ping扫描
- en: Ping sweep is used to identify the live host from a range of IP addresses by
    sending the ICMP ECHO request and the ICMP ECHO reply. From a subnet and network
    address, an attacker or pentester can calculate the network range. In this section,
    I am going to demonstrate how to take advantage of the ping facility of an operating
    system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ping扫描用于通过发送ICMP ECHO请求和ICMP ECHO回复从一系列IP地址中识别活动主机。从子网和网络地址，攻击者或渗透测试人员可以计算网络范围。在本节中，我将演示如何利用操作系统的ping功能。
- en: 'First, I shall write a simple and small piece of code, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将编写一个简单而小的代码片段，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `import os` imports the OS module so that we can run
    on the OS command. The next line, `os.popen('ping -n 1 10.0.0.1')`, which takes
    a DOS command, is passed in as a string and returns a file-like object connected
    to the command's standard input or output streams. The `ping –n 1 10.0.0.1` command
    is a Windows OS command that sends one ICMP ECHO request packet. By reading the
    `os.psopen()` function, you can intercept the command's output. The output is
    stored in the `response` variable. In the next line, the `readlines()` function
    is used to read the output of a file-like object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，“import os”导入OS模块，以便我们可以在OS命令上运行。下一行，“os.popen('ping -n 1 10.0.0.1')”，将DOS命令作为字符串传递，并返回与命令的标准输入或输出流连接的类似文件的对象。
    “ping -n 1 10.0.0.1”命令是Windows OS命令，发送一个ICMP ECHO请求数据包。通过阅读“os.psopen（）”函数，您可以拦截命令的输出。输出存储在“response”变量中。在下一行中，使用“readlines（）”函数来读取类似文件对象的输出。
- en: 'The output of the program is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output shows the `reply`, `byte`, `time`, and `TTL` values, which indicate
    that the host is live. Consider another output of the program for IP `10.0.0.2`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示“回复”，“字节”，“时间”和“TTL”值，表示主机是活动的。考虑程序对IP“10.0.0.2”的另一个输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding output shows that the host is not live.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示主机未活动。
- en: The preceding code is very important for proper functioning and is similar to
    the engine of a car. In order to make it fully functional, we need to modify the
    code so that it is platform-independent and produces easily readable output.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码对于正确的功能非常重要，类似于汽车的引擎。为了使其完全功能，我们需要修改代码，使其与平台无关，并产生易于阅读的输出。
- en: 'I want my code to work for a range of IP addresses:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我的代码适用于一系列IP地址：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code asks for the network address of the subnet, but you can give
    any IP address of the subnet. The next line, `net1= net.split('.')`, splits the
    IP address into four parts. The `net2 = net1[0]+a+net1[1]+a+net1[2]+a` statement
    forms the network address. The last two lines ask for a range of IP addresses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码要求子网的网络地址，但您可以提供子网的任何IP地址。下一行，“net1= net.split('.')”，将IP地址分成四部分。“net2 =
    net1[0]+a+net1[1]+a+net1[2]+a”语句形成网络地址。最后两行要求一系列IP地址。
- en: 'To make it platform-independent, use the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其与平台无关，请使用以下代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code determines whether the code is running on Windows OS or the
    Linux platform. The `oper = platform.system()` statement informs this to the running
    operating system as the `ping` command is different in Windows and Linux. Windows
    OS uses `ping –n 1` to send one packet of the ICMP ECHO request, whereas Linux
    uses `ping –c 1`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码确定了代码是在Windows操作系统上运行还是在Linux平台上。`oper = platform.system()`语句将此通知给正在运行的操作系统，因为Windows和Linux中的`ping`命令不同。Windows操作系统使用`ping
    -n 1`发送一个ICMP ECHO请求数据包，而Linux使用`ping -c 1`。
- en: 'Now, let''s see the full code as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看完整的代码如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A couple of new things are in the preceding code. The `for ip in xrange(st1,en1):`
    statement supplies the numeric values, that is, the last octet value of the IP
    address. Within the `for` loop, the `addr = net2+str(ip)` statement makes it one
    complete IP address, and the `comm = ping1+addr` statement makes it a full OS
    command, which passes to `os.popen(comm)`. The `if(line.count("TTL")):` statement
    checks for the occurrence of `TTL` in the line. If any `TTL` value is found in
    the line, then it breaks the further processing of the line by using the `break`
    statement. The next two lines of code print the IP address as live where `TTL`
    is found. I used `datetime.now()` to calculate the total time taken to scan.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有一些新的东西。`for ip in xrange(st1,en1):`语句提供数字值，即IP地址的最后一个八位值。在`for`循环内，`addr
    = net2+str(ip)`语句使其成为一个完整的IP地址，`comm = ping1+addr`语句使其成为一个完整的操作系统命令，传递给`os.popen(comm)`。`if(line.count("TTL")):`语句检查行中是否出现`TTL`。如果在行中找到任何`TTL`值，则使用`break`语句中断行的进一步处理。代码的下两行打印出找到`TTL`的IP地址。我使用`datetime.now()`来计算扫描所花费的总时间。
- en: 'The output of the `ping_sweep.py` program is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping_sweep.py`程序的输出如下：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To scan 60 IP addresses, the program took 2 minutes 35 seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描60个IP地址，程序花费了2分钟35秒。
- en: The TCP scan concept and its implementation using a Python script
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP扫描概念及其使用Python脚本的实现
- en: 'Ping sweep works on the ICMP ECHO request and the ICMP ECHO reply. Many users
    turn off their ICMP ECHO reply feature or use a firewall to block ICMP packets.
    In this situation, your ping sweep scanner might not work. In this case, you need
    a TCP scan. I hope you are familiar with the three-way handshake, as shown in
    the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ping扫描基于ICMP ECHO请求和ICMP ECHO回复。许多用户关闭了ICMP ECHO回复功能或使用防火墙阻止ICMP数据包。在这种情况下，您的ping扫描器可能无法工作。在这种情况下，您需要进行TCP扫描。我希望您熟悉三次握手，如下图所示：
- en: '![](img/5142a124-0157-4391-b994-3b2bbf01b9ac.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5142a124-0157-4391-b994-3b2bbf01b9ac.png)'
- en: 'To establish the connection, the hosts perform a three-way handshake. The three
    steps in establishing a TCP connection are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，主机执行三次握手。建立TCP连接的三个步骤如下：
- en: The client sends a segment with the **SYN** flag; this means the client requests
    the server to start a session
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送了一个带有**SYN**标志的段; 这意味着客户端请求服务器开始一个会话
- en: In the form of a reply, the server sends the segment that contains the **ACK**
    and **SYN** flags
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器以包含**ACK**和**SYN**标志的段的形式发送回复
- en: The client responds with an **ACK** flag
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端以**ACK**标志响应
- en: 'Now, let''s see the following code for a TCP scan:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下TCP扫描的代码：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The upper part of the preceding code is the same as in the previous code. Here,
    we use two functions. Firstly, the `scan(addr)` function uses the socket as discussed
    in [Chapter 1](12d92e92-a5b2-459c-99d5-51cfe6741888.xhtml), *Python with Penetration
    Testing and Networking*. The `result = sock.connect_ex((addr,135))` statement
    returns an error indicator. The error indicator is `0` if the operation succeeds,
    otherwise it is the value of the `errno` variable. Here, we used port `135`; this
    scanner works for the Windows system. There are some ports such as `137`, `138`,
    `139` (NetBIOS name service), and `445` (Microsoft-DSActive Directory) that are
    usually open. So, for better results, you have to change the port and scan repeatedly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的上半部分与先前的代码相同。在这里，我们使用了两个函数。首先，`scan(addr)`函数使用套接字，如[第1章](12d92e92-a5b2-459c-99d5-51cfe6741888.xhtml)中所讨论的，*Python与渗透测试和网络*。`result
    = sock.connect_ex((addr,135))`语句返回一个错误指示器。如果操作成功，则错误指示器为`0`，否则为`errno`变量的值。在这里，我们使用端口`135`；这个扫描器适用于Windows系统。有一些端口，如`137`，`138`，`139`（NetBIOS名称服务）和`445`（Microsoft-DSActive
    Directory）通常是开放的。因此，为了获得更好的结果，您必须更改端口并重复扫描。
- en: 'The output of the `iptcpscan.py` program is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`iptcpscan.py`程序的输出如下：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s change the port number. Use `137`, and you will see the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改端口号。使用`137`，您将看到以下输出：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There will be no outcome from that port number. Change the port number again.
    Use `445`, and the output will be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该端口号将没有任何结果。再次更改端口号。使用`445`，输出将如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding three outputs show that `10.0.0.5`, `10.0.0.8`, `10.0.0.11`, `10.0.0.12`,
    `10.0.0.13`, and `10.0.0.15` are live. These IP addresses are running on the Windows
    OS. This is an exercise for you to check the common open ports for Linux and make
    IP a complete IP TCP scanner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面三个输出显示`10.0.0.5`，`10.0.0.8`，`10.0.0.11`，`10.0.0.12`，`10.0.0.13`和`10.0.0.15`是活动的。这些IP地址正在运行Windows操作系统。这是一个让您检查Linux的常见开放端口并使IP成为完整IP
    TCP扫描器的练习。
- en: How to create an efficient IP scanner in Windows
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Windows中创建一个高效的IP扫描器
- en: So far, you have seen the ping sweep scanner and the IP TCP scanner. Imagine
    that you buy a car that has all of the necessary facilities, but its speed is
    very slow; you feel that it is a waste of time and money. The same thing happens
    when the execution of our program is very slow. To scan 60 hosts, the `ping_sweep.py`
    program took 2 minutes 35 seconds for the same range of IP addresses for which
    the TCP scanner took nearly one minute. This took a lot of time to produce the
    results. But don't worry. Python offers you multithreading, which will make your
    program faster.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了ping扫描仪和IP TCP扫描仪。想象一下，您购买了一辆拥有所有必要设施的汽车，但速度非常慢；您觉得这是浪费时间和金钱。当我们的程序执行非常缓慢时，情况也是如此。对于`ping_sweep.py`程序扫描60个主机，对于TCP扫描仪几乎花费了一分钟的相同IP地址范围，花费了2分钟35秒。这需要很长时间才能产生结果。但不用担心。Python为您提供了多线程，这将使您的程序更快。
- en: 'I have written a full program about ping sweep with multithreading, and I will
    explain this to you in this section:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经写了一个关于多线程ping扫描的完整程序，并将在本节中向您解释：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `section 1` section is the same as that for the previous program. The one
    thing that has been added here is an ordered dictionary because it remembers the
    order in which its contents were added. If you want to know which thread gives
    the output first, then the ordered dictionary fits here. The `section 2` section
    contains the threading class, and the `class myThread (threading.Thread):` statement
    initializes the threading class. The `self.st = st` and `self.en = en` statements
    take the start and end range of the IP address. The `section 3` section contains
    the definition of the `run1` function, which is the engine of the car and is called
    by every thread with a different IP address range. The `dic[ip]= addr` statement
    stores the host ID as a key and the IP address as a value in the ordered dictionary.
    The `section 4` statement is totally new in this code; the `total_ip` variable
    is the total number of IP addresses to be scanned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “第1节”部分与上一个程序相同。这里添加的一件事是有序字典，因为它记住了其内容添加的顺序。如果想知道哪个线程首先输出，那么有序字典适合这里。 “第2节”部分包含线程类，`class
    myThread (threading.Thread):`语句初始化线程类。`self.st = st`和`self.en = en`语句获取IP地址的起始和结束范围。
    “第3节”部分包含`run1`函数的定义，它是汽车的引擎，并由每个具有不同IP地址范围的线程调用。`dic[ip]= addr`语句将主机ID存储为有序字典中的键，并将IP地址存储为值。
    “第4节”语句在此代码中是全新的；`total_ip`变量是要扫描的IP地址总数。
- en: 'The significance of the `tn =20` variable is that it states that 20 IP addresses
    will be scanned by one thread. The `total_thread` variable contains the total
    number of threads that need to scan `total_ip`, which denotes the number of IP
    addresses. The `threads= []` statement creates an empty list, which will store
    the threads. The `for` loop, `for i in xrange(total_thread):`, produces threads:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`tn =20`变量的重要性在于它表示一个线程将扫描20个IP地址。`total_thread`变量包含需要扫描`total_ip`的总线程数，它表示IP地址的数量。`threads=
    []`语句创建一个将存储线程的空列表。`for`循环，`for i in xrange(total_thread):`，产生线程：'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code produces the range of 20-20 IP addresses, such as `st1-20,
    20-40 ......-en1`. The `thread = myThread(st1,en)` statement is the thread object
    of the threading class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了20-20个IP地址的范围，例如`st1-20, 20-40 ......-en1`。`thread = myThread(st1,en)`语句是线程类的线程对象：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code terminates all the threads. The next line, `dict = collections.OrderedDict(sorted(dic.items()))`,
    creates a new sorted dictionary, `dict`, which contains IP addresses in order.
    The next lines print the live IP in order. The `threading.activeCount()` statement
    shows how many threads are produced. One picture says 1,000 words. The following
    diagram does the same thing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码终止了所有线程。接下来的一行，`dict = collections.OrderedDict(sorted(dic.items()))`，创建了一个新的排序字典`dict`，其中按顺序包含IP地址。接下来的行按顺序打印活动IP。`threading.activeCount()`语句显示了产生了多少个线程。一图胜千言。以下图表也是如此：
- en: '![](img/245d5e07-b312-4e07-815f-226ba9ef1023.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/245d5e07-b312-4e07-815f-226ba9ef1023.png)
- en: Creating and handling of threads
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和处理线程
- en: 'The output of the `ping_sweep_th_.py` program is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping_sweep_th_.py`程序的输出如下：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The scan has been completed in one minute and 11 seconds. As an exercise, change
    the value of the `tn` variable, set it from `2` to `30`, and then study the result
    and find out the most suitable and optimal value of `tn`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描已在一分11秒内完成。作为练习，更改“tn”变量的值，将其从“2”设置为“30”，然后研究结果并找出“tn”的最合适和最佳值。
- en: 'So far, you have seen ping sweep by multithreading; now, I have written a multithreading
    program with the TCP scan method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了多线程的ping扫描；现在，我编写了一个使用TCP扫描方法的多线程程序：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There should be no difficulty in understanding the program. The following diagram
    shows everything:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 理解该程序不应该有困难。以下图表显示了所有内容：
- en: '![](img/e11fcf5c-49fc-400b-88d8-956710f96afb.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e11fcf5c-49fc-400b-88d8-956710f96afb.png)
- en: The IP TCP scanner
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IP TCP扫描仪
- en: The class takes a range as the input and calls the `run1()` function. The `section
    4` section creates a thread, which is the instance of a class, takes a short range,
    and calls the `run1()` function. The `run1()` function has an IP address, takes
    the range from the threads, and produces the output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该类以范围作为输入并调用`run1()`函数。 “第4节”部分创建一个线程，它是类的实例，获取一个短范围，并调用`run1()`函数。`run1()`函数具有一个IP地址，获取来自线程的范围，并生成输出。
- en: 'The output of the `iptcpscan.py` program is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`iptcpscan.py`程序的输出如下：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 60 IP addresses in 20 seconds; the performance is not bad. As an exercise, combine
    both of the scanners into one scanner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 20秒内扫描60个IP地址；性能还不错。作为练习，将两个扫描仪合并成一个扫描仪。
- en: How to create an efficient IP scanner in Linux
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Linux中创建高效的IP扫描仪
- en: The previous IP scanner can work on both Windows and Linux. Now, I am going
    explain an IP scanner that is super fast but will work only on Linux machines.
    In the preceding code, we used the ping utility, but now we shall use our own
    ping packet to ping.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的IP扫描器可以在Windows和Linux上运行。现在，我要解释一个超级快的IP扫描器，但它只能在Linux机器上运行。在前面的代码中，我们使用了ping实用程序，但现在我们将使用我们自己的ping数据包来进行ping。
- en: The concept of the Linux-based IP scanner
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Linux的IP扫描器的概念
- en: 'The concept behind the IP scanner is very simple. We will produce several threads
    to send ping packets to different IP addresses. One daemon thread would be responsible
    for capturing the response of those ping packets. In order to run the IP scanner,
    you need to install the ping module. You can download the `.zip` file of the ping
    module from here: [https://pypi.python.org/pypi/ping](https://pypi.python.org/pypi/ping).
    Just unzip or untar it, browse the folder, and run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: IP扫描器背后的概念非常简单。我们将产生多个线程，向不同的IP地址发送ping数据包。一个守护线程将负责捕获这些ping数据包的响应。要运行IP扫描器，您需要安装ping模块。您可以从这里下载ping模块的`.zip`文件：[https://pypi.python.org/pypi/ping](https://pypi.python.org/pypi/ping)。只需解压缩或解压tar，浏览文件夹，并运行以下命令：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you don't want to install the module, then just copy the `ping.py` file from
    the unzipped folder and paste it into the folder from which you are going to run
    the IP scannercode.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装模块，那么只需从解压后的文件夹中复制`ping.py`文件，并将其粘贴到您将要运行IP扫描器代码的文件夹中。
- en: 'Let''s see the code, for `ping_sweep_send_rec.py`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ping_sweep_send_rec.py`的代码：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the IP calculation and thread creation parts are very
    much similar to previous code blocks we have seen. The `send_ping` function is
    called by threads to send ping packets with the help of the ping module. In the
    syntax `ping.do_one(ip,1,32)`, the second and third arguments signify the timeout
    and packet size respectively. Therefore, I set `1` as timeout and `32` as the
    ping packet size. The code inside `icmp_sniff` might be new to you. You will learn
    the full details of all of the syntax in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*. In a nutshell, the `icmp_sniff` function is
    capturing the sender's IP address from the incoming ICMP reply packets. As we
    already know,the ICMP reply packet's code is `0`. The syntaxes `if(ip_hdr[2]==1)`
    and `(icmp_hdr[0]==0)` mean that we only want ICMP and ICMP reply packets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，IP计算和线程创建部分与我们之前看到的代码块非常相似。`send_ping`函数由线程调用，以便使用ping模块发送ping数据包。在语法`ping.do_one(ip,1,32)`中，第二个和第三个参数分别表示超时和数据包大小。因此，我将`1`设置为超时，`32`设置为ping数据包大小。`icmp_sniff`中的代码可能对您来说是新的。您将在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)中学习所有语法的详细信息，即*嗅探和渗透测试*。简而言之，`icmp_sniff`函数正在从传入的ICMP回复数据包中捕获发送者的IP地址。正如我们已经知道的那样，ICMP回复数据包的代码是`0`。语法`if(ip_hdr[2]==1)`和`(icmp_hdr[0]==0)`表示我们只想要ICMP和ICMP回复数据包。
- en: 'Let''s run the code and see the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码并查看输出：
- en: '![](img/193489c2-4647-48e1-9405-0d61e37d3c6a.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193489c2-4647-48e1-9405-0d61e37d3c6a.jpg)'
- en: The preceding output shows that the program only takes around 11 seconds to
    perform scanning on 254 hosts. In the preceding code, we set 10 IP addresses per
    thread. You can change the IP addresses per thread. Play with different values
    and optimize the value of each IP per thread.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，程序只需要大约11秒就可以对254个主机进行扫描。在前面的代码中，我们设置了每个线程10个IP地址。您可以更改每个线程的IP地址。尝试不同的值并优化每个线程的IP值。
- en: nmap with Python
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的nmap
- en: 'This section is dedicated to the nmap lovers. You can use `nmap` in Python.
    You just need to install the `python-nmap` module and `nmap`. The command to install
    them is very simple. By using pip, we can install `python-nmap`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分专门为nmap爱好者准备。您可以在Python中使用`nmap`。您只需要安装`python-nmap`模块和`nmap`。安装它们的命令非常简单。通过使用pip，我们可以安装`python-nmap`：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After installing the `python-nmap` module, you can check the `nmap` module
    by importing it. If there is no error while importing, then it means that it was
    successfully installed. Let''s check what is inside in `nmap`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`python-nmap`模块后，您可以通过导入来检查`nmap`模块。如果导入时没有错误，那么这意味着它已成功安装。让我们看看`nmap`里面有什么：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will use the `PortScanner` class for this. Let''s see the code and then
    run it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`PortScanner`类来实现这一点。让我们看看代码，然后运行它：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is very simple: just make an object of `nm=nmap.PortScanner()`.
    When you call the `nm.scan(host, arguments="-O")` method, you will get a very
    complex dictionary. The following output is part of the dictionary:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单：只需创建一个`nm=nmap.PortScanner()`对象。当您调用`nm.scan(host, arguments="-O")`方法时，您将获得一个非常复杂的字典。以下输出是字典的一部分：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the preceding code, it is very easy to obtain the information you need;
    basic Python knowledge is required though. Let''s run the code on four different
    operating systems. First, I ran the code on Redhat Linux 5.3 and Debian 7\. You
    can see this in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，很容易获得所需的信息；但需要基本的Python知识。让我们在四种不同的操作系统上运行代码。首先，我在Redhat Linux 5.3和Debian
    7上运行了代码。您可以在以下输出中看到：
- en: '![](img/cec170e7-9c22-4116-9344-6e94dd715f59.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cec170e7-9c22-4116-9344-6e94dd715f59.png)'
- en: From the preceding output, you can see that `nmap` successfully finds the open
    TCP ports and required OS details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到`nmap`成功找到了开放的TCP端口和所需的操作系统详细信息。
- en: 'Let''s run `nmap` on Windows OS:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Windows操作系统上运行`nmap`：
- en: '![](img/78ab4f7b-e470-44fa-a884-32d03897291f.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78ab4f7b-e470-44fa-a884-32d03897291f.jpg)'
- en: In the preceding output, `nmap` successfully find Windows XP and Windows 10\.
    There are lots of other features in `nmap` modules. You can explore these yourself
    and write the appropriate code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`nmap`成功找到了Windows XP和Windows 10。`nmap`模块中还有许多其他功能。您可以自行探索这些功能并编写适当的代码。
- en: What are the services running on the target machine?
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标机器上运行哪些服务？
- en: Now, you are familiar with how to scan IP addresses and identify a live host
    within a subnet. In this section, we will discuss the services that are running
    on a host. These services are the ones that are using a network connection. A
    service using a network connection must open a port; from a port number, we can
    identify which service is running on the target machine. In pentesting, the significance
    of port scanning is to check whether an illegitimate service is running on the
    host machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经熟悉了如何扫描IP地址并在子网中识别活动主机。在本节中，我们将讨论运行在主机上的服务。这些服务是使用网络连接的服务。使用网络连接的服务必须打开一个端口；从端口号，我们可以识别在目标机器上运行的服务。在渗透测试中，端口扫描的重要性在于检查主机上是否运行了非法服务。
- en: Consider a situation where users normally use their computer to download a game,
    and a Trojan is identified during the installation of the game. The Trojan goes
    into hidden mode; opens a port; sends all the keystrokes, including log information,
    to the hacker. In this situation, port scanning helps to identify the unknown
    services that are running on the victim's computer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，用户通常使用他们的计算机下载游戏，在游戏安装过程中发现了特洛伊木马。特洛伊木马进入隐藏模式；打开一个端口；将所有按键，包括日志信息，发送给黑客。在这种情况下，端口扫描有助于识别在受害者计算机上运行的未知服务。
- en: Port numbers range from `0` to `65535`. The well-known ports (also known as
    system ports) are those that range from `0` to `1023` and are reserved for privileged
    services. Ports that range from `1024` to `49151` are registered port-like vendors
    used for applications; for example, port `3306` is reserved for MySQL.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号范围从`0`到`65535`。众所周知的端口（也称为系统端口）是从`0`到`1023`的端口，保留用于特权服务。从`1024`到`49151`的端口是用于应用程序的注册端口，例如，端口`3306`保留用于MySQL。
- en: The concept of a port scanner
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口扫描器的概念
- en: TCP's three-way handshake serves as logic for the port scanner; in the TCP/IP
    scanner, you have seen that the port (`137` or `135`) is one in which IP addresses
    are in a range. However, in the port scanner, the IP is only one port in a range.
    Take one IP and try to connect each port as a range given by the user. If the
    connection is successful, the port opens; otherwise, the port remains closed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的三次握手作为端口扫描器的逻辑；在TCP/IP扫描器中，您已经看到端口（`137`或`135`）是IP地址范围中的一个。但是，在端口扫描器中，IP只是一个范围内的一个端口。取一个IP并尝试连接用户给定的范围内的每个端口。如果连接成功，端口打开；否则，端口保持关闭。
- en: 'I have written some very simple code for port scanning:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为端口扫描编写了一些非常简单的代码：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main logic has been written in the `try` block, which denotes the engine
    of the car. You are familiar with the syntax. Let's do an R&D on the output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主要逻辑已经写在`try`块中，表示汽车的引擎。您熟悉语法。让我们对输出进行研究和开发。
- en: 'The output of the `portsc.py` program is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`portsc.py`程序的输出如下：'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding output shows that the port scanner scanned 1,000 ports in `0.7`
    seconds; the connectivity was full because the target machine and the scanner
    machine were on the same subnet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，端口扫描器在`0.7`秒内扫描了1,000个端口；连接是完整的，因为目标机器和扫描器机器在同一个子网上。
- en: 'Let''s discuss another output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论另一个输出：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s analyze the output: to scan 4,000 ports, the scanner took `1:06:43.272751`
    hours. This took a long time. The topology is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析一下输出：扫描4,000个端口，扫描器花费了`1:06:43.272751`小时。这花了很长时间。拓扑结构是：
- en: '`192.168.0.10 --> 192.168.0.1 --> 10.0.0.16 ---> 10.0.0.1`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.10 --> 192.168.0.1 --> 10.0.0.16 ---> 10.0.0.1`'
- en: The `192.168.0.1` and `10.0.0.16` IP addresses are gateway interfaces. We put
    one second in `socket.setdefaulttimeout(1)`, which means the scanner machine will
    spend a maximum of one second on each port. The total of 4,000 ports means that
    if all ports are closed, then the total time taken will be 4000 seconds; if we
    convert it into hours, it will become 1.07 hours, which is nearly equal to the
    output of our program. If we set `socket.setdefaulttimeout(.5)`, the time taken
    will be reduced to 30 minutes, which is still a long time. Nobody will use our
    scanner. The time taken should be less than 100 seconds for 4,000 ports.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.1`和`10.0.0.16` IP地址是网关接口。我们在`socket.setdefaulttimeout(1)`中设置了一秒，这意味着扫描机器将在每个端口上最多花费一秒。总共有4,000个端口，这意味着如果所有端口都关闭，那么总共花费的时间将是4000秒；如果我们将其转换成小时，将变成1.07小时，几乎等于我们程序的输出。如果我们设置`socket.setdefaulttimeout(.5)`，所需时间将减少到30分钟，这仍然是很长的时间。没有人会使用我们的扫描器。所需时间应该少于100秒扫描4,000个端口。'
- en: How to create an efficient port scanner
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建一个高效的端口扫描器
- en: 'I have stated some points that should be taken into account for a good port
    scanner:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提出了一些应该考虑的要点，以便获得一个良好的端口扫描器：
- en: Multithreading should be used for high performance
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用多线程以获得高性能
- en: The `socket.setdefaulttimeout(1)` method should be set according to the situation
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.setdefaulttimeout(1)` 方法应根据情况设置'
- en: The port scanner should have the ability to take host names as well as domain
    names
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口扫描器应该能够接受主机名和域名
- en: The port should provide the service name with the port number
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口应该提供端口号和服务名称
- en: The total time should be taken into account for port scanning
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该考虑端口扫描的总时间
- en: To scan ports `0` to `65535`, the time taken should be around 3 minutes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要扫描端口`0`到`65535`，所需时间大约为3分钟
- en: 'So now I have written my port scanner, which I usually use for port scanning:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我已经编写了我的端口扫描器，我通常用于端口扫描：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Don't be afraid to see the full code; it took me 2 weeks. I will explain to
    you the full code section-wise. In `section1`, the first two lines are related
    to the database file that stores the port information, which will be explained
    while creating the database file. The `scantcp()` function gets executed by threads.
    In `section 2`, this is for user inputs. If a user provides a port range beyond `65535`,
    then the code automatically takes care of the error. Low connectivity and high
    connectivity means that if you are using the internet, use low connectivity. If
    you are using the code on your own network, you can use high connectivity. In
    `section 3`, thread creation logic is written. The `30` ports would be handled
    by one thread, but if the number of threads exceeds `300`, then the ports per
    thread equation would be recalculated. In a `for` loop, threads get created, and
    each thread carries its own range of ports. In `section 4`, the thread gets terminated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕看到完整的代码；我花了2周的时间。我将逐节向你解释完整的代码。在`section1`中，前两行与存储端口信息的数据库文件有关，这将在创建数据库文件时进行解释。`scantcp()`函数由线程执行。在`section
    2`中，这是用于用户输入的。如果用户提供的端口范围超过`65535`，那么代码会自动处理错误。低连通性和高连通性意味着如果你在使用互联网，使用低连通性。如果你在自己的网络上使用代码，你可以使用高连通性。在`section
    3`中，写入了线程创建逻辑。`30`个端口将由一个线程处理，但如果线程数超过`300`，则端口每个线程的方程将被重新计算。在`for`循环中，线程被创建，每个线程携带自己的端口范围。在`section
    4`中，线程被终止。
- en: I wrote the preceding code after performing lots of experiments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在进行了大量实验后编写了上述代码。
- en: 'Now, it''s time to see the output of the `portsc15.py` program:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看`portsc15.py`程序的输出了：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our efficient port scanner has given the same output as the previous simple
    scanner, but from a performance point of view, there is a huge difference. The
    time taken by a simple scanner was `1:06:43.272751`, but the new multithreaded
    scanner took just 32 seconds. It also shows the service name. Let''s check more
    output with ports `1` to `50000`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们高效的端口扫描器给出了与之前简单扫描器相同的输出，但从性能的角度来看，有很大的差异。简单扫描器所花费的时间是`1:06:43.272751`，但新的多线程扫描器只花了32秒。它还显示了服务名称。让我们检查一下端口`1`到`50000`的更多输出：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The time taken was 2 minutes 48 seconds; I did the same experiment in high connectivity,
    where the time taken was `0:01:23.819774`, which is almost half the previous one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所花费的时间是2分钟48秒；我在高连通性下做了相同的实验，所花费的时间是`0:01:23.819774`，几乎是前一个的一半。
- en: Now, I'm going to teach you how to create a database file that contains the
    description of all the port numbers; let's understand how to create a pickle database
    file that contains the description of all of the ports. Open the following link: [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将教你如何创建一个包含所有端口号描述的数据库文件；让我们了解如何创建一个包含所有端口描述的pickle数据库文件。打开以下链接：[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)。
- en: 'Copy the port description part and save it in a text file. See the following
    screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 复制端口描述部分并将其保存在一个文本文件中。请参阅以下截图：
- en: '![](img/5d3a2287-362e-41db-b1c5-954311e314f1.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d3a2287-362e-41db-b1c5-954311e314f1.png)'
- en: 'Let''s see the code for `creatdicnew.py` to convert the preceding file into
    a `pickle` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`creatdicnew.py`的代码，将前面的文件转换成一个`pickle`文件：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you run the preceding code, the code will ask you to enter the text filename.
    After giving the filename, the code will convert the text file into a pickle file
    named `port_description.dat`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行上述代码时，代码会要求你输入文本文件名。在给出文件名后，代码将把文本文件转换成一个名为`port_description.dat`的pickle文件。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Network scanning is done to gather information on the networks, hosts, and services
    that are running on the hosts. Network scanning is done by using the `ping` command
    of the OS; ping sweep takes advantage of the ping facility and scans the list
    of IP addresses. Sometimes, ping sweep does not work because users might turn
    off their ICMP ECHO reply feature or use a firewall to block ICMP packets. In
    this situation, your ping sweep scanner might not work. In such scenarios, we
    have to take advantage of the TCP three-way handshake; TCP works at the transport
    layer, so we have to choose the port number on which we want to carry out the
    TCP connect scan. Some ports of the Windows OS are always open, so you can take
    advantage of those open ports. The first main section is dedicated to network
    scanning; when you perform network scanning, your program should have maximum
    performance and take minimum time. In order to increase performance significantly,
    multithreading should be used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 网络扫描是为了收集关于网络、主机和正在运行的服务的信息。网络扫描是通过使用操作系统的`ping`命令来完成的；ping扫描利用了ping功能并扫描IP地址列表。有时，ping扫描不起作用，因为用户可能关闭了他们的ICMP
    ECHO回复功能或使用防火墙来阻止ICMP数据包。在这种情况下，你的ping扫描器可能无法工作。在这种情况下，我们必须利用TCP三次握手；TCP工作在传输层，所以我们必须选择我们想要进行TCP连接扫描的端口号。Windows操作系统的一些端口是始终开放的，所以你可以利用这些开放的端口。第一个主要部分是专门用于网络扫描；当你进行网络扫描时，你的程序应该具有最大的性能并且需要最少的时间。为了显著提高性能，应该使用多线程。
- en: After the scanning of live hosts, port scanning is used to check the services
    running on a particular host; sometimes, some programs use an internet connection
    which allows Trojans and port scanning can detect these types of threats. To make
    an efficient port scan, multithreading plays a vital role because port numbers
    range from `0` to `65536`. To scan a huge list, multithreading must be used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描活动主机之后，端口扫描用于检查特定主机上运行的服务；有时，一些程序使用允许特洛伊木马和端口扫描可以检测这些类型威胁的互联网连接。为了进行高效的端口扫描，多线程起着至关重要的作用，因为端口号范围从`0`到`65536`。要扫描一个庞大的列表，必须使用多线程。
- en: 'In the next chapter, you will see sniffing and its two types: passive and active
    sniffing. You will also learn how to capture data, the concept of packet crafting,
    and the use of the Scapy library to make custom packets.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到嗅探及其两种类型：被动嗅探和主动嗅探。您还将学习如何捕获数据，数据包构建的概念，以及使用Scapy库制作自定义数据包。
