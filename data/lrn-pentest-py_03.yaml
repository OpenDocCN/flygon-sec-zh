- en: Chapter 3. Identifying Targets with Nmap, Scapy, and Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Nmap、Scapy和Python识别目标
- en: The identification of targets, network surveillance, and active reconnaissance
    are all terms that you may see in place of each other, in an effort to describe
    the initial process of assessing an environment. Depending on the framework you
    are using, such as PTES, a custom company methodology, or some other industry
    standard, these terms may mean different things. The important thing to remember
    is that you are looking to see which hosts are live in the approved scope and
    what services, ports, and features they have open and responsive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目标识别、网络监视和主动侦察都是您可能在评估环境的初始过程中看到的术语，它们可能互相替代，以描述这个过程。根据您使用的框架，如PTES、自定义公司方法或其他行业标准，这些术语可能有不同的含义。重要的是要记住，您要查看批准范围内哪些主机是活动的，以及它们开放和响应的服务、端口和功能。
- en: These facets will determine what activities you will perform going from here.
    All too often, this stage is short-lived, and assessors jump right into exploiting
    systems that they see responding to scans. Instead of being methodical and researching
    possible targets, new assessors jump in with both feet. This may have served them
    well in previous engagements where they got to the goal quickly, but there are
    other impacts of approaching assessments in this way that many assessors do not
    realize.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面将决定您将从这里开始执行的活动。往往，这个阶段很短暂，评估员们立即开始利用他们看到对扫描作出响应的系统。新的评估员们不是有条不紊地研究可能的目标，而是立即投入其中。这在以前的工作中可能对他们有所帮助，因为他们很快就达到了目标，但是以这种方式进行评估还有其他影响，许多评估员并没有意识到。
- en: They may miss even the lower hanging fruit—systems that are even easier to exploit.
    So if you, as an assessor, do not see this and a malicious actor may see it, then
    you may have an uncomfortable conversation with a client a few months down the
    road about why you missed this vulnerability. Keep in mind, however, that a penetration
    test is a snapshot in time, and environments are always changing. Controls and
    restrictions in the environment are adjusted, and systems are often reallocated.
    So, it is possible to have old vulnerabilities cropping up in new assessments.
    Being methodical means that you may be able to find more than one low-hanging
    target, which may help you build a rapport with your clients and in turn receive
    more work. Most importantly, it will point to the root causes of the flaws in
    the client's that will continue to generate control lapses if they are not fixed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可能会错过甚至更容易利用的系统。因此，如果您作为评估员没有看到这一点，而恶意行为者可能会看到，那么几个月后您可能会与客户进行一次令人不快的对话，讨论为什么您错过了这个漏洞。但请记住，渗透测试是时间的快照，环境总是在变化。环境中的控制和限制会调整，系统经常被重新分配。因此，在新的评估中可能会出现旧的漏洞。有条不紊意味着您可能会找到多个易于攻击的目标，这可能有助于您与客户建立良好的关系，并进而获得更多的工作。最重要的是，它将指出客户缺陷的根本原因，如果不加以修复，将继续产生控制失误。
- en: The biggest impact you will see from an assessor from someone jumping the gun,
    so to speak, is that they may start exploiting systems that have no significant
    purpose in the organization. This means that although they cracked a box, it did
    not provide any value from moving through the networks, or the vulnerability was
    not exploitable, and as such, it could be considered a false positive. So, all
    of those initial scans have to be restarted, losing precious time and increasing
    the chances that the objectives of the engagement will not be met. To understand
    how to scan the network, you have to first understand the network frames, packets,
    messages, and datagrams so that you can manipulate each of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 评估员的最大影响来自于某人过早行动，这意味着他们可能开始利用组织中没有重要目的的系统。这意味着尽管他们破解了一个盒子，但它并没有通过网络传输任何价值，或者漏洞是不可利用的，因此可以被视为虚假阳性。因此，所有这些初始扫描都必须重新启动，浪费宝贵的时间，并增加了达成目标的机会。要了解如何扫描网络，首先必须了解网络帧、数据包、消息和数据报，以便可以操纵它们。
- en: Understanding how systems communicate
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解系统如何通信
- en: There are entire series of books dedicated to how networks communicate; this
    chapter will begin with some very basic information. If you have already understood
    this data, I encourage you to read through it as a refresher, just in case some
    new or different details are covered. Additionally, there are some references
    to the sizes of header components and payloads. These are specifics on how the
    network protocols are referenced, and how the protocols could be different depending
    on what data is being transmitted and/or the differences in specialty networks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有整套书籍专门讨论网络通信；本章将从一些非常基本的信息开始。如果您已经了解了这些数据，我鼓励您阅读一遍，以便复习一下，以防涵盖了一些新的或不同的细节。此外，还有一些关于标头组件和有效载荷大小的参考。这些是关于网络协议如何引用的具体信息，以及根据传输的数据和/或专业网络的差异，协议可能会有所不同。
- en: As a system generates data, it is sent down through the system's **Transmission
    Control Protocol** (**TCP**) / **Internet Protocol** (**IP**) stack. This packages
    the data into something that can be transmitted over the wire. If you have heard
    of the **Open Systems Interconnect** (**OSI**) model, then you know that this
    is how people discuss how systems process data, whereas the TCP/IP Model is the
    way systems actually operate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统生成数据时，它通过系统的**传输控制协议**（**TCP**）/ **互联网协议**（**IP**）堆栈发送。这将数据打包成可以通过电线传输的形式。如果您听说过**开放系统互连**（**OSI**）模型，那么您就知道这是人们讨论系统如何处理数据的方式，而TCP/IP模型是系统实际操作的方式。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every system has a TCP/IP stack, which represents the implementation of the
    TCP/IP Model. It is important to understand that a socket is what communication
    is executed through. This is done by linking source and destination IP addresses,
    and source and destination ports.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有一个TCP/IP堆栈，代表了TCP/IP模型的实现。重要的是要理解套接字是通过什么进行通信的。这是通过链接源和目的IP地址以及源和目的端口来完成的。
- en: There is a range of ports called the **ephemeral port range**. It varies from
    system to system in scope. These ports are also known as dynamic ports and are
    used by clients as the source ports for communication over a socket. They can
    also be destination ports for well-known services on servers, provided the known
    port is designed for communication brokerage as against destination. Services
    such as **File Transfer Protocol** (**FTP**) use this technique. The reason you
    must know this is that these ephemeral ports typically do not need to be scanned
    while you are trying and identifying targets, because they are rarely service
    initiators. As such, they are short-lived and are associated for specific communication
    streams only.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列称为**临时端口范围**的端口。其范围因系统而异。这些端口也被称为动态端口，客户端用作套接字通信的源端口。它们也可以是服务器上已知服务的目的端口，前提是已知端口设计用于通信代理而不是目的地。诸如**文件传输协议**（**FTP**）之类的服务使用这种技术。您必须了解这一点，因为在尝试识别目标时，这些临时端口通常不需要被扫描，因为它们很少作为服务发起者。因此，它们是短暂的，并且仅与特定通信流相关联。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that administrators often hide known services in these higher port
    ranges to try and create situations wherein the services will not be identified.
    This is known as **security by obscurity**. When it comes to scanning many hosts,
    you may need to avoid scanning these ranges because you have to spend more time
    doing so. If you have not identified many services, or there are a few hosts in
    the target network, you may want to include these in your scan range.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，管理员经常将已知服务隐藏在这些较高的端口范围内，以尝试创造服务不被识别的情况。这被称为**安全性通过混淆**。在扫描许多主机时，您可能需要避免扫描这些范围，因为这样会花费更多时间。如果您没有识别出许多服务，或者目标网络中有一些主机，您可能希望将这些包括在您的扫描范围内。
- en: 'Layer 4 headers represent the TCP and **User Datagram Protocol** (**UDP**)
    headers and the targeting connection of ports for a specific IP. Layer 3 headers
    represent the IP and **Internet Control Message Protocol** (**ICMP**) headers.
    Layer 2 headers are related to frame headers, trailers, and the **Address Resolution
    Protocol** (**ARP**). The following diagram depicts the method of frame generation
    to communicate between two systems:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第4层标头代表TCP和**用户数据报协议**（**UDP**）标头以及特定IP的目标连接端口。第3层标头代表IP和**互联网控制消息协议**（**ICMP**）标头。第2层标头与帧标头、尾部和**地址解析协议**（**ARP**）有关。以下图表描述了帧生成的方法，用于两个系统之间的通信：
- en: '![Understanding how systems communicate](img/B04315_03_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![理解系统如何通信](img/B04315_03_1.jpg)'
- en: Now that you have seen how the frame is generated from the top down, let's move
    back up the stack to see how each component is deconstructed to get to the data.
    From there, you start with the Ethernet frame.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了帧是如何从上到下生成的，让我们回到堆栈的顶部，看看如何将每个组件解构以获取数据。从那里开始，您可以从以太网帧开始。
- en: The Ethernet frame architecture
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太网帧结构
- en: 'A frame is the way in which data travels from host to host, and there are a
    number of components that make up a frame. You can read a substantial amount of
    information related to frames, on wiki''s and engineering documents, but there
    are a couple of things you need to understand. Frames communicate via a hardware
    address known as a **Media Access Control** (**MAC**) address. Frames are slightly
    different for wireless networks and Ethernet networks. Also, at the end of a frame
    is a checksum. It is a basic mathematical check meant to verify the integrity
    of data after it has been transmitted over the wire. The following is an screenshot
    of an Ethernet frame with the end destination of a TCP port:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 帧是数据从主机到主机传输的方式，有许多组成帧的组件。您可以在维基百科和工程文件中阅读大量与帧相关的信息，但有一些事情您需要了解。帧通过硬件地址进行通信，这个地址被称为**媒体访问控制**（**MAC**）地址。无线网络和以太网网络的帧略有不同。此外，在帧的末尾是一个校验和。这是一个基本的数学检查，用于验证数据在传输过程中的完整性。以下是一个以太网帧的截图，目的地是TCP端口：
- en: '![The Ethernet frame architecture](img/B04315_03_2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![以太网帧结构](img/B04315_03_2.jpg)'
- en: 'The next screenshot represents the contents of a frame with the ending destination
    of a UDP port:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图代表了帧的内容，目的地是UDP端口：
- en: '![The Ethernet frame architecture](img/B04315_03_3.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![以太网帧结构](img/B04315_03_3.jpg)'
- en: Layer 2 in Ethernet networks
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太网网络中的第2层
- en: Frames are used to communicate within broadcast domains or locations inside
    default gateways, or prior to passing a router. Once a router is passed, the interface
    of its router's hardware address is used for the next broadcast domain. These
    are also typically sent in frames depending on the communication protocols between
    the devices. This is done over and over again until the frame reaches its destination
    delineated by the IP address. This is very important to understand because if
    you wish to run most **Man-in-the-Middle** (**MitM**) attacks with tools such
    as Responder or Ettercap, you have to be within the Broadcast Domain, as they
    are layer 2 attacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 帧用于在广播域或默认网关内部的位置进行通信，或者在通过路由器之前进行通信。一旦通过路由器，下一个广播域将使用路由器硬件地址的接口。根据设备之间的通信协议，这些通常也是以帧的形式发送的。这一过程一遍又一遍地进行，直到帧到达由IP地址标识的目的地。这非常重要，因为如果您希望使用Responder或Ettercap等工具运行大多数**中间人**（**MitM**）攻击，您必须在广播域内，因为它们是第2层攻击。
- en: Layer 2 in wireless networks
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无线网络中的第2层
- en: The concept of wireless attacks is very similar, as you must be within range
    of the **Service Set Identifier** (**SSID**) or the actual wireless network name.
    Your communication train is slightly different depending on the design of the
    wireless network, but you use **Access Points** (AP) that are differentiated by
    **Basic Service Set Identifiers** (**BSSIDs**), which is a fancy name for the
    MAC address of the AP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无线攻击的概念非常相似，因为你必须在**服务集标识符**（**SSID**）或实际无线网络名称的范围内。你的通信方式会略有不同，这取决于无线网络的设计，但你会使用**接入点**（AP），这些AP由**基本服务集标识符**（**BSSIDs**）区分，这是AP的MAC地址的一个花哨的名称。
- en: Once you are associated and authenticated into the network through the AP, you
    are part of the **Basic Service Set** (**BSS**) or the component of the enterprise
    network, but are limited to the range of the AP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过AP关联和认证进入网络，你就成为**基本服务集**（**BSS**）或企业网络的一部分，但受限于AP的范围。
- en: If you move into a wireless network and associate with a new AP because the
    signal is better, you will be part of a new BSS. All BSS are part of the **Enterprise
    Service Set** (**ESS**); interestingly enough, if the wireless network contains
    more than one AP, it is an ESS. To be able to communicate with wireless engineers,
    you must understand that if you are in an enterprise wireless network, the SSID
    is actually known as an **Enterprise SSID** (**ESSID**). Now that you have an
    understanding of layer 2 headers, it's time to look at IP headers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入一个无线网络并与一个新的AP关联，因为信号更好，你将成为一个新的BSS的一部分。所有BSS都是**企业服务集**（**ESS**）的一部分；有趣的是，如果无线网络包含多个AP，它就是一个ESS。要能够与无线工程师进行通信，你必须了解，如果你在企业无线网络中，SSID实际上被称为**企业SSID**（**ESSID**）。现在你已经了解了第2层头部，现在是时候看看IP头部了。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on whose network documentation you are reading, an ESS is created
    if there is a **Distribution System** (**DS**) and an AP, or two APs and a DS.
    A DS is just a fancy name for a nonwireless network that connects APs. This is
    important to keep in mind because depending on the brand of product a company
    is using, the lingo may be slightly different.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在阅读的网络文档，如果有一个**分布系统**（**DS**）和一个AP，或者两个AP和一个DS，就会创建一个ESS。DS只是一个连接AP的非无线网络的花哨名称。这很重要要记住，因为根据公司使用的产品品牌，术语可能略有不同。
- en: The IP packet architecture
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP数据包架构
- en: 'An IP header contains the data necessary for communicating through a network
    that uses IP addresses. This allows the communication to flow beyond Broadcast
    Domains. The following diagram shows an example header for IPv4 header:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IP头部包含了通过使用IP地址进行通信所需的数据。这允许通信在广播域之外流动。下图显示了IPv4头部的一个示例：
- en: '![The IP packet architecture](img/B04315_03_4.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据包架构](img/B04315_03_4.jpg)'
- en: You may have read that IPv4 is nearing its end, or that it is getting to be
    that way. Well, the replacement, as you may have heard, is IPv6\. This new address
    scheme provides a significant number of new host addresses, but as you can see
    in the comparison of the two header types, there are far less fields. One thing
    to know is that there are a large number of vulnerabilities associated with IPv6
    compared to IPv4.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经读到了IPv4即将结束，或者已经接近结束。嗯，你可能已经听说了，它的替代品是IPv6。这种新的地址方案提供了大量的新主机地址，但正如你在两种头部类型的比较中所看到的，字段要少得多。需要知道的一件事是，与IPv4相比，IPv6存在大量的漏洞。
- en: There are many reasons for this, but the most significant reason is that when
    organizations apply security concepts to their network, they forget that IPv6
    is supported by default and is turned on. This means that when they configure
    protection mechanisms, they are usually using the IPv4 address. If IPv6 is enabled
    and the security devices are not aware of the different address types in the network
    or the associations with those devices, attacks can go unnoticed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因，但最重要的原因是，当组织将安全概念应用到他们的网络时，他们忘记了IPv6默认是支持的并且已经打开。这意味着当他们配置保护机制时，他们通常使用IPv4地址。如果IPv6被启用，而安全设备不知道网络中不同地址类型或与这些设备的关联，攻击可能会被忽略。
- en: 'Think of it in this way: let''s say you have a house with a front door and
    a back door, and there is a security guard only at the front door. The house has
    the same physical address, but the manners in which you get inside are completely
    different because it has two different doors. This security concept is very similar,
    and as such, organizations should remember that IPv6 can open up new holes into
    an organization if it does not consider the impact carefully. The following diagram
    shows an example of an IPv6 packet structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：假设你有一所房子，有前门和后门，只有前门有保安。房子有相同的物理地址，但你进入的方式完全不同，因为它有两个不同的门。这个安全概念非常相似，因此组织应该记住，如果不仔细考虑影响，IPv6可能会给组织带来新的漏洞。下图显示了IPv6数据包结构的一个示例：
- en: '![The IP packet architecture](img/B04315_03_5.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据包架构](img/B04315_03_5.jpg)'
- en: The TCP header architecture
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP头部架构
- en: A TCP packet header is much larger than a UDP packet header, relatively speaking.
    It has to accommodate the necessary sequencing, flags, and control mechanisms.
    Specifically, the packet is there to handle session setup and teardown using a
    number of different flags. These flags can be manipulated to get responses from
    the target system as an attacker wants.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相对而言，TCP数据包头部比UDP数据包头部要大得多。它必须容纳必要的排序、标志和控制机制。具体来说，数据包用于使用多种不同的标志进行会话建立和拆除。这些标志可以被操纵，以便攻击者从目标系统获得响应。
- en: 'The following figure shows a TCP header:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个TCP头部：
- en: '![The TCP header architecture](img/B04315_03_6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![TCP头部架构](img/B04315_03_6.jpg)'
- en: Understanding how TCP works
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TCP的工作原理
- en: Before you understand how to execute scans and identify hosts, you need to understand
    how the TCP communication stream works. TCP is a connection-oriented protocol,
    which means that a session is established between two systems. Once this has taken
    place, the information that was originally destined for communication can be sent,
    and when all of the data has been sent, the connection is closed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何执行扫描和识别主机之前，您需要了解TCP通信流如何工作。TCP是一种面向连接的协议，这意味着两个系统之间建立了一个会话。一旦这个会话建立，最初用于通信的信息就可以发送，当所有数据都发送完毕后，连接就会关闭。
- en: The TCP three-way handshake
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP三次握手
- en: The TCP handshake is also known as the three-way handshake. The meaning of this
    is that three messages are sent back and forth between two systems before a communication
    socket is established. These three messages are SYN, SYN-ACK, and ACK. The system
    that is trying to initiate a connection starts with a packet that has the `SYN`
    flag set. The answering system returns a packet with the `SYN` and `ACK` flag
    sets. Finally, the initiating system returns a packet to the original target system
    with the `ACK` flag set. In older systems, if the communication train was not
    completed, there could be unintended consequences. Today, most systems are smart
    enough to just **reset** (**RST**) the connection or close it gracefully.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TCP握手也称为三次握手。这意味着在两个系统之间建立通信套接字之前，要在两个系统之间发送三条消息。这三条消息是SYN、SYN-ACK和ACK。试图建立连接的系统从设置了`SYN`标志的数据包开始。回答系统返回一个设置了`SYN`和`ACK`标志的数据包。最后，发起连接的系统向原始目标系统返回一个设置了`ACK`标志的数据包。在旧系统中，如果通信链路未完成，可能会产生意外后果。如今，大多数系统足够智能，只需**重置**（**RST**）连接或优雅地关闭连接。
- en: The UDP header architecture
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP标头结构
- en: Whereas TCP is a connection-oriented protocol, UDP is a simple connectionless-oriented
    protocol. As you can see in the following image, the header for UDP packets is
    significantly simpler. This is because there is far less overhead for UDP to maintain
    a socket as opposed to TCP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TCP是一种面向连接的协议，UDP是一种简单的无连接协议。正如您在下图中所看到的，UDP数据包的标头要简单得多。这是因为UDP维护套接字的开销要少得多，与TCP相比。
- en: '![The UDP header architecture](img/B04315_03_7.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![UDP标头结构](img/B04315_03_7.jpg)'
- en: Understanding how UDP works
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解UDP的工作原理
- en: UDP establishes a communication stream with a listening port. That port accepts
    the data and runs it up the TCP/IP stack as necessary. While TCP is needed for
    synchronized and reliable communication, UDP is not. Multimedia presentations
    are the best example of what UDP communication is used for. If you are watching
    a movie, you wouldn't care about a packet that might have been lost, because even
    if it is resent, it would make no sense to present it after the movie has moved
    on from the initial hiccup in presentation. Now that you have understood the basics
    of system communication, you need to understand how different flags are used to
    gather the required data using Nmap scan techniques.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: UDP与监听端口建立通信流。该端口接受数据并将其根据需要传递到TCP/IP堆栈。虽然TCP用于同步和可靠的通信，但UDP不需要。多媒体演示是UDP通信的最佳示例。如果您正在观看电影，您不会在意可能丢失的数据包，因为即使它被重发，也没有意义在电影已经从最初的演示中移动之后再呈现它。现在您已经了解了系统通信的基础知识，您需要了解如何使用Nmap扫描技术使用不同的标志来收集所需的数据。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each scan has a different purpose, and specific flags elicit different responses
    from operating systems depending on whether they are received out of order or
    not. The nmap port scanning techniques web page at [http://nmap.org/book/man-port-scanning-techniques.html](http://nmap.org/book/man-port-scanning-techniques.html)
    details this information succinctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次扫描都有不同的目的，特定的标志会引发操作系统不同的响应，具体取决于它们是否按顺序接收。 nmap端口扫描技术网页[http://nmap.org/book/man-port-scanning-techniques.html](http://nmap.org/book/man-port-scanning-techniques.html)简洁地详细介绍了这些信息。
- en: Understanding Nmap
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Nmap
- en: If there is one tool that is ubiquitous through most top-tier and new assessor
    toolkits, it is nmap. You may find different exploitation frameworks, web application
    tools, and other preferences, but nmap is a staple tool for many forms of assessment.
    Now, this is not to say that there are no other tools that can be executed with
    similar capabilities; it's just that they are not as capable. This includes tools
    such as AngryIP, HPing, FPing, NetScan, Unicorn scan, and others. From all of
    these tools, only two stand out as significantly different, and they are HPing
    and Unicorn scan.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种工具在大多数顶级和新的评估工具包中无处不在，那就是nmap。您可能会发现不同的利用框架、Web应用程序工具和其他偏好，但nmap是许多形式评估的基本工具。现在，这并不是说没有其他工具可以执行类似的功能；只是它们没有那么强大。这包括AngryIP、HPing、FPing、NetScan、Unicorn
    scan等工具。在所有这些工具中，只有两种显得显著不同，它们是HPing和Unicorn scan。
- en: The biggest mistake I see new assessors making with nmap is executing more than
    one scan at a time from the same host. What they do not realize is that nmap uses
    the integrated TCP/IP stack of the host operating system. This means that any
    additional scan executed does not speed the results; instead, the multiple sessions
    must be handled at the same time by the operating systems TCP/IP stack. This in
    turn will not only slow down the results of each scan, but also increase errors,
    as each received packet can impact the results depending on the instance it was
    received by.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到新的评估者在使用nmap时犯的最大错误是从同一主机同时执行多次扫描。他们没有意识到nmap使用主机操作系统的集成TCP/IP堆栈。这意味着任何额外的扫描都不会加快结果；相反，操作系统的TCP/IP堆栈必须同时处理多个会话。这不仅会减慢每次扫描的结果，还会增加错误，因为每个接收的数据包都可能影响结果，具体取决于它被哪个实例接收。
- en: Each missing packet may be resent; this means that the scans slow down, not
    only because of the number of packets being resent, but because of the inconsistent
    results and the constrained TCP/IP stack. This means that you can execute only
    one instance of an nmap scan per host. Therefore, you must be as efficient as
    possible. So what is the solution? You can use nmap to execute a scan using the
    host TCP/IP stack and the Unicorn scan, which contains its own TCP/IP stack. The
    truth is that this entire situation can be avoided by efficiently using nmap instead
    of using multiple tools at once, which eats up relative clock cycles.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个丢失的数据包都可以重新发送；这意味着扫描速度变慢，不仅因为重新发送的数据包数量，还因为不一致的结果和受限的TCP/IP堆栈。这意味着您只能对每个主机执行一次nmap扫描。因此，您必须尽可能高效。那么解决方案是什么？您可以使用nmap执行使用主机TCP/IP堆栈和Unicorn扫描的扫描，后者包含其自己的TCP/IP堆栈。事实上，通过高效使用nmap而不是同时使用多个工具，可以避免整个情况，后者会占用相对的时钟周期。
- en: So, besides dealing with the limitations of resident TCP/IP stacks, there is
    also the limitation of how detailed packets can be manipulated through nmap. HPing
    provides the ability to relatively easily create custom packets that meet a specific
    intent. Despite this customization, HPing is efficient only at executing a test
    against a single host in a customized manner. If multiple hosts need simple pings
    with relative customization, FPing should be the tool of choice. This is especially
    because the results produced in **Standard Out** (**STDOUT**) by FPing are easily
    parsable for producing efficient and useful results. This is not to say that nmap
    is not a highly configurable tool, but rather to point out that it is not a replacement
    for an experienced and smart assessor, and that each tool has its place. So, you
    need to understand its limitations and supplement it as necessary.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了处理驻留TCP/IP堆栈的限制外，还有一个限制，即nmap可以如何详细地操作数据包。HPing提供了相对容易创建符合特定意图的自定义数据包的能力。尽管进行了这种自定义，但HPing只能有效地针对单个主机执行测试。如果多个主机需要相对自定义的简单ping测试，FPing应该是首选工具。特别是因为FPing在**标准输出**（**STDOUT**）中产生的结果易于解析，以产生高效和有用的结果。这并不是说nmap不是一个高度可配置的工具，而是指出它不能替代经验丰富且聪明的评估者，每个工具都有其用武之地。因此，您需要了解其限制并根据需要进行补充。
- en: Inputting the target ranges for Nmap
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入Nmap的目标范围
- en: 'Nmap can have targets input either by **Standard Input** (**STDIN**), which
    is when you pass data directly from the **Command-line interface** (**CLI**),
    or via a file. For the CLI, this can be done in a variety of ways to include a
    range of IP addresses, and the **Classless Inter-Domain Routing** (**CIDR**) notation
    of the IP addresses. For files, the IP addresses can be passed by the methods
    mentioned to include CIDR notation, IP addresses, and ranges and also by an IP
    list separated by line breaks or carriage returns. To pass data by the CLI all
    that the user has to do is present the piece at the end of the command, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap可以通过**标准输入**（**STDIN**）或文件输入目标。对于CLI，可以通过多种方式进行，包括一系列IP地址和IP地址的**无类域间路由**（**CIDR**）表示法。对于文件，IP地址可以通过提到的方法传递，包括CIDR表示法、IP地址和范围，以及通过换行或回车分隔的IP列表。要通过CLI传递数据，用户只需在命令的末尾呈现该部分，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For a file input method, all that is required is the `-iL` option followed
    by the filename:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件输入方法，所需的只是`-iL`选项，后面跟着文件名：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Executing the different scan types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行不同的扫描类型
- en: Nmap has a large number of different supported scans, but not all will be covered
    here. Instead, we will focus on the scans that you will use the most in your assessments.
    The four scans you primarily use are the TCP connection scan (also known as the
    full-connection scan), the SYN scan (also known as the half-open or stealth scan),
    the ACK scan, and the UDP scan. These are highlighted to the level set knowledge
    for future scripting efforts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap支持大量不同的扫描，但这里不会涵盖所有扫描。相反，我们将重点关注您在评估中最常使用的扫描。您主要使用的四种扫描是TCP连接扫描（也称为完全连接扫描）、SYN扫描（也称为半开放或隐秘扫描）、ACK扫描和UDP扫描。这些都是为未来脚本编写所需的知识水平而突出显示的。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When performing external testing, you may get automatically blocked or shunned.
    This could be executed by the client's **Internet Service Provider** (**ISP**)
    or their **Information Technology** (**IT**) team. You should always have a backup
    public IP address in case your primary gets blocked. Then, just avoid doing the
    same thing that blocked you earlier. Next, document when you see the client doing
    a proactive block, as this positive activity highlights where they should consider
    continuing their investment and where they have gaps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行外部测试时，您可能会被自动屏蔽或排斥。这可能是由客户的**互联网服务提供商**（**ISP**）或他们的**信息技术**（**IT**）团队执行的。您应该始终备份公共IP地址，以防您的主要IP地址被屏蔽。然后，避免做与之前被屏蔽的相同的事情。接下来，当您看到客户进行积极的屏蔽时，请记录下来，因为这种积极的活动突出了他们应该考虑继续投资的地方以及他们存在差距的地方。
- en: Executing TCP full connection scans
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行TCP完全连接扫描
- en: The TCP connection scan is one of the loudest or easiest to detect scans nmap
    has, but it is also one of the best for eliminating false positives. In earlier
    days, **Incident Response (IR)** and security teams paid a lot of attention to
    what was scanning the perimeter so that they could determine when they were going
    to be attacked. Times changed, as the amount of noise generated at the perimeter
    became excessive, and much of the access that was previously seen was mitigated
    by more advanced firewalls. Today, IR teams are again paying attention to the
    perimeter and using the activity they see to correlate events and potential future
    attempts to get into the network, or follow-up related to already executed attacks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接扫描是nmap中最响亮或最容易检测到的扫描之一，但它也是最适合消除误报的扫描之一。在早期，**事件响应（IR）**和安全团队非常关注外围的扫描，以便确定何时会遭受攻击。时代变了，外围产生的噪音变得过多，许多以前看到的访问被更先进的防火墙所减轻。今天，IR团队再次关注外围，并利用他们看到的活动来相关事件和潜在的未来尝试进入网络，或者跟踪已经执行的攻击相关的后续行动。
- en: 'The TCP connect scan may provide the most accurate results, but automatic shunning
    mechanisms often block the source of the scan at the **Internet Service Provider**
    (**ISP**). To execute a TCP scan, all you have to do is indicate the associated
    scan type with `-sT`, as seen here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接扫描可能提供最准确的结果，但自动拒绝机制通常会阻止扫描源在**互联网服务提供商**（**ISP**）处。要执行TCP扫描，你只需使用`-sT`指示相关的扫描类型，如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I have assessed many an organization, which could be scanned with full connection
    scans only, as they would immediately shun the connection if an SYN scan was executed.
    The trick is to know your target and how advanced their environment is. Much of
    this can be determined during the pre-engagement phases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我评估过许多组织，只能使用完全连接扫描进行扫描，因为如果执行SYN扫描，它们会立即拒绝连接。诀窍在于了解你的目标及其环境的先进程度。在预约阶段，很多情况都可以确定。
- en: Executing SYN scans
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行SYN扫描
- en: SYN scans are a type of TCP scan, and they are the most prominent scans you
    will probably run during your engagements. The reason is that they are much faster
    than TCP connection scans, and much quieter. However, they are not suitable for
    environments with extremely old or sensitive equipment types. Though most modern
    systems have no problem with closing a connection if it does not receive an ACK
    response in a timely manner, others could have problems. There have been repeated
    cases in the past where some legacy systems could have had a **Denial of Service**
    (**DoS**) situation if the connection was not completed. Today, these are much
    rarer, but always consider your customers' concerns, as they know their environment
    better than you do.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SYN扫描是一种TCP扫描，它可能是你在参与中运行的最突出的扫描。原因是它比TCP连接扫描快得多，而且更安静。然而，它不适用于极老或敏感设备类型的环境。虽然大多数现代系统在及时收到ACK响应后关闭连接时不会有问题，但其他系统可能会出现问题。过去曾多次出现这样的情况，如果连接未完成，一些传统系统可能会出现**拒绝服务**（**DoS**）的情况。今天，这种情况已经很少见，但始终要考虑客户的担忧，因为他们比你更了解自己的环境。
- en: 'SYN scans are simply executed using the `-sS` flag, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SYN扫描只需使用`-sS`标志来执行，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Executing ACK scans
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行ACK扫描
- en: ACK scans are the rarest of the three TCP scan types, and they may not be as
    directly useful as you think. Let's see when you would use an ACK scan. It is
    a slow scan, so you would use it if an SYN or TCP scan does not provide you with
    the results you needed. Nmap is pretty smart today; you usually don't need to
    perform the different types of scans to validate the type of target you are hitting.
    So, you would be trying to identify a resource that a full connection scan does
    not work on. This means that you may not be able to connect to the host for further
    attacks, because you were unable to complete a three-way handshake.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ACK扫描是三种TCP扫描类型中最罕见的，它可能并不像你想象的那样直接有用。让我们看看在什么情况下你会使用ACK扫描。它是一种慢速扫描，所以如果SYN或TCP扫描不能提供你需要的结果，你会使用它。Nmap今天非常智能；通常你不需要执行不同类型的扫描来验证你正在攻击的目标类型。因此，你可能会尝试识别一个完全连接扫描无法使用的资源。这意味着你可能无法连接到主机进行进一步的攻击，因为你无法完成三次握手。
- en: 'So where are ACK scans useful? People often ask this, and the answer is, "Firewalls."
    ACK scans are great for mapping firewall rule sets. Some systems react very strangely
    to ACK scans and provide additional data in return, so make sure you have `tcpdump`
    running on either an inline tap or on your system when you execute the ACK scan.
    The following is an example of how to execute an ACK scan. Run the command as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么ACK扫描在哪里有用呢？人们经常问这个问题，答案是“防火墙”。ACK扫描非常适合映射防火墙规则集。一些系统对ACK扫描的反应非常奇怪，并提供额外的数据，所以当你执行ACK扫描时，确保你的系统上运行着`tcpdump`。以下是如何执行ACK扫描的示例。运行以下命令：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Executing UDP scans
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行UDP扫描
- en: You will see tons of blog posts and books and come across several training events
    that highlight the fact that UDP is a protocol that is often overlooked. In future
    chapters, we will highlight how dangerous this really is to an organization. UDP
    scans are extremely slow, and since there are just as many ports for UDP as TCP,
    it will take a substantial amount of time to scan for them. Additionally, UDP
    scans—for lack of a better term—lie. They will often report things as filtered/open,
    which basically means that it does not know.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到大量的博客文章、书籍和几个培训活动强调UDP是一个经常被忽视的协议。在未来的章节中，我们将强调这对一个组织来说是多么危险。UDP扫描非常慢，由于UDP和TCP一样有很多端口，扫描它们需要大量的时间。此外，UDP扫描——用更好的术语来说——是虚假的。它们经常报告一些东西是被过滤/开放的，这基本上意味着它不知道。
- en: This can be infuriating in very large environments. It also does not have the
    full capability to grab most of the UDP port service information. The most common
    ports have specially packaged scan data, which allows nmap to determine whether
    the port is really open and what service is there, because services are not always
    on the default port. When services are moved to UDP ports, there is an impact
    on the default scan data returned by nmap, as opposed to TCP scans, for which
    the impact is not so much.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常大的环境中，这可能会令人恼火。它也没有完全的能力来获取大多数UDP端口服务信息。最常见的端口有特别打包的扫描数据，这使得nmap能够确定端口是否真的开放以及有什么服务，因为服务并不总是在默认端口上。当服务移至UDP端口时，与TCP扫描相比，nmap返回的默认扫描数据会受到影响，影响并不大。
- en: 'To execute a UDP scan, all that is needed is the flag for the scan set to `-sU`,
    as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行UDP扫描，只需将扫描标志设置为`-sU`，如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Executing combined UDP and TCP scans
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行组合UDP和TCP扫描
- en: 'So now, you know how to run your primary scans, but running both TCP and UDP
    scans one after the other can take very long periods of time. To save time, you
    can combine the scanning of resources by targeting ports for both types of scans.
    Be smart about this, however; if you use a lot of ports in this scan, it will
    take forever to complete. So, this scan is great for targeting the top ports that
    you can use to identify vulnerable resources that have the best chance of being
    compromised, such as the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何运行主要扫描，但是连续运行TCP和UDP扫描可能需要很长时间。为了节省时间，您可以通过针对两种类型的扫描的端口来组合资源的扫描。但是要明智地使用，如果在此扫描中使用了大量端口，将需要很长时间才能完成。因此，此扫描非常适合针对您可以用来识别易受攻击的资源的顶级端口，例如以下端口：
- en: '| Service types | Common port numbers | Protocol | Service |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 服务类型 | 常见端口号 | 协议 | 服务 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Databases | `1433` | TCP | Microsoft Structured Query Language (MSSQL) Server
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | `1433` | TCP | Microsoft结构化查询语言（MSSQL）服务器 |'
- en: '| `1434` | UDP | SQL Server Browser Service |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `1434` | UDP | SQL Server浏览器服务 |'
- en: '| `3306` | TCP | MySQL |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `3306` | TCP | MySQL |'
- en: '| `5433` | TCP | The PostgresSQL server |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `5433` | TCP | PostgresSQL服务器 |'
- en: '| Remote file services | `2049` | TCP | Network File Service (NFS) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 远程文件服务 | `2049` | TCP | 网络文件服务（NFS） |'
- en: '| `111` | TCP | Sun Remote Procedure Call (RPP) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `111` | TCP | Sun远程过程调用（RPP） |'
- en: '| `445` | TCP | Server Message Block (SMB) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `445` | TCP | 服务器消息块（SMB） |'
- en: '| `21` | TCP | File Transfer Protocol (FTP) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `21` | TCP | 文件传输协议（FTP） |'
- en: '| Remote administrative interface | `3389` | TCP | Remote Desktop Protocol
    (RDP) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 远程管理界面 | `3389` | TCP | 远程桌面协议（RDP） |'
- en: '| `22` | TCP | Secure Shell (SSH) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `22` | TCP | 安全外壳（SSH） |'
- en: '| `23` | TCP | Telnet |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `23` | TCP | Telnet |'
- en: '| `6000 to 6005` | TCP | x11 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `6000到6005` | TCP | x11 |'
- en: '| `5900` | TCP | Virtual Network Connector (VNC) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `5900` | TCP | 虚拟网络连接器（VNC） |'
- en: '| `9999` | TCP | A Known Remote Administrative Interface for Legacy Networking
    Equipment |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `9999` | TCP | 用于遗留网络设备的已知远程管理界面 |'
- en: '| Interface and system/user enumeration services | `25` | TCP | Send Mail Transfer
    Protocol (SMTP) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: 接口和系统/用户枚举服务 | `25` | TCP | 发送邮件传输协议（SMTP）
- en: '| `79` | TCP | Finger |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `79` | TCP | Finger |'
- en: '| `161` | UDP | Simple Network Management Protocol |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `161` | UDP | 简单网络管理协议 |'
- en: '| Web servers | `80, 443` | TCP | Web services |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Web服务器 | `80、443` | TCP | Web服务 |'
- en: '| `8080, 8443, and 8888` | TCP | Tomcat Management Page, JBoss Management Page,
    System Admin Panel |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `8080、8443和8888` | TCP | Tomcat管理页面，JBoss管理页面，系统管理面板 |'
- en: '| **Virtual Private Network** (**VPN**) management details | `500` | UDP |
    Internet Security Association and Key Management Protocol (ISAKMP) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **虚拟专用网络**（**VPN**）管理详细信息 | `500` | UDP | 互联网安全关联和密钥管理协议（ISAKMP）'
- en: 'To execute a combined scan, all that is needed is to flag the two types of
    scans you want to use and itemize the ports you want to scan for each protocol.
    This is done by providing the `-p` option, followed by `U:` for the UPD ports
    and the `T:` for the TCP ports. See the following example, which highlights only
    a few ports for the sake of brevity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行组合扫描，只需标记要使用的两种类型的扫描，并逐个列出要为每种协议扫描的端口。这是通过提供`-p`选项，后跟`U：`用于UPD端口和`T：`用于TCP端口来完成的。请参阅以下示例，仅为简洁起见突出显示了一些端口：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Skipping the operating system scans
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过操作系统扫描
- en: 'I have seen a number of new assessors jump all over the operating system scan
    for nmap with gleeful excitement. It is one of the quickest ways my team members
    know of of identifying someone who does not assess enterprise environments regularly.
    Here are the reasons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过许多新的评估者对nmap的操作系统扫描充满了愉快的兴奋。这是我团队成员知道的识别不经常评估企业环境的人的最快方法之一。原因如下：
- en: Operating system scans are very noisy
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统扫描非常吵闹
- en: It can bring legacy systems down, because it performs chained scans to determine
    the responses and validate the system type
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会使遗留系统崩溃，因为它执行链接扫描以确定响应并验证系统类型
- en: Against an old or legacy system, it can be damaging
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于旧的或遗留系统，可能会造成破坏
- en: In the past, certain printers would have issues, to include printing ink soaked
    black pages until they were shut off or ran out of paper
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去，某些打印机可能会出现问题，包括打印浸泡墨水的黑色页面，直到它们被关闭或用完纸
- en: The biggest reason for seasoned assessors not using this scan, is because it
    provides little value today. You can identify the details this scan provides faster,
    more easily, and more quietly with other methods. For example, if you see port
    `445` open, it is either a system running a Samba variant or a Windows host—usually.
    Learning the ports, service labels, and versions of each operating system will
    do a better job in identifying the OS and version than this scan will. Additionally,
    if it is a system that you cannot identify by this method, it is unlikely that
    nmap will be able to do it either, of course this is depending on your skill level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的评估者不使用这种扫描的最大原因是因为它在今天提供的价值很小。你可以用其他方法更快、更容易、更安静地识别这种扫描提供的细节。例如，如果你看到端口`445`打开，那么它要么是运行Samba变体的系统，要么是Windows主机——通常是这样。学习每个操作系统的端口、服务标签和版本将比这种扫描更好地识别操作系统和版本。此外，如果是一种你无法通过这种方法识别的系统，那么nmap也不太可能做到，当然这取决于你的技能水平。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As you gain experience, you learn how to passively identify live hosts using
    tools such as Responder, tcpdump, and Wireshark. This means that you don't need
    to scan for hosts and, in essence, you are being quieter. This is also a better
    simulation of real malicious actors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着经验的积累，你会学会如何使用Responder、tcpdump和Wireshark等工具被动地识别活动主机。这意味着你不需要扫描主机，实质上，你更加安静。这也更好地模拟了真正的恶意行为者。
- en: Different output types
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的输出类型
- en: Nmap has four output types, and they are extremely useful depending on the situation.
    They are to the screen, `STDOUT`, or to three different file types. These file
    types have different purposes and advantages. There is the nmap output, which
    looks identical to `STDOUT` but just in a file; this is done with `-oN`. Then,
    there are the `Grepable` and eXtensible Markup Language (XML) outputs, described
    as follows. All outputs can be produced at the same time using the `-oA` flag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap有四种输出类型，根据情况它们非常有用。它们可以输出到屏幕，`STDOUT`，或者三种不同的文件类型。这些文件类型有不同的目的和优势。有nmap输出，看起来和`STDOUT`一样，但是在文件中；这是用`-oN`来实现的。然后，还有`Grepable`和可扩展标记语言（XML）输出，如下所述。所有输出可以使用`-oA`标志同时产生。
- en: Understanding the Nmap Grepable output
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Nmap Grepable输出
- en: There is the Grepable output, which—to tell the truth—is not that great for
    greping out data. It can provide an easy means to extract components of data to
    build lists quickly and easily, but to properly parse it with `grep`, `sed`, and
    `awk`, you actually have to insert characters to signify where data should be
    extracted. The Grepable output can be executed by tagging the `-oG` flags.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '有Grepable输出，说实话，对于提取数据来说并不是那么好。它可以提供一种快速、简单地提取数据组件来构建列表的方法，但是要用`grep`、`sed`和`awk`来正确解析它，你实际上必须插入字符来表示数据应该被提取的位置。Grepable输出可以通过标记`-oG`来执行。 '
- en: 'After you have a Grepable file, the most useful way of parsing the data is
    by keying on certain components of it. You are usually looking for open ports
    related to specific services. So, you can extract these details by executing commands
    such as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个Grepable文件时，解析数据的最有用的方法是根据它的某些组件。通常你要寻找与特定服务相关的开放端口。因此，你可以通过执行以下命令提取这些细节：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The example shows a Grepable file being pushed to `STDOUT` and then piped to
    `grep`, which searches for open `445 ports`. This can be done with `grep` and
    cut only, but it is very easy to read and understand. Once the ports are found,
    cut extracts the IP addresses and pushes them to a flat file known as `smb_hosts_lists`.
    If you look at the `nmap_scan.gnmap` file, you would potentially see lines that
    contain details such as these:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个Grepable文件被推送到`STDOUT`，然后被管道传输到`grep`，`grep`搜索开放的`445端口`。这可以通过`grep`和cut来完成，但是这样很容易阅读和理解。一旦找到端口，cut提取IP地址并将它们推送到一个名为`smb_hosts_lists`的平面文件中。如果你查看`nmap_scan.gnmap`文件，你可能会看到包含以下细节的行：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the line contains the `445/open/tcp` detail, which allows us
    to target that specific line. We then cut using the space as a delimitating key
    and select field two, where, if you count the data fields by spaces, you find
    the IP address. This technique is very common and is useful for quickly identifying
    what is open by the IP address and creating multiple flat files based on the service
    or port.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这行包含`445/open/tcp`的细节，这使我们能够针对特定行进行目标定位。然后我们使用空格作为分隔键进行切割，并选择第二个字段，如果你通过空格计算数据字段，你会找到IP地址。这种技术非常常见，对于快速识别IP地址开放的服务或端口，并基于服务或端口创建多个平面文件非常有用。
- en: 'As shown in [Chapter 1](ch01.html "Chapter 1. Understanding the Penetration
    Testing Methodology"), *Understanding the Penetration Testing Methodology*, you
    use the `rhosts` field in the Metasploit modules to target hosts by CIDR notation
    or range. When you create flat files, you can use Metasploit modules to hit a
    list of hosts instead by referencing the flat file. To run the Metasploit console,
    execute this command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第1章](ch01.html "第1章。理解渗透测试方法论")中所示，*理解渗透测试方法论*，你可以使用Metasploit模块中的`rhosts`字段来通过CIDR表示法或范围来定位主机。当你创建平面文件时，你可以使用Metasploit模块来引用平面文件而不是目标主机列表。要运行Metasploit控制台，执行以下命令：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are running Metasploit Professional from the command line, use the following
    command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从命令行运行Metasploit Professional，使用以下命令：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now see this example, wherein we will try and see whether the password we cracked
    earlier works on any host in the rest of the network:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个例子，在这个例子中，我们将尝试并查看我们之前破解的密码是否适用于网络中其余主机：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `use` command selects the module you want to use—the `smb_login` module
    in this case—which verifies **Server Message Block** (**SMB**) credentials. The
    `SMBUser` set chooses the username you are going to execute this attack against.
    The `SMBPass` set selects the password that is going to be used in this module.
    The set `SMBDomain` field allows you to set the domain for the organization. The
    `run` command executes the auxiliary module. In earlier years, you had to use
    `run` to execute an auxiliary module and exploit for an exploit module. Today,
    these are really interchangeable, with the exception of post exploitation modules,
    which require `run` as highlighted at [https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/](https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`命令选择要使用的模块——在本例中是`smb_login`模块，用于验证**Server Message Block**（**SMB**）凭据。`SMBUser`设置选择要对其执行此攻击的用户名。`SMBPass`设置选择要在此模块中使用的密码。`SMBDomain`字段允许您设置组织的域。`run`命令执行辅助模块。在早些年，您必须使用`run`来执行辅助模块和利用模块。如今，这些实际上是可以互换的，除了需要`run`的后期利用模块，如[https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/](https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/)中所强调的。'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are attacking with a local account, you should set the domain to workgroup.
    When attacking a domain account, you should set the domain to the actual domain
    of the organization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用本地帐户进行攻击，应将域设置为工作组。当攻击域帐户时，应将域设置为组织的实际域。
- en: Metasploit Professional is a tool that helps optimize penetration testing efforts
    and it has a web **Graphical User Interface** (GUI). Metasploit pro provides a
    lot of great features, but if you need to pivot through multiple network tiers
    protected by firewalls, the console is the best option. To learn how to execute
    an automatic pivot, you can find the details at [https://www.offensive-security.com/metasploit-unleashed/pivoting/](https://www.offensive-security.com/metasploit-unleashed/pivoting/).
    To learn how to execute a manual pivot, refer to [https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot](https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot),
    which covers port-based pivoting, manual routing, and SOCKS proxies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit Professional是一种帮助优化渗透测试工作的工具，它具有Web图形用户界面（GUI）。Metasploit pro提供了许多出色的功能，但如果您需要通过由防火墙保护的多个网络层进行枢纽，控制台是最佳选择。要了解如何执行自动枢纽，您可以在[https://www.offensive-security.com/metasploit-unleashed/pivoting/](https://www.offensive-security.com/metasploit-unleashed/pivoting/)找到详细信息。要了解如何执行手动枢纽，请参阅[https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot](https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot)，其中涵盖了基于端口的枢纽、手动路由和SOCKS代理。
- en: 'This method of attack is very common; you find out the credentials, identify
    the services the credentials may work on, and then build flat files to target
    hosts. Next, you reference those flat files to check the hosts for a vulnerability.
    Once you have verified those hosts as vulnerable, you can exploit them with **Pass-the-Hash**
    (**PtH**) using a **Process Execution** (**PSEXEC**) attack (if you had the hash)
    or a standard-credentialed PSEXEC, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击方法非常常见；您找到凭据，确定凭据可能适用的服务，然后构建平面文件以针对主机。接下来，您引用这些平面文件来检查主机是否存在漏洞。一旦验证了这些主机的脆弱性，您就可以使用**Pass-the-Hash**（**PtH**）利用它们，使用**Process
    Execution**（**PSEXEC**）攻击（如果您有哈希）或标准凭证PSEXEC，如下面的代码所示：
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: PtH is an attack that takes advantage of a native Windows weakness related to
    how systems authenticate on a network. Instead of requiring a Challenge/Response
    authentication method, the hashed password can be passed directly to the host.
    This means that you do not have to crack the **Local Area Network Manager** (**LM**)
    or **New Technology LM** (**NTLM**) hashes. Many Metasploit modules can use either
    credentials or hashes against SMB services.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PtH是一种利用与系统在网络上进行身份验证的Windows本机弱点相关的攻击。与要求挑战/响应身份验证方法不同，哈希密码可以直接传递到主机。这意味着您不必破解**本地区域网络管理器**（**LM**）或**新技术LM**（**NTLM**）哈希。许多Metasploit模块可以使用SMB服务的凭据或哈希。
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The set `payload` command chooses the payload that is going to be dropped on
    the host and then executed. The `reverse_tcp` payload dials back to the attack
    box to establish a connection. Had it been a `bind` payload, the attack box would
    have directly connected to a listening port after execution. `RHOST` and `LPORT`
    signify the target host we want to connect to and the port on the attack box that
    we want to listen to for the returning communication. The `exploit -j` runs the
    exploit and then backgrounds the results, which allows you to focus on other things,
    returning to the session as needed with `session -i <session number>`. Keep in
    mind that you do not require cracked credentials to execute `smb_login` or the
    `psexec`; instead, you can just PtH. In that case, the text would look like the
    following code for the `smb_login` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload`命令选择要在主机上投放并执行的有效负载。`reverse_tcp`有效负载拨回攻击盒以建立连接。如果是`bind`有效负载，攻击盒在执行后将直接连接到监听端口。`RHOST`和`LPORT`表示我们要连接的目标主机和攻击盒上要监听返回通信的端口。`exploit
    -j`运行漏洞利用，然后将结果放到后台，这样可以让您专注于其他事情，并在需要时使用`session -i <session number>`返回会话。请记住，您不需要破解凭据来执行`smb_login`或`psexec`；相反，您可以使用PtH。在这种情况下，`smb_login`命令的文本将如下代码所示：'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All payloads that are dropped on the box are deleted when the process execution
    completes. If the execution process is interrupted, the payload may stay on the
    system. Better secured environments that use tools that monitor processes may
    have instances of this if the tools are not correctly configured to delete the
    generator of those detected processes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程完成时，放在盒子上的所有有效负载都将被删除。如果执行过程中断，有效负载可能会留在系统中。更安全的环境使用监视进程的工具，如果这些工具未正确配置以删除检测到的进程的生成器，则可能会出现这种情况。
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following configuration would be for the `psexec` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置将用于`psexec`命令：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have understood the purpose and benefits of the `nmap grepable`
    output, let's look at the benefits of the XML output. One item should be noted
    before moving on, which will help you understand what the XML benefits are. Look
    at the line from the `nmap grepable` output. You can see that there are very few
    special characters for differentiating the fields of data; this means that you
    can extract only small components of information with ease. To get larger quantities,
    you have to insert delineators using `sed` and `awk`. This is a painful process,
    but thankfully, you have the solution at hand—the XML output.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了`nmap grepable`输出的目的和好处，让我们来看看XML输出的好处。在继续之前，有一点需要注意，这将帮助您了解XML的好处。看一下`nmap
    grepable`输出的行。您可以看到用于区分数据字段的特殊字符非常少；这意味着您可以轻松提取只有小部分信息。要获取更大的数量，您必须使用`sed`和`awk`插入分隔符。这是一个痛苦的过程，但幸运的是，您手头上有解决方案——XML输出。
- en: Understanding the Nmap XML output
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Nmap XML输出
- en: XML builds trees of data that use child and parent components to label datasets.
    This allows easy and direct parsing of data using specific label grabs after walking
    the tree that lists the parent and child relationships. Most importantly, because
    of this, XML outputs can be imported by other tools, such as Metasploit. You can
    easily output to only XML using the `-oX` option. More details of these benefits
    will be covered in later chapters, specifically when parsing XML using Python
    in [Chapter 9](ch09.html "Chapter 9. Automating Reports and Tasks with Python"),
    *Automating Reports and Tasks with Python*, to help automatically generate report
    data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: XML构建数据树，使用子父组件来标记数据集。这允许在遍历列出父子关系的树之后，使用特定标签抓取数据进行轻松和直接的解析。最重要的是，由于这一点，XML输出可以被其他工具导入，比如Metasploit。您可以使用`-oX`选项轻松地只输出XML。这些好处的更多细节将在以后的章节中进行介绍，特别是在[第9章](ch09.html
    "第9章。使用Python自动化报告和任务")中使用Python解析XML时，*使用Python自动化报告和任务*，以帮助自动生成报告数据。
- en: The Nmap scripting engine
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nmap脚本引擎
- en: Nmap has a number of scripts that provide unique capabilities for assessors.
    They can help identify vulnerable services and exploit systems or interact with
    complex system components. These scripts are coded in a language called Lua, which
    will not be covered here. These scripts can be found at `/usr/share/nmap/scripts`
    within Kali. Each of these scripts can be called using the `--script` option and
    then called in a comma-delimitated list. Make sure you know what each script does
    before executing it against a target, because there may be unintended consequences
    on target systems.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap有许多脚本，为评估者提供独特的功能。它们可以帮助识别易受攻击的服务、利用系统或与复杂的系统组件交互。这些脚本是用一种叫做Lua的语言编写的，这里不会涉及。这些脚本可以在Kali的`/usr/share/nmap/scripts`中找到。可以使用`--script`选项调用这些脚本，然后以逗号分隔的列表形式调用。在针对目标执行脚本之前，请确保您知道每个脚本的作用，因为它可能对目标系统产生意外后果。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details about `nmap` scripts can be found at [http://nmap.org/book/man-nse.html](http://nmap.org/book/man-nse.html).
    Specific details about `nmap` scripts can be found at [http://nmap.org/nsedoc/](http://nmap.org/nsedoc/),
    along with their purposes and category associations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`nmap`脚本的更多详细信息，请访问[http://nmap.org/book/man-nse.html](http://nmap.org/book/man-nse.html)。可以在[http://nmap.org/nsedoc/](http://nmap.org/nsedoc/)找到有关`nmap`脚本的具体细节，以及它们的目的和类别关联。
- en: 'Scripts can be called by the category they are part of or removed from the
    categories you do not want them to be part of. As an example, you can see that
    the following command runs the `nmap` tool with all default or safe scripts that
    do not start with `http-`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以按其所属的类别调用，或者从您不希望它们所属的类别中移除。例如，您可以看到以下命令运行`nmap`工具，使用所有默认或安全脚本，这些脚本不以`http-`开头：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By now, you should have a pretty good understanding of how to use nmap and the
    capabilities within it. Let's look at being efficient with nmap. This is because
    the biggest limiting component of a penetration test is time, and during that
    time period, we need to succinctly identify vulnerable targets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经对如何使用nmap以及其中的功能有了相当好的了解。让我们来看看如何高效使用nmap。这是因为渗透测试的最大限制因素是时间，在这段时间内，我们需要简明地识别易受攻击的目标。
- en: Being efficient with Nmap scans
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效使用Nmap扫描
- en: Nmap is a great tool, but you can be limited by poor network design, large target
    sets, and unrestricted port ranges. So, the trick to being efficient is to limit
    the number of ports you scan for until you know which targets are live. This can
    be done by targeting subnets that have live devices and only scanning those ranges.
    The easiest way to do this is to look for default gateways that are active in
    a network. So, if you see that your default gateway is `192.168.1.1`, it is likely
    that in this Class C network, other default gateways may be active in areas such
    as `192.168.2.1`. Pinging the default gateway is a process that is a little noisy,
    but it is typically consistent with most of the nominal network traffic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap是一个很棒的工具，但是您可能会受到网络设计不佳、大量目标集和不受限制的端口范围的限制。因此，高效的关键是限制您扫描的端口数量，直到您知道哪些目标是活动的。这可以通过针对具有活动设备的子网并仅扫描这些范围来完成。这样做的最简单方法是查找网络中活动的默认网关。因此，如果您看到您的默认网关是`192.168.1.1`，那么在这个C类网络中，其他默认网关可能在诸如`192.168.2.1`之类的区域是活动的。对默认网关进行ping操作是一个有点吵闹的过程，但它通常与大部分正常的网络流量一致。
- en: Nmap has a built-in capability that lets you target the statistically more common
    ports using the `--top-ports` option and then follow it up with a number. As an
    example, you could look for the top 10 ports using the `--top-ports 10` option.
    This statistics was discovered by long-term scanning of Internet-facing hosts,
    which means that the statistics is based on what would be exposed to the Internet.
    So, remember that if you are doing an internal network assessment, this option
    may not provide the expected results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap具有内置功能，可以使用`--top-ports`选项来定位统计上更常见的端口，然后跟上一个数字。例如，您可以使用`--top-ports 10`选项查找前10个端口。这些统计数据是通过对面向互联网的主机进行长期扫描发现的，这意味着统计数据是基于互联网上可能暴露的内容。因此，请记住，如果您正在进行内部网络评估，此选项可能无法提供预期的结果。
- en: 'As an assessor, you are often provided a range of targets to assess. Sometimes,
    this range is extremely large. This means that you need to try and identify live
    segments by seeing which locations'' default gateways are active. Each active
    default gateway and the relevant subnet will tell you where you should scan. So,
    if you have a default gateway of `192.168.1.1` and your subnet is `255.255.255.0`
    or `/24`, you should check for other default gateways from `192.168.2.1` to `192.168.255.1`.
    As you ping each default gateway, if it responds, you know that there are likely
    live hosts in that subnet. This can be done easily with well-known bash `for`
    loop:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为评估员，您经常会收到一系列要评估的目标。有时，这个范围非常大。这意味着您需要尝试通过查看哪些位置的默认网关是活动的来确定活动段。每个活动的默认网关和相关子网将告诉您应该扫描的位置。因此，如果您的默认网关是`192.168.1.1`，您的子网是`255.255.255.0`或`/24`，您应该检查从`192.168.2.1`到`192.168.255.1`的其他默认网关。当您ping每个默认网关时，如果它有响应，您就知道该子网中可能有活动主机。这可以很容易地通过众所周知的bash
    `for`循环来完成：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that you have to look for your default gateway address and subnet
    to verify the details for each interface you are using. What if you could automate
    the process of finding these system details with a Python script? To begin this
    journey, start by extracting the details of the interfaces with the `netifaces`
    library.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您必须查找您的默认网关地址和子网，以验证您正在使用的每个接口的详细信息。如果您能够使用Python脚本自动化查找这些系统详细信息的过程会怎样呢？要开始这个旅程，请使用`netifaces`库提取接口的详细信息。
- en: Determining your interface details with the netifaces library
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用netifaces库确定您的接口详细信息
- en: We demonstrated how to find interface details using a Python script in [Chapter
    2](ch02.html "Chapter 2. The Basics of Python Scripting"), *The Basics of Python
    Scripting*. It was designed to find details on any system regardless of libraries,
    but it only found addresses based on a list of interface names provided. Also,
    it was a script that would not be considered very tight. Instead, we can use the
    `netifaces` library for Python to iterate through the addresses and discover the
    details.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了如何使用Python脚本在[第2章](ch02.html "第2章。Python脚本的基础")中找到接口详细信息，*Python脚本的基础*。它旨在找到任何系统的详细信息，而不考虑库，但它只能根据提供的接口名称列表找到地址。此外，它是一个不太严密的脚本。相反，我们可以使用Python的`netifaces`库来遍历地址并发现详细信息。
- en: 'This script uses a number of functions to accomplish specific tasks. The functions
    included are `get_networks`, `get_addresses`, `get_gateways`, and `get_interfaces`.
    These functions do exactly what you expect them to. The first function, `get_interfaces`,
    finds all the relevant interfaces for that system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用多个函数来完成特定任务。包括的函数有`get_networks`、`get_addresses`、`get_gateways`和`get_interfaces`。这些函数确切地做你期望它们做的事情。第一个函数`get_interfaces`找到该系统的所有相关接口：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second function identifies the gateways and returns them as a dictionary:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数确定网关并将其作为字典返回：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The third function identifies the addresses for each interface, which includes
    the MAC address, interface address (typically IPv4), broadcast address, and network
    mask. All of these details are sourced by passing the function for the interface
    name:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数确定每个接口的地址，包括MAC地址、接口地址（通常是IPv4）、广播地址和网络掩码。所有这些详细信息都是通过传递接口名称的函数来获取的：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The fourth, and last, function identifies the gateway IP from the dictionary
    provided by the `get_gateways` function to the interface. It then calls the `get_addresses`
    function to identify the rest of the details about the interface. All of this
    is then loaded into a dictionary that is keyed by the interface name:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个，也是最后一个函数，从`get_gateways`函数提供的字典中确定接口的网关IP。然后调用`get_addresses`函数来确定接口的其余详细信息。所有这些都被加载到一个以接口名称为键的字典中：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full script code can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本代码可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py)找到。
- en: 'The following screenshot highlights the execution of this script:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图突出显示了此脚本的执行：
- en: '![Determining your interface details with the netifaces library](img/B04315_03_8.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用netifaces库确定您的接口详细信息](img/B04315_03_8.jpg)'
- en: Now, we know that this is not directly related to scanning and identifying targets,
    but it is for eliminating targets. Those targets are your system; you will see
    once you start assessing some systems automatically that you will not want your
    system to be in the list. We are going to highlight how to scan systems with the
    nmap libraries, identify the targetable services, and then eliminate any IP address
    that may be our system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道这与扫描和识别目标没有直接关系，但是用于消除目标。这些目标是您的系统；一旦您开始自动评估一些系统，您将会发现您不希望您的系统出现在列表中。我们将重点介绍如何使用Nmap库扫描系统，识别可定位的服务，然后消除可能是我们系统的任何IP地址。
- en: Nmap libraries for Python
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的Nmap库
- en: Python has libraries that allow you to execute `nmap` scans directly, either
    through the interactive interpreter or by building multifaceted attack tools.
    For this example, let's use the `nmap` library to scan our local Kali instance
    for a **Secure Shell** (**SSH**) service port. Make sure that the service has
    started by executing the `/etc/init.d/ssh start` command. Then install the Python
    `nmap` libraries with `pip install python-nmap`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Python有库可以直接执行`nmap`扫描，可以通过交互式解释器或构建多功能攻击工具。例如，让我们使用`nmap`库来扫描我们本地Kali实例的**Secure
    Shell** (**SSH**)服务端口。确保服务已启动，执行`/etc/init.d/ssh start`命令。然后使用`pip install python-nmap`安装Python的`nmap`库。
- en: 'You can now execute a scan by directly using the libraries, importing them,
    and assigning `nmap.PortScanner()` to a variable. That instantiated variable can
    then be used to execute scans. Let''s perform an example scan within the interactive
    interpreter. The following is an example of a scan for `port 22`, done using the
    interactive Python interpreter against the local Kali instance:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以直接使用库执行扫描，导入它们，并将`nmap.PortScanner()`分配给一个变量。然后可以使用实例化的变量来执行扫描。让我们在交互式解释器中执行一个示例扫描。以下是使用交互式Python解释器针对本地Kali实例进行`端口22`扫描的示例：
- en: '![Nmap libraries for Python](img/B04315_03_9.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_9.jpg)'
- en: As you can see, it's a dictionary of dictionaries that can each be called as
    necessary. It takes a little more effort to execute a scan through the interactive
    interpreter, but it is very useful in environments you may have gotten a foothold
    in that have Python, and it will allow you to install libraries during the course
    of your engagement. The bigger reason for doing this is scripting of methods that
    will make targeted exploitation easier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个可以根据需要调用的字典的字典。通过交互式解释器执行扫描需要更多的工作，但在您可能已经掌握了具有Python的环境中非常有用，并且它将允许您在参与过程中安装库。这样做的更大原因是编写将使有针对性的利用更容易的方法。
- en: 'To highlight this, we can create a script that accepts CLI arguments to scan
    for specific hosts and ports. Since we are accepting arguments from the CLI, we
    need to import the sys libraries, and because we are scanning with the `nmap`
    libraries, we need to import `nmap`. Remember to use conditional handlers when
    importing libraries that are not native to Python; it makes the maintainability
    of tools simple and it is far more professional:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出这一点，我们可以创建一个接受CLI参数的脚本，以扫描特定的主机和端口。由于我们从CLI接受参数，我们需要导入sys库，并且因为我们正在使用`nmap`库进行扫描，我们需要导入`nmap`。请记住，在导入Python中不是原生的库时使用条件处理程序；这样可以使工具的可维护性简单，并且更加专业。
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the libraries have been imported, the script can have the argument requirements
    designed. We need at least two arguments. This means that if there are less than
    two arguments or more than two, the script should fail with a help message. Remember
    that the script name counts as the first argument, so we have to increment it
    to `3`. The results of the required arguments produce the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库被导入，脚本可以设计参数要求。我们至少需要两个参数。这意味着如果参数少于两个或多于两个，脚本应该失败并显示帮助消息。请记住脚本名称算作第一个参数，所以我们必须将其增加到`3`。所需参数的结果产生以下代码：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if we run the `nmap_scanner.py` script without any arguments, we should
    get an error message, as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`nmap_scanner.py`脚本而没有任何参数，我们应该会收到错误消息，如下截图所示：
- en: '![Nmap libraries for Python](img/B04315_03_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_10.jpg)'
- en: 'This is the basic shell of the script into which you can then build the actual
    scanner. It is a very small component that amounts to instantiating the class
    and then passing to it the address and ports, which are then printed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本的基本框架，您可以在其中构建实际的扫描器。这是一个非常小的组件，相当于实例化类，然后将地址和端口传递给它，然后打印出来：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This fantastically small script provides you with the means to quickly execute
    the necessary scan, as shown in the following screenshot. This test shows the
    system''s virtual interface, which I have tested with both the localhost identifier
    and the interface IP address. There are two things to note when you are scanning
    with the localhost identifier: you will receive a hostname. If you are scanning
    the IP address of the system without querying a name service, you will not be
    able to identify the host name. The following screenshot shows the output of this
    script:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个极小的脚本为您提供了快速执行必要扫描的手段，如下截图所示。这个测试显示了系统的虚拟接口，我已经用本地主机标识符和接口IP地址进行了测试。在使用本地主机标识符进行扫描时，有两件事需要注意：您将收到一个主机名。如果您扫描系统的IP地址而没有查询名称服务，您将无法识别主机名。以下截图显示了此脚本的输出：
- en: '![Nmap libraries for Python](img/B04315_03_11.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_11.jpg)'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py)找到。
- en: So, the big benefit here is that now you can start automating exploitation of
    systems—to a point. These types of automation should be relatively benign so that
    if something fails, it causes no damage or impact to the environment's confidentiality,
    integrity, or availability. You can do this through the **Metasploit Framework's
    Remote Procedure Call** (**MSFRPC**), or by automatically building resource files
    that you can execute. For this example, let's simply build a resource file that
    can execute a credential attack to check for default Kali credentials; you did
    change them, right?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的重大好处是现在您可以开始自动化系统的利用——到一定程度。这些类型的自动化应该相对温和，以便如果某些事情失败，它不会对环境的保密性、完整性或可用性造成损害或影响。您可以通过**Metasploit
    Framework的远程过程调用**（**MSFRPC**）或通过自动构建可以执行的资源文件来执行此操作。例如，让我们简单地构建一个资源文件，该文件可以执行凭据攻击以检查默认的Kali凭据；您已经更改了它们，对吧？
- en: 'We need to generate a file by writing lines to it similar to the commands we
    would execute in the Metasploit Console. So look at the `ssh_login` module for
    Metasploit by performing `search ssh_login`, and then show the options after loading
    the console with `msfconsole`. Identify the required options. The following screenshot
    shows an example of items that can, and must, be set:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过编写类似于我们在Metasploit控制台中执行的命令的行来生成一个文件。因此，通过执行`search ssh_login`来查看Metasploit的`ssh_login`模块，然后在使用`msfconsole`加载控制台后显示选项。识别所需的选项。以下屏幕截图显示了可以设置的示例项目：
- en: '![Nmap libraries for Python](img/B04315_03_12.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_12.jpg)'
- en: Some of these items are already set, but the components that are missing are
    the remote host's IP address and the credentials we are going to test. The default
    port is set, but if your script is designed to test for different ports, then
    this must be set as well. You will notice that the credentials are not required
    fields, but to execute a credential attack, you do need them. To create this,
    we are going open and create a file using the `write` function within Python.
    We are also going to set the buffer size to zero so that data is automatically
    written to the file, unlike taking the operating system defaults to flush the
    data to the file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些项目已经设置，但缺少的组件是远程主机的IP地址和我们将要测试的凭据。默认端口已设置，但如果您的脚本设计用于测试不同端口，则也必须设置。您会注意到凭据不是必需字段，但要执行凭据攻击，您确实需要它们。为此，我们将使用Python中的`write`函数打开并创建一个文件。我们还将将缓冲区大小设置为零，以便数据自动写入文件，而不是采用操作系统默认值将数据刷新到文件。
- en: 'The script is also going to create a separate resource file that contains the
    IP address for each host that it identifies. The additional benefit that comes
    from running this script is that it creates a list of targets that have SSH enabled.
    In future, you should try to build scripts that are not designed for testing a
    single service, but this is a good example to get you started. We are going to
    build on the previous script concepts, but again we are going to build functions
    to modularize it. This will allow you to convert it into a class more easily in
    future. First, we add all the functions of the `ifacedetails.py` script and the
    libraries imported. We are then going to modify the argument code of the script
    so that it accepts more arguments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还将创建一个单独的资源文件，其中包含它识别的每个主机的IP地址。运行此脚本的附加好处是它创建了一个启用SSH的目标列表。将来，您应该尝试构建不仅设计用于测试单个服务的脚本，但这是一个很好的开始示例。我们将建立在先前的脚本概念基础上，但再次构建函数以模块化它。这将使您更容易将其转换为类。首先，我们添加`ifacedetails.py`脚本和导入的库的所有函数。然后我们将修改脚本的参数代码，以便它接受更多参数：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now build a function that is going to accept the details passed to it that
    will create a resource file. You will create string variables that contain the
    necessary values that will be written to the `ssh_login.rc` file. The details
    are then written to the file using the simple open command with the relevant `bufsize`
    of `0`, as mentioned earlier. The file now has string values written to it. Once
    the process is completed, the file is closed. Keep in mind when you look at the
    string values for the `set_rhosts` value. Notice that it points to a file that
    contains one IP address per line. So, we need to generate this file and then pass
    it to this function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建一个函数，它将接受传递给它的详细信息，然后创建一个资源文件。您将创建包含必要值的字符串变量，这些值将被写入`ssh_login.rc`文件。然后使用先前提到的简单打开命令和相关的`bufsize`将详细信息写入文件中。现在文件中已经写入了字符串值。完成该过程后，关闭文件。请记住，当您查看`set_rhosts`值的字符串值时。请注意，它指向一个包含每行一个IP地址的文件。因此，我们需要生成此文件，然后将其传递给此函数：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, let's build the actual `target_identifier` function, which will scan for
    targets using the nmap library using the port and IPs supplied. First, it clears
    the contents of the `ssh_hosts` file. Then it checks whether the scan was successful
    or not. If the scan was successful, the script initiates a `for` lookup for each
    host identified through the scan. For each of those hosts, it loads the interface
    dictionary and iterates through the key-and-value pairs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建实际的`target_identifier`函数，它将使用nmap库扫描使用提供的端口和IP的目标。首先，它清除`ssh_hosts`文件的内容。然后检查扫描是否成功。如果扫描成功，脚本将通过扫描识别的每个主机启动`for`查找。对于这些主机中的每一个，它加载接口字典并遍历键值对。
- en: 'The key holds the interface name, and the value is an embedded dictionary that
    holds the details for each of the values of that interface mapped to named keys,
    as shown in the previous `ifacedetails.py` script. The value of the the `''addr''`
    key is compared with the `host` from the scan. If the two match, then the host
    belongs to the assessor''s box and not the organization being assessed. When this
    happens, the host value is set to `None` and the target is not added to the `ssh_hosts`
    file. There is a final check to verify that the port is actually an SSH port and
    that it is open. Then the value is written to the `ssh_hosts` file and returned
    to the main function. The script does not block out the localhost IP address because
    we left it in for both testing and to highlight as a comparison, if you want to
    include this capability modifying this module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥保存接口名称，值是一个嵌入式字典，保存该接口的每个值的详细信息，映射到以前`ifacedetails.py`脚本中显示的命名键。`'addr'`键的值与扫描中的`host`进行比较。如果两者匹配，则主机属于评估者的盒子，而不是被评估的组织。当这种情况发生时，主机值设置为`None`，目标不会添加到`ssh_hosts`文件中。最后检查验证端口是否实际上是SSH端口并且是打开的。然后将该值写入`ssh_hosts`文件并返回给主函数。脚本不会阻止本地主机IP地址，因为我们留下它进行测试，并且要突出显示作为比较，如果您想包括这个功能，修改这个模块：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now the script needs some default values set prior to execution. The easiest
    way to do this is to set them after the argument validator. Take a look at your
    script, eliminate the duplicates outside of functions (if there are any), and
    place the following code after the argument validator:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本需要在执行之前设置一些默认值。最简单的方法是在参数验证器之后设置它们。查看您的脚本，在函数之外消除重复项（如果有的话），并在参数验证器之后放置以下代码：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One final change to the script is the inclusion of a test to see whether it
    was executed as a standalone script or it was an imported module. We have been
    executing these scripts natively without this, but it is best practice to include
    a simple check so that the script can be converted into a class. The only thing
    this check does is see whether the name of the module executed is `main`, and
    if it is, it means that it was a standalone script. When this happens, it sets
    `__name__` to `'__main__'`, signifying the standalone script.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一个更改是包含一个测试，以查看它是作为独立脚本执行还是作为导入模块执行。我们一直在执行这些脚本，但最好的做法是包含一个简单的检查，以便将脚本转换为类。这个检查的唯一作用是查看执行的模块的名称是否为`main`，如果是，那么它意味着它是一个独立的脚本。当这种情况发生时，它将`__name__`设置为`'__main__'`，表示独立脚本。
- en: 'Look at the following code, which executes the relevant functions in order
    of necessity. This is done to identify the viable hosts to exploit and then pass
    the details to the resource file generator:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码，按照必要性的顺序执行相关函数。这是为了识别可利用的主机并将详细信息传递给资源文件生成器：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will often see on the Internet scripts that call a `main()` function instead
    of a bunch of functions. This is functionally equivalent to what we are doing
    here, but you can create a `main()` function above the `if __name__ == ''__main__'':`
    that contains the preceding details, and then execute it as highlighted here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会在互联网上看到调用`main()`函数而不是一堆函数的脚本。这在功能上等同于我们在这里所做的，但是您可以创建一个`main()`函数，放在`if
    __name__ == '__main__':`上面，其中包含前面的细节，然后按照这里突出显示的方式执行它：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With these minor changes, you can automatically generate resource files based
    on the results of a scan. Finally, change the script name to `ssh_login.py` and
    then save and run it. When the script is run, it generates the code necessary
    for configuring and executing the exploit. Then you can run the resource file
    with the `-r` option, as shown in the following screenshot. As you may have noticed,
    I did a test run that included my interface IP address to highlight the built-in
    error checking, and then executed the test against localhost. I verified that
    the resource file was created correctly and then ran it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的改变，你可以根据扫描结果自动生成资源文件。最后，将脚本名称更改为`ssh_login.py`，然后保存并运行它。运行脚本时，它会生成配置和执行利用所需的代码。然后，您可以使用`-r`选项运行资源文件，如下面的截图所示。正如您可能已经注意到的，我进行了一次测试运行，包括我的接口IP地址，以突出显示内置的错误检查，然后对本地主机执行了测试。我验证了资源文件是否正确创建，然后运行它。
- en: '![Nmap libraries for Python](img/B04315_03_13.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_13.jpg)'
- en: Once in the console, you can see that the resource file executed the attack
    on its own with the following results. The green `+` sign means that a shell was
    opened on the Kali box.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入控制台，您可以看到资源文件独自执行了攻击，并获得了以下结果。绿色的`+`符号表示在Kali盒子上打开了一个shell。
- en: '![Nmap libraries for Python](img/B04315_03_14.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_14.jpg)'
- en: Resource files can also be called from within Metasploit using the `resource`
    command followed by the filename. This can be done for this attack with the following
    command resource `ssh_login.rc`, which would have produced the same results. You
    can then see the interaction with the new session opened up by initiating an interaction
    with the new session using the `session -i <session number>` command.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件也可以在Metasploit中使用`resource`命令调用，后面跟着文件名。对于这次攻击，可以使用以下命令调用资源`ssh_login.rc`，这将产生相同的结果。然后，您可以看到与使用`session
    -i <session number>`命令启动交互的新会话的交互。
- en: 'The following screenshot shows the validation of the username and hostname
    in the Kali instance:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Kali实例中验证用户名和主机名：
- en: '![Nmap libraries for Python](img/B04315_03_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Nmap库](img/B04315_03_15.jpg)'
- en: Of course, you would not want to do this to your normal attack box, but it provides
    three key items, and they need to be foot stomped. Always change your default
    password; otherwise, you may be a victim, even during an engagement. Also change
    your Kali instance hostname to something defensive network tools will not pick
    up, and always test your exploits prior to usage.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会想对你的正常攻击盒这样做，但它提供了三个关键项目，它们需要被强调。始终更改默认密码；否则，即使在参与过程中，你也可能成为受害者。还要更改你的Kali实例主机名为一些防御性网络工具不会检测到的内容，并且始终在使用之前测试你的漏洞利用。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details about the Python nmap library can be found at [http://xael.org/norman/python/python-nmap/](http://xael.org/norman/python/python-nmap/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python nmap库的更多详细信息，请访问[http://xael.org/norman/python/python-nmap/](http://xael.org/norman/python/python-nmap/)。
- en: Now, with an understanding of nmap, nmap libraries, and the automated generation
    of Metasploit resource files, you are ready to start learning about scapy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过对nmap、nmap库和自动生成Metasploit资源文件的理解，你已经准备好开始学习scapy了。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py)找到。
- en: The Scapy library for Python
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的Scapy库
- en: Welcome to Scapy, the Python library that is designed to manipulate, send, and
    read packets. Scapy is one of those tools that have a large amount of applicability,
    but it can seem complex to use. Before we set off, there are some basic rules
    to understand about Scapy that will make creating scripts much easier.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Scapy，这是一个设计用于操纵、发送和读取数据包的Python库。Scapy是那些具有广泛适用性的工具之一，但它可能看起来很复杂。在我们开始之前，有一些关于Scapy的基本规则需要理解，这将使创建脚本变得更容易。
- en: Firstly, refer to the previous sections to understand the TCP flags and how
    they are represented in Scapy. You will need to look at the flags mentioned earlier
    and their relevant positions to use them. Secondly, when Scapy receives responses
    for a packet sent, the flags are represented by binary bits in octal format within
    the 13th octet of a TCP header. So, you have to read the response based on this
    information.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，参考前面的部分，了解TCP标志及其在Scapy中的表示方式。你需要查看前面提到的标志及其相关位置来使用它们。其次，当Scapy接收到发送的数据包的响应时，标志由TCP头的第13个八位字节中的八进制格式的二进制位表示。因此，你必须根据这些信息来读取响应。
- en: 'Look at the following table, which represents the binary positional values
    of each flag as it is set:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下表，它表示了每个标志的二进制位置值：
- en: '![The Scapy library for Python](img/B04315_03_16.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Scapy库](img/B04315_03_16.jpg)'
- en: So when you are reading the responses from the TCP packets and looking for a
    specific type of flag, you have to do the math. The preceding table will help
    simplify this for you, but keep in mind if you have ever played with or worked
    with `tcpdump` that the material transmitted is identical. As an example, if you
    were looking for an SYN packet, you would see the value of the 13th octet as 2\.
    If it was SYN + ACK, it would be a value of 18\. Simply add the flag values together
    and you will have what you are looking for.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你从TCP数据包的响应中寻找特定类型的标志时，你必须进行计算。前面的表将帮助简化这一过程，但请记住，如果你曾经使用过或者使用过`tcpdump`，那么传输的材料是相同的。例如，如果你正在寻找一个SYN数据包，你会看到第13个八位字节的值为2。如果是SYN
    + ACK，它的值将是18。只需将标志值相加，你就会得到你要找的内容。
- en: The next thing to keep in mind is that if you try to ping the loopback interface
    or localhost, the packet will not be assembled. This is because the kernel intercepts
    the request and processes it internally through the TCP/IP stack of the system.
    This is one of the errors that people get stuck with on with Scapy and often quit.
    So, instead of digging into fixing your packets so that they can hit your own
    Kali instance, spin up your Metasploitable instance or try and test your default
    gateway.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要记住的一件事是，如果你尝试ping回环接口或本地主机，数据包将不会被组装。这是因为内核拦截了请求，并通过系统的TCP/IP堆栈在内部处理。这是人们在使用Scapy时经常遇到的错误之一，他们经常因此放弃。因此，与其深入修复数据包以便它们能够到达你自己的Kali实例，不如启动你的Metasploitable实例或尝试测试你的默认网关。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to understand more about testing loopback interfaces or the localhost
    value, you can find the solution at [http://www.secdev.org/projects/scapy/doc/troubleshooting.html](http://www.secdev.org/projects/scapy/doc/troubleshooting.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于测试回环接口或本地主机值的信息，你可以在[http://www.secdev.org/projects/scapy/doc/troubleshooting.html](http://www.secdev.org/projects/scapy/doc/troubleshooting.html)找到解决方案。
- en: Therefore, we are going to highlight testing a connection and then scanning
    a web port with Scapy. You have to understand that Scapy has multiple ways of
    sending and receiving packets, and depending on the data you want to extract,
    complex methods may not be necessary. First, look at what you are trying to accomplish.
    If you want to remain independent of the operating system, the two methods you
    should use are `sr()` for layer 3 and `srp()` for layer 2\. Next, if the method
    has `1` after the function name but before the `()` sign, such as `sr1()`, it
    means that it returns only the first answer. This can be plenty to achieve most
    results, but if there are multiple packets in a stream that need to be evaluated,
    you will want to forego these types of methods.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将重点介绍使用Scapy测试连接，然后扫描Web端口。你必须了解，Scapy有多种发送和接收数据包的方法，取决于你想要提取的数据，可能不需要复杂的方法。首先，看看你想要实现什么。如果你想保持独立于操作系统，你应该使用`sr()`来处理第3层数据，使用`srp()`来处理第2层数据。接下来，如果方法在函数名后面但在`()`符号前面有`1`，比如`sr1()`，这意味着它只返回第一个答案。这通常足以实现大多数结果，但如果有多个数据包需要评估，你将需要放弃这些类型的方法。
- en: Next is the `send()` method, which uses the operating system defaults for layer
    2 and some operating system capabilities for layer 3 and above. Finally, there
    is `sendp()`, which uses a custom layer 2 header. This can be created using the
    `Ether()` method to represent the Ethernet frame header. This is extremely useful
    for wireless networks or locations where **Virtual Local Area Networks** (**VLANs**)
    are used to segment networks based on theoretical security. This is because wireless
    communication operates at layer 2, and VLANs are identified in this layer as well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`send()`方法，它使用操作系统默认的第2层和一些操作系统能力的第3层及以上。最后是`sendp()`，它使用自定义的第2层头部。这可以使用`Ether()`方法来表示以太网帧头部。这对于无线网络或基于理论安全性的**虚拟局域网**（VLAN）分割网络的地方非常有用。这是因为无线通信在第2层操作，VLAN也在这一层被识别。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Access Control Lists** (**ACL**) based on VLANs are considered a cause of
    annoyance by most assessors, not security. This is because in most networks, you
    can easily hop network segments by manipulating the header of layer 2 frames.
    As you gain more experience, you will regularly see examples of this on live networks.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基于VLAN的访问控制列表（ACL）被大多数评估者认为是一个烦恼的原因，而不是安全性。这是因为在大多数网络中，你可以通过操纵第2层帧的头部轻松地跳转网络段。随着经验的增加，你将经常在实际网络中看到这方面的例子。
- en: 'So, import the Scapy library and then set a variable with the destination IP
    address you want to ping. Create a packet that will contain the communication
    details and flags that you want sent to the target host. Then set a response variable
    to catch the results of the `sr1()` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，导入Scapy库，然后设置一个变量，其中包含你想要ping的目标IP地址。创建一个数据包，其中包含你想要发送到目标主机的通信细节和标志。然后设置一个响应变量来接收`sr1()`函数的结果：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![The Scapy library for Python](img/B04315_03_17.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Scapy库](img/B04315_03_17.jpg)'
- en: 'Now that you see that you got one answer, it means that the host is most likely
    up. You can validate it with the following test:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到你得到了一个答案，这意味着主机很可能是存活的。你可以通过以下测试来验证：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you test this, you can see that the results of the ping scan were successful,
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试这个时，你会看到ping扫描的结果是成功的，如下所示：
- en: '![The Scapy library for Python](img/B04315_03_18.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Scapy库](img/B04315_03_18.jpg)'
- en: 'We successfully pinged the host and validated the response variable by proving
    that it was not empty. From this, we can now check whether it has a web port open.
    To accomplish this, we will execute an SYN scan. Before doing this, however, understand
    that when you receive a response from the connection attempt, you receive both
    the answers and the unanswered data. So, the best thing to do is separate the
    two of them, and thanks to Scapy and Python syntax, this is extremely easy. You
    simply pass the response to two different variables, the first being the answers
    and the second being the unanswered, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地ping了主机，并通过证明响应变量不为空来验证了它。从这里，我们现在可以检查它是否有一个开放的web端口。为了实现这一点，我们将执行一个SYN扫描。然而，在这样做之前，要明白当你从连接尝试中收到一个响应时，你会收到答案和未答案数据。所以，最好的做法是将它们分开，幸运的是，由于Scapy和Python的语法，这是非常容易的。你只需将响应传递给两个不同的变量，第一个是答案，第二个是未答案，如下所示：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this simple change, you now have the data returns cleaned up for easier
    manipulation. Furthermore, you can get summaries from these details by simply
    appending `.summary()` to `answers` or `unanswers`. If you are iterating through
    a list of ports from `0` to `1024`, you can look at the specific results by a
    specific port by passing the value to the `answers` variable by position in the
    list. So, if you want to see the results from a scan at port `80` for the answers,
    you can pass the value to the list like this: `answers[80]`. This holds both sent
    and received packets for these answers, but these can further be split just like
    the previous example, as shown in this code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的改变，你现在可以清理数据返回，以便更容易操作。此外，你可以通过简单地在`answers`或`unanswers`后附加`.summary()`来从这些细节中获得摘要。如果你正在迭代从`0`到`1024`的端口列表，你可以通过将值按位置传递给`answers`变量来查看特定端口的具体结果。所以，如果你想要查看端口`80`的答案扫描结果，你可以像这样将值传递给列表：`answers[80]`。这些答案都包含了发送和接收的数据包，但这些可以像前面的例子一样进一步分割，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keep in mind that this example only works for port `80`, as you designated the
    location you wanted to pull the data from. If you had not passed a positional
    value to the `answers` variable, you would have put all the sent packets in the
    `sent` variable and all the received packets in the `received` variable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个例子只适用于端口`80`，因为你指定了你想要从中提取数据的位置。如果你没有将一个位置值传递给`answers`变量，你将把所有发送的数据包放在`sent`变量中，所有接收的数据包放在`received`变量中。
- en: 'Now that you have the basics listed, you can develop a packet, send it to a
    target, and receive the results. One thing to cover before moving forward is how
    easy it is to build a packet from the ground up, which involves building the IP
    header first and then the TCP header. Next, you pass the data to the scanner,
    which identifies the target as either alive or not. You can configure it so that
    there is no timeout value, but I highly discourage this as you may have to wait
    forever with no return. The following script was run to identify the `192.168.195.1`
    host and determine whether a web port was open:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经列出了基本信息，你可以开发一个数据包，发送到目标，然后接收结果。在继续之前需要讨论的一件事是，从头开始构建一个数据包是多么容易，首先构建IP头部，然后是TCP头部。接下来，你将数据传递给扫描器，它会识别目标是存活还是不存活。你可以配置它，使之没有超时值，但我强烈不建议这样做，因为你可能永远等待而没有返回。下面的脚本是用来识别`192.168.195.1`主机，并确定web端口是否开放的：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see in the following screenshot, the system responded with an answer.
    The preceding script can run standalone, or you can use the interactive interpreter
    to execute each line, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的截图中所看到的，系统做出了回应。前面的脚本可以独立运行，或者你可以使用交互式解释器执行每一行，就像这里所示的那样：
- en: '![The Scapy library for Python](img/B04315_03_19.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Scapy库](img/B04315_03_19.jpg)'
- en: 'Now the details can be extracted from the `answers` variable. Remember that
    this is a list, so you should increment each of the values. The first packet sent
    would be represented by position 0, so each location after that represents the
    IP packets received after the original:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以从`answers`变量中提取细节。请记住，这是一个列表，所以你应该递增每个值。发送的第一个数据包将由位置0表示，因此之后的每个位置表示原始数据包之后接收到的IP数据包：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here is what the catch is, though each value in the list is actually another
    list with more data in it. In Python, we call this a matrix, but do not fret!
    It is pretty easy to navigate. First, remember that we used the `sr()` function,
    so this means that the results will be from layer 3 and above. Each embedded list
    is for the protocol above it; in this case, it will be TCP. We performed a SYN
    scan, so we are looking for a SYN + ACK response. Look at the preceding section
    to compute the value you are looking for. As you can see by referencing the preceding
    section related to TCP flags, the value you are looking for in header is 18 to
    verify a SYN + ACK response, which can be calculated by adding the positional
    value of `ACK = 16` and the positional value of `SYN = 2`. The following screenshot
    shows the actual result, which shows that the port is open. Understanding these
    concepts will allow you to use Scapy in future scripts.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表中的每个值实际上是另一个包含更多数据的列表。在Python中，我们称之为矩阵，但不要担心！它很容易导航。首先，请记住我们使用了`sr()`函数，这意味着结果将来自第3层及以上。每个嵌套列表都是用于上面的协议；在这种情况下，它将是TCP。我们执行了一个SYN扫描，因此我们正在寻找一个SYN
    + ACK响应。查看前面的部分来计算你要找的值。通过参考与TCP标志相关的前面部分，你会发现在头部中你要找的值是18，以验证SYN + ACK响应，这可以通过添加`ACK
    = 16`的位置值和`SYN = 2`的位置值来计算。下面的截图显示了实际结果，显示端口是打开的。理解这些概念将使你能够在未来的脚本中使用Scapy。
- en: '![The Scapy library for Python](img/B04315_03_21.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Python的Scapy库](img/B04315_03_21.jpg)'
- en: You now have a basic understanding of Scapy, but don't worry! You are not done
    with it yet. Scapy has a significant amount of capability, which we have only
    touched on, and it provides you with the means to not only execute simple scans,
    but also manipulate network traffic. Many embedded devices and **Industrial Control
    Systems** (**ICS**) use unique communication forms to provide command and control
    for other units. At other times, you will realize that you need to identify live
    devices when nmap is being blocked. Scapy can help you fulfill all of these tasks.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对Scapy有了基本的了解，但不用担心！你还没有完成它。Scapy具有相当多的功能，我们只是触及了一部分，并且它不仅可以执行简单的扫描，还可以操纵网络流量。许多嵌入式设备和工业控制系统使用独特的通信形式来为其他单元提供命令和控制。有时，当nmap被阻止时，你会意识到需要识别活动设备。Scapy可以帮助你完成所有这些任务。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, a lot of details about identifying live hosts on the network,
    viable targets, and the different communication models were covered. To facilitate
    your understanding of the protocols and how they communicate, we discussed their
    different forms at the packet and frame levels. This chapter culminated with the
    automated exploitation of hosts using the Python `nmap` and `Scapy` libraries
    supporting the target identification. In the next chapter, we will build on these
    concepts to see how to exploit services with dictionary, brute-force, and password
    spray attacks.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，涵盖了关于在网络上识别活动主机、可行的目标以及不同通信模型的许多细节。为了帮助你理解协议以及它们的通信方式，我们讨论了它们在数据包和帧级别的不同形式。本章以使用Python的`nmap`和`Scapy`库自动利用主机来支持目标识别而告终。在下一章中，我们将在这些概念的基础上，看看如何利用字典、暴力和密码喷射攻击来利用服务。
