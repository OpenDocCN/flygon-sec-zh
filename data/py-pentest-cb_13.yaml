- en: Windows Exploit Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows利用开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Windows memory layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows内存布局
- en: Buffer overflow attacks with saved return pointer overwrites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用保存的返回指针覆盖的缓冲区溢出攻击
- en: Structured Exception Handling (SEH)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化异常处理（SEH）
- en: Egg hunters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋猎手
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will go through some Windows-based vulnerabilities and the exploit
    techniques using Python. The solution for the exploit development tasks is to
    replace the program instructions with our instructions to manipulate the application
    behavior. We will be using an Immunity Debugger for debugging the applications.
    As the victim machine will be a Windows machine, we require a machine with Window
    XP OS installed on it. We are using the old XP version for the ease of exploiting,
    and the sample applications with vulnerabilities will work in XP.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些基于Windows的漏洞以及使用Python的利用技术。利用开发任务的解决方案是用我们的指令替换程序指令，以操纵应用程序行为。我们将使用Immunity
    Debugger来调试应用程序。由于受害机器将是Windows机器，我们需要一台安装了Windows XP操作系统的机器。我们使用旧版XP以便于利用，并且具有漏洞的示例应用程序将在XP中运行。
- en: Windows memory layout
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows内存布局
- en: The Windows OS memory has a number of sections that can be considered as the
    high-level components. To write exploits and take advantage of vulnerable programs,
    we have to understand the memory structure and its sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统内存有许多部分，可以被视为高级组件。为了编写利用并利用有漏洞的程序，我们必须了解内存结构及其各个部分。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting the exploit script writing, we have to get an idea about the
    structure of the Windows memory layout.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写利用脚本之前，我们必须了解Windows内存布局的结构。
- en: 'Let''s have a look at the memory structure for an executable:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下可执行文件的内存结构：
- en: '![](img/00073.gif)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.gif)'
- en: As we use a stack and heap in most cases of exploits, we can start with these.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数利用中我们使用堆栈和堆，我们可以从这些开始。
- en: The stack
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: The stack is used for short-term local storage in an ordered manner. Each thread
    in an application has a stack. A unique stack with a fixed size is assigned for
    a thread or a function when it is called. The size of the stack is defined when
    the application or thread starts. Also, this stack gets destroyed when this function
    or thread gets finished. The stack is mainly used to store local variables, save
    function return pointers, function argument exception handler records, and much
    more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈用于有序的短期本地存储。应用程序中的每个线程都有一个堆栈。当调用线程或函数时，为其分配一个具有固定大小的唯一堆栈。堆栈的大小在应用程序或线程启动时定义。此堆栈在函数或线程完成时被销毁。堆栈主要用于存储局部变量、保存函数返回指针、函数参数异常处理程序记录等。
- en: 'The stack builds up the data from bottom of the stack to the top, from a high
    memory address to a low memory address:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈从堆栈底部到顶部构建数据，从高内存地址到低内存地址：
- en: '![](img/00074.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: The heap
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: The heap is used dynamically for allocation memory. The heap is used in a situation
    when the application is unaware of the data it will receive or process. So, the
    heap is used to store global variables and values assigned in a disorganized manner.
    The heap is freed only when the application is terminated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是用于动态分配内存的。当应用程序不知道将接收或处理的数据时，堆将用于存储以无序方式分配的全局变量和值。堆仅在应用程序终止时才被释放。
- en: 'The heap grows opposite to the stack. It grows from the lower addresses to
    the higher addresses:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的增长与堆栈相反。它从较低的地址增长到较高的地址：
- en: '![](img/00075.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: Program image and dynamic link libraries
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序映像和动态链接库
- en: The program image is the location where the actual executable is stored in memory.
    The executables will be in **portable executable** (**PE**) format and include
    the executable and the DLL. Within this section, there are some items defined,
    such as the PE header, `.text`, `.rdata`, `.data`, and so on. The PE header defines
    the header information for the rest of the executable and `.text` includes the
    code segments. `.rdata` is the read only data segment and `.rsrc` is the section
    in which resources such as icons, menus, and fonts for the executable are stored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 程序映像是实际可执行文件存储在内存中的位置。可执行文件将以**可移植可执行文件**（**PE**）格式存在，并包括可执行文件和DLL。在这个部分中，定义了一些项目，如PE头、`.text`、`.rdata`、`.data`等。PE头定义了可执行文件的其余部分的头信息，`.text`包括代码段。`.rdata`是只读数据段，`.rsrc`是存储可执行文件的资源，如图标、菜单和字体的部分。
- en: Process Environment Block (PEB)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程环境块（PEB）
- en: When we run an application, an instance of that executable will run as a process
    and provide the required resources to run that application. The process attribute
    in which the non-kernel components of the running process are stored is PEB. Also,
    PEB resides in the user-accessible memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行一个应用程序时，该可执行文件的一个实例将作为一个进程运行，并提供运行该应用程序所需的资源。存储运行进程的非内核组件的进程属性是PEB。此外，PEB驻留在用户可访问的内存中。
- en: For more details on PEB structures, follow this link: [https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PEB结构的更多详细信息，请访问此链接：[https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)
- en: Thread Environment Block (TEB)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程环境块（TEB）
- en: Some process may have one or more threads. In that case, each process starts
    with a single primary thread and creates more additional threads when required.
    Also, all these threads share the same virtual addresses. Each thread has its
    own resources which include the exception handlers, local storage, and much more.
    So, like PEB, each thread has TEB. TEB also resides in the process address space.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进程可能有一个或多个线程。在这种情况下，每个进程都从一个单一的主线程开始，并在需要时创建更多的附加线程。此外，所有这些线程共享相同的虚拟地址。每个线程都有自己的资源，包括异常处理程序、本地存储等。因此，就像PEB一样，每个线程都有TEB。TEB也驻留在进程地址空间中。
- en: You can read more on processes and threads in the following article: [https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx)
    Also, more on TEB structures can be found here: [https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文章中了解有关进程和线程的更多信息：[https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx)
    此外，有关TEB结构的更多信息可以在此处找到：[https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx)
- en: We require a Windows XP machine installed with an Immunity Debugger for analyzing
    a sample application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个安装了Immunity Debugger的Windows XP机器来分析示例应用程序。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here are the steps to understand the basic usage of Immunity Debugger:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是了解Immunity Debugger基本用法的步骤：
- en: Open the Immunity Debugger in the Windows machine.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows机器中打开Immunity Debugger。
- en: 'Then load a program to analyze in the Immunity Debugger. From the menu, select
    File | Open and select the application to monitor:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后加载一个要在Immunity Debugger中分析的程序。从菜单中选择文件 | 打开并选择要监视的应用程序：
- en: '![](img/00076.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: 'We can view the memory map by opening the Memory map. You can open it from
    the menu View | Memory or by hitting the *Alt* + *M* keys:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过打开内存映射来查看内存映射。您可以从菜单查看 | 内存中打开它，或者按下*Alt* + *M*键：
- en: '![](img/00077.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'This will open up the following pane:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开以下窗格：
- en: '![](img/00078.gif)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.gif)'
- en: This is the memory map for the application opened in the Immunity Debugger.
    This includes all stacks, heaps , DLLs, and the executable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Immunity Debugger中打开的应用程序的内存映射。这包括所有堆栈、堆、DLL和可执行文件。
- en: 'You can view the stack as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式查看堆栈：
- en: '![](img/00079.gif)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.gif)'
- en: 'DLLs can be identified as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DLLs可以被识别如下：
- en: '![](img/00080.gif)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.gif)'
- en: 'A program image and its contents will be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序图像及其内容将如下所示：
- en: '![](img/00081.gif)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.gif)'
- en: 'DLLs, TEB, and PEB will be identified as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DLLs、TEB和PEB将被识别如下：
- en: '![](img/00082.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.gif)'
- en: 'We can get the memory dump of PEB and TEB by right-clicking on the address
    and selecting the Dump option:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过右键单击地址并选择转储选项来获取PEB和TEB的内存转储：
- en: '![](img/00083.gif)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.gif)'
- en: Buffer overflow with saved return pointer overwrite
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用保存的返回指针覆盖的缓冲区溢出
- en: In this recipe, we will discuss exploiting an application with buffer overflow
    vulnerability and with a saved return pointer overwrite.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将讨论利用具有缓冲区溢出漏洞和保存的返回指针覆盖的应用程序。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: We can use **FreeflotFTP** as the vulnerable application. You can get the application
    from: [https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip](https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**FreeflotFTP**作为易受攻击的应用程序。您可以从以下网址获取该应用程序：[https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip](https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip)。
- en: The vulnerable machine environment is Windows XP. So run Windows XP in a real
    or virtual environment and install the Immunity Debugger in it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 易受攻击的机器环境是Windows XP。因此在真实或虚拟环境中运行Windows XP并在其中安装Immunity Debugger。
- en: Installing Mona
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Mona
- en: We need to install Mona, a `pycommand` module for the Immunity Debugger. To
    do this, download the `mona.py` from: [https://github.com/corelan/mona](https://github.com/corelan/mona).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装Mona，这是Immunity Debugger的`pycommand`模块。为此，请从以下网址下载`mona.py`：[https://github.com/corelan/mona](https://github.com/corelan/mona)。
- en: 'Then, add the `mona.py` to the `pyCommands` folder inside `Immunity Debugger`
    application folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`mona.py`添加到`Immunity Debugger`应用程序文件夹内的`pyCommands`文件夹中：
- en: '![](img/00084.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow the steps to create an exploit for buffer overflow attack:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建缓冲区溢出攻击的利用：
- en: In a Windows machine, start the Immunity Debugger and open the vulnerable application
    in it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows机器上，启动Immunity Debugger并在其中打开易受攻击的应用程序。
- en: As it is an FTP server, we can try to crash the application by connecting it
    from another machine.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是一个FTP服务器，我们可以尝试通过从另一台机器连接来使应用程序崩溃。
- en: 'We can write a script to connect to the FTP server with Python. To do this,
    create an `ftp_exploit.py` and open it in your editor:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以编写一个Python脚本来连接到FTP服务器。为此，创建一个名为`ftp_exploit.py`的文件并在编辑器中打开它：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates a large chunk of data and posts to the FTP server in the Windows
    machine. By sending this, the program will crash:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Windows机器上创建大量数据并将其发送到FTP服务器。通过发送这个，程序将崩溃：
- en: '![](img/00085.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Here you can see that the EIP register is overwritten by the buffer we provided.
    Also, ESP and EDI registers also contain our buffer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到EIP寄存器被我们提供的缓冲区覆盖。此外，ESP和EDI寄存器也包含我们的缓冲区。
- en: 'Next, we have to analyze the crash. To do this, we need to replace the `A`
    in the payload with a pattern. We can generate patterns with the following script:
    [https://github.com/Svenito/exploit-pattern](https://github.com/Svenito/exploit-pattern).'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要分析崩溃。为了做到这一点，我们需要用模式替换有效负载中的`A`。我们可以使用以下脚本生成模式：[https://github.com/Svenito/exploit-pattern](https://github.com/Svenito/exploit-pattern)。
- en: Download the script
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下载脚本
- en: 'We need to generate a pattern with exactly the same payload as we provided
    before. With the script download, generate the pattern with 1,000 characters.
    Copy the generated pattern:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要生成一个与我们之前提供的完全相同的有效负载模式。使用脚本下载，生成包含1,000个字符的模式。复制生成的模式：
- en: '![](img/00086.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'Update the Python scripts with the pattern as the payload. So, replace the
    following line in the script:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模式作为有效负载更新Python脚本。因此，请在脚本中替换以下行：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now restart the application in the Immunity Debugger which is running in the
    test machine:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新启动在测试机器中运行的Immunity Debugger中的应用程序：
- en: '![](img/00087.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'Then run the Python script again:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后再次运行Python脚本：
- en: '![](img/00088.gif)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.gif)'
- en: This will also crash the application, but the EIP register is updated with a
    part of the patterns we injected
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会使应用程序崩溃，但EIP寄存器会更新为我们注入的模式的一部分
- en: 'Now we can use the `mona` for analyzing the crash. Run the following command
    in the Immunity Debugger console:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`mona`来分析崩溃。在Immunity Debugger控制台中运行以下命令：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00089.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: From this we can identify that the EIP register is overwritten by the 4-bytes
    after the 247th.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以确定EIP寄存器被247后的4个字节覆盖了。
- en: So now we can update the pattern which could exactly overwrite the EIP register
    with the data we want.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更新模式，确切地覆盖EIP寄存器为我们想要的数据。
- en: 'So, we can try writing A for the first 247 and then 4 B for EIP register and
    add the padding with C, as we need 1,000\. Then update the Python script with
    the new payload:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以尝试在前247个位置写入A，然后在EIP寄存器中写入4个B，并用C填充，因为我们需要1000个。然后用新的有效载荷更新Python脚本：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Restart the application inside the debugger and run the Python script again.
    This will also crash the application. But, check the registers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中重新启动应用程序并再次运行Python脚本。这也会使应用程序崩溃。但是，检查寄存器：
- en: '![](img/00090.gif)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.gif)'
- en: Now the EIP is overwritten by the value we provided. Here it is `42424242,`
    which is `BBBB`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在EIP被我们提供的值覆盖了。这里是`42424242`，也就是`BBBB`。
- en: 'Now we have to replace `BBBB` with the pointer to redirect the execution flow
    to the ESP register. We can make use of `mona` to find this pointer:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须用指针替换`BBBB`，以将执行流重定向到ESP寄存器。我们可以利用`mona`来找到这个指针：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00091.gif)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.gif)'
- en: We can use the first pointer from the list, which is `77def069`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表中的第一个指针，即`77def069`。
- en: 'Now craft the payload with the pointer we selected. Make sure to reverse the
    byte order to match the Little Endian architecture of the CPU. Update the Python
    script with the following value in the `evil`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用我们选择的指针来制作有效载荷。确保反转字节顺序以匹配CPU的小端架构。在`evil`中更新Python脚本的以下值：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now restart the application in the Immunity Debugger and set a break point
    at `77def069`. You can go to the address with the Go to option in the Immunity
    Debugger:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Immunity Debugger中重新启动应用程序，并在`77def069`处设置断点。您可以使用Immunity Debugger中的Go to选项转到该地址：
- en: '![](img/00092.jpeg)![](img/00093.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)![](img/00093.jpeg)'
- en: 'Set the Breakpoint as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点如下：
- en: '![](img/00094.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: Select the Memory, on access option.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择内存，选择访问选项。
- en: 'Then run the Python script. This will break the application at the breakpoint
    and we can view the registers as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行Python脚本。这将在断点处使应用程序中断，我们可以查看寄存器如下：
- en: '![](img/00095.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: 'Now we can generate the shell code from Metasploit and include it in the payload:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从Metasploit生成shell代码并将其包含在有效载荷中：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00096.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: 'Update the script with the shell code. Then the script will be as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用shell代码更新脚本。然后脚本将如下所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Restart the application in the debugger and run the Python script. This will
    inject the shell code. Now we can try connecting to the victim machine with `nc`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试器中重新启动应用程序并运行Python脚本。这将注入shell代码。现在我们可以尝试用`nc`连接受害机：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/00097.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: Structured Exception Handling
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化异常处理
- en: 'The **Structured Exception Handling** (**SEH**) is a protection mechanism to
    prevent the buffer overflows. SEH uses a linked list as it contains a sequence
    of data records. When an exception occurs, the OS will go through this list and
    check for the suitable exception function. For this, the exception handler requires
    a pointer to the current exception registration record (SEH) and another pointer
    to the next exception registration record (nSEH). As the Windows stack grows downwards,
    the order will be reversed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化异常处理**（SEH）是一种防止缓冲区溢出的保护机制。SEH使用链表，因为它包含一系列数据记录。当发生异常时，操作系统将遍历此列表并检查适当的异常函数。为此，异常处理程序需要指向当前异常注册记录（SEH）的指针和指向下一个异常注册记录（nSEH）的另一个指针。由于Windows堆栈向下增长，顺序将被颠倒：'
- en: '![](img/00098.gif)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.gif)'
- en: So, if we can overwrite the SEH with a `POP POP RETN` instruction, the POP will
    remove four bytes from the top of the stack and the RETN will return an execution
    to the top of the stack. As the SEH is located at `esp+8`, we can increment the
    stack with eight bytes and return to the new pointer at the top of the stack.
    Then we will be executing nSEH. So, we can add a four-byte opcode to jump to another
    memory location where we can include the shell.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们可以用`POP POP RETN`指令覆盖SEH，POP将从堆栈顶部移除四个字节，RETN将返回执行到堆栈顶部。由于SEH位于`esp+8`，我们可以用八个字节增加堆栈，并返回到堆栈顶部的新指针。然后我们将执行nSEH。因此，我们可以添加一个四字节的操作码来跳转到另一个内存位置，我们可以在其中包含shell。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we are going to work with another vulnerable application: DVD
    X Player 5.5 PRO. You can download it from: [https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip](https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用另一个易受攻击的应用程序：DVD X Player 5.5 PRO。您可以从以下网址下载：[https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip](https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip)。
- en: As in the previous recipe, we need a victim machine, Windows XP, installed with
    the Immunity Debugger and `mona.py`. Also, install the downloaded application,
    DVD X Player 5.5 PRO, in the Windows machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个教程一样，我们需要一台受害机器，安装有Immunity Debugger和`mona.py`的Windows XP。还要在Windows机器上安装下载的应用程序DVD
    X Player 5.5 PRO。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create an exploit script for SEH attack:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为SEH攻击创建利用脚本的步骤：
- en: 'Start the Immunity Debugger in the Windows machine and attach the vulnerable
    application to it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows机器上启动Immunity Debugger并将易受攻击的应用程序附加到其中：
- en: '![](img/00099.jpeg)![](img/00100.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)![](img/00100.jpeg)'
- en: Create a Python file called `dvd_exploit.py` to exploit or the DVD player and
    open it in your editor.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dvd_exploit.py`的Python文件来利用DVD播放器，并在编辑器中打开它。
- en: 'As we are creating an exploit based on a file format, we will be creating a
    playlist file (`.plf`) with a long buffer in it and allow the DVD player to read
    it. Due to the long buffer, the DVD player will crash with the buffer overflow.
    So, the victim needs to open the playlist file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在基于文件格式创建利用，我们将创建一个播放列表文件（.plf），其中包含一个很长的缓冲区，并允许DVD播放器读取它。由于缓冲区很长，DVD播放器将因缓冲区溢出而崩溃。因此，受害者需要打开播放列表文件：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then create the playlist file by running the Python script and open it with
    the player:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过运行Python脚本创建播放列表文件并用播放器打开它：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a `evil.plf` file
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`evil.plf`文件
- en: Open it in the DVD player. Then the player will crash.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DVD播放器中打开它。然后播放器会崩溃。
- en: 'Check the registers for the crash. Also pass the crash with the *Shift* + *F9*
    keys:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 检查崩溃的寄存器。还可以使用*Shift* + *F9*键通过崩溃：
- en: '![](img/00101.gif)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.gif)'
- en: 'Here in the register, there are many zeros because the SEH zeroed them. And
    then we can check the SEH chain to verify that we have overwritten the SEH:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器中有许多零，因为SEH将它们清零。然后我们可以检查SEH链以验证我们是否已覆盖了SEH：
- en: '![](img/00102.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: 'Now, we can generate a pattern and update the script to generate the playlist
    file. We have downloaded a script to generate the pattern for the previous recipe.
    We can use the same script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以生成一个模式并更新脚本以生成播放列表文件。我们已经下载了一个脚本来为之前的配方生成模式。我们可以使用相同的脚本：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the `pattern` in the Python script and generate the payload file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Python脚本中的`pattern`并生成有效载荷文件：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the generated playlist file in the application. It will crash. Now we
    can use the `mona.py` to analyze the crash and get us the details. To do this,
    run the following command in the Immunity Debugger console:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中打开生成的播放列表文件。它会崩溃。现在我们可以使用`mona.py`来分析崩溃并获取详细信息。为此，在Immunity Debugger控制台中运行以下命令：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/00103.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: From this we can infer that SEH is the 4 bytes after 608.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以推断出SEH是608之后的4个字节。
- en: 'So we can craft our test payload so that it will be like `buffer = "A"*604
    + [nSEH] + [SEH] + "D"*1384`. We can add `BBBB` for nSEH and `CCCC` for SEH:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以制作我们的测试有效载荷，使其类似于`buffer = "A"*604 + [nSEH] + [SEH] + "D"*1384`。我们可以为nSEH添加`BBBB`，为SEH添加`CCCC`：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then our script will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的脚本将如下所示：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the script and generate the playlist file and open it with the application.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并生成播放列表文件，然后用应用程序打开它。
- en: 'Now we need to get a valid pointer, as we need to overwrite SEH with a pointer.
    To do this, we can use `mona.py`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要获得一个有效的指针，因为我们需要用指针覆盖SEH。为了做到这一点，我们可以使用`mona.py`：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00104.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Select `s` pointer from this one. Here we can select the following one:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从中选择`s`指针。在这里我们可以选择以下一个：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can update the `buffer` in the script to write this to the SEH:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更新脚本中的`buffer`，将其写入SEH：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, our script will be as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的脚本将如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the script and generate the playlist file and a breakpoint at the SEH.
    Then, load it in to the DVD player application. Now check the SEH memory location.
    We can find that the pointer we put in the SEH is converted to opcode:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并生成播放列表文件并在SEH处设置断点。然后，将其加载到DVD播放器应用程序中。现在检查SEH内存位置。我们可以发现我们放在SEH中的指针被转换为操作码：
- en: '![](img/00105.gif)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.gif)'
- en: Next we can insert an opcode to make a short jump from nSEH to our padding area
    with the `D`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以插入一个操作码，使nSEH向我们的填充区域进行短跳转。
- en: 'Now we can generate a shell code with Metasploit and update the script to include
    the shell code. We can use the same shell code generated for the previous recipe.
    Now our exploit code will be as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用Metasploit生成shell代码，并更新脚本以包含shell代码。我们可以使用为之前的配方生成的相同shell代码。现在我们的利用代码将如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now generate the payload file with the script.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用脚本生成有效载荷文件。
- en: Run the application in the debugger and load the payload.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试器中运行应用程序并加载有效载荷。
- en: 'Now we can run the `nc` command to connect to the system:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行`nc`命令连接到系统：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Egg hunters
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Egg hunters
- en: In the buffer overflow, we hijack the execution flow and redirect to a CPU register
    that contains part of our buffer and the instructions in that buffer will be executed.
    But, if the buffer size is very small we can't inject any payload. So we can't
    exploit the vulnerability. In such cases, we have to check two possible options.
    First check if the location of the buffer, before overwriting the EIP register,
    is located in the memory. The other option is a buffer segment in a different
    region of the memory and nearby so that we can jump to the offset.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区溢出中，我们劫持执行流并重定向到包含我们缓冲区一部分和该缓冲区中的指令的CPU寄存器。但是，如果缓冲区大小非常小，我们无法注入任何有效载荷。因此，我们无法利用这个漏洞。在这种情况下，我们必须检查两种可能的选项。首先检查EIP寄存器被覆盖之前缓冲区的位置是否位于内存中。另一个选项是内存中不同区域的缓冲区段，附近的缓冲区段，以便我们可以跳转到偏移量。
- en: An egg hunter is created with a set of instructions that are translated to opcode.
    So, the egg hunters can be used to search the entire memory range, including the
    stack and heap, for the final stage shell code and redirect the execution flow
    to the shell code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组指令创建了一个egg hunter，这些指令被翻译成操作码。因此，egg hunters可以用于搜索整个内存范围，包括堆栈和堆，以查找最终阶段的shell代码，并将执行流重定向到shell代码。
- en: Egg hunters include a user-defined four-byte tag, which will be used to search
    through the memory until it finds this tag repeated twice. When it finds the tag,
    it will redirect the execution flow to just after the tag where our shell code
    resides.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Egg hunters包括一个用户定义的四字节标记，它将用于在内存中搜索，直到找到这个标记重复两次为止。当它找到标记时，它将重定向执行流到标记后面，我们的shell代码所在的地方。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We require another application for demonstrating this method of creating an
    exploit. Here we use the Kolibri v2.0 HTTP Server. This can be downloaded from: [https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip](https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个应用程序来演示创建利用的方法。在这里，我们使用Kolibri v2.0 HTTP服务器。可以从以下网址下载：[https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip](https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip)。
- en: Our victim machine is a Windows XP 32 bit machine. Make sure to install the
    Immunity Debugger with `mona.py` in it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的受害机是一个Windows XP 32位机器。确保在其中安装了带有`mona.py`的Immunity Debugger。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to generate an exploit script with egg hunters:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用egg hunters生成利用脚本的步骤：
- en: We have to create a new exploit file. So create `kolibri_exploit.py` and open
    it in your editor.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建一个新的利用文件。因此创建`kolibri_exploit.py`并在编辑器中打开它。
- en: 'We can start with a big buffer submitting to the server. So add the following
    code. Make sure to update the IP address with the correct IP address of your vulnerable
    machine:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从向服务器提交一个大缓冲区开始。因此添加以下代码。确保使用正确的IP地址更新IP地址为您的易受攻击机器的正确IP地址：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the vulnerable application with the debugger as File | Open and select
    the `kolibri.exe`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试器打开易受攻击的应用程序，选择`kolibri.exe`。
- en: 'Then run the exploit script we created:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行我们创建的利用脚本：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will crash the application as usual:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将像往常一样使应用程序崩溃：
- en: '![](img/00106.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'Then change the `A` buffer with the pattern. We can use the pattern generator
    to create a pattern. Update the code with the pattern. Our script will be as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后用模式更改`A`缓冲区。我们可以使用模式生成器创建一个模式。用模式更新代码。我们的脚本将如下所示：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Restart the application and run the script again. This will also crash the
    application. Then use `mona` to get the details about registers. To do this, provide
    the following command in the Immunity Debugger console:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序并再次运行脚本。这也将使应用程序崩溃。然后使用`mona`获取有关寄存器的详细信息。为此，在Immunity Debugger控制台中提供以下命令：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/00107.gif)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.gif)'
- en: From this we can identify that the EIP can be overwritten by four bytes after
    515 bytes
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以确定在515字节后EIP可以被四个字节覆盖
- en: 'Based on the information, we can update the buffer as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据信息，我们可以更新缓冲区如下：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can get an address to redirect the execution flow to the ESP register.
    For that we can make use of `mona.py`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以获取一个地址，将执行流程重定向到ESP寄存器。为此，我们可以使用`mona.py`：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/00108.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: 'We can select one of the pointers from this and place it in our buffer. We
    can select the following pointer:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中选择一个指针，并将其放置在我们的缓冲区中。我们可以选择以下指针：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, we will place the egg hunter in the buffer and make a short jump to that.
    To do this, we have to include the opcode for the short jump at the end. So, update
    the buffer accordingly with the pointer and the opcode for the short jump. The
    opcode short jump can be calculated as follows. The short jump opcode starts with
    `\xEB` followed by the distance we need to jump. Here we have to jump 60 bytes
    back.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在缓冲区中放置egg hunter，并进行短跳转。为此，我们必须在最后包含短跳转的操作码。因此，相应地更新缓冲区，包括指针和短跳转的操作码。短跳转的操作码可以计算如下。短跳转操作码以`\xEB`开头，后面跟着我们需要跳转的距离。这里我们需要向后跳转60个字节。
- en: 'So convert the -60 decimal to Hex with the calculator:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用计算器将-60十进制转换为十六进制：
- en: '![](img/00109.jpeg)![](img/00110.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)![](img/00110.jpeg)'
- en: 'Now, combining these two, the opcode will be `\xEB\xC4` as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，结合这两者，操作码将如下所示：`\xEB\xC4`
- en: 'Now, our script will be as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的脚本将如下所示：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now restart the application and the debugger and run the script again. With
    this execution, the flow will redirect to ESP from EIP, as ESP contains our short
    jump and it will jump back 60 bytes to end up in the area where we put the `A`
    buffer:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新启动应用程序和调试器，再次运行脚本。通过这个执行，流程将从EIP重定向到ESP，因为ESP包含我们的短跳转，并且它将向后跳转60个字节，最终到达我们放置`A`缓冲区的区域：
- en: '![](img/00111.gif)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.gif)'
- en: Now we can generate an egg hunter with `mona.py` and include it in the script.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`mona.py`生成一个egg hunter，并将其包含在脚本中。
- en: 'Issue the following commands in the Immunity Debugger console and copy the
    generated egg hunter code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Immunity Debugger控制台中发出以下命令，并复制生成的egg hunter代码：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](img/00112.gif)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.gif)'
- en: 'Update the script with the egg hunter code. Now our script will be as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用egg hunter代码更新脚本。现在我们的脚本将如下所示：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now generate the shell code with Metasploit and include the shell in the script
    to push the shell code to the server. So our final script with the shell code
    will be as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用Metasploit生成shell代码，并将shell包含在脚本中，将shell代码推送到服务器。因此，我们的最终脚本将如下所示：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now restart the application in the debugger and run the script to exploit.
    Check the exploit with the `nc` command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在调试器中重新启动应用程序并运行脚本进行利用。使用`nc`命令检查利用：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
