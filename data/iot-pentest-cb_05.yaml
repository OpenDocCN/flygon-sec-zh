- en: Exploiting IoT Mobile Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用物联网移动应用程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Acquiring IoT mobile applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取物联网移动应用程序
- en: Decompiling Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反编译Android应用程序
- en: Decrypting iOS applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密iOS应用程序
- en: Using MobSF for static analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MobSF进行静态分析
- en: Analyzing iOS data storage with idb
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用idb分析iOS数据存储
- en: Analyzing Android data storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Android数据存储
- en: Performing dynamic analysis testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行动态分析测试
- en: In consumer, and some commercial, IoT devices, there is an accompanied mobile
    application employed to fulfill a purpose. For instance, a mobile application
    may report analytical data to a server in a fleet management infrastructure, or
    the application may be given delegated control to start a car engine. In each
    case, data is likely stored in the mobile application and can be manipulated to
    perform unintended actions. To start discovering vulnerabilities and reverse engineering
    mobile applications, similar methodologies discussed in [Chapter 3](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml),
    *Analyzing and Exploiting* *Firmware *can also be applied to the mobile space.
    An application must first be acquired; afterwards, the application can be statically
    analyzed, dynamically analyzed, and can also be repackaged where applicable. This
    chapter will assist with assessing IoT mobile applications in an effort to exploit
    common vulnerabilities discovered in the field.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者和一些商业的物联网设备中，通常会配备一个移动应用程序来实现某种目的。例如，移动应用程序可能会向车队管理基础设施的服务器报告分析数据，或者该应用程序可能被授予委托控制启动汽车发动机。在每种情况下，数据很可能存储在移动应用程序中，并且可以被操纵以执行意外的操作。为了开始发现漏洞并逆向工程移动应用程序，可以将[第3章](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml)中讨论的类似方法应用于移动空间。首先必须获取应用程序；之后，可以对应用程序进行静态分析、动态分析，并在适用的情况下重新打包。本章将帮助评估物联网移动应用程序，以便利用在该领域发现的常见漏洞。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In mobile application security testing, there is a four-phase methodology which
    can be categorized by the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序安全测试中，有一个四阶段的方法论，可以按以下方式分类：
- en: '**Application mapping**: Application mapping pertains to the application''s
    logic and the application''s business function. Think of application mapping as
    gathering information about the application to be used in the next phase.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序映射**：应用程序映射涉及应用程序的逻辑和业务功能。将应用程序映射视为收集有关应用程序的信息，以便在下一阶段使用。'
- en: '**Client-side attacks**: Client-side attacks pertain to data being stored in
    the application and how that data can be manipulated from the client side.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端攻击**：客户端攻击涉及存储在应用程序中的数据以及如何从客户端进行操纵。'
- en: '**Network attacks**: Network attacks pertain to network layer concerns such
    as SSL/TLS or maybe XMPP protocol data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络攻击**：网络攻击涉及网络层的问题，如SSL/TLS或XMPP协议数据。'
- en: '**Server attacks**: Server attacks apply to API vulnerabilities and backend
    server misconfigurations brought to light as a result of API testing.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器攻击**：服务器攻击适用于API漏洞和后端服务器配置错误，这些问题是由API测试揭示的。'
- en: 'This methodology may vary if testing is conducted via a white box or black
    box perspective. What is relevant from both the white and black box testing perspective
    is the **Mobile Application Security Verification Standard** (**MASVS**). The
    MASVS aimed to establish a framework of security requirements needed to design,
    develop, and test mobile applications for both iOS and Android ([https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf](https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf)).
    In addition, trends and patterns of common vulnerabilities that affect both Android
    and iOS applications have been identified and translated into a checklist created
    to accompany the MASVS, which testers as well as developers can follow when assessing
    an application ([https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx](https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx)).
    The checklist also contains links to OWASP''s Mobile Testing Guide, which is still
    in progress but is at a mature stage. The MASVS and the checklist point out many
    potential vulnerabilities and the requirements for mitigation. Some of the most
    common vulnerabilities within the IoT space include:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过白盒或黑盒视角进行测试，这种方法可能会有所不同。从白盒和黑盒测试视角都相关的是**移动应用程序安全验证标准**（**MASVS**）。MASVS旨在建立所需的安全要求框架，以设计、开发和测试iOS和Android移动应用程序（[https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf](https://www.owasp.org/images/f/fe/MASVS_v0.9.3.pdf)）。此外，已经确定了影响Android和iOS应用程序的常见漏洞的趋势和模式，并将其转化为一个检查表，以配合MASVS，测试人员和开发人员在评估应用程序时可以遵循该检查表（[https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx](https://www.owasp.org/images/1/1b/Mobile_App_Security_Checklist_0.9.3.xlsx)）。该检查表还包含到OWASP的移动测试指南的链接，该指南仍在进行中，但已经处于成熟阶段。MASVS和检查表指出了许多潜在的漏洞和缓解要求。物联网空间中一些最常见的漏洞包括：
- en: Hardcoded sensitive values
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码的敏感值
- en: Verbose logging
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗长的日志记录
- en: Session management weaknesses
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理漏洞
- en: Caching of sensitive data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感数据的缓存
- en: Insecure data storage
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的数据存储
- en: Data leakage
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据泄露
- en: API communication
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API通信
- en: These common types of vulnerabilities can occur due to the type of application
    (native or hybrid) but are also introduced via poor coding practices. In this
    chapter, many of the common vulnerabilities listed will be demonstrated on both
    mobile platforms. Applying these methodologies and the checklist is outside of
    the scope of this book, however it is a good idea to use them as a reference when
    attacking IoT mobile applications. For simplicity, we will take the path of statically
    analyzing mobile applications then work towards dynamically analyzing the mobile
    applications during runtime. To get started, we need the target application binaries
    to start the process of testing an IoT mobile app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常见的漏洞可能是由于应用程序的类型（原生或混合）而产生，但也可能是由于糟糕的编码实践引入的。在本章中，将演示许多常见漏洞在两个移动平台上的情况。虽然本书不涵盖这些方法和检查表，但在攻击物联网移动应用时，使用它们作为参考是个好主意。为了简单起见，我们将选择静态分析移动应用的路径，然后逐步向运行时动态分析移动应用。要开始，我们需要目标应用的二进制文件来开始测试物联网移动应用的过程。
- en: While we will put more emphasis on static as well as dynamic testing in this
    chapter, there is also runtime analysis testing, which consists of instrumenting
    and break pointing the target application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章中我们将更加强调静态和动态测试，但也有运行时分析测试，包括对目标应用进行插装和断点设置。
- en: Acquiring IoT mobile applications
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取物联网移动应用
- en: The first step in assessing an IoT device's mobile application is acquiring
    and installing the app for the target platform. Usually, if an IoT device has
    an Android app, there is also an iOS app available as well. To install an application
    for Android, Google Play Store is used, which also shares basic information about
    the app. For iOS applications, Apple's App Store is used to install an app to
    an iDevice. However, the raw application binaries are not made available and cannot
    be obtained via the Play Store or App Store. The application binaries or packages
    are known as Android packages or APK, and **iOS App Store Package Archive** (**IPA**)
    for iOS. If you happen to be testing an application from a white box perspective,
    these binaries will be given to you without the need of exploring ways to obtain
    the app binaries. If you are testing from a black box perspective for research
    purposes, you may be wondering how we are going to get our hands on the application
    binaries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 评估物联网设备的移动应用的第一步是获取并安装目标平台的应用。通常，如果物联网设备有一个安卓应用，也会有一个iOS应用。要安装安卓应用，使用Google
    Play商店，它也会分享有关应用的基本信息。对于iOS应用，使用苹果的App Store来安装应用到iDevice。然而，原始应用程序二进制文件并不是公开的，也无法通过Play商店或App
    Store获得。应用程序二进制文件或包被称为安卓包或APK，以及iOS的**iOS App Store Package Archive**（IPA）。如果你是从白盒的角度测试应用，这些二进制文件将会直接提供给你，无需探索获取应用程序二进制文件的方法。如果你是出于研究目的从黑盒的角度测试，你可能会想知道我们将如何获取应用程序二进制文件。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the next steps, we will discuss methods of acquiring apps for Android and
    iOS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将讨论获取安卓和iOS应用的方法。
- en: 'Android has plenty of third-party app stores that can be used to download APK
    files. However, there are some caveats to consider when using these third-party
    app stores. Sometimes, the app stores do not have an updated version of the app,
    or have an incorrect app altogether. It is important to verify the hash, version,
    and contents of the app prior to installation of the Play Store''s version. Some
    third-party app stores claim to have an app you are looking for but they end up
    being masked as spyware apps that require unnecessary permissions. The cool part
    about downloading Android apps from third-party app stores is the ability to download
    older versions of an application as well as their historical release notes. Select
    a third-party app store, such as [https://apps.evozi.com](https://apps.evozi.com)
    and [https://apkpure.com/](https://apkpure.com/), search for the target Android
    app, and download the APK as seen in the following screenshots:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安卓有很多第三方应用商店可以用来下载APK文件。但是，在使用这些第三方应用商店时需要考虑一些注意事项。有时，应用商店没有更新的应用版本，或者根本就是错误的应用。在安装Play商店版本之前，验证应用的哈希值、版本和内容是很重要的。一些第三方应用商店声称有你要找的应用，但最终却被伪装成需要不必要权限的间谍软件应用。从第三方应用商店下载安卓应用的一个很酷的地方是能够下载应用的旧版本以及它们的历史发布说明。选择一个第三方应用商店，比如[https://apps.evozi.com](https://apps.evozi.com)和[https://apkpure.com/](https://apkpure.com/)，搜索目标安卓应用，并按照以下截图中的步骤下载APK文件：
- en: '![](img/2eb46de1-b127-4060-a5eb-c7ee9b29d7e3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eb46de1-b127-4060-a5eb-c7ee9b29d7e3.png)'
- en: 'The next screenshot shows the Subaru application being downloaded from [https://app.evozi.com](https://app.evozi.com):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了从[https://app.evozi.com](https://app.evozi.com)下载Subaru应用程序：
- en: '![](img/d730a5cd-9ca5-4bdc-b7a5-0c8cacca4bdd.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d730a5cd-9ca5-4bdc-b7a5-0c8cacca4bdd.png)'
- en: For iOS, obtaining an IPA file is a lot more difficult from a black box perspective.
    In contrast to Android, there are no similar third-party app stores to choose
    from. This is due to iOS applications being encrypted by Apple's FairPlay DRM.
    This is a bit of a challenge without the necessary tools. In subsequent recipes,
    a walkthrough of decrypting an iOS application will be given. Feel free to skip
    to the *Decrypting iOS applications* recipe if you're focusing on iOS testing.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于iOS来说，从黑盒的角度获取IPA文件要困难得多。与安卓相比，没有类似的第三方应用商店可供选择。这是因为苹果的FairPlay DRM加密了iOS应用。没有必要的工具，这是一个挑战。在接下来的教程中，将介绍解密iOS应用的步骤。如果你专注于iOS测试，可以直接跳到*解密iOS应用*的教程。
- en: Decompiling Android applications
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反编译安卓应用
- en: With a target IoT app and APK file downloaded, the application can now be decompiled
    to view its contents. For Android apps, this task can be completed in a matter
    of minutes. Later, automation testing techniques for statically analyzing an app
    will be covered in more detail. Decompiling an application is one of the first
    steps in reverse engineering an application to manipulate its functions. Apps
    can also be recompiled and packaged after modification, however this is out of
    scope for our purposes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有了目标IoT应用程序和下载的APK文件，现在可以对应用程序进行反编译以查看其内容。对于Android应用程序，这个任务可以在几分钟内完成。稍后，将更详细地介绍静态分析应用程序的自动化测试技术。反编译应用程序是逆向工程应用程序以操纵其功能的第一步。应用程序也可以在修改后重新编译和打包，但这超出了我们的范围。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To decompile an Android app, we will make use of Enjarify and JD-GUI. Enjarify
    translates Dalvik bytecode to Java bytecode which will be used to analyze it further
    with JD-GUI. JD-GUI is a Java decompiler used to view Java code. Both tools are
    included in the accompanied virtual machine:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要反编译Android应用程序，我们将使用Enjarify和JD-GUI。Enjarify将Dalvik字节码转换为Java字节码，然后使用JD-GUI进一步分析。JD-GUI是一个用于查看Java代码的Java反编译器。这两个工具都包含在附带的虚拟机中：
- en: 'Enjarify can be downloaded via the GitHub repository at: [https://github.com/google/enjarify](https://github.com/google/enjarify).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enjarify可以通过GitHub存储库下载：[https://github.com/google/enjarify](https://github.com/google/enjarify)。
- en: Enjarify does require Python 3 as a dependency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Enjarify确实需要Python 3作为依赖项。
- en: 'JD-GUI is available via the GitHub repository at: [https://github.com/java-decompiler/jd-gui/releases](https://github.com/java-decompiler/jd-gui/releases).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JD-GUI可以通过GitHub存储库获得：[https://github.com/java-decompiler/jd-gui/releases](https://github.com/java-decompiler/jd-gui/releases)。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, enter the Enjarify folder path and point Enjarify to the target APK.
    In this case, the APK is in the same directory as Enjarify:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，输入Enjarify文件夹路径，并将Enjarify指向目标APK。在这种情况下，APK与Enjarify在同一个目录中：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open JD-GUI and drag over the JAR file Enjarify created:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开JD-GUI并拖动Enjarify创建的JAR文件：
- en: '![](img/2a53fc0b-6e22-4dbd-aa77-6655fd55895a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a53fc0b-6e22-4dbd-aa77-6655fd55895a.png)'
- en: 'Now the Java classes can be read and understood for further analysis. For example,
    instances where `rawQuery` is used to save data to SQLite can be searched in an
    effort to identify SQL injections, as seen in the following screenshot. Other
    keywords, such as `*keys*`, `execSQL`, or `*password*`, are also common search
    terms:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以阅读和理解Java类，以进行进一步的分析。例如，可以搜索使用`rawQuery`保存数据到SQLite的实例，以便识别SQL注入，如下面的屏幕截图所示。其他关键字，如`*keys*`，`execSQL`或`*password*`，也是常见的搜索词：
- en: '![](img/c2fd41df-c00f-4543-aee4-9765bc6e1bc5.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2fd41df-c00f-4543-aee4-9765bc6e1bc5.png)'
- en: 'This technique has been used to locate hardcoded secrets such as the iBeacons
    values embedded within the **Consumer Electronics Show** (**CES**) mobile app,
    used for the scavenger hunt contest ([http://www.ibeacon.com/the-beacons-at-ces-were-hacked/](http://www.ibeacon.com/the-beacons-at-ces-were-hacked/)):'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种技术已经被用来定位硬编码的秘密，比如嵌入在**消费电子展**（**CES**）移动应用程序中的iBeacons值，用于寻宝比赛（[http://www.ibeacon.com/the-beacons-at-ces-were-hacked/](http://www.ibeacon.com/the-beacons-at-ces-were-hacked/)）：
- en: '![](img/f9625703-ddff-4420-9883-8de21bf07271.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9625703-ddff-4420-9883-8de21bf07271.png)'
- en: With hardcoded beacons published in CES's mobile app, everyone can play without
    needing to be in Las Vegas. Simple, right? Having Java pseudocode is much easier
    to read than smali/baksmali code. This may not always be the case if forms of
    obfuscation are utilized or the app makes use of C/C++, but that is app-specific.
    Additional understanding of how an application functions will be gained, which
    can be tested and verified via runtime or dynamic analysis.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用硬编码的信标发布在CES的移动应用程序中，每个人都可以玩，而不需要在拉斯维加斯。简单，对吧？拥有Java伪代码比阅读smali/baksmali代码要容易得多。如果应用程序使用了混淆形式，或者应用程序使用了C/C++，情况可能并非总是如此，但这是特定于应用程序的。将获得对应用程序功能的额外理解，这可以通过运行时或动态分析进行测试和验证。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: OWASP's Mobile Security Testing Guide provides additional details on reverse
    engineering Android applications and tampering techniques ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md)
    and [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP的移动安全测试指南提供了有关反向工程Android应用程序和篡改技术的更多详细信息（[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05b-Basic-Security_Testing.md)和[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)）。
- en: Decrypting iOS applications
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密iOS应用程序
- en: Since iOS apps are encrypted by Apple's FairPlay DRM, unencrypted versions are
    not available for download via third-party app stores. To view the contents of
    an iOS app, it must be first decrypted and extracted. Although encrypted IPA files
    can be downloaded directly from iTunes, it is a manual process to decrypt the
    app manually using tools like otool, lldb, and dd. Thankfully, this process has
    been automated using a tool known as Clutch2.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iOS应用程序由苹果的FairPlay DRM加密，因此无法通过第三方应用商店下载未加密的版本。要查看iOS应用程序的内容，必须首先对其进行解密和提取。尽管可以直接从iTunes下载加密的IPA文件，但是使用otool、lldb和dd等工具手动解密应用程序是一个手动过程。幸运的是，使用一个名为Clutch2的工具已经自动化了这个过程。
- en: Dumpdecrypted is another tool that can be used to dump decrypted iOS applications
    to a file, but will not be used in this chapter. Dumpdecrypted can be found via
    the repository at [https://github.com/stefanesser/dumpdecrypted](https://github.com/stefanesser/dumpdecrypted).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Dumpdecrypted是另一个工具，可以用来将解密的iOS应用程序转储到文件中，但本章不会使用。Dumpdecrypted可以在存储库中找到：[https://github.com/stefanesser/dumpdecrypted](https://github.com/stefanesser/dumpdecrypted)。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, otool will be used, which is included with XCode''s command-line
    tools. Installing XCode command-line tools can be accomplished by executing the
    following command in an OS X terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，将使用otool，它包含在XCode的命令行工具中。可以通过在OS X终端中执行以下命令来安装XCode命令行工具：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Clutch2 will be used to decrypt applications. Clutch2 can be downloaded via
    the GitHub repository at [https://github.com/KJCracks/Clutch](https://github.com/KJCracks/Clutch)
    or installed via Cydia on your jailbroken device by adding [http://cydia.iphonecake.com](http://cydia.iphonecake.com)
    as a source and searching for Clutch 2.0, as seen in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Clutch2将用于解密应用程序。可以通过GitHub存储库[https://github.com/KJCracks/Clutch](https://github.com/KJCracks/Clutch)下载Clutch2，也可以通过Cydia在越狱设备上安装Clutch
    2.0，方法是添加[http://cydia.iphonecake.com](http://cydia.iphonecake.com)作为源，并搜索Clutch
    2.0，如下屏幕截图所示：
- en: '![](img/ace9bd7b-8fdd-442d-baa2-5b1109a7f707.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ace9bd7b-8fdd-442d-baa2-5b1109a7f707.png)'
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To find out if an application is encrypted, the IPA must be renamed to a ZIP
    file and the application binary must be located inside of the extracted folder
    that was renamed. For example, run the following commands against the application
    binary itself, not the IPA file, to check whether the app is encrypted. If the
    value for `cryptid` is `1`, this means the application is encrypted:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出应用程序是否加密，必须将IPA文件重命名为ZIP文件，并且必须在重命名的提取文件夹内找到应用程序二进制文件。例如，对应用程序二进制文件运行以下命令，而不是对IPA文件运行，以检查应用程序是否加密。如果`cryptid`的值为`1`，则表示应用程序已加密：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is now established that the application is encrypted. Decrypting the application
    manually is out of scope, however the application decryption process can be automated
    utilizing `Clutch2`. When running `Clutch2` without any arguments, all installed
    applications are listed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经确定应用程序已加密。手动解密应用程序超出了范围，但是可以利用`Clutch2`自动化应用程序解密过程。运行`Clutch2`而不带任何参数时，将列出所有已安装的应用程序：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, dump the application to be decrypted by using the `-d` flag and selecting
    the number. In this case, the app to be decrypted and dumped is number one:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`-d`标志和选择数字来转储要解密的应用程序。在这种情况下，要解密和转储的应用程序是编号为一的应用程序：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The application is now decrypted. Transfer the decrypted app from the iDevice
    over to the host computer using `scp` as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序现在已解密。使用`scp`将解密的应用程序从iDevice传输到主机计算机，方法如下：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Rename the decrypted IPA file to a ZIP, similar to the steps taken to verify
    if an app is encrypted in the previous exercise:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解密后的IPA文件重命名为ZIP，类似于之前练习中用来验证应用程序是否加密的步骤：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Change to the `Payload/STARLINK.app` directory where the application binary
    resides:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Payload/STARLINK.app`目录，该目录包含应用程序二进制文件：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The application binary''s contents can be disassembled using tools such as
    Hopper for further analysis. Class information can also be dumped with `class-dump`
    and analyzed further with a disassembler. For instance, examining how credentials
    are stored within the application''s `saveCredentialsToKeychain` class can now
    be performed via Hopper as seen in the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用诸如Hopper之类的工具对应用程序二进制文件的内容进行反汇编以进行进一步分析。还可以使用`class-dump`转储类信息，并通过反汇编器进行进一步分析。例如，可以通过Hopper执行以下屏幕截图中所示的方式来检查应用程序的`saveCredentialsToKeychain`类中存储凭据的方式：
- en: '![](img/dd3a0aad-01a7-418b-bc91-63691a2c4483.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd3a0aad-01a7-418b-bc91-63691a2c4483.png)'
- en: With additional knowledge of an application's classes and methods, functions
    of the application can be manipulated and tested via dynamic or runtime analysis.
    Dynamic testing will be covered later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对应用程序的类和方法有额外的了解，可以通过动态或运行时分析来操纵和测试应用程序的功能。动态测试将在本章后面进行介绍。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: OWASP's Mobile Security Testing Guide provides additional details on dumping
    encrypted iOS applications ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md)).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP的移动安全测试指南提供了有关转储加密iOS应用程序的详细信息（[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md)）。
- en: Using MobSF for static analysis
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MobSF进行静态分析
- en: Given that the application binaries for Android and iOS have been obtained,
    we can perform further analysis using automated techniques. A great open source
    Python tool that can be leveraged for both Android and iOS is the **Mobile Security
    Framework** (**MobSF**). There are several features and capabilities MobSF can
    automate for us, particularly for Android apps. This recipe will demonstrate MobSF's
    automated static analysis features for both Android and iOS. Static analysis typically
    requires access to source code, however, decompiling Android and iOS applications
    can give us a form of pseudocode close to the original source.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于已获取了Android和iOS的应用程序二进制文件，我们可以使用自动化技术进行进一步分析。一个非常好的开源Python工具，可以用于Android和iOS的是**移动安全框架**（**MobSF**）。MobSF可以为我们自动化执行多项功能和能力，特别是对于Android应用程序。本步骤将演示MobSF对Android和iOS的自动静态分析功能。静态分析通常需要访问源代码，但是反编译Android和iOS应用程序可以为我们提供接近原始源代码的伪代码形式。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: MobSF is included in the accompanied virtual machine with version 0.9.5.2 beta.
    MobSF is constantly being updated and can be downloaded via [https://github.com/MobSF/Mobile-Security-Framework-MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF).
    Ensure all dependencies have been installed as listed in MobSF's documentation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MobSF包含在附带的虚拟机中，版本为0.9.5.2 beta。MobSF不断更新，可以通过[https://github.com/MobSF/Mobile-Security-Framework-MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)下载。确保已安装MobSF文档中列出的所有依赖项。
- en: Ensure target APKs and decrypted iOS IPA applications have been obtained. MobSF
    will not decrypt an iOS application automatically. The decrypted IPA file is required
    for MobSF to analyze the application and not the decrypted binary inside the app's
    Payload when renaming the IPA file to a ZIP, as MobSF performs this step automatically
    (MobSF is open source and can be modified to use the raw binary rather than the
    IPA). Clutch2 can dump the IPA file when using the `-d` flag on the iOS device.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已获取目标APK和解密的iOS IPA应用程序。MobSF不会自动解密iOS应用程序。MobSF需要解密的IPA文件来分析应用程序，而不是应用程序Payload中的解密二进制文件，当将IPA文件重命名为ZIP时，MobSF会自动执行此步骤（MobSF是开源的，可以修改为使用原始二进制文件而不是IPA）。Clutch2可以在iOS设备上使用`-d`标志转储IPA文件。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To start MobSF, run the following command in your Terminal:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动MobSF，请在终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The web-UI of MobSF should appear in your browser at the address `127.0.0.1:8000`,
    as seen in the following screenshot:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobSF的Web-UI应该出现在您的浏览器中，地址为`127.0.0.1:8000`，如下截图所示：
- en: '![](img/1b32c84f-ba07-4933-a4f9-43377b2b857d.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b32c84f-ba07-4933-a4f9-43377b2b857d.png)'
- en: Android static analysis
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android静态分析
- en: To start off, we will analyze an Android application. Drag the target APK to
    MobSF's web interface and MobSF will automatically decompile as well as analyze
    the application's content. Within this interface, the core Android components
    (ACTIVITIES, SERVICES, RECEIVERS, and PROVIDERS) are listed along with metadata
    about the application.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将分析一个Android应用程序。将目标APK拖放到MobSF的Web界面上，MobSF将自动反编译并分析应用程序的内容。在此界面中，列出了核心Android组件（活动、服务、接收器和提供者），以及有关应用程序的元数据。
- en: MobSF allows for the flexibility to use different Java decompilers and Dex to
    JAR converters. Have a look at the `MobSF/settings.py` configuration file for
    how to modify these settings.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MobSF允许灵活使用不同的Java反编译器和Dex到JAR转换器。查看`MobSF/settings.py`配置文件，了解如何修改这些设置。
- en: '![](img/b7888a1a-ae09-4d1c-8b13-26ee0ba6e904.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7888a1a-ae09-4d1c-8b13-26ee0ba6e904.png)'
- en: 'As you scroll down, MobSF analyzes app permissions, Android API usage, browsable
    activities, and many other static analysis features that may be of use. The area
    we will have a look at, and may be the most helpful, is the Code Analysis subsection.
    Here, MobSF has generously flagged poor coding practices as well as potential
    vulnerable pieces of code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着您向下滚动，MobSF会分析应用程序权限、Android API使用情况、可浏览的活动等许多其他静态分析功能，这些功能可能会有所帮助。我们将查看的区域，可能是最有帮助的，是代码分析子部分。在这里，MobSF慷慨地标记了糟糕的编码实践以及潜在的易受攻击的代码片段：
- en: '![](img/0437d8b1-95f5-42c3-8f1d-05479667f732.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0437d8b1-95f5-42c3-8f1d-05479667f732.png)'
- en: 'One of the handiest sections to use and look for is Files may contain hardcoded
    sensitive information like usernames, passwords, keys etc. The following are examples
    of Java classes that MobSF flagged, which may contain hardcoded data in the application:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中一个最方便的部分是查找文件可能包含硬编码的敏感信息，如用户名、密码、密钥等。以下是MobSF标记的可能在应用程序中包含硬编码数据的Java类的示例：
- en: '![](img/28f49cae-7706-44ac-8f87-3c273e93a0ce.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28f49cae-7706-44ac-8f87-3c273e93a0ce.png)'
- en: 'In mobile apps, it''s quite common to find hardcoded OAuth `client_secret`
    values and cloud provider API account credentials. A similar example was given
    earlier in the chapter with CES''s hardcoded iBeacons. When selecting one of the
    flagged Java classes, Java pseudocode will appear which demonstrates hardcoded
    values such as those in the following screenshot:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动应用程序中，很常见找到硬编码的OAuth `client_secret`值和云提供商API帐户凭据。在本章的前面部分，已经给出了CES的硬编码iBeacons的类似示例。当选择其中一个标记的Java类时，将显示Java伪代码，其中演示了硬编码的值，如下截图所示：
- en: 'In 2016, Samsung fell victim to hardcoding their `client_secret` within their
    SmartThings mobile application, granting attackers bearer tokens to access door
    locks. Additional details pertaining to this incident can be found in the following
    paper:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，三星成为了在其SmartThings移动应用程序中硬编码他们的`client_secret`的受害者，使攻击者能够获得访问门锁的令牌。有关此事件的更多详细信息可以在以下论文中找到：
- en: '[https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf](https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf](https://web.eecs.umich.edu/~earlence/assets/papers/smartthings_sp16.pdf)。'
- en: '![](img/8d8def19-06a8-4471-aaf5-3f040d48f0aa.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d8def19-06a8-4471-aaf5-3f040d48f0aa.png)'
- en: With MobSF, testing Android applications is a breeze. iOS apps, on the other
    hand, are not as cut and dry as the Android static analysis MobSF provides.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MobSF，测试Android应用程序变得轻而易举。另一方面，iOS应用程序并不像MobSF提供的Android静态分析那样简单明了。
- en: iOS static analysis
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS静态分析
- en: 'MobSF does provide helpful features for the static analysis of iOS applications.
    Like Android, the decrypted iOS IPA can be dragged over to MobSF''s web interface.
    MobSF will then rename the IPA to a ZIP, extract the contents, analyze plist files,
    check permissions that the app requests, and dump class information from the app,
    amongst other things. The following screenshot displays the landing page once
    the decrypted iOS IPA has been dragged over to MobSF. There are three main options
    that MobSF provides, including viewing the `Info.plist`, strings, and class dump:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobSF确实提供了有关iOS应用程序的静态分析的有用功能。与Android一样，解密后的iOS IPA可以拖放到MobSF的Web界面上。然后，MobSF将IPA重命名为ZIP，提取内容，分析plist文件，检查应用程序请求的权限，并从应用程序中转储类信息，等等。下面的截图显示了一旦解密的iOS
    IPA被拖放到MobSF后的着陆页面。MobSF提供了三个主要选项，包括查看`Info.plist`、字符串和类转储：
- en: '![](img/5eb678a5-2323-450f-89d6-3d801f6ca1a8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eb678a5-2323-450f-89d6-3d801f6ca1a8.png)'
- en: Ensure you adjust your `class-dump-z` path in MobSF's settings file, located
    in `MobSF/settings.py` and look for `CLASSDUMPZ_BINARY`. In my case, the path
    to `class-dump-z` is `/opt/iOSOpenDev/bin/class-dump-z`, however using the regular
    `class-dump` should work as well as `/opt/iOSOpenDev/bin/class-dump`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在MobSF的设置文件`MobSF/settings.py`中调整`class-dump-z`路径，并查找`CLASSDUMPZ_BINARY`。在我的情况下，`class-dump-z`的路径是`/opt/iOSOpenDev/bin/class-dump-z`，但是使用常规的`class-dump`也应该可以，以及`/opt/iOSOpenDev/bin/class-dump`。
- en: 'The first place you will want to have a look at is the `Info.plist` file. The
    `Info.plist` file contains basic information pertaining to the app, such as the
    permissions, IPC URL schemes, and app transport security settings which MobSF
    extracts for us within its interface. The following screenshot presents the `Info.plist`
    file within MobSF:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将要查看的第一个地方是`Info.plist`文件。`Info.plist`文件包含有关应用程序的基本信息，例如权限、IPC URL方案和MobSF在其界面中提取的应用程序传输安全设置。以下截图显示了MobSF中的`Info.plist`文件：
- en: '![](img/08df2252-fa06-40dc-aff0-fc0d95bf9a22.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08df2252-fa06-40dc-aff0-fc0d95bf9a22.png)'
- en: 'Next, select the strings button, which displays strings in the binary as shown
    in the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择字符串按钮，显示二进制中的字符串，如下截图所示：
- en: '![](img/e5fed86c-20d0-4f43-b7b0-90105c8d3fd5.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5fed86c-20d0-4f43-b7b0-90105c8d3fd5.png)'
- en: 'Notice there is a CONSUMERSECRET as a string, which was also discovered in
    the Android application. Often, if one version of the app contains a hardcoded
    value, the other may, as well. We will validate this in a moment, after we have
    a look at the class information MobSF has dumped for us. Click on View Class Dump
    to list the application''s class details. If you have set up your class dump binary
    settings correctly, a separate tab should open and display classes, as shown in
    the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，有一个CONSUMERSECRET作为字符串，这也在Android应用程序中发现。通常，如果应用程序的一个版本包含硬编码值，另一个版本可能也包含。我们将在一会儿验证这一点，在查看MobSF为我们转储的类信息之后。单击“查看类转储”以列出应用程序的类详细信息。如果您已正确设置了类转储二进制设置，应该会打开一个单独的选项卡并显示类，如下截图所示：
- en: '![](img/d494ad51-aa46-4a96-afa4-5b8cdb7cc824.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d494ad51-aa46-4a96-afa4-5b8cdb7cc824.png)'
- en: 'With the class details available, we can pinpoint the functionality within
    the app to analyze. For example, we can search for password strings that are within
    classes to be analyzed in a disassembler like Hopper. The following screenshot
    shows the class `addBasicAuthenticationHeaderWithUsername` being used:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了可用的类细节，我们可以确定要分析的应用程序中的功能。例如，我们可以在类似Hopper的反汇编器中搜索要分析的类中的密码字符串。以下截图显示了正在使用的类`addBasicAuthenticationHeaderWithUsername`：
- en: '![](img/cc6d3c21-8cfb-4089-9b3d-4cc3219f1c6c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc6d3c21-8cfb-4089-9b3d-4cc3219f1c6c.png)'
- en: '`addBasicAuthenticationHeaderWithUsername` can be further analyzed in Hopper,
    viewing its pseudocode as follows. Simply search for the class `addBasicAuthenticationHeaderWithUsername`
    in the string tab to view its contents:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addBasicAuthenticationHeaderWithUsername`可以在Hopper中进一步分析，查看其伪代码如下。只需在字符串选项卡中搜索类`addBasicAuthenticationHeaderWithUsername`以查看其内容：'
- en: '![](img/c5317fd1-ab95-4ed5-9b1d-11fc19f824c9.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5317fd1-ab95-4ed5-9b1d-11fc19f824c9.png)'
- en: Viewing the content of the class in the string tab
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看字符串选项卡中的类内容
- en: 'Since we are in Hopper and have located the CONSUMERSECRET in the previous
    steps, we can search for this string to check if it is also hardcoded in the iOS
    application. Following is a screenshot showing the same hardcoded values as the
    Android application. One of the hardcoded secret values ended in c4d5, which is
    highlighted in the screenshot:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在Hopper中并且已经在之前的步骤中找到了CONSUMERSECRET，我们可以搜索此字符串以检查它是否也在iOS应用程序中硬编码。以下是显示与Android应用程序相同的硬编码值的截图。其中一个硬编码的秘密值以c4d5结尾，在截图中被突出显示：
- en: '![](img/3ac75df2-1dfb-4481-8853-49a68f5d336c.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ac75df2-1dfb-4481-8853-49a68f5d336c.png)'
- en: Hardcoded secret values
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码的秘密值
- en: A common next step of testing when locating these hardcoded values in an application
    is verifying their impact via dynamic analysis. Dynamic analysis testing will
    be covered later in this chapter.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定位应用程序中这些硬编码值时，常见的下一步测试是通过动态分析验证它们的影响。动态分析测试将在本章后面进行介绍。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this section, we covered the static analysis of Android and iOS applications.
    We did not cover runtime analysis testing, which entails hooking application classes
    and functions during app execution. Depending on how much time and effort you
    are willing to spend on testing a mobile app, this may not always be within your
    scope. Runtime analysis is great for validating client-side security controls
    such as bypassing pin code lock screens or brute forcing logins. The OWASP Testing
    Guide provides details on runtime analysis techniques for both Android and iOS.
    Visit the links below for more information:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了Android和iOS应用的静态分析。我们没有涵盖运行时分析测试，这需要在应用执行期间挂钩应用程序类和函数。根据您愿意在测试移动应用上花费多少时间和精力，这可能并不总是在您的范围之内。运行时分析非常适用于验证客户端安全控件，例如绕过PIN码锁定屏幕或暴力破解登录。OWASP测试指南提供了Android和iOS的运行时分析技术的详细信息。访问以下链接获取更多信息：
- en: '**Android**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md)'
- en: '**iOS**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06c-Reverse-Engineering-and-Tampering.md)'
- en: Analyzing iOS data storage with idb
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用idb分析iOS数据存储
- en: Unfortunately, iOS developers tend to ignore data storage API controls that
    Apple provides. This leads to data leakage via clear text databases (including
    realm DBs), plist files (property lists), caching, keyboards, and other storage
    locations. Sometimes, the hybrid frameworks that the applications employ encourage
    this behavior for application performance but fail to list the security repercussions.
    Depending on the hybrid framework and custom modules, plugins may be required
    to clear locations such as the cache, which increases complexity for developers.
    This section will assist you with analyzing data storage for IoT iOS applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，iOS开发人员倾向于忽略苹果提供的数据存储API控制。这导致数据通过明文数据库（包括realm DBs）、plist文件（属性列表）、缓存、键盘和其他存储位置泄漏。有时，应用程序使用的混合框架会鼓励这种行为以提高应用程序性能，但未列出安全后果。根据混合框架和自定义模块的不同，可能需要插件来清除缓存等位置，这增加了开发人员的复杂性。本节将帮助您分析IoT
    iOS应用程序的数据存储。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, an already jailbroken iDevice is needed, as well as a free
    tool known as idb. Idb is a free tool that runs on OS X, and Ubuntu is used for
    simplifying common iOS app security assessment tasks. It is currently installed
    in the accompanied virtual machine but can also be installed manually by visiting
    idb's webpage at [http://www.idbtool.com/](http://www.idbtool.com/). If you are
    using **gem** to manage Ruby, idb can be installed using `gem install idb`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，需要一个已经越狱的iDevice，以及一个名为idb的免费工具。Idb是一个在OS X上运行的免费工具，Ubuntu用于简化常见的iOS应用程序安全评估任务。它目前已安装在附带的虚拟机中，但也可以通过访问idb的网页[http://www.idbtool.com/](http://www.idbtool.com/)手动安装。如果您使用**gem**来管理Ruby，可以使用`gem
    install idb`来安装idb。
- en: As of writing this, iOS 10 applications are not supported by idb.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，idb不支持iOS 10应用程序。
- en: To view SQLite database entries, download and install sqlitebrowser via [http://sqlitebrowser.org](http://sqlitebrowser.org).
    SQLite browser has been included in the VM provided for this book as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看SQLite数据库条目，请下载并安装sqlitebrowser，网址为[http://sqlitebrowser.org](http://sqlitebrowser.org)。SQLite浏览器也已包含在为本书提供的虚拟机中。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start idb from the Terminal, simply execute `idb`, and the user interface will
    appear:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端启动idb，只需执行`idb`，用户界面将出现：
- en: '![](img/e892dd5c-2e9c-4caf-a668-54d0fea38072.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e892dd5c-2e9c-4caf-a668-54d0fea38072.png)'
- en: 'Next, select Connect to USB/SSH device:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择连接到USB/SSH设备：
- en: '![](img/46387dad-6125-4d60-8c77-2815f950d044.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46387dad-6125-4d60-8c77-2815f950d044.png)'
- en: If this is your first time using idb, there are several packages that need to
    be installed on your jailbroken device which idb will install itself if it has
    access to the device via USB or SSH. These packages are listed in the following
    screenshot.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用idb，那么需要在越狱设备上安装几个软件包，如果idb可以通过USB或SSH访问设备，它将自行安装这些软件包。这些软件包列在以下屏幕截图中。
- en: The default username and password for jailbroken iDevices is alpine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 越狱iDevices的默认用户名和密码是alpine。
- en: '![](img/825424a3-190e-4933-83f0-a090d178671f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/825424a3-190e-4933-83f0-a090d178671f.png)'
- en: 'If all the required packages are installed, select an app from the App Selection
    menu. In this case, com.skybell.doorbell is selected:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有所需的软件包都已安装，请从应用程序选择菜单中选择一个应用程序。在这种情况下，选择了com.skybell.doorbell：
- en: '![](img/ed716c17-98c5-4abf-a59c-fe286ec911d6.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed716c17-98c5-4abf-a59c-fe286ec911d6.png)'
- en: 'With the SkyBell app selected, we can now focus on the app contents and how
    the app stores data. There are several features that can be utilized to automate
    iOS app assessment tasks, however for this demonstration the storage will be analyzed.
    To analyze the app''s data storage, select the Storage tab, select the plists
    tab, and press the Refresh button:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择了SkyBell应用程序后，我们现在可以专注于应用程序内容以及应用程序如何存储数据。有几个功能可用于自动化iOS应用程序评估任务，但是在本演示中将分析存储。要分析应用程序的数据存储，请选择Storage选项卡，选择plists选项卡，然后按刷新按钮：
- en: '![](img/181efd97-80c8-4cd7-8fdf-2c64fa1acea6.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/181efd97-80c8-4cd7-8fdf-2c64fa1acea6.png)'
- en: 'There are many files that appear, but many are not relevant for our purposes.
    The files to consider analyzing initially are the `Info.plist` file within the
    app bundle directory as well as any preference file that the app creates at runtime.
    The preference file in this case is listed as com.skybell.doorbell.plist. What
    we want to look for in the clear text plist files is any personal or sensitive
    data about either the company itself or the users. If we open the preferences
    file by double-clicking, we will see OAuth `access_tokens` and `refresh_tokens`
    stored in unprotected storage (CVE-2017-6082). These clear text tokens can be
    seen in the following screenshot. Typically, `access_tokens` are long lasting
    to improve user experience so that logging into the app each time the app is opened
    will not be required:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多文件出现，但很多对我们的目的不相关。最初要考虑分析的文件是应用程序包目录中的`Info.plist`文件，以及应用程序在运行时创建的任何偏好文件。在这种情况下，偏好文件被列为com.skybell.doorbell.plist。我们想要在清晰的plist文件中寻找的是关于公司本身或用户的任何个人或敏感数据。如果我们双击打开偏好文件，我们将看到存储在未受保护存储中的OAuth`access_tokens`和`refresh_tokens`（CVE-2017-6082）。这些明文令牌可以在以下屏幕截图中看到。通常，`access_tokens`持久存在以提高用户体验，这样每次打开应用程序时都不需要登录：
- en: '![](img/e3f324dc-7fc1-46c5-afd7-08fe75d98b68.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3f324dc-7fc1-46c5-afd7-08fe75d98b68.png)'
- en: Chances are, data is not being stored securely in multiple areas when session
    tokens are in clear text. A common area to look for sensitive data stored on the
    disk is any type of database or files generated upon application startup in the
    app's `data` directory. Idb has the ability to analyze each of these areas. We
    will have a look at the Cache.db tab and see what we find.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当会话令牌以明文形式存在时，数据很可能没有在多个区域安全存储。在磁盘上寻找存储的敏感数据的常见区域是应用程序启动时在应用程序的`data`目录中生成的任何类型的数据库或文件。Idb有能力分析这些区域。我们将查看Cache.db选项卡，看看我们找到了什么。
- en: 'Navigate to the Cache.dbs tab, select the Refresh button, and open the Cache.db
    entry by double-clicking:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到Cache.dbs选项卡，选择刷新按钮，并双击打开Cache.db条目：
- en: '![](img/34802275-4b2c-4b57-8d6a-5e5bdee0c3d4.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34802275-4b2c-4b57-8d6a-5e5bdee0c3d4.png)'
- en: 'As shown in the following screenshot, there are many tables within this SQLite
    database:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，此SQLite数据库中有许多表：
- en: '![](img/db223886-7e3f-4934-bdc7-1b2d3036488a.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db223886-7e3f-4934-bdc7-1b2d3036488a.png)'
- en: 'These tables contain BLOB data which can be viewed as text. As it turns out,
    the application caches all requests and responses which include personal details
    as well as token data (CVE-2017-6084):'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些表包含可以视为文本的BLOB数据。事实证明，该应用程序缓存了所有请求和响应，其中包括个人详细信息和令牌数据（CVE-2017-6084）：
- en: '![](img/f1823557-28d2-4ffe-a4de-b17e369bcf8c.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1823557-28d2-4ffe-a4de-b17e369bcf8c.png)'
- en: Custom SQLite external editors can be utilized by specifying the editors path
    via idb's settings (for example, `~/.idb/settings.yml`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定编辑器路径来利用自定义SQLite外部编辑器，例如通过idb的设置（例如，`~/.idb/settings.yml`）。
- en: This data can be stolen by attackers when plugging a victim's phone into iTunes
    with the auto backup setting enabled. The attacker needs to plug in a test iDevice
    and restore it to the victim's backup. Another technique consists of using tools
    such as iFunbox which grants access to a non-jailbroken device's filesystem ([http://www.i-funbox.com/](http://www.i-funbox.com/)).
    At this point, the attacker can transfer the app's `Cache.db`, plists, and SQLite
    databases externally to gain access to session tokens and other personal account
    information. In this case, an attacker can view video feeds from the video doorbell
    and make changes to its configuration by adjusting motion settings or sharing
    the video feed to an external account.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以在启用了自动备份设置的情况下，将受害者的手机插入iTunes，从而窃取这些数据。攻击者需要插入一个测试iDevice并将其恢复到受害者的备份。另一种技术是使用诸如iFunbox之类的工具，该工具可以访问非越狱设备的文件系统（[http://www.i-funbox.com/](http://www.i-funbox.com/)）。在这一点上，攻击者可以外部传输应用的`Cache.db`，plist和SQLite数据库，以获取会话令牌和其他个人账户信息的访问权限。在这种情况下，攻击者可以查看视频门铃的视频源，并通过调整运动设置或将视频源共享到外部账户来更改其配置。
- en: With this knowledge, session management controls and API data can be viewed
    without proxying the connection. Session expiration and randomization testing
    can be analyzed according to the aforementioned Mobile App Security Checklist.
    Data within the `plist` file or the `Cache.db` can be modified and uploaded back
    to the device to observe the application's trust relationship with these files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，可以在不代理连接的情况下查看会话管理控件和API数据。可以根据前述的移动应用程序安全检查表来分析会话过期和随机化测试。可以修改`plist`文件或`Cache.db`中的数据，并将其上传回设备，以观察应用程序与这些文件的信任关系。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Additional data storage locations can be analyzed that were not covered in
    this section. Items such as the keychain, local storage, realm databases, logs,
    BinaryCookies, and many more storage locations were not discussed. Review OWASP''s
    Mobile Security Testing Guide for additional details on techniques for testing
    data storage weaknesses within iOS applications: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以分析其他未在本节中涵盖的数据存储位置。未讨论的项目包括钥匙链、本地存储、领域数据库、日志、BinaryCookies等许多其他存储位置。请查看OWASP的移动安全测试指南，了解有关在iOS应用程序中测试数据存储弱点的技术的更多详细信息：[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md)。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To learn more about idb's features, have a look at the documentation idb has
    made available at [http://www.idbtool.com/documentation/](http://www.idbtool.com/documentation/).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关idb功能的更多信息，请查看idb提供的文档 [http://www.idbtool.com/documentation/](http://www.idbtool.com/documentation/)。
- en: Analyzing Android data storage
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Android数据存储
- en: 'There are several methods for testing Android data storage during runtime.
    Free, as well as commercial, Android testing distributions are made available
    to help automate viewing and modifying common data storage file locations. In
    a manual approach, we want to analyze the following common storage locations during
    application runtime:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，有几种测试Android数据存储的方法。提供了免费和商业的Android测试发行版，以帮助自动查看和修改常见的数据存储文件位置。在手动方法中，我们希望在应用程序运行时分析以下常见的存储位置：
- en: '`/data/data/<package_name>/`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/<package_name>/`'
- en: '`/data/data/<package_name>/databases`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/<package_name>/databases`'
- en: '`/data/data/<package_name>/shared_prefs`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/<package_name>/shared_prefs`'
- en: '`/data/data<package_name>/files/<dbfilename>.realm`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data<package_name>/files/<dbfilename>.realm`'
- en: Requires a Realm Browser ([https://itunes.apple.com/us/app/realm-browser/id1007457278?](https://itunes.apple.com/us/app/realm-browser/id1007457278?))
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个Realm浏览器（[https://itunes.apple.com/us/app/realm-browser/id1007457278?](https://itunes.apple.com/us/app/realm-browser/id1007457278?)）
- en: '`/data/data/<package name>/app_webview/`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/<package name>/app_webview/`'
- en: Cookies
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookies
- en: Local storage
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储
- en: Web data
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web数据
- en: '`/sdcard/Android/data/<package_name>`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sdcard/Android/data/<package_name>`'
- en: With Android, the file structure for applications does not change, which makes
    manual analysis easier. This recipe will assist you with analyzing data storage
    for IoT Android applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，应用程序的文件结构不会改变，这使得手动分析更加容易。这个步骤将帮助您分析IoT Android应用程序的数据存储。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The following items are required for this recipe:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤需要以下物品：
- en: A rooted Android device (with USB debugging enabled) or a rooted Android emulator.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已root的Android设备（启用了USB调试）或一个已root的Android模拟器。
- en: '**Android debug bridge** (**ADB**): ADB is available in the accompanied virtual
    machine or can be installed manually via the URL [https://developer.android.com/studio/releases/platform-tools.html](https://developer.android.com/studio/releases/platform-tools.html).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android调试桥**（**ADB**）：ADB可在附带的虚拟机中使用，也可以通过URL [https://developer.android.com/studio/releases/platform-tools.html](https://developer.android.com/studio/releases/platform-tools.html)
    手动安装。'
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Ensure a test Android device or emulator is attached using the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用以下命令连接了测试Android设备或模拟器：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Connect to the test Android device''s console and switch to the root user with
    the following ADB command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到测试Android设备的控制台，并使用以下ADB命令切换到root用户：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Change the target app''s directory as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目标应用程序的目录如下：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, browse to the `shared_prefs` directory, list each file, and view the
    preferences file available as shown in the following screenshot:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，浏览到`shared_prefs`目录，列出每个文件，并查看可用的首选项文件，如下面的屏幕截图所示：
- en: '![](img/8f2bec1c-8ba3-4d5c-b0a5-e18fb387ce90.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f2bec1c-8ba3-4d5c-b0a5-e18fb387ce90.png)'
- en: There appears to be special encoding; the app is running on strings which may
    pertain to login credentials, but it does reveal the username of the account.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎存在特殊的编码；应用程序正在运行字符串，这些字符串可能与登录凭据有关，但它确实显示了帐户的用户名。
- en: 'Next, we will examine the `com.skybell.app.networking.oauth.oauth_shared_preferences_key.xml`
    file as shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`com.skybell.app.networking.oauth.oauth_shared_preferences_key.xml`文件，如下面的屏幕截图所示：
- en: '![](img/8b771c3f-4d52-4278-a78f-0f5560af21bc.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b771c3f-4d52-4278-a78f-0f5560af21bc.png)'
- en: 'Our account OAuth tokens appear to be stored in clear text, similar to what
    we saw in the iOS application. There is a `files` directory available which may
    have Realm database files that can be viewed. Change to the `files` directory
    and list the files, as shown in the following screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的帐户OAuth令牌似乎以明文存储，类似于我们在iOS应用程序中看到的情况。有一个可用的`files`目录，其中可能有可以查看的Realm数据库文件。更改到`files`目录并列出文件，如下面的屏幕截图所示：
- en: '![](img/7773cad1-5c5c-4cd3-a32c-b27ea8c65f40.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7773cad1-5c5c-4cd3-a32c-b27ea8c65f40.png)'
- en: 'There seems to be a Realm database that the application utilizes. Take note
    of the directory where the Realm database resides and pull the file to your host
    computer using the following `adb` command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序似乎使用了一个Realm数据库。注意Realm数据库所在的目录，并使用以下`adb`命令将文件拉到您的主机计算机：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the time of writing, Realm databases can only be viewed on an OS X computer
    using the Real Browser available in the App Store. There are unofficial Real Browsers
    for Android and iOS which need to be built from the source. More details on Realm
    databases can be found at [http://news.realm.io/news/realm-browser-tutorial/](http://news.realm.io/news/realm-browser-tutorial/).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Realm数据库只能在使用App Store中提供的Real Browser的OS X计算机上查看。有非官方的Real Browser适用于Android和iOS，需要从源代码构建。有关Realm数据库的更多详细信息，请访问[http://news.realm.io/news/realm-browser-tutorial/](http://news.realm.io/news/realm-browser-tutorial/)。
- en: 'Double-click the `default.realm` file, which will open the Realm database in
    the Real Browser, as seen in the following screenshot:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`default.realm`文件，将在Real Browser中打开Realm数据库，如下面的屏幕截图所示：
- en: '![](img/3241e3d0-e5dd-4aca-a55f-436d179d16b1.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3241e3d0-e5dd-4aca-a55f-436d179d16b1.png)'
- en: The DeviceRecord model states the name of the doorbell and the status, whether
    it is online or not, while the DeviceRecordActivity model lists events, their
    timestamps, and thumbnails of the events. This is a type of data leakage that
    can be taken advantage of by backing up an Android device to a computer and restored
    like iPhones, or pulling the data the same way we would via ADB, if enabled. Unfortunately,
    this application did not flag `[android:allowBackup=false]` in `AndroidManifest.xml`,
    which would have mitigated this specific issue, but it is still bad practice to
    store data that leaves customers at risk or pertains to privacy concerns in this
    case.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceRecord模型说明了门铃的名称和状态，即在线或离线，而DeviceRecordActivity模型列出了事件、它们的时间戳和事件的缩略图。这是一种数据泄露，可以通过将Android设备备份到计算机并像iPhone一样还原，或者通过启用ADB后以与通过ADB相同的方式提取数据。不幸的是，此应用程序在`AndroidManifest.xml`中没有标记`[android:allowBackup=false]`，这本来可以减轻这个特定问题，但在这种情况下，存储会使客户面临风险或涉及隐私问题，这仍然是不良做法。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Review OWASP's Mobile Security Testing Guide for additional details on techniques
    for testing data storage weaknesses within Android applications: [https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请查看OWASP的移动安全测试指南，了解有关测试Android应用程序中数据存储弱点的技术的更多详细信息：[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md)。
- en: Performing dynamic analysis testing
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动态分析测试
- en: At this stage, we have statically analyzed and assessed how data is stored within
    example IoT mobile applications. We have yet to view the API traffic sent between
    the application and server. Viewing and tampering with application communication
    at runtime is known as **dynamic analysis**. Dynamic analysis testing focuses
    on evaluating an app during its execution. Dynamic analysis is conducted both
    on the mobile platform layer as well as against the backend services and APIs
    of mobile applications, where requests and responses can be analyzed. In this
    recipe, we will set up a dynamic analysis testing environment for iOS and walk
    you through some test cases.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经静态分析并评估了示例IoT移动应用程序中数据的存储方式。我们还没有查看应用程序和服务器之间发送的API流量。在运行时查看和篡改应用程序通信被称为**动态分析**。动态分析测试侧重于评估应用程序在执行过程中的情况。动态分析既在移动平台层进行，也针对移动应用程序的后端服务和API进行，其中可以分析请求和响应。在本示例中，我们将为iOS设置动态分析测试环境，并为您介绍一些测试用例。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: For this recipe, Burp Suite and/or OWASP ZAP will be used to observe application
    communication. Access to both an iDevice and an Android device is also needed
    to perform this recipe. The iDevice and Android device do not have to be jailbroken
    or rooted, which is the nice part of viewing app communications. Although these
    steps apply to both mobile platforms, examples in this recipe will be given only
    for iOS.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，将使用Burp Suite和/或OWASP ZAP来观察应用程序通信。还需要访问iDevice和Android设备来执行此示例。iDevice和Android设备不必经过越狱或root，这是查看应用程序通信的好方法。尽管这些步骤适用于两种移动平台，但本示例中的示例仅适用于iOS。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Like configuring a web application testing environment, ZAP and Burp Suite''s
    CA certificates need to be installed on your jailbroken device to proxy `HTTPS`
    requests. This can be accomplished by adjusting the mobile device''s proxy settings
    for Wi-Fi to point to the IP and port of your Burp Suite listener, as seen in
    the following screenshot:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与配置Web应用程序测试环境类似，需要在您的越狱设备上安装ZAP和Burp Suite的CA证书以代理`HTTPS`请求。这可以通过调整移动设备的Wi-Fi代理设置来实现，以指向您的Burp
    Suite侦听器的IP和端口，如以下截图所示：
- en: '![](img/364d88e0-e9af-471c-b9e7-1a11bc332c70.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/364d88e0-e9af-471c-b9e7-1a11bc332c70.png)'
- en: 'The following screenshot shows how to configure proxy settings for iOS devices
    to point to your Burp proxy listener. In this case, my Burp proxy is listening
    on IP address `192.168.2.183` and port `8080`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何配置iOS设备的代理设置，以指向您的Burp代理侦听器。在这种情况下，我的Burp代理正在监听IP地址`192.168.2.183`和端口`8080`：
- en: '![](img/76abc6a0-33f7-419c-8429-80f31bc76dd8.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76abc6a0-33f7-419c-8429-80f31bc76dd8.png)'
- en: 'Next, add the Burp CA certificate to the device by navigating to Burp''s IP,
    and port with `/cert` as the URL path. In this case, Burp''s address is `http://192.168.2.183:8080/cert`
    as shown in the following screenshot:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过导航到Burp的IP和端口，并使用`/cert`作为URL路径，将Burp的CA证书添加到设备。在这种情况下，Burp的地址是`http://192.168.2.183:8080/cert`，如下图所示：
- en: '![](img/e04fb789-ca33-4229-b092-722e8a43993e.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e04fb789-ca33-4229-b092-722e8a43993e.png)'
- en: Once executed, iOS will ask whether you want to install a profile for Burp's
    CA certificate as seen in the following image. Select Install and `HTTPS` traffic
    can now be analyzed by Burp Suite.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，iOS将询问您是否要安装Burp的CA证书配置文件，如下图所示。选择安装，`HTTPS`流量现在可以由Burp Suite分析。
- en: '![](img/22528c5a-ea59-4d64-99f0-e5fca8a637a0.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22528c5a-ea59-4d64-99f0-e5fca8a637a0.png)'
- en: The following screenshot shows `HTTPS` requests going through our Burp suite
    proxy from our mobile device.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从我们的移动设备通过Burp套件代理的`HTTPS`请求。
- en: '![](img/447e7e83-93aa-4351-b4ca-c5e9fdd5b778.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/447e7e83-93aa-4351-b4ca-c5e9fdd5b778.png)'
- en: HTTPS requests via Burp suite proxy
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Burp套件代理的HTTPS请求
- en: 'Similar steps can be taken with an Android device. We will demonstrate how
    to set up ZAP''s CA certificate. First, export ZAP''s certificate by navigating
    to Tools | Options | Dynamic SSL Certificates. Save the certificate in a convenient
    location to be transferred over to the Android device:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似的步骤也可以用于Android设备。我们将演示如何设置ZAP的CA证书。首先，通过导航到工具|选项|动态SSL证书来导出ZAP的证书。将证书保存在方便的位置，以便传输到Android设备：
- en: '![](img/7b4d937b-ea2e-4abf-96cd-cab8cbbd01e9.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b4d937b-ea2e-4abf-96cd-cab8cbbd01e9.png)'
- en: 'The `ZAPCert` needs to be downloaded onto the Android device. There are several
    methods that can assist with fulfilling this requirement. A trick that is quick
    and handy for file transfer is using Python''s `SimpleHTTPServer`. If you are
    using a Nix-based operating system, run the following command from the directory
    where the certificate resides:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ZAPCert`需要下载到Android设备上。有几种方法可以帮助满足此要求。一个快速方便的文件传输技巧是使用Python的`SimpleHTTPServer`。如果您使用的是基于Nix的操作系统，请从证书所在的目录运行以下命令：'
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Python webserver will now be running on port `1111`. On your Android device,
    open a browser and navigate to your listening webserver. In this case, the address
    is `http://192.168.2.186:1111` as seen in the following screenshot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python web服务器现在将在端口`1111`上运行。在您的Android设备上，打开浏览器并导航到您的监听Web服务器。在这种情况下，地址是`http://192.168.2.186:1111`，如下图所示：
- en: '![](img/765aa81c-0620-4a2a-bee6-86f718f7f53e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/765aa81c-0620-4a2a-bee6-86f718f7f53e.png)'
- en: 'Download the certificate to the Android device. On the Android device, navigate
    to Settings | Security | Install from storage and the Download folder should appear,
    as shown in the following screenshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将证书下载到Android设备。在Android设备上，导航到设置|安全|从存储安装，然后下载文件夹应该出现，如下图所示：
- en: '![](img/ab5204a9-abe8-4053-b931-7209b075b804.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab5204a9-abe8-4053-b931-7209b075b804.png)'
- en: 'Select ZAP''s certificate and name the certificate as shown in the following
    screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择ZAP的证书，并按照以下截图中所示命名证书：
- en: '![](img/7de4d427-54e3-4e62-8a4a-45f609d3182e.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7de4d427-54e3-4e62-8a4a-45f609d3182e.png)'
- en: 'Navigate to your Wireless settings and modify the proxy settings to your ZAP
    proxy listener:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的无线设置，并修改代理设置以匹配您的ZAP代理侦听器：
- en: '![](img/900ce53b-7395-4648-86c5-ab9bfca16c0b.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/900ce53b-7395-4648-86c5-ab9bfca16c0b.png)'
- en: 'Navigate to the target IoT mobile application and observe `HTTPS` requests
    and responses populate ZAP''s History tab:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目标IoT移动应用程序，并观察`HTTPS`请求和响应填充ZAP的历史选项卡：
- en: '![](img/22118096-fa90-4f4b-9ff3-e8ec2cb7f068.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22118096-fa90-4f4b-9ff3-e8ec2cb7f068.png)'
- en: 'Both the Android and iDevice are set up to proxy application requests and responses.
    With this access, parameters can be fuzzed for injection flaws (if testing has
    been authorized) and the app can be tested for business logic flaws. For example,
    proxying the request and responses while viewing a video from our target doorbell,
    we notice an `access_token` being sent as a URL parameter in a `GET` request directed
    to an MP4 of the video (CVE-2017-6085). Copying this `GET` request to our clipboard
    and pasting it into a browser allows access to download the MP4 video without
    a username or password, as seen in the following images:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android和iDevice都已设置为代理应用程序的请求和响应。通过这种访问，可以对参数进行模糊处理以进行注入漏洞测试（如果已经获得授权），并且可以测试应用程序的业务逻辑漏洞。例如，在查看来自我们目标门铃的视频时代理请求和响应，我们注意到`access_token`作为`GET`请求中的URL参数发送到视频的MP4文件（CVE-2017-6085）。将此`GET`请求复制到剪贴板并粘贴到浏览器中，即可访问下载MP4视频，无需用户名或密码，如下图所示：
- en: '![](img/781c9f74-c2e0-4171-bb21-c18aa0b1e266.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/781c9f74-c2e0-4171-bb21-c18aa0b1e266.png)'
- en: MP4 video download without a username or password
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 无需用户名或密码即可下载MP4视频
- en: 'The request is then copied to our clipboard:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将请求复制到我们的剪贴板：
- en: '![](img/4ffcdef1-0033-4793-924c-ecb50e821ebf.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ffcdef1-0033-4793-924c-ecb50e821ebf.png)'
- en: 'Paste the URL copied to a browser and observe the auto download of the video
    doorbell event to your local computer:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL粘贴到浏览器中，并观察视频门铃事件的自动下载到您的本地计算机：
- en: '![](img/b7822852-d7b4-43fd-8d40-54cb243ce21d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7822852-d7b4-43fd-8d40-54cb243ce21d.png)'
- en: 'Once the copied URL is requested in the browser, the browser should automatically
    ask where to save the downloaded video on your local computer:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在浏览器中请求复制的URL，浏览器应自动询问在本地计算机上保存下载视频的位置：
- en: '![](img/af1ad43b-205a-417a-b162-b10d2d974443.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af1ad43b-205a-417a-b162-b10d2d974443.png)'
- en: 'The video is now downloaded as an `.mp4` and can be viewed as seen in the following
    screenshot:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视频已经以`.mp4`的格式下载，并且可以像以下截图中所示查看：
- en: '![](img/4c6763e7-c6c6-4fe7-b938-db8e0782430e.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c6763e7-c6c6-4fe7-b938-db8e0782430e.png)'
- en: Remember, we did not input any username or password to download and watch this
    video. This shows that the doorbell manufacturer has access control issues for
    users and may indicate other holes in the product as well. For a video doorbell,
    accessing video feeds without credentials is a risk from a security and privacy
    perspective. Several vulnerabilities can be identified within this finding alone,
    which includes sending session tokens as `GET` requests, lack of token expiration,
    and insufficient access controls. An attacker may acquire the necessary `access_token`
    via social engineering or MITM techniques. Additional access control test cases
    can be performed with external user accounts as a follow-up to this finding.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，我们没有输入任何用户名或密码来下载和观看这个视频。这表明门铃制造商对用户的访问控制存在问题，并且可能还表明产品中存在其他漏洞。对于视频门铃来说，在没有凭据的情况下访问视频源存在安全和隐私风险。仅在这一发现中就可以识别出几个漏洞，包括将会话令牌作为`GET`请求发送、令牌过期不足以及访问控制不足。攻击者可以通过社会工程或MITM技术获取必要的`access_token`。可以通过外部用户帐户执行额外的访问控制测试用例以跟进此发现。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For some Android applications, MobSF has the capability to perform dynamic tests
    inside an emulator, virtual machine, and even a physical device. Dynamic testing
    for Android apps also includes testing intents and activities. There are some
    caveats that are listed in MobSF's wiki ([https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM)).
    If the app you are testing requires access to hardware such as the camera or wireless
    protocol (that is, Bluetooth, ZigBee, or Z-Wave), it is recommended you use a
    physical device and test manually.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些Android应用程序，MobSF具有在模拟器、虚拟机甚至物理设备内执行动态测试的能力。对于Android应用程序的动态测试还包括测试意图和活动。MobSF的维基中列出了一些注意事项（[https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/2.-Configure-MobSF-Dynamic-Analysis-Environment-in-your-Android-Device-or-VM)）。如果您正在测试的应用程序需要访问硬件，比如相机或无线协议（即蓝牙、ZigBee或Z-Wave），建议您使用物理设备并进行手动测试。
- en: To learn more about Android and iOS application security testing, visit OWASP's
    Mobile Security Testing Guide: [https://github.com/OWASP/owasp-mstg/](https://github.com/OWASP/owasp-mstg/).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关Android和iOS应用程序安全测试的更多信息，请访问OWASP的移动安全测试指南：[https://github.com/OWASP/owasp-mstg/](https://github.com/OWASP/owasp-mstg/)。
