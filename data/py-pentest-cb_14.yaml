- en: Linux Exploit Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux漏洞利用开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Format string exploitation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式字符串利用
- en: Buffer overflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Developing exploits for vulnerabilities in the applications developed for the
    Linux environment can be done with the Python tools. We have to use debuggers
    such as `pwndbg` to debug the applications. Then, we can use Python scripts to
    exploit the vulnerabilities. In this chapter, we will go through some basic vulnerabilities
    and methods to develop an exploit script for it with Python.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Linux环境开发的应用程序中开发漏洞的利用可以使用Python工具。我们必须使用调试器，如`pwndbg`来调试应用程序。然后，我们可以使用Python脚本来利用这些漏洞。在本章中，我们将介绍一些基本漏洞和开发利用脚本的方法。
- en: Format string exploitation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式字符串利用
- en: 'A format string is an ASCIIZ string that contains text and format parameters.
    The format string vulnerability occurs when the submitted data of an input string
    is evaluated as a command by the application. With the help of this method, the
    attacker could execute code, read the stack, and may cause a segmentation fault.
    Format string vulnerability exist in most of the `printf` family functions, such
    as `printf`, `sprintf`, and `fprintf`. These are the common parameters that can
    be used in format string vulnerabilities:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串是一个包含文本和格式参数的ASCIZ字符串。格式字符串漏洞发生在应用程序将输入字符串的提交数据评估为命令时。借助这种方法，攻击者可以执行代码，读取堆栈，并可能导致分段错误。格式字符串漏洞存在于大多数`printf`系列函数中，如`printf`，`sprintf`和`fprintf`。这些是格式字符串漏洞中常用的参数：
- en: '`"%x"`: It reads data from the stack'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"%x"`：它从堆栈中读取数据'
- en: '`"%s"`: It reads character strings from the process memory'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"%s"`：它从进程内存中读取字符字符串'
- en: '`"%n"`: It writes an integer to locations in the process memory'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"%n"`：它将整数写入进程内存中的位置'
- en: '`"%p"`: It''s external representation of a pointer to void'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"%p"`：它是指向void的指针的外部表示'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need a 32-bit x86 Linux real or virtual environment for creating the vulnerable
    application and getting the basic idea about the process involved in it. It is
    also a prerequisite to have a basic idea about some concepts in Linux environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个32位x86 Linux真实或虚拟环境来创建有漏洞的应用程序，并了解其中涉及的基本概念。在Linux环境中有一些概念的基本了解也是先决条件。
- en: 'Make sure to install the `pwndbg` debugger in the Linux environment. To check,
    open up the Terminal and type `gdb`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在Linux环境中安装了`pwndbg`调试器。要检查，请打开终端并输入`gdb`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will open up the `pwndbg` console if installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了`pwndbg`，这将打开`pwndbg`控制台：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use `q` to quit from this console. We also need a vulnerable application
    for our work. For better understanding we can create a simple vulnerable application
    in C.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`q`退出此控制台。我们还需要一个有漏洞的应用程序来进行工作。为了更好地理解，我们可以在C中创建一个简单的有漏洞的应用程序。
- en: Global offset table
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局偏移表
- en: A global offset table is used by the program during its compile time. It helps
    to get the location of the function used from external libraries. To view this
    we have to depend on the `objdump` command. The `objdump` command is the Linux
    environment used to get the detailed information of an object file. This is very
    helpful while debugging.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在编译时使用全局偏移表。它有助于从外部库中获取使用的函数的位置。要查看这一点，我们必须依赖`objdump`命令。`objdump`命令是Linux环境中用于获取对象文件详细信息的命令。这在调试时非常有用。
- en: Generating shell code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成shell代码
- en: To generate shell code for injecting we have to use Metasploit shell code generation
    functionality, so make sure you have Metasploit installed on your machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成用于注入的shell代码，我们必须使用Metasploit shell代码生成功能，因此请确保您的计算机上已安装Metasploit。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create an exploit script for exploiting format string
    in Linux environment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Linux环境中创建利用格式字符串的利用脚本的步骤：
- en: To start, we need to create a vulnerable application. So, we can write a C file
    with format string vulnerability. Create an `fmt.c` file and open it in your editor.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个有漏洞的应用程序。因此，我们可以编写一个具有格式字符串漏洞的C文件。创建一个`fmt.c`文件并在编辑器中打开它。
- en: 'Add the following code in it and Save:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to compile this code with format security disabled. For that run the
    following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用禁用格式安全性的编译此代码。为此，请运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will create an executable named `fmt`. We can use this as our sample application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`fmt`的可执行文件。我们可以将其用作我们的示例应用程序。
- en: 'Make sure to disable **Address Space Layout Randomization** (**ASLR**) in your
    test machine:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试机器上禁用**地址空间布局随机化**（**ASLR**）：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can run the application for testing:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序进行测试：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will print the parameter passed to the application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印传递给应用程序的参数
- en: 'Then we will test the application with the format string inputs:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将使用格式字符串输入测试应用程序：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/00113.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: Here the first test prints some hexadecimal values from the stack, but the second
    writes values to locations in the memory where the stack values points to and
    finally end up in segmentation fault. So, from the results of the tests it is
    pretty clear that we can read from the RAM and also we can write to RAM.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个测试从堆栈打印一些十六进制值，但第二个将值写入堆栈值指向的内存位置，最终导致分段错误。因此，从测试结果来看，很明显我们可以从RAM中读取，也可以向RAM中写入。
- en: 'Now we can change the input and try to control the parameter:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更改输入并尝试控制参数：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00114.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: The characters `AAAA` and `BBBB` that we passed appear as the fourth parameter
    on the stack in hex values, as `41414141` for `AAAA` and `42424242` for `BBBB`.
    From this it's clear that we can now control the fourth parameter on the stack.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的`AAAA`和`BBBB`字符以十六进制值的形式出现在堆栈的第四个参数上，`AAAA`为`41414141`，`BBBB`为`42424242`。从中可以清楚地看出，我们现在可以控制堆栈上的第四个参数。
- en: 'As we are planning to control the code execution, we need to change a function''s
    address. So let''s try to find a RAM location to write. For that we can use `pwndbg`
    to view the assembly code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们计划控制代码执行，我们需要更改函数的地址。因此，让我们尝试找到一个RAM位置进行写入。为此，我们可以使用`pwndbg`查看汇编代码：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will print the assembly code. From this we can identify that the application
    calls `printf@plt` on `59` and `putchar@plt` on `72`. So we can set the break
    point at `59` for debugging:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出汇编代码。从中我们可以确定应用程序在`59`上调用`printf@plt`，在`72`上调用`putchar@plt`。因此，我们可以在`59`处设置断点以进行调试：
- en: '![](img/00115.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: 'As we know, global offset tables hold the current addresses of library functions.
    So we can use `objdump` to view the entries in the GOT:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所知，全局偏移表保存库函数的当前地址。因此，我们可以使用`objdump`查看GOT中的条目：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/00116.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: From this we will get the location for the `putchar` in the dynamic relocation
    record. Here it is, `08049748`, and it may be different for you. So make sure
    to update your scripts accordingly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们将得到动态重定位记录中`putchar`的位置。在这里是`08049748`，对您可能是不同的。因此，请确保相应地更新您的脚本。
- en: 'Now we can try to write to the `putchar` PLT entry. We can make use of `pwndbg`
    for this. Open the app in `pwndbg`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试写入`putchar` PLT入口。我们可以利用`pwndbg`来做这个。在`pwndbg`中打开应用程序：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the first breakpoint before the `printf` and after the `printf`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`printf`之前和之后设置第一个断点：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then run the app with our payload to write to the address location of `putchar`
    that we got from `objdump`. In my case it is `08049748`. We have to convert the
    address to Little Endian format to work with the Intel architecture:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用我们的有效载荷运行应用程序，以写入我们从`objdump`中获得的`putchar`的地址位置。在我的情况下是`08049748`。我们必须将地址转换为小端格式，以便与英特尔架构一起使用：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will run up to our first breakpoint, which is before the `printf`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行到我们的第一个断点，即`printf`之前：
- en: '![](img/00117.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.jpeg)'
- en: 'Then we can examine the value at the memory location for its current value:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以检查内存位置的当前值：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/00118.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: 'Then forward to the next break point by typing `c`. Then check the memory location
    again:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后输入`c`以前进到下一个断点。然后再次检查内存位置：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/00119.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: From this we know that the value changed to `0x00000018`. When `printf` executes
    with a format sting value `%n` as the parameter, it prints out a 32-bit length
    value equal to the bytes printed so far. Here the program has printed 18 bytes
    so far.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们知道该值更改为`0x00000018`。当`printf`执行时，格式字符串值`%n`作为参数，它打印出一个等于到目前为止打印的字节数的32位长度值。在这里，程序到目前为止打印了18个字节。
- en: Now we can write our exploit code to craft the payload. For that, create an
    `exploit.py` file and open it in your editor.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的利用代码来制作有效载荷。为此，请创建一个`exploit.py`文件并在编辑器中打开它。
- en: 'Then add the following code in it:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在其中添加以下代码：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we create a payload for our application. This will be submitted as the
    input to write to the memory location. So the best way to generate a 32-bit word
    is to perform four writes, with each targeting the one byte, and combining them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的应用程序创建一个有效载荷。这将作为输入提交以写入内存位置。因此，生成32位字的最佳方法是执行四次写入，每次针对一个字节，并将它们组合起来。
- en: 'Make sure the exploit code has execute permission:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保利用代码具有执行权限：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can run the application in debugger with this payload. This is exactly
    what we did before:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用此有效载荷在调试器中运行应用程序。这正是我们之前做的事情：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Examine the memory location:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查内存位置：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/00120.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: Then the value changed to `0x4c443c34`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该值更改为`0x4c443c34`
- en: 'Let''s try changing one byte in the payload then. For that, change the third
    format string parameter, `%x` to `%16x`. This will add 16 leading zeros to it
    and make it 16 bytes long:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试改变有效载荷中的一个字节。为此，将第三个格式字符串参数`%x`更改为`%16x`。这将在前面添加16个零，并使其长度为16个字节：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then run the app in debug mode and examine the value in the memory:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后以调试模式运行应用程序，并检查内存中的值：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/00121.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpeg)'
- en: The value changed to `0x564e46` from its previous value of `0x4c443c`. So all
    bytes increased by 16\. Now it is 16 bytes long.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该值从其先前的值`0x4c443c`更改为`0x564e46`。因此，所有字节都增加了16。现在它的长度为16个字节。
- en: 'Now we can try to write a specific address to that address location. Here we
    can try to write `ddccbbaa`. For that, update our `exploit.py` as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试将特定地址写入该地址位置。在这里，我们可以尝试写入`ddccbbaa`。为此，更新我们的`exploit.py`如下：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we have added enough leading zeros before each `%n` to match the
    total number of printed characters and match the desired value we plan to write.
    Also, the total number of bytes increases with each write; we have to add 256
    to each value to make the last bytes clean.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们在每个`%n`之前添加了足够的前导零，以匹配打印字符的总数，并匹配我们计划写入的期望值。此外，每次写入时字节的总数都会增加；我们必须为每个值添加256，以使最后的字节干净。
- en: 'Now execute the application with our crafted payload and examine the memory
    location:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用我们精心制作的有效载荷执行应用程序，并检查内存位置：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/00122.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: Now the `putchar@got.plt` pointer has the value `0xddccbbaa`, which is the value
    we planned to write in it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`putchar@got.plt`指针的值为`0xddccbbaa`，这是我们计划写入其中的值。
- en: 'Now we can create a pattern and insert it in the exploit. This will help to
    identify the location we can insert our shell code in. So, update our exploit
    with the pattern. This will update the script as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个模式并将其插入到利用中。这将有助于确定我们可以插入我们的shell代码的位置。因此，使用模式更新我们的利用。这将更新脚本如下：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now run the application in debugger with the payload, and examine the `200`
    bytes after the ESP register:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用有效载荷在调试器中运行应用程序，并检查ESP寄存器后的`200`个字节：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/00123.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00123.jpeg)'
- en: Now we can see the NOP sled on the stack. And we can select an address in the
    middle of the NOP sled for adding shell code. Here we can select `0xbffff110`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在堆栈上看到NOP滑梯。我们可以选择NOP滑梯中间的地址来添加shell代码。在这里我们可以选择`0xbffff110`。
- en: 'Now we have to replace the address, `0xddccbbaa`, with the real address we
    selected from the NOP sled. For that, update the `exploit.py` with correct bytes:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须用真实地址替换`0xddccbbaa`，这个地址是我们从NOP sled中选择的。为此，用正确的字节更新`exploit.py`：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now run the application with debugger and examine the memory location:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用调试器运行应用程序并检查内存位置：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/00124.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00124.jpeg)'
- en: 'Now we can generate a shell code with Metasploit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用Metasploit生成一个shell代码：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/00125.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00125.jpeg)'
- en: 'Now update the exploit code with the shell code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用shell代码更新利用代码：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added a postfix to make the total number of injected characters constant.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个后缀，使注入字符的总数保持恒定。
- en: 'Now run the application with the payload:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用有效载荷运行应用程序：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now try connecting with `nc` as the shell code and open port `4444`, and try
    running the following commands:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试使用`nc`连接作为shell代码并打开端口`4444`，然后尝试运行以下命令：
- en: '![](img/00126.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00126.jpeg)'
- en: 'We can see these details in the debugger as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调试器中看到这些细节：
- en: '![](img/00127.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.jpeg)'
- en: Buffer overflow
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: Buffer overflow can cause the program to crash or leak private information.
    A buffer in case of a running program, can be considered as a section in a computer's
    main memory with specific boundaries, so basically accessing any buffer outside
    this allocated region of memory space.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出可能导致程序崩溃或泄露私人信息。在运行程序的情况下，缓冲区可以被视为计算机主内存中具有特定边界的部分，因此基本上访问分配的内存空间之外的任何缓冲区。
- en: As the variables are stored together in stack/heap, accessing anything outside
    this boundary may cause read/write of some bytes of some other variables. But
    with a better understanding we can execute some attacks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量存储在堆栈/堆中，访问这个边界之外的任何内容可能导致读/写其他变量的一些字节。但是通过更好的理解，我们可以执行一些攻击。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the steps to generate an exploit code for buffer overflow attacks in
    Linux environment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在Linux环境中生成缓冲区溢出攻击的利用代码：
- en: 'We have to create a vulnerable application for the test. Create a `bof.c` file
    and add the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为测试创建一个有漏洞的应用程序。创建一个`bof.c`文件并添加以下代码：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile it as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编译它：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can run the following application test:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行以下应用程序测试：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/00128.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.jpeg)'
- en: 'We can run `objdumb`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行`objdumb`：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'From that we can get the memory location of the secret function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以得到secret function的内存位置：
- en: '![](img/00129.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00129.jpeg)'
- en: 'Here it is, `0804848b`. And 28 bytes are reserved for local variables of the
    `echo` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它，`0804848b`。并且28个字节被保留用于`echo`函数的本地变量：
- en: '![](img/00130.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: Now we can design the payload--as we know, 28 bytes are reserved for the buffer,
    and it's next to the EBP pointer. So, the next four bytes will store EIP. Now
    we can set the first 28+ 4 =32 bytes with any random characters, and then the
    next four bytes will be the address to `secretfunction()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设计有效载荷--我们知道，28个字节被保留用于缓冲区，紧挨着EBP指针。所以，接下来的四个字节将存储EIP。现在我们可以用任意随机字符设置前28+4=32个字节，然后接下来的四个字节将是`secretfunction()`的地址。
- en: 'Now the payload will be as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有效载荷将如下：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save this to an `exploit_bof.py` file and load it as a payload for the application
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存到一个`exploit_bof.py`文件中，并将其加载为应用程序的有效载荷
- en: This will crash the application and provide access to the `secretfunction()`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使应用程序崩溃并提供对`secretfunction()`的访问。
- en: '![](img/00131.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.jpeg)'
