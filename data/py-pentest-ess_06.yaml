- en: Honeypot – Building Traps for Attackers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜜罐-为攻击者建立陷阱
- en: In [Chapter 5](acbc308f-dc4c-40e4-8bf4-d17a38233226.xhtml), *Wireless Pentesting*,
    you saw the various network attacks and how to prevent them. In this chapter,
    you will see some proactive approaches. In [Chapter 2](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit),
    *Scanning Pentesting*, you learned about IP scanning using ping sweep and port
    scanning by using the TCP connect scan. But what happens when the ping-sweep and
    port-scanning codes give you fake targets? You would try to exploit the fake targets.
    The machine, which is set up to act as a decoy to lure attackers, records the maneuvers
    of the attacker. After seeing all the tricks and attacks, the admin can build
    a new strategy to harden the network. In this chapter, we will use Python code
    to accomplish the tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](acbc308f-dc4c-40e4-8bf4-d17a38233226.xhtml)中，*无线渗透*，您看到了各种网络攻击以及如何防范。在本章中，您将看到一些积极的方法。在[第2章](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit)，*扫描渗透*，您学习了使用ping扫描进行IP扫描以及使用TCP连接扫描进行端口扫描。但是当ping扫描和端口扫描代码给出虚假目标时会发生什么？您会尝试利用虚假目标。设置为诱使攻击者的诱饵机器记录攻击者的动作。在看到所有的技巧和攻击之后，管理员可以制定新的网络加固策略。在本章中，我们将使用Python代码来完成任务。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Fake ARP reply
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪ARP回复
- en: Fake ping reply
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪ping回复
- en: Fake port-scanning reply
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪端口扫描回复
- en: Fake OS-signature reply to nmap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对nmap的伪OS签名回复
- en: Fake web server reply
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪Web服务器回复
- en: The ARP protocol comes under the TCP/IP layer 1, Network Access Layer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ARP协议属于TCP/IP第1层，网络访问层。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Python 2.7.x installed on a system. Finally, to
    use the Git repository of this book, the user needs to install Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要在系统上安装Python 2.7.x。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的运行情况：
- en: '[https://goo.gl/jbgbBU](https://goo.gl/jbgbBU)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/jbgbBU](https://goo.gl/jbgbBU)'
- en: Fake ARP reply
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪ARP回复
- en: In this section, we will learn how to send a fake ARP reply. The fake ARP reply
    program is made for the fake ping reply because when the attacker sends the ping
    request to a particular IP, the attacker machine first sends an ARP request for
    the MAC address.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何发送伪ARP回复。伪ARP回复程序是为了伪ping回复而制作的，因为当攻击者向特定IP发送ping请求时，攻击者机器首先发送ARP请求以获取MAC地址。
- en: 'When an attacker is on the subnet of the honeypot or outside the subnet, a fake
    reply will be sent by the honeypot. Let''s see the topology diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者在蜜罐的子网上或子网外时，蜜罐将发送伪回复。让我们看看拓扑图：
- en: '![](img/8cf458f9-5822-4a0e-8c19-08ddcc9fbbfb.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf458f9-5822-4a0e-8c19-08ddcc9fbbfb.jpg)'
- en: 'I have used three machines: Debian running honeypot codes, RHEL, as a gateway,
    and Kali Linux, as the attacker machine.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了三台机器：运行蜜罐代码的Debian，作为网关的RHEL，以及作为攻击者机器的Kali Linux。
- en: 'Let''s see the fake reply code. The code name is `arp_reply.py`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看伪回复代码。代码名称是`arp_reply.py`：
- en: 'The following modules will be used in the code:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将使用以下模块：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following code, two sockets have been created. One for the receiver
    and one for sending the reply packet. A global queue, `Q`, is created as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，创建了两个套接字。一个用于接收器，一个用于发送回复数据包。创建了一个全局队列`Q`，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following function receives the incoming frames. The `arp_l = struct.unpack("!2s2sss2s6s4s6s4s",arp_h)` code
    unpacks the ARP packets and the `if arp_l[4] == ''\x00\x01'':` syntax only broadcasts
    ARP packets. The `Q.put([eth,arp_l])` syntax puts the packets in the global queue, `Q`,
    as follows:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数接收传入的帧。`arp_l = struct.unpack("!2s2sss2s6s4s6s4s",arp_h)`代码解包ARP数据包，`if
    arp_l[4] == '\x00\x01':`语法只广播ARP数据包。`Q.put([eth,arp_l])`语法将数据包放入全局队列`Q`中，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following function get the ARP packets from global queue. The function
    takes the MAC (current machine MAC) from the command-line argument, which is provided
    by the user. After forming Ethernet and ARP packets, the `mysocket_s.send(target_packet)` syntax
    sends the packet as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数从全局队列获取ARP数据包。该函数从用户提供的命令行参数中获取MAC（当前机器MAC）。在形成以太网和ARP数据包之后，`mysocket_s.send(target_packet)`语法发送数据包，如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following piece of code creates two threads that run the receiver and sender
    functions in parallel:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码创建了两个线程，以并行方式运行接收器和发送器函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before running the code, use the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码之前，使用以下命令：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command disables the built-in TCP/IP reply, because now our program
    will send the reply.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令禁用了内置的TCP/IP回复，因为现在我们的程序将发送回复。
- en: 'Let''s run the code by using the following command in the Debian machine:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Debian机器上使用以下命令来运行代码：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In my machine, I''ve given it as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我已经给出如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now the `arp_reply` code is running. Now we have to run the fake code that would
    give the fake ping reply.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`arp_reply`代码正在运行。现在我们必须运行会给出伪ping回复的伪代码。
- en: Fake ping reply
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪ping回复
- en: In this section, you will learn how to send fake ping reply packets. In the
    fake ping reply code, I have not used any libraries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何发送伪ping回复数据包。在伪ping回复代码中，我没有使用任何库。
- en: 'Let''s understand the code. The code name is `icmp_reply.py`. In order to run
    the code, you need to install the `ping` module from [https://pypi.python.org/pypi/ping/0.2](https://pypi.python.org/pypi/ping/0.2):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解代码。代码名称是`icmp_reply.py`。为了运行代码，您需要从[https://pypi.python.org/pypi/ping/0.2](https://pypi.python.org/pypi/ping/0.2)安装`ping`模块：
- en: 'The following modules have been used in the code:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中使用了以下模块：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code defines a queue, `Q`, and two sockets. One socket will be
    used to receive packets and the other will be used to send packet:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码定义了一个队列`Q`和两个套接字。一个套接字将用于接收数据包，另一个将用于发送数据包：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following piece of code will be used to calculate the checksum of the ICMP
    reply packets. The code is very complicated:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码将用于计算ICMP回复数据包的校验和。代码非常复杂：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following function is used to calculate the checksum of the IPv4 packets:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数用于计算IPv4数据包的校验和：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following function is responsible for making the IPv4 header for the ICMP
    reply packet:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数负责为ICMP回复数据包创建IPv4头：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function makes an ICMP reply packet. In the `ipv4_creator` and `icmp_creator`
    functions, I used different approaches to add fields. You can use whatever approach
    you like. In the `IPv4_creator` function, I used `ipv4_new_header = field1+ip_id+field2+''40''.decode(''hex'')+protocol+check_sum.decode(''hex'')+ip2+ip1`
    to add fields, and in `icmp_creator`, I used `struct.pack` to form the packets:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数生成ICMP回复数据包。在`ipv4_creator`和`icmp_creator`函数中，我使用了不同的方法来添加字段。您可以使用任何您喜欢的方法。在`IPv4_creator`函数中，我使用`ipv4_new_header
    = field1+ip_id+field2+'40'.decode('hex')+protocol+check_sum.decode('hex')+ip2+ip1`来添加字段，在`icmp_creator`中，我使用`struct.pack`来形成数据包：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following function creates the Ethernet header:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数创建了以太网头：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code receives the incoming request packet. Just for simplicity,
    I took 20 bytes for the IPv4 header:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码接收传入的请求数据包。为简单起见，我为IPv4头部取了20个字节：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following function sends the ICMP reply packets:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数发送ICMP回复数据包：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following piece of code two threads are created, which run the receiver
    and sender functions:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码创建了两个线程，分别运行接收和发送函数：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that the coding part is complete, run `code icmp_reply.py`. Please make
    sure `arp_reply` is running. To test the code, just ping the different IPs from
    Kali Linux, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编码部分已经完成，请运行`code icmp_reply.py`。请确保`arp_reply`正在运行。要测试代码，只需从Kali Linux ping不同的IP，如下图所示：
- en: '![](img/b725f338-2b23-45ab-a67a-4de33a8af68e.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b725f338-2b23-45ab-a67a-4de33a8af68e.jpg)'
- en: 'The preceding output shows that the code is working fine.  Let''s test with
    the `ping_sweep_send_rec.py` code from [Chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml),
    *Scanning Pentesting*. See the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示代码运行正常。让我们使用[第2章](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml)中的`ping_sweep_send_rec.py`代码进行测试，*扫描渗透测试*。请参阅以下屏幕截图：
- en: '![](img/f7077bea-933b-4cb2-826f-ed4f224546dd.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7077bea-933b-4cb2-826f-ed4f224546dd.jpg)'
- en: We are getting fake replies for 100 IPs. Our next aim is to give fake replies
    to the transport layer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为100个IP获得虚假回复。我们的下一个目标是给传输层提供虚假回复。
- en: Fake port-scanning reply
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假端口扫描回复
- en: 'In this section, we will look at how to give a fake reply at the TCP layer.
    The program will give fake replies to open ports. For this code, we are going
    to use the scapy library because the TCP header is very complicated to make. The
    program name is `tcp_trap.py`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何在TCP层给出虚假回复。程序将对打开的端口给出虚假回复。对于这段代码，我们将使用scapy库，因为TCP头部非常复杂。程序名称是`tcp_trap.py`：
- en: 'Use the following library and module:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下库和模块：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A raw socket has been created to receive incoming packets as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已创建原始套接字以接收传入数据包，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following function receives the incoming TCP/IP packets. A lot of lines
    have already been discussed in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*. The  if (`D_port==445` or `D_port==135` or
    `D_port==80`): syntax shows that we are only interested in ports  `445`, `135`,
    and `80`:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数接收传入的TCP/IP数据包。很多行已经在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)，*嗅探和渗透测试*中讨论过。`if（D_port==445`或`D_port==135`或`D_port==80`）：语法表明我们只对端口`445`、`135`和`80`感兴趣：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following function sends the TCP SYN, ACK-flag-enabled response for ports
    `445` and `135`, and for port `80` RST, ACK flags are sent:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数发送TCP SYN，ACK标志启用的响应，端口为`445`和`135`，端口`80`发送RST，ACK标志：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following piece of code indicates the creation of threads, one to handle
    the receiver function and three to handle the sender function:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码指示了线程的创建，一个用于处理接收函数，另外三个用于处理发送函数：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Due to scapy, the library code has become very short. Now run the `tcp_trap.py` code.
    Make sure the `arp_reply.py` and `icmp_reply.py` codes are also being run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于scapy，库代码变得非常简短。现在运行`tcp_trap.py`代码。确保`arp_reply.py`和`icmp_reply.py`代码也在运行。
- en: 'From the attacker, the machine runs the `nmap`; see the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者那里，机器运行`nmap`；请参阅以下屏幕截图：
- en: '![](img/705a9bfd-da56-4d7d-ac71-fcc9c8b8b5cb.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/705a9bfd-da56-4d7d-ac71-fcc9c8b8b5cb.png)'
- en: In the preceding output, we have used `nmap` and `portscanner_15.py` ([Chapter
    2](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit),
    *Scanning Pentesting*). Both `nmap` and the Python code use the three-way handshake
    process. The output shows that ports `135` and `445` are open.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们使用了`nmap`和`portscanner_15.py`（[第2章](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit)，*扫描渗透测试*）。`nmap`和Python代码都使用了三次握手过程。输出显示端口`135`和`445`是打开的。
- en: Fake OS-signature reply to nmap
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nmap的虚假OS签名回复
- en: 'In this section, we are going to create a fake OS signature. By using the following
    `nmap`, we can identify the OS of the victim machine:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个虚假的OS签名。通过使用以下`nmap`，我们可以识别受害者机器的操作系统：
- en: '`nmap -O <ip-address>`: The `nmap` sends seven TCP/IP-crafted packets and evaluates
    the response with its own OS signature databases. For more details, you can read
    the web page at [https://nmap.org/misc/defeat-nmap-osdetect.html](https://nmap.org/misc/defeat-nmap-osdetect.html).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap -O <ip-address>`：`nmap`发送七个TCP/IP精心制作的数据包，并使用自己的OS签名数据库评估响应。有关更多详细信息，您可以阅读[https://nmap.org/misc/defeat-nmap-osdetect.html](https://nmap.org/misc/defeat-nmap-osdetect.html)网页。'
- en: The `nmap` needs at least one open and one closed port to identify the OS. Again,
    we are going to use all the previous codes. The ports `445` and `135` acts as
    open ports and `80` act as a closed port.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap`需要至少一个开放和一个关闭的端口来识别操作系统。同样，我们将使用之前的所有代码。端口`445`和`135`作为开放端口，`80`作为关闭端口。'
- en: 'Let''s run `nmap` as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`nmap`，如下截图所示：
- en: '![](img/5dbde29f-8ac4-45ca-905a-89e97e228e46.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dbde29f-8ac4-45ca-905a-89e97e228e46.jpg)'
- en: It is giving a different OS, not Debian. You can make the code more complicated
    by learning the `nmap` OS detection algorithm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了不同的操作系统，而不是Debian。通过学习`nmap`操作系统检测算法，您可以使代码变得更加复杂。
- en: Fake web server reply
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假的Web服务器回复
- en: In this section, you will learn how to create a fake web server signature. This
    is the application layer code. This section's code has no relation to the previous
    code. In order to get the server signature or banner grabbing, I am going to use
    the ID Servetool.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何创建一个虚假的Web服务器签名。这是应用层代码。本节的代码与之前的代码无关。为了获取服务器签名或横幅抓取，我将使用ID Servetool。
- en: 'Let''s see the `fake_webserver.py` code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`fake_webserver.py`代码：
- en: 'Use the following modules in the program. The `logger1` module is used to create
    a log file. You will see the code of `logger1` later:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中使用以下模块。`logger1`模块用于创建日志文件。稍后您将看到`logger1`的代码：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Look at the following piece of code carefully. The `fakewebserver ` class inherits
    the `BaseHTTPRequestHandler` class. The `send_response` method is overriding the
    method of the `BaseHTTPRequestHandler` class because we are sending our custom
    message as `self.send_header(''Server'', "mohit``raj")`. The `log_date_time_string` and
    `send_header` methods and the `client_address` instance variable are inherited
    from the `BaseHTTPRequestHandler` class. Here I am sending the `mohit raj` server
    name as:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细看以下代码片段。`fakewebserver`类继承自`BaseHTTPRequestHandler`类。`send_response`方法覆盖了`BaseHTTPRequestHandler`类的方法，因为我们将我们的自定义消息发送为`self.send_header('Server',
    "mohit``raj")`。`log_date_time_string`和`send_header`方法以及`client_address`实例变量都是从`BaseHTTPRequestHandler`类继承的。在这里，我将`mohit
    raj`服务器名称发送为：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following method sends the header and response code:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下方法发送标头和响应代码：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following method gets invoked when a `GET` request comes:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收到`GET`请求时，将调用以下方法：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following method gets invoked when a `HEAD` request comes:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收到`HEAD`请求时，将调用以下方法：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is used for an incoming `POST` request:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用于传入的`POST`请求：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following function is used to start the server. Port `80` would be used.
    The `serve_forever` method handles requests until an explicit `shutdown()` request
    is received. The method is inherited from the `SocketServer.BaseServer` class:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数用于启动服务器。将使用端口`80`。`serve_forever`方法处理请求，直到收到显式的`shutdown()`请求。该方法是从`SocketServer.BaseServer`类继承的：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code on another machine. I am using Windows 10 to run the code. From
    a second computer, use the tool ID server to find the server signature. I got
    the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一台机器上运行代码。我正在使用Windows 10来运行代码。从第二台计算机上，使用工具ID服务器来查找服务器签名。我得到了以下输出：
- en: '![](img/9eb7b79d-f007-4e3d-be5c-192f8fd2a3f3.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eb7b79d-f007-4e3d-be5c-192f8fd2a3f3.jpg)'
- en: From the output, we can say our code is running fine. So you can craft your
    own message.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以说我们的代码运行正常。因此，您可以编写自己的消息。
- en: 'Let''s see the code of `logger1`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`logger1`的代码：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code creates a log file that tells us the client address of the
    incoming requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了一个日志文件，告诉我们传入请求的客户端地址。
- en: 'See the output of the `live1.log` file as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`live1.log`文件的输出，如下截图所示：
- en: '![](img/15541ec1-181d-475c-8b62-f1888ac140d9.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15541ec1-181d-475c-8b62-f1888ac140d9.jpg)'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned how to send a fake ICMP (ping) reply. In order
    to send the ICMP reply, the ARP protocol must be running. By running both the
    codes simultaneously, they create an illusion at the network layer. But, before
    running the code, a firewall must be set to drop the outgoing frames. At the transport
    layer, two experiments were performed: a fake port open and fake OS running. By
    learning more about `nmap`, an exact fake response of a particular OS can be created.
    At the application layer, a Python web server code is giving a fake server signature.
    You can change the server signature according to your needs.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何发送虚假的ICMP（ping）回复。为了发送ICMP回复，必须运行ARP协议。通过同时运行这两个代码，它们在网络层上创建了一种错觉。但是，在运行代码之前，必须设置防火墙以丢弃传出帧。在传输层，进行了两个实验：虚假的端口开放和虚假的操作系统运行。通过更多了解`nmap`，可以创建特定操作系统的准确虚假响应。在应用层，Python
    Web服务器代码提供了一个虚假的服务器签名。您可以根据自己的需要更改服务器签名。
- en: In [Chapter 7](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml), *Foot Printing a
    Web Server and a Web Application*, you will learn about footprinting a web server.
    You will also learn how to obtain the header of HTTP and about banner grabbing
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml)中，*足迹打印Web服务器和Web应用程序*，您将学习如何足迹打印Web服务器。您还将学习如何获取HTTP的标头和横幅抓取
