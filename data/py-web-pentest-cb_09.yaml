- en: Chapter 9. Reporting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。报告
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Converting Nmap XML to CSV
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Nmap XML转换为CSV
- en: Extracting links from URLs to Maltego
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从URL提取链接到Maltego
- en: Extracting e-mails to Maltego
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从URL提取电子邮件到Maltego
- en: Parsing Sslscan to CSV
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Sslscan解析为CSV
- en: Generating graphs using `plot.ly`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`plot.ly`生成图表
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We’ve got recipes throughout this book to perform various aspects of web application
    testing. So, we’ve got all this information. We’ve got console outputs from our
    recipes, but how do we collect all this into a useful format? Ideally, we’ll want
    the output to be in a format that we can use. Or we might want to convert the
    output from another application such as Nmap, into the format that we’re using.
    This can either be as **comma separated variables** (**CSV**), or possibly a Maltego
    transform, or any other format that you want to work with.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中有各种执行Web应用程序测试的方法。因此，我们有所有这些信息。我们从我们的方法中得到控制台输出，但是如何将所有这些收集到一个有用的格式中呢？理想情况下，我们希望输出以一种我们可以使用的格式。或者我们可能希望将来自另一个应用程序（如Nmap）的输出转换为我们正在使用的格式。这可以是**逗号分隔变量**（**CSV**），或者可能是Maltego变换，或者任何您想要使用的其他格式。
- en: What’s this Maltego thing you just mentioned? I hear you ask. Maltego is an
    **Open Source Intelligence** (**OSINT**) and forensics application. It has a nice
    GUI that helps you visualize your information in a nice, pretty, and easy to understand
    way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才提到的Maltego是什么？我听到你问。Maltego是一个**开源情报**（**OSINT**）和取证应用程序。它有一个漂亮的GUI，可以帮助您以一种漂亮、漂亮且易于理解的方式可视化您的信息。
- en: Converting Nmap XML to CSV
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Nmap XML转换为CSV
- en: Nmap is a common tool used in the reconnaissance phase of a web application
    test. It is normally used to scan ports with a variety of options to help you
    customise the scan to exactly how you like it. For instance, do you want to do
    TCP or UDP? What TCP flags do you want to set? Is there a particular Nmap script
    that you would like to run, such as checking for **Network Time Protocol** (**NTP**)
    reflection, but on a non-default port? The list can be endless.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap是在Web应用程序测试的侦察阶段中常用的工具。通常用于使用各种选项扫描端口，以帮助您自定义扫描的方式。例如，您想要进行TCP还是UDP？您想设置什么TCP标志？是否有特定的Nmap脚本，例如检查**网络时间协议**（**NTP**）反射，但在非默认端口上运行？列表可能是无穷无尽的。
- en: The Nmap output is easy to read, but not very easy to use in a programmatic
    way. This simple recipe will convert XML output from Nmap (through the use of
    the –oX flag when running an Nmap scan) and convert it to CSV output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap输出很容易阅读，但在程序化的方式下并不容易使用。这个简单的示例将把Nmap的XML输出（通过在运行Nmap扫描时使用-oX标志）转换为CSV输出。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While this recipe is very simple in its implementation, you will need to install
    Python’s `nmap` module. You can do this by using `pip` or building it from the
    source files. You will also need XML output from an Nmap scan. You can get this
    from scanning a vulnerable virtual machine of your choice or a site that you have
    permission to run a scan on. You can use Nmap as it is or you can use Python’s
    `nmap` module to do this within a Python script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例在实现上非常简单，但您需要安装Python的`nmap`模块。您可以使用`pip`或从源文件构建它来实现。您还需要来自Nmap扫描的XML输出。您可以从扫描您选择的易受攻击的虚拟机或您有权限扫描的站点中获取这些输出。您可以直接使用Nmap，也可以在Python脚本中使用Python的`nmap`模块来实现。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Like I mentioned earlier, this recipe is very simple. This is mainly due to
    the fact that the `nmap` library has done most of the hard work for us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前提到的，这个示例非常简单。这主要是因为`nmap`库已经为我们做了大部分的工作。
- en: 'Here’s the script that we are going to use for this task:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于此任务的脚本：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'So, after the importing of necessary modules, we have to initialize an Nmap’s
    `Portscanner` function. Although we won’t be doing any port scanning within this
    recipe, this is necessary to allow us to use the methods within the object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在导入必要的模块之后，我们必须初始化Nmap的`Portscanner`函数。尽管在这个示例中我们不会进行任何端口扫描，但这是必要的，以便我们可以使用对象中的方法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we have a `with` statement. What’s one of those? Previously, when you
    opened files in Python, you would have to remember to close it once you were finished.
    In this situation, the `with` statement will do that for you once all the code
    within it has been executed. It’s great if you don’t have a great memory and keep
    forgetting to close files in your code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`with`语句。那是什么？以前，在Python中打开文件时，您必须记住在完成后关闭它。在这种情况下，`with`语句将在其中的所有代码执行完毕后为您关闭文件。如果您记忆力不好，经常忘记在代码中关闭文件，这将非常有用：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the `with` statement, we read the contents of the file into a `content`
    variable (we could call this variable whatever we want, but why overcomplicate
    things?):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句之后，我们将文件的内容读入`content`变量中（我们可以将此变量命名为任何我们想要的，但为什么要使事情变得过于复杂呢？）：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the `Portscanner` object we created earlier, we can now analyze the contents
    with a method that will parse the XML output we have provided, which we can then
    print out as a CSV:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前创建的`Portscanner`对象，我们现在可以分析我们提供的XML输出的内容，然后将其打印为CSV：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extracting links from a URL to Maltego
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从URL提取链接到Maltego
- en: There is another recipe in this book that illustrates how to use the `BeautifulSoup`
    library to programmatically get domain names. This recipe will show you how to
    create a local Maltego transform, which you can then use within Maltego itself
    to generate information in an easy to use, graphical way. With the links gathered
    from this transform, this can then also be used as part of a larger spidering
    or crawling solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中还有另一个示例，说明如何使用`BeautifulSoup`库以编程方式获取域名。这个示例将向您展示如何创建一个本地的Maltego变换，然后您可以在Maltego中使用它以一种易于使用、图形化的方式生成信息。通过从这个变换中收集的链接，这也可以作为更大的爬虫或抓取解决方案的一部分使用。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following code shows how you can create a script that will output the enumerated
    information into the correct format for Maltego:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何创建一个脚本，将枚举信息输出到Maltego的正确格式中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First we import all the necessary modules for this recipe. You may have noticed
    that for `BeautifulSoup`, we have the following line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为这个配方导入所有必要的模块。您可能已经注意到，对于`BeautifulSoup`，我们有以下行：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is so that when we use `BeautifulSoup`, we just have to type `BeautifulSoup`
    instead of `bs4.BeautifulSoup`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们使用`BeautifulSoup`时，我们只需输入`BeautifulSoup`，而不是`bs4.BeautifulSoup`。
- en: 'We then assign the target URL supplied in the argument into a variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将提供的目标URL分配给一个变量：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have done that, we check to see whether the target URL ends in a `/`.
    If it does, then we remove the last character by replacing the `tarurl` variable
    with all but the last character of `tarurl`, so that it can be used later on in
    the recipe when outputting relative links in full:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们检查目标URL是否以`/`结尾。如果是，则通过用`tarurl`变量替换`tarurl`的最后一个字符之外的所有字符，以便在配方中输出完整的相对链接时可以稍后使用：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then print out the tags that form part of a Maltego transform response:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印出构成Maltego变换响应的标签：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then open the target `url` with `urllib2` and store this within `BeautifulSoup`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`urllib2`打开目标`url`并将其存储在`BeautifulSoup`中：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now use soup to find all `<a>` tags. More specifically, we will be looking
    for the `<a>` tags with hypertext references (links):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用soup来查找所有`<a>`标签。更具体地说，我们将寻找具有超文本引用（链接）的`<a>`标签：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the first four characters of the link are `http`, we’ll output it into the
    correct format as an entity for Maltego:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接的前四个字符是`http`，我们将其输出为Maltego的实体的正确格式：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the first character is a `/`, which indicates that the link is a relative
    link, then we’ll output it to the correct format after we have prepended the target
    URL to the link. While this recipe shows how to deal with one example of a relative
    link, it is important to note that there are other types of relative links, such
    as just a filename (`example.php`), a directory, and also a relative path dot
    notation (`../../example.php`), as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个字符是`/`，表示链接是相对链接，那么我们将在将目标URL添加到链接之后将其输出到正确的格式。虽然这个配方展示了如何处理相对链接的一个示例，但重要的是要注意，还有其他类型的相对链接，比如只是一个文件名（`example.php`），一个目录，以及相对路径点符号（`../../example.php`），如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we have processed all the links on the page, we close all the tags that
    we opened at the start of the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理页面上的所有链接之后，我们关闭了输出开始时打开的所有标签：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s more…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `BeautifulSoup` library contains other functions that could make your code
    simpler. One of these functions is called **SoupStrainer**. SoupStrainer will
    allow you to parse only the parts of the document that you want. We have left
    this as an exercise for you to explore.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeautifulSoup`库包含其他可以使您的代码更简单的函数。其中一个函数叫做**SoupStrainer**。SoupStrainer允许您仅解析您想要的文档部分。我们留下这个作为一个让您探索的练习。'
- en: Extracting e-mails to Maltego
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将电子邮件提取到Maltego
- en: There is another recipe in this book that illustrates how to extract e-mails
    from a website. This recipe will show you how to create a local Maltego transform,
    which you can then use within Maltego itself to generate information. It can be
    used in conjunction with URL spidering transforms to pull e-mails from entire
    websites.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中还有另一个配方，说明了如何从网站中提取电子邮件。这个配方将向您展示如何创建一个本地的Maltego变换，然后您可以在Maltego本身中使用它来生成信息。它可以与URL蜘蛛变换一起使用，从整个网站中提取电子邮件。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following code shows how to extract e-mails from a website through the
    use of regular expressions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何通过使用正则表达式从网站中提取电子邮件：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The top of the script imports the necessary modules. After this, we then assign
    the URL supplied as an argument to a variable and open the `url` list using `urllib2`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的顶部导入了必要的模块。之后，我们将提供的URL分配为一个变量，并使用`urllib2`打开`url`列表：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then create a regular expression that matches the format of a standard e-mail
    address:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个匹配标准电子邮件地址格式的正则表达式：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding regular expression should match e-mail addresses in the format
    `email@address.com` or e-mail at address dot com.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的正则表达式应匹配格式为`email@address.com`或电子邮件在地址点com中的电子邮件地址。
- en: 'We then output the tags required for a valid Maltego transform output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们输出了一个有效的Maltego变换输出所需的标签：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we find all instances of text that match our regular expression inside
    the `url` content:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到`url`内容中与我们的正则表达式匹配的所有文本实例：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then take each e-mail address we have found and output it in the correct
    format for a Maltego transform response:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到我们找到的每个电子邮件地址，并以正确的格式输出到Maltego变换响应中：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then close the open tags that we opened earlier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们关闭了之前打开的标签：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Parsing Sslscan into CSV
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Sslscan解析为CSV
- en: Sslscan is a tool used to enumerate the ciphers supported by HTTPS sites. Knowing
    the ciphers that are supported by a site is useful in web application testing.
    This is even more useful in a penetration test if some of the supported ciphers
    are weak.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Sslscan是一种用于枚举HTTPS站点支持的密码的工具。了解站点支持的密码对Web应用程序测试很有用。如果一些支持的密码较弱，这在渗透测试中更有用。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This recipe will run Sslscan on a specified IP address and output the results
    into a CSV format:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将在指定的IP地址上运行Sslscan，并将结果输出为CSV格式：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We first import the necessary modules and assign the filename supplied in the
    argument to a variable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的模块，并将参数中提供的文件名分配给一个变量：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The filename supplied should point to a file containing a list of IP addresses.
    We open this file as read-only:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的文件名应指向包含IP地址列表的文件。我们以只读方式打开此文件：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then open up a file for reading and writing output by using `w+` instead
    of `r`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打开一个文件以进行读取和写入输出，而不是使用`r`：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have our input and somewhere to write our output, we’re ready to
    rock and roll. We start by iterating through the IP addresses:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入和写输出的地方，我们已经准备好了。我们首先通过IP地址进行迭代：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For each IP, we run Sslscan:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个IP，我们运行Sslscan：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then split up the output from the command into chunks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将命令的输出分成几块：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then go through the output, line by line. If the line contains the word
    `Accepted`, then we arrange the elements of the line for CSV output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们逐行查看输出。如果行包含`Accepted`这个词，那么我们会为CSV输出排列行的元素：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, if for any reason the attempt to run the SSL scan on the IP fails,
    we simply move on to the next IP address:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果由于任何原因尝试对IP运行SSL扫描失败，我们只需继续下一个IP地址：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Generating graphs using plot.ly
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用plot.ly生成图表
- en: Sometimes it’s really nice to have a visual representation of your data. In
    this recipe, we are going to look at using the `plot.ly` python API to generate
    a nice graph.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候有一个数据的可视化表示真的很好。在这个示例中，我们将使用`plot.ly` python API来生成一个漂亮的图表。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will be using the `plot.ly` API to generate our graph. If
    you don’t already have one, you’ll need to sign up for an account at [https://plot.ly](https://plot.ly).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`plot.ly` API来生成我们的图表。如果您还没有账户，您需要在[https://plot.ly](https://plot.ly)注册一个账户。
- en: Once you have an account, you will need to prepare your environment for using
    `plot.ly`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了账户，您就需要准备好使用`plot.ly`的环境。
- en: 'The easiest way is to use `pip` to install it, so simply run the command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用`pip`来安装它，所以只需运行以下命令：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you will need to run the following command (substituting the `{username}`,
    `{apikey}`, and `{streamids}` with your own, which are viewable under your account
    subscriptions on the `plot.ly` site):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要运行以下命令（用您自己的用户名、API密钥和流ID替换`{username}`、`{apikey}`和`{streamids}`，这些信息可以在`plot.ly`网站的账户订阅下查看）：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you are following along with this example, I used the `pcap` file that is
    available online here for testing: [http://www.snaketrap.co.uk/pcaps/hbot.pcap](http://www.snaketrap.co.uk/pcaps/hbot.pcap).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在按照这个示例进行操作，我使用的是在线测试的`pcap`文件：[http://www.snaketrap.co.uk/pcaps/hbot.pcap](http://www.snaketrap.co.uk/pcaps/hbot.pcap)。
- en: We will be enumerating all the FTP packets from the `pcap` file and plotting
    them against time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将枚举`pcap`文件中的所有FTP数据包，并将它们根据时间绘制出来。
- en: To parse the `pcap` file, we will be using the `dpkt` module. Like `Scapy`,
    which has been used in earlier recipes, `dpkt` can be use to parse and manipulate
    packets.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析`pcap`文件，我们将使用`dpkt`模块。就像之前的示例中使用的`Scapy`一样，`dpkt`可以用来解析和操作数据包。
- en: 'The easiest way is to use `pip` to install it. Simply run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用`pip`来安装它。只需运行以下命令：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This recipe will read a `pcap` file and extract the dates and times of any
    FTP packets before plotting this data to a graph:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将读取一个`pcap`文件，并提取任何FTP数据包的日期和时间，然后将这些数据绘制成图表：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We first import the necessary modules and assign the filename of our `pcap`
    file to a variable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的模块，并将我们的`pcap`文件的文件名分配给一个变量：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we set up our lists that we will populate when we iterate over our `pcap`
    file. The `Full_datetime_list` variable will hold all the FTP packets dates while
    `dates` we will use to hold unique `datetime` from the full list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置我们将在迭代`pcap`文件时填充的列表。`Full_datetime_list`变量将保存所有FTP数据包的日期，而`dates`将用于保存完整列表中唯一的`datetime`：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then open up the `pcap` file for reading and iterate over it in a `for`
    loop. This section checks that the packet is an FTP packet and if it is, it then
    appends the time to our array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打开`pcap`文件进行读取，并在`for`循环中迭代。这一部分检查数据包是否是FTP数据包，如果是，然后将时间追加到我们的数组中：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have our list of `datetime` function for the FTP traffic, we can
    get the unique `datetime` function out of it and populate our `dates` array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了FTP流量的`datetime`函数列表，我们可以从中获取唯一的`datetime`函数，并填充我们的`dates`数组：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We then sort the dates, so that they are in order on our graph:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对日期进行排序，以便它们在我们的图表上按顺序排列：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we simply iterate over the unique dates and count all the packets sent/received
    during that time from our larger array and populate our counter array:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需迭代唯一的日期，并计算在那个时间段内从我们的较大数组中发送/接收的所有数据包，并填充我们的计数器数组：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All that is left to do is make an API call to `plot.ly`, using our date array
    and count the array as the data points:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是通过API调用`plot.ly`，使用我们的日期数组和计数数组作为数据点：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When you run the script, it should pop open the browser to your newly created
    `plot.ly` graph, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行脚本时，它应该会弹出浏览器到您新创建的`plot.ly`图表，如下所示：
- en: '![How it works…](img/B04044_09_01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04044_09_01.jpg)'
- en: And that’s all there is to it. `plot.ly` has a lot of different methods to visualize
    your data and it is well worth having a play around with it. Think of how impressed
    your boss will be when they see all the pretty graphs that you start sending them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。`plot.ly`有很多不同的方法来可视化您的数据，值得花点时间去尝试一下。想象一下当老板看到您发送给他们的漂亮图表时会有多么印象深刻。
