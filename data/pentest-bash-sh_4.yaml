- en: Chapter 4. Exploitation and Reverse Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。利用和逆向工程
- en: In the previous chapter, we covered some of the command-line tools that handle
    target enumeration on the network. In this chapter, we're going to look at a collection
    of tools that enable you to perform activities such as reverse engineering and
    backdooring hosts, and we will also cover ways to integrate powerful tools such
    as the Metasploit exploitation framework and bash scripting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一些处理网络上目标枚举的命令行工具。在本章中，我们将看一些工具的集合，使您能够执行诸如逆向工程和后门主机等活动，并且我们还将介绍集成强大工具的方法，例如Metasploit利用框架和bash脚本。
- en: In addition, we will cover a collection of tools in this chapter that may enable
    you to discover memory corruption, code injection, and general data- or file-handling
    flaws that may be used to instantiate arbitrary code execution vulnerabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将涵盖一系列工具，这些工具可能使您能够发现内存损坏、代码注入和一般数据或文件处理缺陷，这些缺陷可能用于实例化任意代码执行漏洞。
- en: Every vulnerability discovered everywhere at some point involves reverse engineering.
    When someone figures out how to exploit a given behavior—in a piece of code—it
    means this person has, to some extent, detailed the nuances of the given behavior
    and used this knowledge to take advantage of it. This process is called reverse
    engineering. As reverse engineering has such crucial importance, we will cover
    some of the fundamental tools that play a part in reverse engineering. We will
    specifically focus on the tools packaged with Kali Linux that are purely command-line-driven—hence
    the book's title.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时间点发现的每个漏洞都涉及逆向工程。当有人找出如何利用给定行为时——在一段代码中——这意味着这个人在某种程度上详细说明了给定行为的细微差别，并利用这些知识来利用它。这个过程称为逆向工程。由于逆向工程具有如此重要的意义，我们将涵盖一些在逆向工程中发挥作用的基本工具。我们将特别关注Kali
    Linux中打包的纯命令行驱动的工具——因此是本书的标题。
- en: Using the Metasploit command-line interface
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit命令行界面
- en: Metasploit is probably the most widely used penetration testing and exploitation
    development framework—the one tool people use the most for testing, finding, and
    developing exploits for vulnerabilities. Over the years, Metasploit is seen as
    support to the security industry's most talented developers and exploit writers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit可能是最广泛使用的渗透测试和利用开发框架，人们用来测试、发现和开发漏洞利用的最常用工具。多年来，Metasploit被视为安全行业最有才华的开发人员和利用编写者的支持。
- en: One of the many useful functionalities of the Metasploit Framework is its ability
    to expose the invocation of its modules and tools to the command line. This means
    Metasploit can be used in the feature-rich and powerful problem-solving environment
    of the bash shell. This functionality is known as the **Metasploit command-line
    interface** (**msfcli**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit框架的许多有用功能之一是其能够将其模块和工具的调用暴露给命令行。这意味着Metasploit可以在功能丰富和强大的问题解决环境中使用bash
    shell。这个功能称为**Metasploit命令行界面**（**msfcli**）。
- en: Getting started with msfcli
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用msfcli入门
- en: In this section, we will see how to use the Metasploit command-line interface
    to do basic scanning, exploit some generic vulnerabilities, and integrate some
    useful bash scripting with the Metasploit command-line interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用Metasploit命令行界面进行基本扫描，利用一些通用漏洞，并将一些有用的bash脚本与Metasploit命令行界面集成。
- en: 'The following is the usage specification for the `msfcli` command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`msfcli`命令的用法规范：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the previous command, `MODULE`, `OPTIONS`, and `MODE` are explained as
    follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个命令中，`MODULE`，`OPTIONS`和`MODE`解释如下：
- en: '`[MODULE]`: This is the Metasploit module to invoke. This could be any of the
    modules you can invoke from the Metasploit console.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[MODULE]`：这是要调用的Metasploit模块。这可以是您可以从Metasploit控制台调用的任何模块。'
- en: '`[OPTIONS]`: This is a space-delimited key-value pair list of options for the
    given module. These options are specific to the module being invoked here. In
    the following paragraphs, we will see how to determine the options for a given
    module.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[OPTIONS]`：这是给定模块的空格分隔的键值对选项列表。这些选项特定于此处调用的模块。在接下来的段落中，我们将看到如何确定给定模块的选项。'
- en: '`[MODE]`: This is the invocation mode of the module.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[MODE]`：这是模块的调用模式。'
- en: 'Consider the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous example, the `MODULE` option would be `exploit/windows/smb/ms08_067_netapi`
    and the `OPTIONS` list is `RHOST=192.168.10.108`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`MODULE`选项将是`exploit/windows/smb/ms08_067_netapi`，`OPTIONS`列表是`RHOST=192.168.10.108`。
- en: 'You can specify a bigger list of options for the modules as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式为模块指定更多选项列表：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's not important exactly what this exploit does here; we are merely demonstrating
    a basic use of msfcli. Later on, we will demonstrate ways to use msfcli to find
    out more about the exploitation modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并不重要这个利用在这里做什么；我们只是演示了msfcli的基本用法。稍后，我们将演示如何使用msfcli来了解更多关于利用模块的方法。
- en: Using invocation modes with msfcli
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用msfcli的调用模式
- en: The Metasploit command-line interface can be invoked in different ways depending
    on the invocation mode you specify. Invocation modes vary in effect, that is,
    from providing you with information about a module, for instance, information
    about who developed it, to modes that provide you with information about how you
    can enable IDS evasion techniques and which payloads can be used to trigger or
    package the associated vulnerability, if applicable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您指定的调用模式，可以以不同的方式调用Metasploit命令行界面。调用模式的效果各不相同，即从提供有关模块的信息，例如有关谁开发了它的信息，到提供有关如何启用IDS规避技术以及可以用于触发或打包相关漏洞的有效负载的信息（如果适用）。
- en: 'To start off with, let''s look at the invocation modes that are designed to
    deliver information about a module. You may not always know which options are
    available for the module you''d like to invoke. In this case, Metasploit has a
    very useful mode you can invoke with the msfcli module. The following command
    is used to do this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下旨在提供有关模块信息的调用模式。您可能不总是知道要调用的模块有哪些选项。在这种情况下，Metasploit有一个非常有用的模式，您可以使用msfcli模块调用。以下命令用于执行此操作：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous command will produce the output as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将产生以下输出：
- en: '![Using invocation modes with msfcli](img/5107OT_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用msfcli的调用模式](img/5107OT_04_01.jpg)'
- en: 'The option invocation mode—abbreviated `O` as a command-line argument—displays
    a short summary of only the necessary options, namely the options strictly required
    in order to successfully run the specified module. You may also want to know a
    little bit more about the background of the module, for instance, who developed
    it, which vulnerability it tries to exploit, and which are the operating systems
    it is designed to target. You can find this out by using the Summary invocation
    mode, which is abbreviated as `S`. The following command is used to do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选项调用模式——作为命令行参数缩写为`O`——显示了仅必要选项的简要摘要，即成功运行指定模块所需的严格必要的选项。您可能还想了解一些关于模块背景的信息，例如由谁开发，它试图利用哪些漏洞，以及它设计用于目标的操作系统。您可以使用摘要调用模式来找到这些信息，它的缩写是`S`。以下命令用于执行此操作：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous command will produce the output as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的命令将产生以下输出：
- en: '![Using invocation modes with msfcli](img/5107OT_04_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用msfcli的调用模式](img/5107OT_04_02.jpg)'
- en: 'The mode demonstrated in the preceding screenshot only prints a summary of
    the basic, necessary options. You could also have Metasploit print out the full
    list of options that use the advanced mode using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中演示的模式只打印基本必要选项的摘要。您还可以让Metasploit使用以下命令打印出使用高级模式的完整选项列表：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous command produces the output as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令产生以下输出：
- en: '![Using invocation modes with msfcli](img/5107OT_04_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![使用msfcli的调用模式](img/5107OT_04_03.jpg)'
- en: 'Some output from the preceding screenshot has been omitted for the sake of
    brevity. The following could be the other invocation options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，前面截图中的一些输出已被省略。以下可能是其他调用选项：
- en: '`AC`: This details the available options for the given module'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AC`：详细说明了给定模块的可用选项'
- en: '`C`: This checks the routine for the supplied module'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`：检查所提供模块的例行程序'
- en: '`I`: This shows the IDS evasion techniques available for this module'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I`：显示此模块可用的IDS规避技术'
- en: '`P`: This lists the available payload types for the module'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`：列出模块的可用有效载荷类型'
- en: '`T`: This lists the available operating system targets for this module'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`：列出此模块的可用操作系统目标'
- en: This concludes our discussion about the Metasploit Frameworks command-line interface.
    The next section will cover useful ways to integrate this functionality with bash
    scripting and other command-line utilities in common situations during a penetration
    test or vulnerability assessment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于Metasploit Framework命令行界面的讨论。下一部分将介绍如何在渗透测试或漏洞评估的常见情况下，将这种功能与bash脚本和其他命令行实用程序集成起来。
- en: Bash hacks and msfcli
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash hacks和msfcli
- en: Given that msfcli allows us to invoke Metasploit modules straight from the command
    line, we can do some pretty useful things such as integrate the results of an
    Nmap scan with msfcli, or plug in the results of a DNS or Whois lookup directly
    to a msfcli module invocation. The following section will demonstrate a few useful
    bash scripts that do just this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到msfcli允许我们直接从命令行调用Metasploit模块，我们可以做一些非常有用的事情，比如将Nmap扫描的结果与msfcli集成，或者直接将DNS或Whois查找的结果插入到msfcli模块调用中。接下来的部分将演示一些非常有用的bash脚本，就是做这些事情。
- en: 'If you''d like to check the exploitability of a given vulnerability on a range
    of IPs proliferated from a Whois lookup, you can execute the following bash script
    straight from your command-line interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要检查从Whois查找中传播的一系列IP的漏洞利用性，您可以直接从命令行界面执行以下bash脚本：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous commands, `[MODULE]` and `[DOMAIN NAME]` will be the name and
    path of the Metasploit module you want to use—as it is used in the Metasploit
    console—and the domain name you'd like to run the module against, respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[MODULE]`和`[DOMAIN NAME]`将分别是您想要使用的Metasploit模块的名称和路径（就像在Metasploit控制台中使用的那样），以及您想要针对其运行模块的域名。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**About long command lines**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于长命令行**'
- en: The previous example must be entered in its entirety, in one command line, in
    your bash shell. This means no pressing *Enter* until you've completed entering
    the line as it is shown. The `\` escape character allows you to enter multiple
    lines in your terminal and have it treated as a single command-line invocation.
    This avoids having your output wrap around the screen, which in some instances
    becomes a little unreadable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例必须完整输入，一次输入到您的bash shell中的一行命令。这意味着在输入完整行之前不要按*Enter*。`\`转义字符允许您在终端中输入多行并将其视为单个命令行调用。这避免了输出在屏幕上换行，这在某些情况下会变得有点难以阅读。
- en: 'The module you choose needs to support multiple hosts for the check invocation
    mode. A simple practical example is using this with a given domain name to do
    a port scan with one of the Metasploit modules. The following command shows how
    you to do this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的模块需要支持检查调用模式的多个主机。一个简单的实际示例是使用给定的域名与Metasploit模块之一进行端口扫描。以下命令显示了如何执行此操作：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, if the organization you are assessing is responsible for a number
    of IP ranges according to the Whois database, you can first enumerate all the
    IP ranges and feed them to msfcli with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您正在评估的组织根据Whois数据库负责一些IP范围，您可以首先枚举所有IP范围，并使用以下命令将它们提供给msfcli：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you''d like to specify the previous command in a single command line, it
    would look like the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在单个命令行中指定先前的命令，它将如下所示的代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another useful way in which you can combine msfcli with bash is to plug out
    from an Nmap scan, and based on which ports are found to be open, start fuzzing
    them using some of the Metasploit fuzzing modules. The following command shows
    you how to do this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将msfcli与bash结合使用的另一种有用的方法是从Nmap扫描中拔出，并根据发现的开放端口开始使用一些Metasploit模糊测试模块对它们进行模糊测试。以下命令向您展示了如何执行此操作：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If specified in a single command line, it would look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在单个命令行中指定，它将如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, you could fuzz the HTTP forms on a page with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用以下代码对页面上的HTTP表单进行模糊测试：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another example would be fuzzing the SSHv2 servers with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是使用以下代码对SSHv2服务器进行模糊测试：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are many more examples that one can demonstrate here. In fact, you can
    write an entire book that comprises just examples that involve msfcli and port
    scanning tools. Not only this, but you could also develop your own Metasploit
    fuzzing and vulnerability scanning modules.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以展示许多其他例子。实际上，您可以编写一本完全由涉及msfcli和端口扫描工具的例子组成的书。不仅如此，您还可以开发自己的Metasploit模糊测试和漏洞扫描模块。
- en: 'The point behind explaining these examples was to show you a general style
    you can follow, should you want to grab a list of IPs either from Nmap or another
    enumeration tool and feed the results autonomously to msfcli. The following is
    the general pattern we will follow while developing these kinds of bash scripts:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这些例子的目的是向您展示一个通用的样式，您可以遵循这个样式，如果您想从Nmap或其他枚举工具中抓取IP列表并自动将结果提供给msfcli。在开发这些类型的bash脚本时，我们将遵循以下通用模式：
- en: Using `grep` or awk to isolate the data in the results you're interested in
    integrating with your Metasploit module.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`grep`或awk来隔离您感兴趣的结果中的数据，以便与您的Metasploit模块集成。
- en: Iterating through a list of the extracted data samples, if applicable.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代通过提取的数据样本列表（如果适用）。
- en: Stuffing them to the command line that invokes a given module.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们填充到调用给定模块的命令行。
- en: There are tons of problems you could not only solve but also automate using
    this pattern. It may also help you combine Metasploit modules in ways the framework
    doesn't really cater to by default—unless we include scripting our own modules
    to the functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多问题，您不仅可以解决，还可以使用这种模式自动化。它还可以帮助您以默认方式组合Metasploit模块，除非我们将自己的模块脚本化到功能中。
- en: Preparing payloads with Metasploit
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit准备有效载荷
- en: During penetration tests, you may often need to demonstrate that you have unbridled
    control of a host, or you may need to actually interact with them using some form
    of remotely—either from the local network or the wider Internet—accessible command-line
    interface. If you find yourself in a situation that allows you to execute the
    arbitrary code on a host, and you'd like to control it remotely, one of the most
    common ways to take advantage of the situation is to upload a shell that allows
    you to remotely interact with the command shell or prompt. Metasploit has a tool
    dedicated to catering to these situations called msfpayload.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试期间，您可能经常需要证明您对主机有无限制的控制，或者您可能需要实际使用某种远程访问命令行界面与它们交互。如果您发现自己处于可以在主机上执行任意代码的情况，并且希望远程控制它，那么利用这种情况的最常见方式之一是上传一个允许您远程与命令行或提示交互的shell。Metasploit有一个专门用于满足这些情况的工具，称为msfpayload。
- en: The Metasploit payload generator (msfpayload) allows you to generate an executable
    package that connects back to the Meterpreter instance that runs in your Metasploit
    session.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit有效载荷生成器（msfpayload）允许您生成一个可执行包，该包连接到在您的Metasploit会话中运行的Meterpreter实例。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**About Meterpreter**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于Meterpreter**'
- en: Metasploit's Meterpreter is an interface to a payload that allows its users
    to dynamically inject instructions into a host compromised with the appropriate—Meterpreter-enabled—payload.
    In simpler terms, penetration testers can prepare payloads that call back to a
    Meterpreter instance, which allows them to interact with the host with a variety
    of tools, such as injecting the code to dump password hashes, escalate privileges,
    and even avoid detection.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit的Meterpreter是一个接口，允许用户动态地将指令注入到使用适当的Meterpreter启用的有效载荷感染的主机中。简单来说，渗透测试人员可以准备调用回到Meterpreter实例的有效载荷，这使他们可以使用各种工具与主机交互，例如注入代码以转储密码哈希、提升权限，甚至避免检测。
- en: In this tutorial, we will demonstrate how to prepare exploits that grant you
    this functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示如何准备授予您此功能的利用。
- en: 'To start off with, let''s take a look at the payloads available. You can check
    these out by executing the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下可用的有效载荷。您可以通过执行以下命令来查看这些：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot demonstrates the previous option:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了先前的选项：
- en: '![Preparing payloads with Metasploit](img/5107OT_04_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用Metasploit准备有效载荷](img/5107OT_04_04.jpg)'
- en: 'Each payload has a number of options, as is the style with most Metasploit
    modules. To see the available invocation options for your payload, you should
    execute the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有效载荷都有许多选项，这是大多数Metasploit模块的风格。要查看有效载荷的可用调用选项，您应该执行以下命令：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, consider the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下命令：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot demonstrates the previous command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了先前的命令：
- en: '![Preparing payloads with Metasploit](img/5107OT_04_05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用Metasploit准备有效载荷](img/5107OT_04_05.jpg)'
- en: 'There are a number of ways to represent the various payloads based on which
    code format you''d like to use. The following are the available options:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您想要使用的代码格式，有许多方法来表示各种有效载荷。以下是可用的选项：
- en: '`R`: This is for raw, binary format.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：这是用于原始的二进制格式。'
- en: '`C`: This is for the C code'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`：这是用于C代码'
- en: '`y`: This is for the Ruby code'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：这是用于Ruby代码'
- en: '`H`: This is for the C# code'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：这是用于C#代码'
- en: '`P`: This is for the Perl code'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`：这是用于Perl代码'
- en: '`J`: This is for JavaScript'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`J`：这是用于JavaScript'
- en: '`X`: This is for the executable formats'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`：这是用于可执行格式'
- en: '`D`: This is for Dynamic Linkable Libraries (DLLs)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`：这是用于动态链接库（DLL）'
- en: '`V`: This is for the VBA code'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V`：这是用于VBA代码'
- en: '`W`: This is for War archives'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`：这是用于War存档'
- en: 'The following screenshot demonstrates the effect of some of these options:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图演示了其中一些选项的效果：
- en: '![Preparing payloads with Metasploit](img/5107OT_04_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用Metasploit准备有效载荷](img/5107OT_04_06.jpg)'
- en: Each of the options exists to cater to exploitation on different operating system
    and runtime environments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都存在以满足不同操作系统和运行时环境的利用。
- en: Creating and deploying a payload
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和部署有效载荷
- en: 'As an example, we will create a backdoor for an Ubuntu 32-bit machine. Perform
    the following steps to do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为Ubuntu 32位机器创建一个后门。执行以下步骤：
- en: 'Create the payload in an executable format. Here, we will use a Meterpreter
    shell and save it in a file called `backdoor`. The following command will achieve
    this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以可执行格式创建有效载荷。在这里，我们将使用Meterpreter shell并将其保存在名为`backdoor`的文件中。以下命令将实现此目的：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`LHOST` is the IP address of the machine you as an attacker are using, or rather
    the machine from which you would like to interact with the backdoor.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`LHOST`是您作为攻击者使用的机器的IP地址，或者更确切地说，您希望与后门进行交互的机器的IP地址。'
- en: 'See the following screenshot for a example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下屏幕截图以获取示例：
- en: '![Creating and deploying a payload](img/5107OT_04_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![创建和部署有效载荷](img/5107OT_04_07.jpg)'
- en: Deploy the backdoor on the target host. This step will obviously depend on your
    access to the mentioned host. For our example, we will simply use `scp` to upload
    it to the home folder of a given user.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标主机上部署后门。这一步显然取决于您对所述主机的访问权限。对于我们的示例，我们将简单地使用`scp`将其上传到给定用户的主目录。
- en: 'Start a Metasploit handler on the attacker machine with the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在攻击者机器上启动Metasploit处理程序，使用以下代码：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, use the following command to start a Metasploit handler:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令启动Metasploit处理程序：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Execute the payload on the target host. For our example, this will simply involve
    starting the payload as shown in the following screenshot:![Creating and deploying
    a payload](img/5107OT_04_08.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标主机上执行有效载荷。对于我们的示例，这将简单地涉及启动有效载荷，如下面的屏幕截图所示：![创建和部署有效载荷](img/5107OT_04_08.jpg)
- en: You should see the following startup on your machine, namely a connect back
    to the Meterpreter handler:![Creating and deploying a payload](img/5107OT_04_09.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在您的机器上看到以下启动，即与Meterpreter处理程序的连接回来：![创建和部署有效载荷](img/5107OT_04_09.jpg)
- en: The preceding screenshot shows directory access to the affected host.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了对受影响主机的目录访问。
- en: You should keep in mind that msfpayload is used quite prolifically in the security
    industry, both by penetration testers and the guys who write antivirus software.
    What this means is that if you try to deploy one of the run-of-the-mill Metasploit
    payloads on a host that has modern antivirus installed, it likely won't do much
    except trigger a signature in the antivirus's database. To defeat this protection,
    you need to employ the services of an encoder or a polymorphic engine. The two
    mechanisms (encoding and polymorphing) encode and obfuscate the malicious payload
    in your backdoor so that an antivirus is incapable of recognizing it as malicious.
    Refer to the *Further reading* section at the end of this chapter for more details
    on this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，msfpayload在安全行业中被广泛使用，无论是渗透测试人员还是编写防病毒软件的人。这意味着，如果您尝试在安装了现代防病毒软件的主机上部署一种常见的Metasploit有效载荷，它可能不会触发防病毒软件数据库中的签名，除非您使用编码器或多态引擎的服务。这两种机制（编码和多态化）对您的后门中的恶意有效载荷进行编码和混淆，以使防病毒软件无法识别它为恶意。有关更多详细信息，请参阅本章末尾的*进一步阅读*部分。
- en: That's about it for the msfpayload command. We can move on to learning the reverse
    engineering tools.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: msfpayload命令就介绍到这里。我们可以继续学习逆向工程工具。
- en: Disassembling binaries
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反汇编二进制文件
- en: As mentioned in the introduction of this chapter, reverse engineering is a crucial
    aspect of an all-effective security research. One important aspect of reverse
    engineering—of compiled executable files—is disassembly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章介绍中所提到的，逆向工程是全面有效的安全研究的一个关键方面。对编译的可执行文件进行反汇编是逆向工程的一个重要方面。
- en: Disassembly is the process of reversing the effect of code compilation as much
    as possible. Kali Linux offers a few very good tools to orchestrate this process;
    however, when it comes to disassembly on the command line, very few tools come
    close to Objdump.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编是尽可能逆转代码编译效果的过程。Kali Linux提供了一些非常好的工具来协调这个过程；然而，当涉及到命令行上的反汇编时，很少有工具能与Objdump媲美。
- en: Disassembling with Objdump
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Objdump进行反汇编
- en: In this section, we will learn how to use Objdump and some of its various invocation
    options to strip out various sections of information from the **Executable and
    Linkable Format** (**ELF**) binaries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Objdump及其各种调用选项从**可执行和可链接格式**（**ELF**）二进制文件中剥离出各种信息部分。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**About the Executable and Linkable Format**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于可执行和可链接格式**'
- en: ELF is the file format that packages executable, shared libraries, object files
    for Linux/Unix systems, and some of the their various derivatives.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ELF是Linux/Unix系统的可执行文件、共享库、目标文件及其各种衍生物的文件格式。
- en: Using Objdump is pretty straightforward though whether you'd be able to make
    use of it properly or not depends on how well you understand the ELF format; for
    this reason, I've included some very useful references in the *Further reading*
    section of this chapter, which details the format, and I suggest you check them
    out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Objdump非常简单，但您能否正确使用它取决于您对ELF格式的理解程度；因此，我在本章的*进一步阅读*部分中包含了一些非常有用的参考资料，其中详细介绍了格式，建议您查阅。
- en: 'To disassemble a given binary—here we will use the example of the bash shell
    executable binary—with Objdump, you can perform the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要对给定的二进制文件进行反汇编——在这里我们将使用bash shell可执行二进制文件的示例——您可以执行以下步骤：
- en: 'We''re going to use the actual binary for the bash shell. To grab a copy of
    it, you can execute the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用bash shell的实际二进制文件。要获取它的副本，您可以执行以下命令：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding command will grab a copy of the binary for the bash shell—the
    current focus of the book. We're going to pull it through Objdump to find out
    more about how it works and detail areas to look for an explanation on the way
    it executes according to its code. We opt for working on a copy of the bash executable
    binary in case we do anything that corrupts it accidentally—after all Kali runs
    as root by default!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将获取bash shell的二进制文件的副本——这本书的当前重点。我们将通过Objdump来了解更多关于它的工作原理，并详细说明查找解释其执行方式的区域。我们选择在bash可执行二进制文件的副本上工作，以防止意外损坏它——毕竟Kali默认以root身份运行！
- en: 'Invoke the following command to run Objdump on the binary:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用以下命令在二进制文件上运行Objdump：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What this command does is supply the `–D` option, which tells Objdump to disassemble
    the binary and print it to the screen. You should see the output as shown in the
    following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是提供`-D`选项，告诉Objdump对二进制文件进行反汇编并将其打印到屏幕上。您应该看到如下截图所示的输出：
- en: '![Disassembling with Objdump](img/5107OT_04_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![使用Objdump进行反汇编](img/5107OT_04_10.jpg)'
- en: That's all you need to do to get Objdump to disassemble a binary. Though the
    fun doesn't end there, an executable binary has a number of sections, each dedicated
    to detailing a given part of the executable behavior. Objdump has a number of
    options, each dedicated to extracting various kinds of information from the binary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的一切，以便Objdump对二进制文件进行反汇编。尽管乐趣并不止于此，可执行二进制文件有许多部分，每个部分都专门详细说明了可执行行为的某个部分。Objdump有许多选项，每个选项都专门用于从二进制文件中提取各种信息。
- en: 'If you call up Objdump as we did in the example, you may see this section of
    the output as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像我们在示例中那样调用Objdump，您可能会看到输出的这部分，如下截图所示：
- en: '![Disassembling with Objdump](img/5107OT_04_22.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用Objdump进行反汇编](img/5107OT_04_22.jpg)'
- en: 'The output details the sections available in the given binary; though, if you''d
    like to only look at the code for a given section, you should use the following
    option:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出详细说明了给定二进制文件中可用的部分；不过，如果您只想查看给定部分的代码，您应该使用以下选项：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, if you''d like to dump the code for the `.text` section, you can
    use the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想转储`.text`部分的代码，您可以使用以下命令：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For our current example, it will produce an output similar to the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的示例，它将产生类似于以下截图的输出：
- en: '![Disassembling with Objdump](img/5107OT_04_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用Objdump进行反汇编](img/5107OT_04_11.jpg)'
- en: There are a number of options available with Objdump. I've added some useful
    links to the *Further reading* section for those of you who would like to find
    out more.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Objdump有许多选项可供选择。我在*进一步阅读*部分添加了一些有用的链接，供那些想了解更多的人使用。
- en: A note about the reverse engineering assembler code
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于逆向工程汇编代码的说明
- en: So, we've pretty much covered the basics as far as Objdump goes. However, I
    would not be doing you justice if I didn't mention a little something about what
    you need to understand about binaries in order to become a successful reverse
    engineer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就Objdump而言，我们已经基本涵盖了基础知识。然而，如果我不提一点关于你需要了解的关于二进制文件的东西，那就对不起你了，这是成为成功的逆向工程师所必须的。
- en: In the previous section about Objdump, we learned how to extract information
    about the `.text` segment. The `.text` segment of an ELF contains the executable
    code. This section will naturally contain the information about how the binary
    behaves, which is usually what a reverse engineer is interested in. The executable
    code in an ELF is represented in assembler language, and in order for you to understand
    the information in the `.text` segment, you will need to understand the assembler
    code to some extent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于Objdump的上一节中，我们学习了如何提取关于`.text`段的信息。ELF的`.text`段包含可执行代码。这个部分通常包含关于二进制行为的信息，这通常是逆向工程师感兴趣的。ELF中的可执行代码用汇编语言表示，为了理解`.text`段中的信息，您需要在一定程度上理解汇编代码。
- en: 'Assembler code is the language that semantically describes the machine code,
    and machine code is the collection of bits and bytes that literally control your
    CPU and memory—what we call software. So, the assembler code represents the actual
    code that runs your machine, as opposed to C, C++, Java, and others that the code
    was developed in. This is because computers actually don''t possess the computational
    power to understand C, C++, or any other high-level languages we develop and must
    rely on compilers to parse and translate these languages into a more basic, atomic
    language before it can be executed. An assembler language describes a software
    computation strictly in terms of the interactions between the CPU registers and
    memory and vice-versa. This is based on a set of simple operations: addition,
    subtraction, XOR, comparison of values, and so on.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码是语义上描述机器代码的语言，而机器代码是字节和位的集合，它们实际上控制着你的CPU和内存——我们称之为软件。因此，汇编代码代表了运行您的机器的实际代码，而不是C、C++、Java等代码是在其中开发的。这是因为计算机实际上没有计算能力来理解C、C++或任何其他高级语言，我们开发的语言必须依赖编译器来解析和翻译这些语言，将其转换为更基本的、原子的语言，然后才能执行。汇编语言严格地描述了软件计算与CPU寄存器和内存之间的交互，反之亦然。这是基于一组简单的操作：加法、减法、异或、值的比较等等。
- en: Each CPU, or rather architecture, represents these instructions in a format
    unique to it. These formats are called instructions and can be categorized according
    to a base set of attributes. Broadly, they are categorized into either **Reduced
    Instruction Set Computer** (**RISC**) or **Complex Instruction Set Computing**
    (**CISC**). Each RISC and CISC instruction set is then defined according to the
    largest amount of data that can be moved from the memory to a register, which
    is called the register size. I'm sure some of you are familiar with 32-bit or
    x86 and 64-bit or x86-64 machines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CPU，或者说架构，都以其独特的格式表示这些指令。这些格式称为指令，并可以根据一组基本属性进行分类。广义上，它们被分为**精简指令集计算机**（**RISC**）或**复杂指令集计算**（**CISC**）。然后，每个RISC和CISC指令集根据可以从内存移动到寄存器的最大数据量进行定义，这称为寄存器大小。我相信你们中的一些人对32位或x86和64位或x86-64机器已经很熟悉了。
- en: If you have some experience in programming, you will already know that when
    the code is executing, it is almost always doing so in the context of a function.
    This means a lot of the code that is translated into the assembler will describe
    the process of setting up execution inside a function and transferring the execution
    to another function. Each instruction set and architecture has a certain standard
    that defines how this is to be done in terms of the CPU registers and operations
    involved. This standard is referred to as a procedure-calling function. I've included
    some of the procedure-calling standards for ARM, Intel, and MIPS architectures
    in the *Further reading* section, and unless you want to spend weeks reading about
    assembler, which you really don't need to, I suggest checking these references
    out.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些编程经验，你就会知道当代码执行时，几乎总是在函数的上下文中执行。这意味着翻译成汇编语言的大部分代码将描述在函数内设置执行并将执行转移到另一个函数的过程。每个指令集和架构都有一个特定的标准，定义了在CPU寄存器和涉及的操作方面如何完成这个过程。这个标准被称为过程调用函数。我在*进一步阅读*部分中包含了一些ARM、Intel和MIPS架构的过程调用标准，除非你想花几周时间阅读有关汇编语言的内容，而你实际上并不需要这样做，我建议你查看这些参考资料。
- en: That being said, we can move onto dynamic analysis of binaries using GDB.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以继续使用GDB对二进制文件进行动态分析。
- en: Debugging binaries for dynamic analysis
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析二进制文件
- en: Tools such as Objdump are great for getting a look at the code in an executable
    while it's not executing. However, if you'd like to actually observe an executable
    in execution and find out more about how it processes information as well as how
    its internal data structures are altered by its execution, you will need something
    called a debugger. One such tool is called the **GNU Debugger** (**GDB**). In
    this section, we will cover the basic usage of GDB, and you will also get to know
    some of the tasks it allows us to pull off during a binary's execution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Objdump之类的工具非常适合在可执行文件不执行时查看代码。然而，如果你想实际观察可执行文件的执行并了解它如何处理信息以及它的内部数据结构如何被执行改变，你将需要一种称为调试器的工具。其中一种工具称为**GNU调试器**（**GDB**）。在本节中，我们将介绍GDB的基本用法，你也将了解到它允许我们在二进制文件执行期间执行哪些任务。
- en: Getting started with GDB
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GDB入门
- en: 'To start off with, let''s load up a binary and run it in GDB using the following
    command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们加载一个二进制文件并在GDB中运行它，使用以下命令：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For our current example, this command would look like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的例子，这个命令看起来像这样：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What GDB does here is prepare to attach itself to the binary during its execution—this
    means it places the binary in a special environment that allows it to observe
    detailed information during its execution. It also tries to read the debugging
    information from the supplied file, which is a collection of information that
    helps describe the program more semantically for testing purposes. Unfortunately,
    bash, as in our example, was not complied with the debugging flag set. This means
    there is no semantic metadata about objects such as variable names, source code
    to assembler code mapping, and so on available for GDB to work with, and you are
    left with just the low-level assembler code to work with. However, this is not
    a dead end for a determined reverse engineer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GDB在这里所做的是准备在二进制文件执行期间附加到它自身——这意味着它将二进制文件放置在一个特殊的环境中，允许它在执行期间观察详细信息。它还尝试从提供的文件中读取调试信息，这是一组帮助更语义地描述程序以进行测试的信息。不幸的是，像我们的例子中一样，bash并没有使用调试标志进行编译。这意味着没有关于对象的语义元数据，比如变量名、源代码到汇编代码的映射等，供GDB使用，你只能使用低级的汇编代码。然而，对于一个决心的逆向工程师来说，这并不是死路。
- en: 'Once the binary is loaded up, the first thing we''re going to do is run the
    program inside GDB. Use the following command from within your `gdb` prompt:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦二进制文件加载完成，我们要做的第一件事就是在GDB中运行程序。在`gdb`提示符中使用以下命令：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the following pop up on your screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在屏幕上看到以下内容：
- en: '![Getting started with GDB](img/5107OT_04_12.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用GDB入门](img/5107OT_04_12.jpg)'
- en: The way GDB and most debugging programs operate, they allow you to specify a
    halt point or rather a breakpoint at a given address in the program's executable
    code. This allows you to stop the program and inspect its data structures for
    information. GDB allows you to do many things with a program once it reaches a
    breakpoint. You can inspect the values of the CPU registers or rather the copy
    of the contents of the CPU registers available for this program during its execution.
    You can also inspect the value of memory, print out local and global variables,
    inspect the stack, and perform tons of other tasks. We're going to cover the bare
    minimum to get you going and show you how to find out more information about the
    things GDB is capable of.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: GDB和大多数调试程序的操作方式是，它们允许您在程序的可执行代码中指定一个停止点或者说断点。这使您可以停止程序并检查其数据结构以获取信息。一旦程序达到断点，GDB允许您对程序执行许多操作。您可以检查CPU寄存器的值，或者在程序执行期间可用于此程序的CPU寄存器内容的副本。您还可以检查内存的值，打印出局部和全局变量，检查堆栈，并执行大量其他任务。我们将介绍最基本的内容，以便让您开始并向您展示如何获取有关GDB功能的更多信息。
- en: 'You can also use the `run` command to pass arguments to the executable you''re
    currently studying. The command would look as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`run`命令将参数传递给您当前正在研究的可执行文件。命令如下：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For instance, consider the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下命令：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The previous command would pass the two strings `Hello` and `World` as arguments
    to the current executable. You should also know that the `run` command is fully
    integrated with the bash command-line processer, so you can use the full specification
    of bash hacks, command substitution, redirects, and pipes to pass arguments via
    the `run` command. The following is a typical example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将把字符串`Hello`和`World`作为参数传递给当前可执行文件。您还应该知道，`run`命令与bash命令行处理器完全集成，因此您可以使用bash的完整规范，命令替换，重定向和管道通过`run`命令传递参数。以下是一个典型的例子：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous command will pass an argument containing all lines in the `/etc/passwd`
    file that start with the word `root` as an argument to the current executable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将传递一个参数，该参数包含`/etc/passwd`文件中以单词`root`开头的所有行作为当前可执行文件的参数。
- en: Setting execution breakpoints and watch points
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置执行断点和监视点
- en: So, moving on, you probably want to set a breakpoint at some point during your
    reverse engineering adventures with GDB, but before we do so, we need to find
    an address to set a breakpoint at.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续进行，您可能希望在使用GDB进行逆向工程时的某个时刻设置断点，但在这样做之前，我们需要找到要设置断点的地址。
- en: 'For this example, we''re going to use the first address in the main function
    that is executed as soon as this program starts up. Before we do that, we need
    to find out what this address is and you can use the following command to do this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用`main`函数中的第一个地址，该地址在程序启动时立即执行。在这样做之前，我们需要找出这个地址，您可以使用以下命令来执行：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous command will grab the first address that executes in the function
    called `main`. If you''d like to set breakpoints for arbitrary addresses in the
    `main` function, you need to scratch around in the code a bit. To find out which
    addresses are available in the `main` function, execute the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将获取执行名为`main`的函数中的第一个地址。如果您想要在`main`函数中的任意地址设置断点，您需要在代码中进行一些调查。要找出`main`函数中可用的地址，执行以下命令：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous command tells GDB to disassemble the `main` function of the given
    executable. This is usually where all the code written by the developer and specific
    to the given executable starts off. You should see something similar to the following
    screenshot appear on your screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令告诉GDB反汇编给定可执行文件的`main`函数。这通常是开发人员编写的与给定可执行文件特定的所有代码的起点。您应该看到类似以下截图出现在屏幕上：
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_13.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![设置执行断点和监视点](img/5107OT_04_13.jpg)'
- en: In the preceding screenshot, we can see that the `disass` command, shorthand
    for the disassemble, is being used. It performs the same function as the `disassemble`
    command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到正在使用`disass`命令，它是`disassemble`命令的缩写。它执行与`disassemble`命令相同的功能。
- en: The preceding screenshot shows how GDB disassembles the `main` function. What
    we are interested in is the first address of the `main` function. To make things
    simpler, we are going to emulate the behavior of the breakpoint `main` command
    executed in a preceding example. The address you're looking for is the first one
    that is listed; for this example, it will be the address `0x0806dc0`. Addresses
    are listed here in a hexadecimal format. If you're not used to working with hex
    numbers, you should study up on how they work as soon as possible; most reverse
    engineers probably read in hexadecimal more than they read in their native tongues!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了GDB如何反汇编`main`函数。我们感兴趣的是`main`函数的第一个地址。为了简化操作，我们将模拟在前面的示例中执行的`main`断点命令的行为。您要查找的地址是列出的第一个地址；在本例中，它将是地址`0x0806dc0`。这里以十六进制格式列出地址。如果您不习惯使用十六进制数字，您应该尽快学习它们的工作原理；大多数逆向工程师可能更多地以十六进制阅读而不是以母语阅读！
- en: 'For interest''s sake, you would probably have guessed that Objdump should give
    you the same information about the address that starts off the `main` function.
    The following screenshot shows what Objdump says about the starting point of main
    functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 出于兴趣，您可能已经猜到Objdump应该为您提供有关启动`main`函数的地址的相同信息。以下截图显示了Objdump关于main函数起始点的信息：
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_14.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![设置执行断点和监视点](img/5107OT_04_14.jpg)'
- en: Objdump seems to agree with GDB about the `main` function's starting address.
    This is because the `.text` section of an executable is mapped to static and predetermined
    collection addresses; that is, the `.text` section will reliably always appear
    in the addresses detailed in the `.text` section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Objdump似乎同意GDB关于`main`函数的起始地址。这是因为可执行文件的`.text`部分被映射到静态和预定的集合地址；也就是说，`.text`部分将始终可靠地出现在`.text`部分中详细说明的地址中。
- en: 'So, what you''d want to do now is set a breakpoint for this address as a simple
    demonstration of breakpoints. To do this, enter the following command in your
    GDB prompt:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在您想要做的是设置此地址的断点，作为断点的简单演示。要执行此操作，请在GDB提示符中输入以下命令：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For our example, this command will work as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，此命令将按以下方式工作：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous command should produce the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令应该产生以下输出：
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_15.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![设置执行断点和监视点](img/5107OT_04_15.jpg)'
- en: 'You could also use the shorthand for the breakpoint command, which works as
    follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用断点命令的简写形式，操作如下：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Otherwise, you could use the following command to specify a specific memory
    address as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以使用以下命令指定特定的内存地址，如下所示：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Besides setting breakpoints, which interrupt and stop the execution of a binary
    depending on the value of the instruction pointer, you can also interrupt execution
    using watch points. The following command shows how you set a watch point for
    a given variable:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置断点，根据指令指针的值中断和停止二进制文件的执行之外，您还可以使用监视点中断执行。以下命令显示了如何为给定变量设置监视点：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using the variable''s address, you could do this the following way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的地址，您可以按以下方式执行：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using our current example here, we can set a watch point for the top of the
    stack pointer, namely the value saved in the ESP when `main` starts executing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们可以为堆栈指针的顶部设置一个监视点，即在`main`开始执行时保存的ESP中的值：
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_16.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![设置执行断点和监视点](img/5107OT_04_16.jpg)'
- en: 'If we rerun the executable, the watch point will trigger as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行可执行文件，监视点将触发如下：
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_17.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![设置执行断点和监视点](img/5107OT_04_17.jpg)'
- en: Inspecting registers, memory values, and runtime information
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查寄存器、内存值和运行时信息
- en: 'Once you''ve gotten the hang of stopping a binary just where you''d like it
    to stop—that is, at a function or specific line in the code or once a variable
    changes its value according to a given criteria—you may want to start poking around
    at the executable''s data structures and memory contents. Building on the example
    we just discussed, let''s take a look at the register values saved after our first
    breakpoint hit. The following command shows how you do this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了在二进制文件中停止的位置——也就是在函数或代码中特定行或一旦变量根据给定条件更改其值时停止——您可能希望开始查看可执行文件的数据结构和内存内容。在我们刚刚讨论的示例基础上，让我们看一下第一个断点命中后保存的寄存器值。以下命令显示了如何执行此操作：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previous command should produce the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令应该产生以下输出：
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_18.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![检查寄存器、内存值和运行时信息](img/5107OT_04_18.jpg)'
- en: You can also print the current stacktrace, namely information about which function
    is the caller of the current function and which arguments were passed to it during
    invocation, as well as the caller's caller and that caller's caller ad infinitum.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以打印当前堆栈跟踪，即关于哪个函数是当前函数的调用者以及在调用期间传递了哪些参数的信息，以及调用者的调用者和调用者的调用者等等。
- en: 'The following is an example of the current stacktrace:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前堆栈跟踪的示例：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The previous command should produce the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令应该产生以下输出：
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_19.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![检查寄存器、内存值和运行时信息](img/5107OT_04_19.jpg)'
- en: 'You can also look at the actual contents of the stack using the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令查看堆栈的实际内容：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we''re using the Swiss army knife called x, which prints memory values.
    It''s used in the GDB prompt to print values from the memory, local variables,
    and other information storage areas in an executable in various formats. For example,
    x is capable of printing values in decimal, hexadecimal, octal, and binary, as
    well as converting data into instructions so that it can print a list of the executable
    instructions stored at a given memory address. What we did here is give `x` an
    argument of `/5x,` which means:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了称为x的瑞士军刀，它可以打印内存值。它在GDB提示符中用于以各种格式打印可执行文件中的内存、局部变量和其他信息存储区域中的值。例如，x能够以十进制、十六进制、八进制和二进制格式打印值，并将数据转换为指令，以便它可以打印存储在给定内存地址处的可执行指令列表。我们在这里所做的是给`x`一个参数`/5x`，这意味着：
- en: Print 5 address values in hexadecimal format—indicated with a 'x'.
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以十六进制格式打印5个地址值—用'x'表示。
- en: For more information about how `x` works, execute the `help x` command in your
    GDB prompt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`x`的更多信息，请在GDB提示符中执行`help x`命令。
- en: 'Anyways, the previous command should produce the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，上一个命令应该产生以下输出：
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_20.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![检查寄存器、内存值和运行时信息](img/5107OT_04_20.jpg)'
- en: 'If you''d like to estimate the stack size at the current instance in the execution,
    you can execute the following commands:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要估计执行时当前实例的堆栈大小，可以执行以下命令：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The previous commands will print the following to the screen, depending on
    when you perform those commands during the execution of the program:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在程序执行期间执行这些命令的时间，上述命令将在屏幕上打印以下内容：
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_21.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![检查寄存器、内存值和运行时信息](img/5107OT_04_21.jpg)'
- en: You can use the `eval` command to build commands based on variable values such
    as this for just about any purpose. Here, we used this command to calculate the
    difference in the addresses saved at the top of stack pointer value saved in the
    ESP register and at the bottom of the stack pointer saved in the EBP register.
    We also divided this value by `4` to calculate the number of addresses needed
    to print just about the entire stack.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`eval`命令基于变量值构建命令，以便用于任何目的。在这里，我们使用此命令计算了保存在ESP寄存器中的堆栈指针值的顶部和保存在EBP寄存器中的堆栈指针底部的地址之间的差异。我们还将此值除以`4`，以计算打印整个堆栈所需的地址数量。
- en: 'Moving on, there is a myriad of other runtime analysis tools and functions.
    For more information on these functions, execute the following command in your
    GDB prompt:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，还有许多其他运行时分析工具和功能。有关这些功能的更多信息，请在GDB提示符中执行以下命令：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will list and describe the info type functions you can execute. To find
    out more about any of GDB''s capabilities, you can use the `help` function as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出并描述您可以执行的信息类型函数。要了解有关GDB任何功能的更多信息，可以使用`help`函数，如下所示：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This concludes the basic usage of GDB. Hopefully, you've learnt enough about
    it to make it a useful tool in reverse engineering and penetration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了GDB的基本用法。希望您已经学会了足够的知识，使其成为逆向工程和渗透测试中的有用工具。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered using the command-line-based reverse engineering
    and general application-focused exploitation tools available in the Kali Linux
    and also detailed ways to integrate them with some very useful bash scripts.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在Kali Linux中可用的基于命令行的逆向工程和通用应用程序专注的利用工具，并详细介绍了如何将它们与一些非常有用的bash脚本集成。
- en: More specifically, we learned to use the Metasploit command-line interface.
    We also covered the Metasploit Frameworks command-line-based payload generator
    and, as an example, saw how to build backdoors for Linux 32-bit machines. Lastly,
    we looked at the reverse engineering tools Objdump and GDB. We used Objdump to
    detail the sections of an executable and also look up the address of a given function.
    Our example was to look up `main`. With GDB, we covered setting breakpoints, setting
    watch points, and proliferating useful information not only from a binary before
    its execution but also during its execution, by dumping the stack, register values,
    and also keeping track of some memory values as they change.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们学会了使用Metasploit命令行界面。我们还介绍了Metasploit Frameworks基于命令行的有效负载生成器，并且举例说明了如何为Linux
    32位机器构建后门。最后，我们看了Objdump和GDB这两个逆向工程工具。我们使用Objdump详细说明了可执行文件的各个部分，并查找了给定函数的地址。我们的例子是查找`main`。使用GDB，我们介绍了设置断点、设置监视点，并且不仅可以在执行之前从二进制文件中获取有用信息，还可以在执行期间通过转储堆栈、寄存器值以及跟踪一些内存值的变化来获取有用信息。
- en: Hopefully, all of these tools will come in handy anytime you need to crack open
    an application and find out what it's all about. For more information about the
    tools we covered in this chapter, as well as some of the important support technical
    information, please refer to the links in the *Further reading* section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些工具在您需要打开应用程序并找出其全部内容时会派上用场。有关本章中涵盖的工具以及一些重要的支持技术信息，请参阅*进一步阅读*部分中的链接。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: About the Metasploit Meterpreter, you can find more information at [http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter](http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Metasploit Meterpreter，您可以在[http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter](http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter)找到更多信息
- en: For Metasploit's Meterpreter, go to [https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf](https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Metasploit的Meterpreter，请转到[https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf](https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf)
- en: For Meterpreter Basics, go to [http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics](http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Meterpreter基础知识，请转到[http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics](http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics)
- en: More information on MSFCLI can be obtained at [http://www.offensive-security.com/metasploit-unleashed/Msfcli](http://www.offensive-security.com/metasploit-unleashed/Msfcli)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MSFCLI的更多信息，请访问[http://www.offensive-security.com/metasploit-unleashed/Msfcli](http://www.offensive-security.com/metasploit-unleashed/Msfcli)
- en: You can read up the GNU GDB documentation at [http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)阅读GNU
    GDB文档。
- en: You can read up the Executable and Linkable Format at [http://wiki.osdev.org/ELF](http://wiki.osdev.org/ELF)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[http://wiki.osdev.org/ELF](http://wiki.osdev.org/ELF)阅读可执行和可链接格式
- en: 'For The ELF Object File Format: Introduction, go to [http://www.linuxjournal.com/article/1059](http://www.linuxjournal.com/article/1059)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关ELF对象文件格式：简介，请转到[http://www.linuxjournal.com/article/1059](http://www.linuxjournal.com/article/1059)
- en: To read up more on DWARF Debugging Information Format revision 2.2.0, go to
    [http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf](http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关DWARF调试信息格式修订2.2.0的更多信息，请转到[http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf](http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf)
- en: For details on the Objdump command reference, go to [https://sourceware.org/binutils/docs/binutils/objdump.html#objdump](https://sourceware.org/binutils/docs/binutils/objdump.html#objdump)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Objdump命令参考的详细信息，请转到[https://sourceware.org/binutils/docs/binutils/objdump.html#objdump](https://sourceware.org/binutils/docs/binutils/objdump.html#objdump)
- en: You can read up on the Introduction to x64 Assembly by Intel at [https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf](https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf](https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf)阅读英特尔的x64汇编简介
- en: Also, check out Intel Architecture Software Developer's Manual Volume 2 by Intel
    at [https://www.cs.cmu.edu/~410/doc/intel-isr.pdf](https://www.cs.cmu.edu/~410/doc/intel-isr.pdf)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，您还可以在英特尔的《英特尔体系结构软件开发人员手册第2卷》中找到[https://www.cs.cmu.edu/~410/doc/intel-isr.pdf](https://www.cs.cmu.edu/~410/doc/intel-isr.pdf)
- en: The ARM-THUMB Procedure Call Standard can be found at [http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf](http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf%20)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM-THUMB过程调用标准可以在[http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf](http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf%20)找到
- en: ARM Procedure Call Standard – ARM can be found at [http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM过程调用标准-ARM可以在[http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf)找到
- en: You can read up further on iOS ABI Function Call Guide, Apple Developers Site,
    at [https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在苹果开发者网站上阅读更多关于iOS ABI函数调用指南的信息，网址为[https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html)
- en: Reverse Engineering for Beginners by Dennis Yurichev can be found at [http://yurichev.com/writings/RE_for_beginners-en.pdf](http://yurichev.com/writings/RE_for_beginners-en.pdf)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dennis Yurichev的《逆向工程入门》可以在[http://yurichev.com/writings/RE_for_beginners-en.pdf](http://yurichev.com/writings/RE_for_beginners-en.pdf)找到
