- en: Chapter 2. The Basics of Python Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Python脚本的基础知识
- en: Before diving into writing your first Python script, a few concepts should be
    understood. Learning these items now will help you develop code quicker in the
    future. This will improve your abilities as a penetration tester or in understanding
    what an assessor is doing when they are creating real-time custom code and what
    questions you should be asking. You should also understand how to create the scripts
    and the goal you are trying to achieve. You will often find out that your scripts
    will morph over time and the purpose may change. This may happen because you realize
    that the real need for the script may not be there or that there is an existing
    tool for the particular capability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写你的第一个Python脚本之前，应该先了解一些概念。现在学习这些内容将有助于你将来更快地开发代码。这将提高你作为渗透测试人员的能力，或者理解评估人员在创建实时自定义代码时在做什么以及你应该问什么问题。你还应该了解如何创建脚本以及你试图实现的目标。你会经常发现你的脚本会随着时间而变化，目的可能会改变。这可能是因为你意识到脚本的真正需求可能不存在，或者有一个特定功能的现有工具。
- en: Many scripters find this discouraging, as a project that they may have been
    working on for a great deal of time you may find that the tool has duplicate features
    of more advanced tools. Instead of looking at this as a failed project, look at
    the activity as an experience wherein you learned new concepts and techniques
    that you did not initially know. Additionally, keep it at the back of your mind
    at all times when you are developing code snippets that can be used for other
    projects in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本编写者会觉得沮丧，因为他们可能已经花了很多时间在一个项目上，但最终发现这个工具具有更高级工具的重复功能。不要把这看作是一个失败的项目，而是把这个活动看作是一个经历，在这个过程中你学到了一些最初不知道的新概念和技术。此外，无论何时你在开发代码片段时，都要时刻记在心里，这些代码片段可以在将来的其他项目中使用。
- en: To this end, try and build your code cleanly, comment it with what you are doing,
    and make it modular so that once you learn how to build functions, they can be
    cut and pasted into other scripts in the future. The first step in this journey
    is to describe the computer science glossary at a high level so that you can understand
    future chapters or other tutorials. Without understanding these basic concepts,
    you may misunderstand how to achieve your desired results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽量编写清晰的代码，用注释说明你在做什么，并使其模块化，这样一旦学会了如何构建函数，它们可以在将来的其他脚本中被剪切和粘贴。这个旅程的第一步是以高层次描述计算机科学词汇表，这样你就可以理解将来的章节或其他教程。如果不理解这些基本概念，你可能会误解如何实现你想要的结果。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before running any of the scripts in this book, I recommend that you run the
    setup script on the git repository, which will configure your Kali instance with
    all the necessary libraries. The script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本书中的任何脚本之前，我建议你在git存储库上运行设置脚本，这将为你的Kali实例配置所有必要的库。该脚本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh)找到。
- en: Understanding the difference between interpreted and compiled languages
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解解释型语言和编译型语言之间的区别
- en: Python, like Ruby and Perl, is an interpreted language, which means that the
    code is turned into a machine language and run as the script is executed. A language
    that needs to be compiled prior to running, such as Cobol, C, or C++, can be more
    efficient and faster, as it is compiled prior to execution, but it also means
    that the code is typically less portable. As compiled code is generated for specific
    environments, it may not be as useful when you have to move through heterogeneous
    environments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python、Ruby和Perl等语言都是解释型语言，这意味着代码在执行脚本时会被转换为机器语言并运行。需要在运行之前编译的语言，比如Cobol、C或C++，可能更有效率和更快，因为它在执行之前被编译，但这也意味着代码通常不太可移植。由于编译代码是为特定环境生成的，当你需要在异构环境中移动时，它可能不太有用。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A heterogeneous environment is an environment that has multiple system types
    and different distributions. So, there may be multiple Unix/Linux distributions,
    Mac OS, and Windows systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异构环境是一个具有多个系统类型和不同发行版的环境。因此，可能会有多个Unix/Linux发行版、Mac OS和Windows系统。
- en: Interpreted code usually has the benefit of being portable to different locations
    as long as the interpreter is available. So for Python scripts, as long as the
    script is not developed for an operating system, the interpreter is installed,
    and the libraries are natively available, the Python script should work. Always
    keep in mind that there will be idiosyncrasies in an environment, and before scripts
    are used, they should be thoroughly tested in similar test beds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型代码通常具有可移植性的好处，只要解释器可用。因此，对于Python脚本，只要安装了解释器并且库是本地可用的，脚本就应该可以运行。始终记住环境中会有特殊情况，在使用脚本之前，应该在类似的测试环境中进行彻底测试。
- en: So why should you learn Python over other scripting languages? I am not making
    this argument here, and the reason is that the best assessors use the tools available
    in the environment that they are assessing. You will build scripts that are useful
    for assessing environments, and Python is fantastic for doing this, but when you
    gain access to a system, it is best to use what is available to you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么你应该学习Python而不是其他脚本语言呢？我在这里不做这个论点，原因是最好的评估人员使用他们所评估的环境中可用的工具。你将编写对评估环境有用的脚本，Python非常适合这样做，但当你获得对系统的访问权限时，最好使用可用的工具。
- en: Highly secure environments may prevent you from using exploitation frameworks,
    or the assessment rules may do the same. When this happens, you have to look at
    what is available on the system to take advantage of and move forward. Today,
    newer generation Windows systems are compromised with PowerShell. Often in current
    Mac, Linux, Unix, and Windows **Operating System** (**OS**), you can find a version
    of Python, especially in development environments. On web servers, you will find
    Ruby, Python, or Perl. On all forms of operating systems, you will find native
    shell languages. They provide many capabilities, but typically, they have archaic
    language structures that require more lines of code than other scripting languages
    to accomplish the same task. Examples of these shell languages would include **Bourne-again
    Shell** (**BASH**), **Korn Shell** (**KSH**), Windows Command Shell, and equivalents.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 高度安全的环境可能会阻止您使用渗透框架，或者评估规则可能会做同样的事情。当这种情况发生时，您必须查看系统上可用的内容并继续前进。如今，新一代Windows系统使用PowerShell进行攻击。在当前的Mac、Linux、Unix和Windows操作系统中，尤其是在开发环境中，您可以找到Python的版本。在Web服务器上，您会发现Ruby、Python或Perl。在所有形式的操作系统上，您都会找到本机shell语言。它们提供了许多功能，但通常具有过时的语言结构，需要比其他脚本语言更多的代码行来完成相同的任务。这些shell语言的示例包括Bourne-again
    Shell（BASH）、Korn Shell（KSH）、Windows命令Shell和等效物。
- en: In most exploitation systems, you will find all the languages, as most hacking
    laptops, or HackTops, use multiple **Virtual Machines** (**VMs**) with many operating
    systems. Older assessment tools were coded in Perl, as the language provided multiple
    capabilities that other interpreted languages could not provide at that time.
    Newer tools are typically created in Ruby and Python. In fact, many libraries
    that are being created today are for improving the capabilities of these languages,
    specifically for assessing the potential viability an organization has for being
    compromised by a malicious actor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数渗透系统中，您会发现所有的语言，因为大多数黑客笔记本电脑或HackTops使用多个虚拟机（VMs）和许多操作系统。旧的评估工具是用Perl编写的，因为该语言在当时提供了其他解释语言无法提供的多种功能。新工具通常是用Ruby和Python创建的。事实上，今天正在创建的许多库都是为了改进这些语言的能力，特别是为了评估组织被恶意行为者威胁的潜在可行性。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that your HackTop has multiple VMs to provide you with not only
    attack tools but also a test bed to test your scripts safely. Reverting to a snapshot
    of a VM on your HackTop is easy, but telling a customer why you damaged their
    business-critical component with an untested script is not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的HackTop有多个虚拟机，不仅提供攻击工具，还提供一个安全测试平台来测试您的脚本。在您的HackTop上恢复虚拟机的快照很容易，但是告诉客户为什么您使用未经测试的脚本损坏了他们的业务关键组件却不容易。
- en: Compiled languages are not without value; many tools have been created in C,
    C++, and Java. Examples of these types of tools include Burp Suite, Cain & Abel,
    DirBuster, **Zed Attack Proxy** (**ZAP**), CSRFtester, and so on. You might notice
    that most of these tools were generated originally in the early days of assessing
    environments. As systems have gotten more powerful and interpreters have become
    more efficient, we have seen additional tools move to languages that are interpreted
    as against compiled.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言并非毫无价值；许多工具是用C、C++和Java创建的。这些类型的工具的示例包括Burp Suite、Cain & Abel、DirBuster、Zed
    Attack Proxy（ZAP）、CSRFtester等。您可能会注意到，这些工具中的大多数最初是在评估环境的早期创建的。随着系统变得更加强大和解释器变得更加高效，我们看到其他工具转移到了解释语言而不是编译语言。
- en: So what is the lesson here? Learn as much as you can to operate in as many environments
    as possible. In this way, when you encounter an obstacle, you can return to the
    code and script your way to the level of access necessary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里的教训是什么？尽可能多地学习，以在尽可能多的环境中操作。这样，当遇到障碍时，您可以返回到代码并脚本化以获得必要的访问级别。
- en: Python – the good and the bad
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python-优点和缺点
- en: Python is one of the easiest languages for creating a working piece of code
    that accomplishes tangible results. In fact, Python has a native interactive interpreter
    through which you can test code directly by just executing the word `python` at
    the CLI. This will bring up an interface in which concepts of code can be tested
    prior to trying to write a script. Additionally, this interface allows a tester
    to not only test new concepts, but also to import modules or other scripts as
    modules and use them to create powerful tools.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python是创建可实现切实结果的工作代码的最简单的语言之一。事实上，Python具有本地交互式解释器，通过它可以直接测试代码，只需在CLI中执行单词`python`。这将带来一个界面，可以在尝试编写脚本之前测试代码的概念。此外，这个界面不仅允许测试新概念，还允许导入模块或其他脚本作为模块，并使用它们创建强大的工具。
- en: Not only does this testing capability of Python allow assessors to verify concepts,
    but they can also avoid dealing with extensive debuggers and test cases to quickly
    prototype attack code. This is especially important when on an engagement and
    when determining whether a particular exploit train will net useful results in
    a timely manner. Most importantly, the use of Python and the importing of specific
    libraries usually do not break entire tool suites, and uninstalling a specific
    library is very easy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python的这种测试能力不仅允许评估者验证概念，还可以避免处理繁琐的调试器和测试用例，快速原型化攻击代码。当参与项目并确定特定的攻击训练是否能够及时产生有用的结果时，这一点尤为重要。最重要的是，使用Python和导入特定库通常不会破坏整个工具套件，卸载特定库也非常容易。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To maintain the integrity of the customer environment, you should avoid installing
    libraries on client systems. If there is a need to do so, make sure that you work
    with your point of contact, because there may be unintended consequences. It could
    also be considered a violation of the organization's **System Development Life
    cycle** (**SDLC**) and its change control process. The end result is that you
    could be creating more risk for the client than the original assessment's intention.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护客户环境的完整性，你应该避免在客户系统上安装库。如果有必要这样做，确保你与你的联系人一起工作，因为可能会产生意想不到的后果。这也可能被视为违反组织的**系统开发生命周期**（**SDLC**）和其变更控制流程。最终结果是，你可能会为客户创造比原始评估意图更多的风险。
- en: The language structure for Python, though different from many other forms of
    coding, is very simple. Reading Python is similar to reading a book, but with
    some slight caveats. There are basically two different forms of Python development
    trees at the time of writing this book—Python 2.X and Python 3.X. Most assessment
    tools run on the 2.X version, which is what we will be focusing on, but improvements
    in the language versions for all intents and purposes has stopped. You can write
    code that works for both versions, but it will take some effort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python的语言结构虽然与许多其他形式的编码不同，但非常简单。阅读Python类似于阅读一本书，但有一些细微的注意事项。在撰写本书时，基本上有两种不同形式的Python开发树——Python
    2.X和Python 3.X。大多数评估工具在2.X版本上运行，这也是我们将重点关注的，但是语言版本的改进基本上已经停止。你可以编写适用于两个版本的代码，但这需要一些努力。
- en: In essence, Python version 3.X has been developed to be more **Object-oriented**
    (**OO**), which means that coding for it means focusing on OO methods and attributes.
    This is not to say that 2.X is not OO; it's just that it is not as well developed
    as version 3.X. Most importantly, some libraries are not compatible with both
    versions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，Python 3.X版本已经开发成更加**面向对象**（**OO**），这意味着为它编码意味着专注于面向对象的方法和属性。这并不是说2.X不是面向对象的；只是它没有3.X版本发展得那么好。最重要的是，一些库与两个版本都不兼容。
- en: Believe it or not, the most common reason a Python script is not completely
    version compatible is the built-in `print` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，Python脚本不完全兼容的最常见原因是内置的`print`函数。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 2.X, `print` is a statement, and in 3.X, it is a function, as you
    will see next. Throughout this book, the use of the word statement and function
    may be used interchangeably, but understanding the difference is the key to building
    version-agnostic scripts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.X中，`print`是一个语句，在3.X中，它是一个函数，你将在下面看到。在本书中，单词语句和函数的使用可能是可以互换的，但理解它们之间的区别是构建版本无关脚本的关键。
- en: Attempting to print something on the screen with `print` can be done in two
    ways. One is by using wrapped-in parameters, and the other is without using them.
    If it is with wrapped-in parameters, it is compatible with both 2.X and 3.X; if
    not, then it will work with 2.X only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`print`在屏幕上打印一些东西可以通过两种方式完成。一种是使用包裹在参数中，另一种是不使用它们。如果使用包裹在参数中，它与2.X和3.X兼容；如果不是，那么它只能与2.X一起使用。
- en: 'The following example shows what a 2.X-only `print` function looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个仅适用于2.X的`print`函数的样子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an example of a `print` function that is compatible with both 2.X and
    3.X Python interpreters:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与2.X和3.X Python解释器兼容的`print`函数的示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After you have started creating scripts, you will notice how often you will
    be using the `print` function in your scripts. As such, large-scale text replacements
    in big scripts can be laborious and error-prone, even with automated methods.
    Examples include the use of `sed`, `awk`, and other data manipulation tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建脚本之后，你会注意到你在脚本中经常使用`print`函数。因此，在大型脚本中进行大规模的文本替换可能是费力且容易出错的，即使使用自动化方法也是如此。例如，包括`sed`、`awk`和其他数据处理工具。
- en: As you become a better assessor, you should endeavor to write your scripts so
    that they would run in either version. The reason is that if you compromise an
    environment and you need a custom script to complete some post-exploitation activity,
    you would not want to be slowed down because it is version incompatible. The best
    way to start is to make sure that you use `print` functions that are compatible
    with both versions of Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你成为一个更好的评估者，你应该努力编写你的脚本，使它们可以在任何一个版本中运行。原因是，如果你妥协了一个环境，你需要一个自定义脚本来完成一些后渗透活动，你不会希望因为版本不兼容而减慢速度。开始的最佳方式是确保你使用与Python两个版本兼容的`print`函数。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OO programming means that the language supports objects that can be created
    and destroyed as necessary to complete tasks. Entire training classes have been
    developed on explaining and expanding on OO concepts. Deep explanations of these
    concepts are beyond the scope of this book, but further study is always recommended.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程意味着语言支持可以根据需要创建和销毁的对象来完成任务。已经开发了整个培训课程来解释和扩展面向对象的概念。这些概念的深入解释超出了本书的范围，但建议进一步学习。
- en: In addition to the OO thought process and construction of OO supported code,
    there is also creating scripts "Pythonically," or "Pythonic scripts". This is
    not made up; instead, it is a way of defining the proper method of creating and
    writing a Python script. There are many ways you can write a Python script, and
    over the years, best practices have evolved. This is called **Pythonic**, and
    as such, we should always endeavor to write in this fashion. The reason is that
    when we, as contributors, provide scripts to the community, they are easier to
    read, maintain, and use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向对象的思维过程和支持面向对象的代码的构建之外，还有创建“Python化”或“Pythonic脚本”。这不是虚构的；相反，它是一种定义创建和编写Python脚本的正确方法。你可以以许多方式编写Python脚本，多年来，最佳实践已经发展。这就是所谓的**Pythonic**，因此，我们应该始终努力以这种方式编写。原因是，当我们作为贡献者向社区提供脚本时，它们更容易阅读、维护和使用。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pythonic is a great concept as it deals with some of the biggest things that
    have impacted the adoption of other languages and bad practices among the community.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonic是一个很好的概念，因为它涉及到影响其他语言的采用和社区中不良实践的一些最重要的事情。
- en: A Python interactive interpreter versus a script
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python交互式解释器与脚本
- en: There are two ways in which the Python language can be used. One is through
    an interactive interpreter, that allows quick testing of functions, code snippets,
    and ideas. The other is through a full-fledged script that can be saved and transported
    between systems. If you want to try out an interactive interpreter, just type
    `python` in your command-line shell.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言有两种使用方式。一种是通过交互式解释器，允许快速测试函数、代码片段和想法。另一种是通过一个完整的脚本，可以保存并在不同系统之间传输。如果你想尝试交互式解释器，只需在命令行中输入`python`。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An interactive interpreter will function the same way in different operating
    systems, but the libraries and called functions that interact with a system may
    not. If specific locations are referenced or if commands and/or libraries use
    operating-system-specific capabilities, the functionality will be different. As
    such, referencing these details in a script will impact its portability substantially,
    so it is not considered a leading practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式解释器在不同操作系统中的功能方式相同，但与系统交互的库和调用函数可能不同。如果引用了特定位置，或者命令和/或库使用特定于操作系统的功能，功能将不同。因此，在脚本中引用这些细节将大大影响其可移植性，因此不被认为是一种主流做法。
- en: Environmental variables and PATH
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量和PATH
- en: 'These variables are important for executing scripts written in Python, not
    for writing them. If they are not configured, the location of the Python binary
    has to be referenced by its fully qualified path location. As an example, here
    is the execution of a Python script without the environmental variable being declared
    in Windows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量对于执行Python编写的脚本很重要，但不是用于编写脚本。如果它们没有配置，Python二进制文件的位置必须通过其完全限定的路径位置引用。例如，在Windows中，没有声明环境变量的情况下执行Python脚本的示例：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the equivalent in Linux or Unix if the reference to the proper
    interpreter is not listed at the top of the script and the file is in your current
    directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本顶部没有列出对正确解释器的引用，并且文件在当前目录中，则在Linux或Unix中相当于以下内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Windows, if the environmental variable is set, you can simply execute the
    script by typing `python` and the script name. In Linux and Unix, we add a line
    at the top of the script to make it more portable. A benefit to us (penetration
    testers) is that this makes the script useful on many different types of systems,
    including Windows. This line is ignored by the Windows operating system natively,
    as it is treated as a comment. The following referenced line should be included
    at the top of all Python scripts:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，如果环境变量已设置，只需输入`python`和脚本名称即可执行脚本。在Linux和Unix中，我们在脚本顶部添加一行以使其更具可移植性。对我们（渗透测试人员）的好处是，这使得脚本在许多不同类型的系统上都很有用，包括Windows。这行在Windows操作系统中被忽略，因为它被视为注释。所有Python脚本的顶部应包含以下引用行：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line lets the operating system determine the correct interpreter to run
    based on what is set in the `PATH` environmental variable. In many script examples
    on the Internet, you may see a direct reference to an interpreter, such as `/usr/bin/python`.
    This not considered good practice as it makes the code less portable and more
    prone to errors with potential system changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这行让操作系统根据`PATH`环境变量中设置的内容确定正确的解释器来运行。在互联网上的许多脚本示例中，你可能会看到对解释器的直接引用，比如`/usr/bin/python`。这不被认为是一种良好的做法，因为它会使代码不够可移植，并且更容易出现潜在的系统更改错误。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Setting up and dealing with `PATH` and environmental variables will be different
    for each operating system. Refer to [https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)
    for Windows. For Unix and Linux platforms, the details can be found at [https://docs.python.org/2/using/unix.html#python-related-paths-and-files](https://docs.python.org/2/using/unix.html#python-related-paths-and-files).
    Additionally, if you need to create specialty environmental variables for a specific
    tool someday, you can find the details at [https://docs.python.org/2/using/cmdline.html](https://docs.python.org/2/using/cmdline.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和处理`PATH`和环境变量对每个操作系统都是不同的。有关Windows，请参阅[https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)。对于Unix和Linux平台，详细信息可以在[https://docs.python.org/2/using/unix.html#python-related-paths-and-files](https://docs.python.org/2/using/unix.html#python-related-paths-and-files)找到。此外，如果有一天需要为特定工具创建特殊的环境变量，可以在[https://docs.python.org/2/using/cmdline.html](https://docs.python.org/2/using/cmdline.html)找到详细信息。
- en: Understanding dynamically typed languages
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态类型语言
- en: Python is a dynamically typed language, which means many things, but the most
    crucial aspect is how variables or objects are handled. Dynamically typed languages
    are usually synonymous with scripting languages, but this is not always the case,
    just to be clear. What this means to you when you write your script is that variables
    are interpreted at runtime, so they do not have to defined in size or by content.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态类型的语言，这意味着很多东西，但最关键的方面是变量或对象的处理方式。动态类型的语言通常与脚本语言等同，但这并不总是如此，需要明确。当你编写脚本时，这对你的意义是变量在运行时被解释，因此它们不必按大小或内容定义。
- en: The first Python script
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个Python脚本
- en: 'Now that you have a basic idea of what Python is, let''s create a script. Instead
    of the famous `Hello World!` introduction, we are going to use a cult film example.
    The scripts will define a function, which will print a famous quote from the 1983
    cult classic *WarGames*. There are two ways of doing this, as mentioned previously;
    the first is through the interactive interpreter, and the second is through a
    script. Open an interactive interpreter and execute the following line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Python 是什么有了一个基本的概念，让我们创建一个脚本。我们不使用著名的 `Hello World!` 介绍，而是使用一个文化电影的例子。脚本将定义一个函数，该函数将打印出
    1983 年文化经典电影 *WarGames* 中的一句名言。有两种方法可以做到这一点，如前面提到的；第一种是通过交互式解释器，第二种是通过脚本。打开交互式解释器并执行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding print statement will show that the code execution worked. To
    exit the interactive interpreter, either type `exit()` or use *Ctrl* + *Z* in
    Windows or *Ctrl* + *D* in Linux. Now, create a script in your preferred editing
    tool, such as vi, vim, emacs, or gedit. Then save the file in `/root/Desktop`
    as `wargames_print.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的打印语句将显示代码执行成功。要退出交互式解释器，可以输入`exit()`，或者在 Windows 中使用 *Ctrl* + *Z*，在 Linux
    中使用 *Ctrl* + *D*。现在，在你喜欢的编辑工具中创建一个脚本，比如 vi、vim、emacs 或 gedit。然后将文件保存在 `/root/Desktop`
    中，命名为 `wargames_print.py`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After saving the file, run it with the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，使用以下命令运行它：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will again see the script execute with the same results. Be aware of a
    few items in this example. The `python` script is run by referencing the fully
    qualified path so as to ensure that the correct script is called, no matter what
    the location is. If the script resided in the current location, it could, instead,
    be executed in the following manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次看到脚本执行相同的结果。在这个例子中要注意一些事项。`python` 脚本是通过引用完全限定的路径来运行的，以确保调用正确的脚本，无论位置如何。如果脚本驻留在当前位置，可以以以下方式执行：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Kali does not natively require `./` to execute these scripts, but it is a good
    habit to be in, as most other Linux and Unix operating systems do. If you are
    out of the habit and slightly sleep deprived on an assessment, you may not realize
    why your script is not executing initially. This technique can save you a little
    embarrassment on multimember team engagements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 不需要本地执行这些脚本的 `./`，但养成这个习惯是很好的，因为大多数其他 Linux 和 Unix 操作系统都需要。如果你不习惯这种做法，而且在评估时有点睡眠不足，你可能意识不到你的脚本为什么一开始没有执行。这种技巧可以在多人团队合作中避免一些尴尬。
- en: Developing scripts and identifying errors
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发脚本和识别错误
- en: Before we jump into creating large-scale scripts, you need to understand the
    errors that can be produced. If you start creating scripts and generating a bunch
    of errors, you may get discouraged. Keep in mind that Python does a pretty good
    job at directing you to what you need to look at. Often, however, the producer
    of the error is either right before the line referenced or the function called.
    This in turn can be misleading, so to prevent discouragement, you should understand
    the definitions that Python may reference in the errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建大规模的脚本之前，你需要了解可能产生的错误。如果你开始创建脚本并产生了一堆错误，你可能会感到沮丧。请记住，Python 在指导你需要查看的内容方面做得相当不错。然而，错误的产生者通常要么就在引用的行之前，要么就是调用的函数。这可能会产生误导，为了防止沮丧，你应该了解
    Python 可能在错误中引用的定义。
- en: Reserved words, keywords, and built-in functions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留字、关键字和内置函数
- en: Reserved words, keywords, and built-in functions are also known as **prohibited**,
    which means that the name cannot be used as a variable or function. If the word
    or function is reused, an error will be shown. There are set words and built-in
    functions natively within Python, and depending on the version you are using,
    they can change. You should not worry too much about this now, but if you see
    errors related to the definitions of variables or values, consider the fact that
    you may be using a keyword or built-in function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字、关键字和内置函数也被称为**禁用**，这意味着这些名称不能用作变量或函数。如果重复使用这些单词或函数，将会显示错误。Python 中本地设置了一些保留字和内置函数，取决于你使用的版本，它们可能会发生变化。现在你不必太担心这个问题，但如果你看到与变量或值的定义相关的错误，要考虑到你可能使用了关键字或内置函数。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details about keywords and built-in functions can be found at [https://docs.python.org/2/library/keyword.html](https://docs.python.org/2/library/keyword.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关键字和内置函数的更多细节可以在 [https://docs.python.org/2/library/keyword.html](https://docs.python.org/2/library/keyword.html)
    找到。
- en: 'Here are some examples of Python keywords and some brief definitions. These
    are described in detail throughout the rest of the chapter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 Python 关键字的示例和简要定义。这些将在本章的其余部分详细描述：
- en: '| Example keyword | Purpose |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 示例关键字 | 目的 |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `for` | A type of Python loop used mostly for iterations |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `for` | 一种用于迭代的 Python 循环类型 |'
- en: '| `def` | The definition of a function that will be created in the current
    script |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `def` | 在当前脚本中创建的函数的定义 |'
- en: '| `if` | A method of evaluating a statement and determining a resulting course
    of action |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `if` | 评估语句并确定结果行动的方法 |'
- en: '| `elif` | A follow-on evaluation for an `if` statement, which allows more
    than two different outcomes |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `elif` | `if` 语句的后续评估，允许超过两种不同的结果 |'
- en: '| `import` | The manner in which libraries are imported |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 导入库的方式 |'
- en: '| `print` | The statement to output data to **Standard Out** (**STDOUT**) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `print` | 输出数据到 **标准输出** (**STDOUT**) 的语句 |'
- en: '| `try` | A conditional handler test |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `try` | 条件处理程序测试 |'
- en: 'If you want to confirm a name as a keyword, fire up the interactive interpreter
    and set a variable to the specific keyword name. Then, run it through the function
    of keyword. If it returns `true`, then you know it is a keyword; if it returns
    `false`, you know it is not. Refer to the following screenshot to better understand
    this concept:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确认一个名称是否是关键字，可以启动交互式解释器，并将一个变量设置为特定的关键字名称。然后，通过关键字的函数运行它。如果返回 `true`，那么你就知道它是一个关键字；如果返回
    `false`，你就知道它不是。参考以下截图更好地理解这个概念：
- en: '![Reserved words, keywords, and built-in functions](img/B04315_02_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![保留字、关键字和内置函数](img/B04315_02_01.jpg)'
- en: Global and local variables
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局和局部变量
- en: 'Global variables are defined outside of functions, and local variables are
    defined within a specific function. This is important because if the name is reused
    within a function, its value will remain only within that function—typically.
    If you wished to change the value of a global variable, you could call the global
    version with the global keyword and set a new value. This practice should be avoided,
    if at all possible. As an example of local and global variable usage, see this
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是在函数外定义的，局部变量是在特定函数内定义的。这很重要，因为如果在函数内重复使用名称，其值通常只会在该函数内保留。如果你希望改变全局变量的值，你可以使用global关键字调用全局版本并设置一个新值。如果可能的话，应该避免这样做。关于局部和全局变量的使用示例，请参见以下代码：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following output of this script shows the printing of the local variable
    `hacker` within the `local_variable_example` function example. Then, we have the
    printing of the global variable `hacker` after the function has been executed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的输出显示了在`local_variable_example`函数示例中打印局部变量`hacker`，然后在函数执行后打印全局变量`hacker`。
- en: '![Global and local variables](img/B04315_02_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![全局和局部变量](img/B04315_02_02.jpg)'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example shows how to insert a value into a string through a variable.
    Further along in this chapter, several methods of doing this are provided.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何通过变量将值插入到字符串中。在本章的后面，将提供几种方法来实现这一点。
- en: Understanding a namespace
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解命名空间
- en: 'The basic idea of a variable in Python is a name; these names reside in a bucket.
    Every module or script receives its own global namespace, and the names reside
    in this bucket, which is called the namespace. This means that when a name is
    used, it is reserved for a specific purpose. If you use it again, it is going
    to result in one of two things: either you are going to overwrite the value or
    you are going to see an error.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python中变量的基本概念是一个名称；这些名称驻留在一个桶中。每个模块或脚本都有自己的全局命名空间，这些名称驻留在这个桶中，这个桶被称为命名空间。这意味着当一个名称被使用时，它是为特定目的而保留的。如果你再次使用它，会导致两种情况之一：要么你会覆盖这个值，要么你会看到一个错误。
- en: Modules and imports
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和导入
- en: 'Within Python, a library or module can be imported to execute a specific task
    or supplement functionality. When you have written your own script, you can import
    a script as a module to be used within a new script. There are a couple of ways
    of doing this, and each way has its benefits and disadvantages:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以导入库或模块来执行特定任务或补充功能。当你编写自己的脚本时，你可以将一个脚本作为模块导入到一个新的脚本中使用。有几种方法可以做到这一点，每种方法都有其优点和缺点：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows you to import a module and use it and functions by referencing
    them similar to a function. As an example, you could reference the module and
    the function within the module as `module.function()`. This means that your namespace
    is kept simple and you do not have to worry about overwrites and collisions, unlike
    the following method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你导入一个模块并使用它和函数，通过引用它们类似于一个函数。例如，你可以引用模块和模块内的函数为`module.function()`。这意味着你的命名空间保持简单，你不必担心覆盖和冲突，不像以下方法：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is very commonly seen in Python scripts and examples on the Internet. The
    danger is that all functions or functions within the module are brought in directly.
    This means that if you defined a function within your script named `hacker_tool`
    and `hacker_tool` (the imported module contains a module with the same name),
    you could get a namespace collision and produce multiple errors. At runtime, when
    the script is interpreted, it will take up a larger memory footprint because unnecessary
    functions are imported. The benefit, however, is that you will not have to identify
    the necessary function, nor will you have to the method of `module.function()`.
    You can instead just directly call `function()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Python脚本和互联网上的示例中非常常见。危险在于所有函数或模块内的函数都直接引入。这意味着如果你在脚本中定义了一个名为`hacker_tool`的函数，而`hacker_tool`（被导入的模块包含同名的模块），你可能会遇到命名空间冲突并产生多个错误。在运行时，当脚本被解释时，它将占用更多的内存空间，因为不必要的函数被导入。然而，好处是你不必识别必要的函数，也不必使用`module.function()`的方法。相反，你可以直接调用`function()`。
- en: 'The next two methods are ways of referencing a module or function as a different
    name. This allows you to shorten statements that need reuse and can often improve
    readability. The same namespace conflicts are present, so your imports and references
    should be defined carefully. The first is the declaration of a module as a different
    name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法是引用模块或函数为不同的名称。这允许你缩短需要重用的语句，并且通常可以提高可读性。相同的命名空间冲突存在，因此你的导入和引用应该谨慎定义。第一种是将模块声明为不同的名称：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second is the declaration of a function as a different name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是将函数声明为不同的名称：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are other methods of executing these tasks, but this is enough to read
    the majority of the scripts produced and create useful tools.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他执行这些任务的方法，但这已经足够阅读大部分生成的脚本并创建有用的工具了。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you know that Python modules are scripts themselves? You can take a look
    at how these products work by checking out the `Lib` directory within the Python
    installation of Windows, which defaults to `C:\Python27\Lib` for Python 2.7\.
    In Kali Linux, it can be found at `/usr/lib/python2.7`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道Python模块本身就是脚本吗？你可以通过查看Windows Python安装中的`Lib`目录来了解这些产品的工作方式，默认情况下为`C:\Python27\Lib`对于Python
    2.7\. 在Kali Linux中，它可以在`/usr/lib/python2.7`找到。
- en: Python formatting
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python格式化
- en: This language's greatest selling feature for me is its formatting. It takes
    very little work to put a script together, and because of its simplistic formatting
    requirements, you reduce chances of errors. For experienced programmers, the loathsome
    `;` and `{}` signs will no longer impact your development time due to syntax errors.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言对我来说最大的卖点是它的格式。将脚本放在一起需要很少的工作，由于其简单的格式要求，您减少了出错的机会。对于有经验的程序员来说，可恶的`;`和`{}`符号不再会因为语法错误而影响您的开发时间。
- en: Indentation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进
- en: 'The most important thing to remember in Python is indentation. Python uses
    indents to show where logic blocks are changed. So, if you are writing a simple
    `print` script as mentioned earlier, you are not necessarily going to see this,
    but if you are writing an `if` statement, you will. See the following example,
    which prints the statement previously mentioned here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中最重要的是缩进。Python使用缩进来显示逻辑块的更改位置。因此，如果您正在编写一个简单的`print`脚本，就像前面提到的那样，您不一定会看到这一点，但是如果您正在编写一个`if`语句，您会看到。请参见以下示例，它打印了先前在此处提到的语句：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More details on how this script operates and executes can be found in the *Compound
    statements* section of this chapter. The following example prints the statement
    to the screen if execute is not `False`. This indentation signifies that the function
    separates it from the rest of the global code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此脚本的操作和执行的更多详细信息可以在本章的*复合语句*部分找到。以下示例在执行不是`False`时将语句打印到屏幕上。这个缩进表示该函数将其与全局代码分开。
- en: 'There are two ways of creating an indent: either through spaces or through
    tabs. Four spaces are equivalent to one tab; the indentation in the preceding
    code signifies the separation of the codes logic from the rest of the global code.
    The reason for this is that spaces translate better when moved from one system
    type to another, which again makes your code more portable.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建缩进的方法：通过空格或制表符。四个空格相当于一个制表符；前面代码中的缩进表示代码逻辑与全局代码的分离。这样做的原因是，当从一个系统类型移动到另一个系统时，空格的转换效果更好，这样可以使您的代码更具可移植性。
- en: Python variables
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python变量
- en: 'The Python scripting language has five types of variables: numbers, strings,
    lists, dictionaries, and tuples. These variables have different intended purposes,
    reasons for use, and methods of declaration. Before seeing how these variable
    types work, you need to understand how to debug your variables and ensure that
    your scripts are working.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本语言有五种变量类型：数字、字符串、列表、字典和元组。这些变量具有不同的预期目的、使用原因和声明方法。在了解这些变量类型的工作方式之前，您需要了解如何调试变量并确保您的脚本正常工作。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lists, tuples, and dictionaries fall under a variable category know as **data
    structures**. This chapter covers enough details to get you off the ground and
    running, but most of the questions you notice about Python in help forums are
    related to proper use and handling of data structures. Keep this in mind when
    you start venturing on your own projects outside of the details given in this
    book. Additional information about data structures and how to use them can be
    found at [https://docs.python.org/2/tutorial/datastructures.html](https://docs.python.org/2/tutorial/datastructures.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、元组和字典属于一个名为**数据结构**的变量类别。本章涵盖了足够的细节来让您起步并运行，但是您在帮助论坛中注意到的关于Python的大部分问题都与数据结构的正确使用和处理有关。在您开始在本书中给出的细节之外进行自己的项目时，请记住这一点。有关数据结构及其使用方法的更多信息可以在[https://docs.python.org/2/tutorial/datastructures.html](https://docs.python.org/2/tutorial/datastructures.html)找到。
- en: Debugging variable values
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试变量值
- en: 'The simple solution for debugging variable values is to make sure that the
    expected data is passed to a variable. This is especially important if you need
    to convert a value in a variable from one type to another, which will be covered
    later in this chapter. So, you need to know what the value in the variable is,
    and often what type it is. This means that you will have to debug your scripts
    as you build them; this is usually done through the use of `print` statements.
    You will often see initial scripts sprinkled with `print` statements throughout
    the code. To help you clean these at a later point in time, I recommend adding
    a comment to them. I typically use a simple `#DEBUG` comment, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 调试变量值的简单解决方案是确保预期的数据传递给变量。如果需要将变量中的值从一种类型转换为另一种类型，这一点尤为重要，这将在本章后面进行介绍。因此，您需要知道变量中的值，通常还需要知道它的类型。这意味着您将不得不在构建脚本时调试它们；这通常是通过使用`print`语句来完成的。您经常会看到初始脚本中散布着`print`语句。为了帮助您在以后的某个时间点清理它们，我建议给它们添加注释。我通常使用一个简单的`#DEBUG`注释，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will allow you to quickly search for and delete the `#DEBUG` line. In
    vi or vim, this is very simple—by first pressing *Esc*, then pressing *:*, and
    then executing the following command, which searches for and deletes the entire
    line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您快速搜索并删除`#DEBUG`行。在vi或vim中，这非常简单——首先按下*Esc*，然后按下*:*，然后执行以下命令，搜索并删除整行：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you wanted to temporarily comment out all of the `#DEBUG` lines and delete
    them later, you can use the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想暂时注释掉所有`#DEBUG`行并稍后删除它们，可以使用以下方法：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: String variables
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串变量
- en: 'Variables that hold strings are basically words, statements, or sentences placed
    in a reference. This item allows easy reuse of values as needed throughout a script.
    Additionally, these variables can be manipulated to produce different values over
    the course of the script. To pass a value to the variable, the equal to sign is
    used after the word has been selected to assign a value. In a string, the value
    is enclosed in either quotes or double quotes. The following example shows how
    to assign a value using double quotes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 保存字符串的变量基本上是放置在引用中的单词、语句或句子。这个项目允许在脚本中需要时轻松重用值。此外，这些变量可以被操纵以在脚本的过程中产生不同的值。要将值传递给变量，需要在选择单词后使用等号来分配一个值。在字符串中，值要么用单引号括起来，要么用双引号括起来。以下示例显示了如何使用双引号分配一个值：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following example shows single quotes assigned to a variable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了单引号分配给一个变量：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The reason for allowing both single and double quotes is to grant a programmer
    the means to insert one or the other into a variable as a part of a sentence.
    See the following example to highlight the differences:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 允许使用单引号和双引号的原因是为了让程序员能够将其中一个插入变量作为句子的一部分。请参考以下示例以突出显示差异：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to passing strings or printing values in this method, you can use
    the same type of quote to escape the special character. This is done by preceding
    any special character with a `\` sign, which effectively escapes the special capability.
    The following example highlights this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过此方法传递字符串或打印值，您还可以使用相同类型的引号来转义特殊字符。这是通过在任何特殊字符之前加上`\`符号来完成的，这有效地转义了特殊功能。以下示例突出了这一点：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The important thing about declaring strings is to pick a type of quote to use—either
    single or double—and use it consistently through the script. Additionally, as
    you can see in Python, variable sizes do not have to be declared initially. This
    is because they are interpreted at runtime. Now you know how to create variables
    with strings in them. The next step is to create variables with numbers in them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 声明字符串的重要事项是选择一种引号类型——单引号或双引号——并在脚本中一致使用。此外，正如您在Python中所看到的，变量大小不必在初始时声明。这是因为它们在运行时被解释。现在您知道如何创建包含字符串的变量了。下一步是创建包含数字的变量。
- en: Number variables
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字变量
- en: 'Creating variables that hold numbers is very straight forward. You define a
    variable name and then assign it a value by placing a number on the right-hand
    side of an equal to sign, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建保存数字的变量非常简单。您定义一个变量名，然后通过在等号的右侧放置一个数字来为它赋值，如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once a variable has been defined, it holds a reference to the value it was passed.
    These variables can be overwritten, can have mathematical operations executed
    against them, and can even be changed in the middle of the program. The following
    example shows variables of the same type being added together and printed. First,
    we show the same variable added and printed, and then we show two different variables.
    Finally, the two variables are added together, assigned to a new variable, and
    printed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量被定义，它就保存了它传递的值的引用。这些变量可以被覆盖，可以对它们执行数学运算，并且甚至可以在程序运行中更改。以下示例显示了相同类型的变量被相加并打印出来。首先，我们展示了相同的变量相加并打印，然后我们展示了两个不同的变量。最后，这两个变量被相加，分配给一个新变量，并打印出来。
- en: '![Number variables](img/B04315_02_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![数字变量](img/B04315_02_04.jpg)'
- en: 'Notice that the numerical values passed to the variables do not have quotes.
    If they did, the Python interpreter would consider them as strings, and the results
    would be significantly different. Refer to the following screenshot, which shows
    the same method prescribed to numeric variables with string equivalents:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给变量的数值没有引号。如果有引号，Python解释器会将它们视为字符串，结果会有显著不同。请参考以下截图，显示了将相同的方法应用于具有字符串等效的数字变量：
- en: '![Number variables](img/B04315_02_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![数字变量](img/B04315_02_05.jpg)'
- en: 'As you can see, the values are—instead—merged into a single string verses adding
    them together. Python has built-in functions that allow us to interpret strings
    as numbers and numbers as strings. Additionally, you can determine what a variable
    is using the `type function`. This screenshot shows the declaration of two variables,
    one as a string and one as an integer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些值不是相加在一起，而是合并成一个字符串。Python具有内置函数，允许我们将字符串解释为数字，将数字解释为字符串。此外，您可以使用`type`函数确定变量的类型。这个截图显示了两个变量的声明，一个是字符串，一个是整数：
- en: '![Number variables](img/B04315_02_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![数字变量](img/B04315_02_06.jpg)'
- en: 'Had the variable been declared with a decimal value in it, it would have been
    declared as a floating-point number or a `float` for short. This is still a numeric
    variable, but it requires a different method of storage, and as you can see, the
    interpreter has determined that for you. The following screenshot shows an example
    of this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量中包含小数值，它将被声明为浮点数或简称为`float`。这仍然是一个数值变量，但它需要不同的存储方法，正如您所看到的，解释器已经为您确定了这一点。以下截图显示了一个例子：
- en: '![Number variables](img/B04315_02_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![数字变量](img/B04315_02_07.jpg)'
- en: Converting string and number variables
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换字符串和数字变量
- en: As mentioned in the number variables section, Python has functions that are
    built-in in a manner that allows you to convert one variable type to another.
    As a simple example, we are going to convert a number into a string and string
    into a number. When using the interactive interpreter, the variable value will
    be printed immediately if it is not passed to a new variable; however, in a script,
    it will not. This method of manipulation is extremely useful if data is passed
    by the **Command-line Interface** (**CLI**) and you want to ensure the method
    that the data will be handled.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如数字变量部分所述，Python具有内置函数，允许您将一个变量类型转换为另一个变量类型。作为一个简单的例子，我们将把一个数字转换为一个字符串，将一个字符串转换为一个数字。在使用交互式解释器时，如果变量值没有传递给新变量，它将立即打印出来；但是，在脚本中，它不会。如果数据通过**命令行界面**（**CLI**）传递，并且您想确保数据的处理方法，这种操作方法非常有用。
- en: 'This is executed using the following three functions: `int()`, `str()`, and
    `float()`. These functions do exactly what you think they would; `int()` changes
    the applicable variables of other types to integers, `str()` turns other applicable
    variable types to strings, and `float()` turns applicable variables to floating-point
    numbers. It is important to keep in mind that if the variable cannot be converted
    to the desired type, you will receive a `ValueError` exception, as shown in this
    screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用以下三个函数执行的：`int()`、`str()`和`float()`。这些函数确切地做了你认为它们会做的事情；`int()`将其他类型的适用变量更改为整数，`str()`将其他适用变量类型转换为字符串，`float()`将适用变量转换为浮点数。重要的是要记住，如果变量无法转换为所需的类型，您将收到一个`ValueError`异常，如此截图所示：
- en: '![Converting string and number variables](img/B04315_02_08.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_08.jpg)'
- en: 'As an example, let''s take a string and an integer and try to add them together.
    If the two values are not of the same type, you will receive a `TypeError` exception.
    This is demonstrated in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们拿一个字符串和一个整数并尝试将它们加在一起。如果这两个值不是相同类型，你将会收到一个`TypeError`异常。这在以下屏幕截图中得到了证明：
- en: '![Converting string and number variables](img/B04315_02_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_09.jpg)'
- en: 'This is where you will have to determine what type the variable is and choose
    one of them to convert to the same type. Which one you choose to convert will
    depend on the expected outcome. If you want a variable that contains the total
    value of two numbers, then you need to convert string variables into number type
    variables. If you want the values to be combined together, then you would convert
    the non-string variable into a string. This example shows the definition of two
    values: one of a string and one of an integer. The string will be converted into
    an integer to allow the mathematical operation to continue, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你必须确定变量的类型并选择其中一个转换为相同类型的地方。你选择转换哪一个将取决于预期的结果。如果你想要一个包含两个数字总值的变量，那么你需要将字符串变量转换为数字类型变量。如果你想要将值组合在一起，那么你将把非字符串变量转换为字符串。这个例子展示了两个值的定义：一个是字符串，一个是整数。字符串将被转换为整数以允许数学运算继续进行，如下所示：
- en: '![Converting string and number variables](img/B04315_02_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_10.jpg)'
- en: 'Now that you can see how easy this is, consider what would happen if a string
    variable was the representative of a `float` value and was converted to an integer.
    The decimal portion of the number will be lost. This does not round the value
    up or down; it just strips the decimal part and gives a whole number. Refer to
    the following screenshot to understand an example of this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到这是多么容易，考虑一下如果一个字符串变量代表一个`float`值并被转换为整数会发生什么。数字的小数部分将会丢失。这不会将值四舍五入；它只是去掉小数部分并给出一个整数。请参考以下屏幕截图以了解这个例子：
- en: '![Converting string and number variables](img/B04315_02_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_11.jpg)'
- en: So be sure to change the numeric variable to the appropriate type. Otherwise,
    some data will be lost.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一定要将数字变量更改为适当的类型。否则，一些数据将会丢失。
- en: List variables
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表变量
- en: 'Lists are data structures that hold values in a method that can be organized,
    adjusted, and easily manipulated. An easy way to identify a list in Python is
    by `[]`, which denotes where the values will reside. The manipulation of these
    lists is based on adjusting the values by position, typically. To create a list,
    define a variable name, and on the right-hand side of the equal to sign, place
    brackets with comma-separated values. This simple script counts the length of
    a predefined list and iterates and prints the position and value of the list.
    It is important to remember that a list starts at position 0, not 1\. Since a
    list can contain different types of variables in order to include other lists,
    we are going to print the values as strings to be safe:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一种数据结构，以一种可以组织、调整和轻松操作的方式保存值。在Python中识别列表的简单方法是通过`[]`，它表示值将驻留的位置。对这些列表的操作是基于通常通过位置调整值。要创建一个列表，定义一个变量名，并在等号的右侧放置用逗号分隔的值的括号。这个简单的脚本计算预定义列表的长度，并迭代并打印列表的位置和值。重要的是要记住，列表从位置0开始，而不是1。由于列表可以包含不同类型的变量以包含其他列表，我们将打印值作为字符串以确保安全：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the successful execution of this script:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此脚本的成功执行：
- en: '![List variables](img/B04315_02_12.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![列表变量](img/B04315_02_12.jpg)'
- en: 'As you can see, extracting values from a list and converting them into numerical
    or string values are important concepts. Lists are used to hold multiple values,
    and extracting these values so that they can be represented is often necessary.
    The following code shows you how to do this for a string:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，从列表中提取值并将它们转换为数字或字符串值是重要的概念。列表用于保存多个值，并提取这些值以便它们可以被表示通常是必要的。以下代码向你展示了如何对字符串执行此操作：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is important to note that a list cannot be printed as an integer, so it
    has to be either converted to a string or iterated through and printed. To show
    only the simple differences, the following code demonstrates how to extract an
    integer value from the list and print both it and a string:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，列表不能被打印为整数，所以它必须要么转换为字符串，要么通过迭代打印。为了只显示简单的差异，以下代码演示了如何从列表中提取一个整数值并打印它和一个字符串：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'List values can be manipulated further with list-specific functions. All you
    have to do is call the name of the list and then add `.function(x)` to the list,
    where `function` is the name of the specific activity you want to accomplish and
    `x` is the position or data you want to manipulate. Some common functions used
    include adding values to the end of a list, such as the number 555, which would
    be accomplished like this: `list_example.append(555)`. You can even combine lists;
    this is done using the `extend` function, which adds the relevant items at the
    end of the list. This is accomplished by executing the function as follows: `list_example.extend(list_example2)`.
    If you want to remove the value of 555, you can simply execute `list_example.remove(555)`.
    Values can be inserted in specific locations using the appropriately named `insert`
    function like this: `list_example.insert(0, 555)`. The last function that will
    be described here is the `pop` function, which allows you to either remove the
    value at a specific location by passing a positional value, or remove the last
    entry in the list by specifying no value.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表值可以进一步使用特定于列表的函数进行操作。您只需调用列表的名称，然后在列表中添加`.function(x)`，其中`function`是您想要完成的特定活动的名称，`x`是您想要操作的位置或数据。一些常用的函数包括向列表末尾添加值，例如数字555，可以这样完成：`list_example.append(555)`。您甚至可以合并列表；这是使用`extend`函数完成的，它将相关项目添加到列表的末尾。通过执行以下函数来完成：`list_example.extend(list_example2)`。如果要删除值555，只需执行`list_example.remove(555)`。可以使用名为`insert`的适当命名的函数在特定位置插入值，如此：`list_example.insert(0,
    555)`。这里将描述的最后一个函数是`pop`函数，它允许您通过传递位置值来删除特定位置的值，或者通过指定没有值来删除列表中的最后一个条目。
- en: Tuple variables
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组变量
- en: 'Tuples are similar to lists, but unlike lists, they are defined using `()`.
    Also, they are immutable; that is, they cannot be changed. The motive behind this
    is to provide a means of controlling data in complex operations that will not
    destroy it during the process. A tuples can be deleted, and a new tuple can be
    created to hold portions of a different tuple''s data and show as if the data
    has changed. The simple rule with tuples is as follows: if you want data to be
    unaltered, use tuples; otherwise, use lists.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类似于列表，但与列表不同的是，它们使用`()`进行定义。此外，它们是不可变的；也就是说，它们不能被更改。这样做的动机是为了在复杂操作中控制数据的方式，以便在过程中不破坏它。元组可以被删除，并且可以创建一个新的元组来保存不同元组数据的部分，并显示数据已更改的样子。元组的简单规则如下：如果要保持数据不变，请使用元组；否则，请使用列表。
- en: Dictionary variables
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典变量
- en: 'Dictionaries are a means of associating a key with a value. If you see curly
    brackets, it means that you are looking at a dictionary. The key represents a
    reference to a specific value stored in an unsorted data structure. You may be
    asking yourself why you would do this when standard variables already do something
    similar. Dictionaries provide you with the means to store other variables and
    variable types as values. They also allow quick and easy referencing as necessary.
    You will see detailed examples of dictionaries in later chapters; for now, check
    out the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是将键与值关联起来的一种方式。如果看到花括号，这意味着您正在查看一个字典。键表示对存储在无序数据结构中的特定值的引用。您可能会问自己为什么要这样做，当标准变量已经做了类似的事情。字典为您提供了存储其他变量和变量类型作为值的手段。它们还允许根据需要快速轻松地引用。您将在后面的章节中看到字典的详细示例；现在，请查看以下示例：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This example will print the numbers related to the `''james''` key, as shown
    in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将打印与`'james'`键相关的数字，如下图所示：
- en: '![Dictionary variables](img/B04315_02_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![字典变量](img/B04315_02_13.jpg)'
- en: 'Adding data to dictionaries is extremely simple; you just have to assign a
    new key to the dictionary and a value for that key. For example, to add the value
    of `789` to a `''john''` key, you can execute the following: `dictionary_example[''john'']
    = 789`. This will assign the new value and key to the dictionary. More details
    about dictionaries will be covered later, but this is enough to gain an understanding
    of them.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加数据非常简单；您只需为字典分配一个新的键和一个该键的值。例如，要将值`789`添加到`'john'`键，您可以执行以下操作：`dictionary_example['john']
    = 789`。这将为字典分配新的值和键。关于字典的更多细节将在后面介绍，但这已足以理解它们。
- en: Understanding default values and constructors
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解默认值和构造函数
- en: People who have programmed or scripted previously are probably used to declaring
    a variable with a default value or setting up constructors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以前编程或脚本编写过的人可能习惯于声明具有默认值的变量或设置构造函数。
- en: In Python, this is not necessary to get started, but it is a good habit to set
    a default value in a variable prior to its use. Besides being good practice, it
    will also mitigate some of the reasons for your scripts to have unexpected errors
    and crashes. This will also add traceability if a value is passed to a variable
    that was unexpected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，这并不是必须的，但在使用变量之前设置默认值是一个好习惯。除了是一个良好的实践外，它还可以减轻脚本出现意外错误和崩溃的一些原因。这也将增加可追溯性，如果将意外值传递给变量。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Python, constructor methods are handled by `__init__` and `__new__` when
    a new object is instantiated. When creating new classes, however, it is only required
    to use the `__init__` function to act as the constructor for the class. This will
    not be needed until much later, but keep it in mind; it is important if you want
    to develop a multithreaded application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当实例化新对象时，构造方法由`__init__`和`__new__`处理。然而，当创建新类时，只需要使用`__init__`函数作为类的构造函数。这将在很久以后才需要，但请记住；如果您想开发多线程应用程序，这很重要。
- en: Passing a variable to a string
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变量传递给字符串
- en: Let's say that you want to produce a string with a dynamic value, or include
    a variable in the string as it is printed and interpret the value in real time.
    With Python, you can do it in a number of ways. You can either combine the data
    using arithmetic symbols, such as `+`, or insert values using special character
    combinations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要生成一个带有动态值的字符串，或者在打印字符串时包含一个变量并实时解释值。使用Python，你可以用多种方式做到。你可以使用算术符号，比如`+`，来组合数据，或者使用特殊的字符组合来插入值。
- en: 'The first example will use a combination of two strings and a variable joined
    with the statement to create a dynamic statement, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将使用两个字符串和一个变量的组合与语句一起创建一个动态语句，如下所示：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This produces the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Passing a variable to a string](img/B04315_02_14.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![将变量传递给字符串](img/B04315_02_14.jpg)'
- en: After creating the first script, you can improve it by inserting a value directly
    into the string. This is done by using the `%` special character and appending
    `s` for a string or `d` for a digit to produce the intended result. The `print`
    statement then has the `%` sign appended to it, with parameters wrapped around
    the requisite variable or variables. This allows you to control data quickly and
    easily and clean up your details as you prototype or create your scripts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建第一个脚本后，可以通过直接将值插入字符串来改进它。这是通过使用`%`特殊字符并附加`s`用于字符串或`d`用于数字来实现的。然后在`print`语句后附加`%`符号，并在所需的变量或变量周围包装参数。这样可以快速轻松地控制数据，并在原型设计或创建脚本时清理细节。
- en: 'The variables in the parameters are passed to replace the keyed symbol in the
    statement. Here is an example of this type of script:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 参数中的变量被传递以替换语句中的键入符号。以下是这种类型脚本的一个例子：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following image shows the code being executed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了代码的执行：
- en: '![Passing a variable to a string](img/B04315_02_15.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![将变量传递给字符串](img/B04315_02_15.jpg)'
- en: 'An added benefit is that you can insert multiple values into this script without
    drastically altering it, as shown in the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，你可以在不大幅改变脚本的情况下插入多个值，就像下面的例子所示：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Passing a variable to a string](img/B04315_02_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![将变量传递给字符串](img/B04315_02_16.jpg)'
- en: 'This form of insertion can be done with digits as mentioned in the preceding
    lines and by changing `%s` to `%d`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像前面提到的那样使用数字进行插入，并将`%s`更改为`%d`：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output can be seen in this screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以在这个截图中看到：
- en: '![Passing a variable to a string](img/B04315_02_17.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![将变量传递给字符串](img/B04315_02_17.jpg)'
- en: Instead of using variables, statements can be passed directly. There is usually
    little reason to do such things, as variables provide you with a means to change
    code and have it applied to the entire script. When possible, variables should
    be used to define statements as necessary. This is very important when you start
    writing statements that will be passed to systems. Use a combination of joined
    variables to create commands that will be executed in your Python scripts. If
    you do so, you can change the content provided to the system by simply changing
    a specific value. More examples on this will be covered later.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接传递语句，而不是使用变量。通常没有这样做的理由，因为变量提供了一种改变代码并将其应用于整个脚本的方法。在可能的情况下，应该使用变量来定义必要的语句。当你开始编写将传递给系统的语句时，这一点非常重要。使用组合的变量来创建将在Python脚本中执行的命令。如果这样做，你可以通过简单更改特定值来改变提供给系统的内容。稍后将介绍更多关于这方面的例子。
- en: Operators
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: Operators in Python are symbols that represent functional executions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的运算符是代表功能执行的符号。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details about this can be found at [https://docs.python.org/2/library/operator.html](https://docs.python.org/2/library/operator.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这方面的更多细节可以在[https://docs.python.org/2/library/operator.html](https://docs.python.org/2/library/operator.html)找到。
- en: The important thing to remember is that Python has extensive capabilities that
    allow complex mathematical and comparative operations. Only a few of them will
    be covered here to prepare you for more detailed work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Python具有广泛的功能，允许进行复杂的数学和比较操作。这里只涵盖了其中的一部分，以便为更详细的工作做好准备。
- en: Comparison operators
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: A comparison operator checks whether a condition is true or false based on the
    method of evaluation. In simpler terms, we try to determine whether one value
    equals, does not equal, is greater than, is less than, is greater than or equal
    to, or is less than or equal to another value. Interestingly enough, the Python
    comparison operators are very straightforward.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符根据评估方法检查条件是否为真或假。简单来说，我们试图确定一个值是否等于、不等于、大于、小于、大于等于或小于等于另一个值。有趣的是，Python的比较运算符非常直接。
- en: 'The following table will help define the details of operators:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将帮助定义运算符的细节：
- en: '| Comparison test | Operator |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 比较测试 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Are the two values equal? | == |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 两个值是否相等？ | == |'
- en: '| Are the values not equal? | != |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 值是否不相等？ | != |'
- en: '| Is the value on the left greater than the value on the right? | > |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 左边的值是否大于右边的值？ | > |'
- en: '| Is the value on the left less than the value on the right? | < |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 左边的值是否小于右边的值？ | < |'
- en: '| Is the value on the left greater than or equal to the value on the right?
    | >= |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 左边的值是否大于或等于右边的值？ | >= |'
- en: '| Is the value on the left less than or equal to the value on the right? |
    <= |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 左边的值是否小于或等于右边的值？ | <= |'
- en: Assignment operators
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Assignment operators confuse most people when they transition from a different
    language. The reason for this is that AND assignment operators are different from
    most languages. People who are used to writing incrementors short hands of `variable
    = variable + 1` from in other languages using the format `variable++`, they are
    often confused to see the exact operation is not done in Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们从其他语言过渡时，赋值运算符会让大多数人感到困惑。原因在于AND赋值运算符与大多数语言不同。习惯于在其他语言中使用`variable++`格式的增量器简写的人，往往会困惑地发现在Python中并没有进行完全相同的操作。
- en: The functional equivalent of a variable incrementor in Python is `variable=+1`,
    which is the same as `variable = variable + 1`. You might notice something here,
    however; you can define what is added to the variable in this expression. So,
    instead of the double addition sign, which means, "add 1 to this variable," the
    AND expression allows you to add anything you want to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量增量器的功能等效于`variable=+1`，这与`variable = variable + 1`是一样的。然而，你可能会注意到这里的一点；你可以在这个表达式中定义要添加到变量中的内容。因此，与双加号表示“将1添加到这个变量”不同，AND表达式允许你向其中添加任何你想要的东西。
- en: 'This is important when you write exploits, because you can append multiple
    hexadecimal values to the same string with this operator, as shown in the previous
    string concatenation example, where two strings were added together. [Chapter
    8](ch08.html "Chapter 8. Exploit Development with Python, Metasploit, and Immunity"),
    *Exploit Development with Python, Metasploit, and Immunity*, will cover more of
    this when you develop a **Remote Code Executio**n (**RCE**) exploit. Until then,
    consider this table to see the different assignment operators and what they are
    used for:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写漏洞利用时，这很重要，因为你可以使用这个运算符将多个十六进制值附加到同一个字符串上，就像前面的字符串连接示例中所示，其中两个字符串被相加在一起。[第8章](ch08.html
    "第8章。使用Python、Metasploit和Immunity进行漏洞开发")，*使用Python、Metasploit和Immunity进行漏洞开发*，将在开发**远程代码执行**（**RCE**）漏洞时涵盖更多内容。在那之前，考虑一下这个表格，看看不同的赋值运算符及其用途：
- en: '| Assignment action | Operator |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 赋值操作 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Set a value to something | = |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 将一个值设置为某物 | = |'
- en: '| Add a value to the variable on the left, and set the new value to the same
    variable on the left | += |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 添加一个值到左边的变量，并将新值设置为左边的同一个变量 | += |'
- en: '| Subtract a value from the variable on the left, and set the new value to
    the same variable on the left | -= |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 从左边的变量中减去一个值，并将新值设置为左边的同一个变量 | -= |'
- en: '| Multiply a value by the variable on the left, and set the new value to the
    same variable on the left | *= |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 乘以左边的变量的值，并将新值设置为左边的同一个变量 | *= |'
- en: '| Divide a value by the variable on the left, and set the new value to the
    same variable on the left | /= |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 除以左边的变量的值，并将新值设置为左边的同一个变量 | /= |'
- en: Arithmetic operators
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators are extremely simple overall and are what you would expect.
    Addition executions use the `+` symbol, subtraction executions use `-`, multiplication
    executions use `*`, and division executions use `/`. There are also additional
    items that can be used, but these four cover the majority of cases you are going
    to see.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符总体上非常简单，就像你所期望的那样。加法运算使用`+`符号，减法运算使用`-`，乘法运算使用`*`，除法运算使用`/`。还有其他可以使用的项目，但这四个涵盖了你将要看到的大多数情况。
- en: Logical and membership operators
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑和成员运算符
- en: Logical and membership operators utilize words instead of symbols. Generally,
    Python's most confusing operators are membership operators, because new script
    writers think of them as logical operators. So let's take a look at what a logical
    operator really is.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑和成员运算符使用单词而不是符号。一般来说，Python中最令人困惑的运算符是成员运算符，因为新的脚本编写者会把它们当作逻辑运算符。所以让我们来看看逻辑运算符到底是什么。
- en: 'A logical operator helps a statement or a compound statement determine whether
    multiple conditions are met so as to prove a `true` or `false` condition. So what
    does this mean in layman terms? Look at the following script, which helps determine
    whether two variables contain the values required to continue the execution:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符帮助语句或复合语句确定是否满足多个条件，从而证明“真”或“假”条件。那么这在通俗的术语中是什么意思呢？看看下面的脚本，它有助于确定两个变量是否包含所需的值以继续执行：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Logical operators include `and`, `or`, and `not`, which can be combined with
    more complex statements. The `not` operator here can be confused with `not in`,
    which is part of a membership operator. A `not` test reverses the combined condition
    test. The following example highlights this specifically; if both values or `False`
    or not equal to each other, then the condition is met; otherwise, the test fails.
    The reason for this is that the test checks whether it is both. Examples similar
    to this do surface, but they are not common, and this type of code can be avoided
    if you are not feeling comfortable with the logic flow yet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符包括`and`、`or`和`not`，可以与更复杂的语句结合使用。这里的`not`运算符可能会与成员运算符中的`not in`混淆。`not`测试会反转组合条件测试。以下示例特别突出了这一点；如果两个值都为`False`或不相等，则条件满足；否则，测试失败。原因在于测试检查它是否都是。类似于这样的示例确实会出现，但并不常见，如果你对逻辑流程还不感到舒适，可以避免使用这种类型的代码：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Membership operators, instead, test for the value being part of a variable.
    There are two of these types of operators, `in` and `not in`. Here is an example
    of their usage:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 成员运算符则测试变量是否为其一部分的值。这两种类型的运算符是`in`和`not in`。以下是它们的使用示例：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The logic of this code will cause the statement to return as `True` and the
    first conditional message will be printed to screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的逻辑将导致语句返回为`True`，并且第一个条件消息将被打印到屏幕上。
- en: Compound statements
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合语句
- en: Compound statements contain other statements. This means a test or execution
    while `true` or `false` executes the statements within itself. The trick is to
    write statements so that they are efficient and effective. Examples of this include
    `if then` statements, loops, and exception handling.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句包含其他语句。这意味着测试或执行`true`或`false`时，会执行其中的语句。关键是编写语句，使其既高效又有效。这包括`if then`语句、循环和异常处理的示例。
- en: The if statements
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: 'An `if` statement tests for a specific condition, and if that condition is
    met (or not met), then the statement is executed. The `if` statement can include
    a simple check to see whether a variable is `true` or `false`, and then print
    the details, as shown in the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句测试特定条件，如果满足（或不满足）条件，则执行语句。`if`语句可以包括一个简单的检查，以查看变量是`true`还是`false`，然后打印详细信息，如下例所示：'
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `if` statement can even be used to check for multiple conditions at the
    same time. Keep in mind that it will execute the first portion of the compound
    statement that meets the condition and skip the rest. Here is an example that
    builds on the previous one, using `else` and `elif` statements. The **else** statement
    is a catch all if none of the `if` or `elif` statements are met. An `elif` test
    is a follow-on `if` test. Its condition can be tested after `if` and before `else`.
    Refer to the following example to understand this better:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句甚至可以用于同时检查多个条件。请记住，它将执行满足条件的复合语句的第一部分并跳过其余部分。以下是一个建立在前一个示例基础上的示例，使用`else`和`elif`语句。**else**语句是一个捕获所有的语句，如果没有满足`if`或`elif`语句，则执行。`elif`测试是一个后续的`if`测试。它的条件可以在`if`之后和`else`之前进行测试。请参考以下示例以更好地理解：'
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from these statements, the second `elif` statement will process
    the results. Change the value of `x` to something else and see how the script
    flow really works.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些语句中可以看出，第二个`elif`语句将处理结果。将`x`的值更改为其他值，然后查看脚本流程是如何工作的。
- en: 'Keep one thing in mind: testing for conditions requires thinking through the
    results of your test. The following is an example of an `if` test that may not
    provide the expected results depending on the variable value:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住一件事：测试条件需要仔细思考测试结果。以下是一个`if`测试的示例，根据变量值可能不会提供预期结果：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This script sets the `execute` variable to `True`. Then, `if` is the script
    with the `print` statement. If the variable had not been set to `True` and had
    not been set to `False` either, the statement would have still been printed. The
    reason for this is that we are simply testing for the `execute` variable not being
    equal to `False`. Only if `execute` had been set to `False` would nothing be printed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将`execute`变量设置为`True`。然后，`if`是带有`print`语句的脚本。如果变量既没有被设置为`True`也没有被设置为`False`，语句仍然会被打印。原因是我们只是测试`execute`变量不等于`False`。只有当`execute`被设置为`False`时，才不会打印任何内容。
- en: Python loops
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python循环
- en: 'A loop is a statement that is executed over and over until a condition is either
    met or not met. If a loop is created within another loop, it is known as an embedded
    loop. In penetration testing, having multiple loops within each other is typically
    not considered best practice. This is because it can create situations of memory
    exhaustion if they are not properly controlled. There are two primary forms of
    loops: `while` loops and `for` loops.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一种语句，它一遍又一遍地执行，直到条件满足或不满足为止。如果在另一个循环中创建了一个循环，则称为嵌套循环。在渗透测试中，通常不认为在彼此之间有多个循环是最佳实践。这是因为如果它们没有得到适当控制，它可能会导致内存耗尽的情况。循环有两种主要形式：`while`循环和`for`循环。
- en: The while loop
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while` loops are useful when a situation is true or false and you want
    the test to be executed as long as the condition is valid. As an example, this
    `while` loop checks whether the value of `x` is greater than `0`, and if it is,
    the loop continues to process the data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在情况为真或假且您希望测试在条件有效时执行时非常有用。例如，此`while`循环检查`x`的值是否大于`0`，如果是，则循环将继续处理数据：'
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The for loop
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for循环
- en: 'The `for` loop is executed with the idea that a defined situation has been
    established and it is going to be tested. As a simple example, you can create
    a script that counts a range of numbers between 1 and 15, one number at a time,
    and then prints the results. The following example of a `for` loop statement does
    this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的执行是基于已经建立的情况并对其进行测试的想法。举个简单的例子，您可以创建一个脚本，逐个计算1到15之间的一系列数字，然后打印结果。以下是一个`for`循环语句的示例：'
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The break condition
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中断条件
- en: 'A `break` condition is used to exit a loop and continue processing the script
    from the next statement. Breaks are used to control loops when a specific situation
    occurs within the loop instead of the next iteration of a loop. Even though breaks
    can be used to control loops, you should consider writing your code in such a
    way that you don''t need breaks. The following loop with a `break` condition will
    stop executing if the variable value equals `5`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`条件用于退出循环并从下一个语句继续处理脚本。当循环内发生特定情况而不是循环的下一个迭代时，使用`break`来控制循环。尽管`break`可以用于控制循环，但您应该考虑以这样的方式编写代码，以便您不需要`break`。以下带有`break`条件的循环将在变量值等于`5`时停止执行：'
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of this script is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出如下：
- en: '![The break condition](img/B04315_02_18.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![中断条件](img/B04315_02_18.jpg)'
- en: 'Though this works, the same results can be achieved with a better designed
    script, as shown in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样可以工作，但可以通过更好设计的脚本实现相同的结果，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see here, the same results are produced with cleaner and more manageable
    code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用更干净和更易管理的代码产生了相同的结果：
- en: '![The break condition](img/B04315_02_19.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![中断条件](img/B04315_02_19.jpg)'
- en: Conditional handlers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件处理程序
- en: 'Python, like many other languages, has the ability to handle situations where
    exceptions or relatively unexpected things occur. In such situations, a catch
    will occur and capture the error and the follow-on activity. This is completed
    with the `try` and `except` clauses, which handle the condition. As an example,
    I often use conditional handlers to determine whether the necessary library is
    installed, and if it is not, it tells you how and where to get it. This is a simple,
    but effective, example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Python，像许多其他语言一样，具有处理异常或相对意外情况发生的能力。在这种情况下，会发生捕获并捕获错误和后续活动的情况。这是通过`try`和`except`子句完成的，它们处理条件。例如，我经常使用条件处理程序来确定是否安装了必要的库，如果没有安装，它会告诉您如何在哪里获取它。这是一个简单但有效的例子：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Functions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Python functions allow a scripter to create a repeatable task and have it called
    frequently throughout the script. When a function is part of a class or module,
    it means that a certain portion of the script can be called specifically from
    another script, also known as a module, once imported to execute a task. An additional
    benefit in using Python functions is the reduction of script size. An often unexpected
    benefit is the ability to copy functions from one script to another, speeding
    up development.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数允许脚本作者创建可重复的任务，并在整个脚本中频繁调用它。当函数是类或模块的一部分时，这意味着可以从另一个脚本，也称为模块，中专门调用脚本的某个部分，一旦导入就执行任务。使用Python函数的另一个好处是减少脚本大小。一个经常意想不到的好处是能够从一个脚本复制函数到另一个脚本，加快开发速度。
- en: The impact of dynamically typed languages on functions on functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型语言对函数的影响
- en: Remember that variables hold references to objects, so as the script is written,
    you are executing tests with variables that reference the value. One fact about
    this is that the variable can change and can still point to the original value.
    When a variable is passed to a function through a parameter, it is done as an
    alias of the original object. So, when you are writing a function, the variable
    name within the function will often be different—and it should be. This allows
    easier troubleshooting, cleaner scripts, and more accurate error control.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，变量保存对对象的引用，因此在编写脚本时，您正在使用引用值执行测试。关于这一点的一个事实是变量可以更改，仍然可以指向原始值。当变量通过参数传递给函数时，它作为原始对象的别名进行。因此，当您编写函数时，函数内的变量名称通常会有所不同——而且应该有所不同。这可以更容易地进行故障排除，使脚本更清洁，并且更准确地控制错误。
- en: Curly brackets
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花括号
- en: 'If you have ever written in another language, the one thing that will surprise
    you is that there are no curly brackets like these: `{}`. This is usually done
    to delineate where the code for a logic test or compound statement stops and begins,
    such as a loop, an `if` statement, a function, or even an entire class. Instead,
    Python uses the aforementioned indentation method, and the deeper the indent,
    the more nested the statement.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经在另一种语言中编写过，会让您感到惊讶的是没有像这样的花括号`{}`。这通常是为了界定逻辑测试或复合语句的代码停止和开始的地方，比如循环，`if`语句，函数，甚至整个类。相反，Python使用前面提到的缩进方法，缩进越深，语句嵌套越多。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A nested statement or function means that within a logic test or compound statement,
    another an additional logic test is being performed. An example would be an `if`
    statement within another `if` statement. More examples of this type will be seen
    later in this chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套语句或函数意味着在逻辑测试或复合语句中，正在执行另一个额外的逻辑测试。一个例子是在另一个`if`语句中的`if`语句。这种类型的更多示例将在本章后面看到。
- en: To see a difference between logic tests in Python and other languages, an example
    of a Perl function known as a subroutine will be shown. An equivalent Python function
    will also be demonstrated to showcase the differences. This will highlight how
    Python controls logic flows throughout a script. Feel free to try both of these
    scripts and see how they work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到Python和其他语言中逻辑测试之间的差异，将展示Perl函数的一个示例，称为子例程。还将演示等效的Python函数，以展示差异。这将突出显示Python如何在整个脚本中控制逻辑流。随时尝试这两个脚本，看看它们是如何工作的。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following Python script is slightly longer than the Perl one due to the
    fact that a `return` statement was included. This is not necessary for this script,
    but it is a habit many scripters get into. Additionally, the `print` statement
    has been modified, as you can see, to support both version 2.X and version 3.X
    of Python.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包含了`return`语句，以下Python脚本比Perl脚本稍长。这对于此脚本并非必需，但许多脚本作者会养成这个习惯。此外，`print`语句已经修改，如您所见，以支持Python的2.X版本和3.X版本。
- en: 'Here is an example of the `Perl` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Perl`函数的一个例子：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following function is the equivalent in Python:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是Python中的等效函数：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of both of these scripts can be seen in this screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个脚本的输出可以在这个截图中看到：
- en: '![Curly brackets](img/B04315_02_03.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Curly brackets](img/B04315_02_03.jpg)'
- en: Instead, in Python, curly brackets are used for dictionaries, as previously
    described in the *Python variable* section of this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Python中，花括号用于字典，如本章的*Python变量*部分中先前描述的。
- en: How to comment your code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何注释您的代码
- en: 'In a scripting language, a comment is useful for blocking code and/or describing
    what it is trying to achieve. There are two types of comments in Python: single-line
    and multiline. Single-line comments make everything from the `#` sign to the end
    of the line a comment; it will not be interpreted. If you place code on the line
    and then follow it up with a comment at the end of the line, the code will still
    be processed. Here is an example of effective single-line comment usage:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本语言中，注释对于阻止代码和/或描述其试图实现的内容非常有用。Python中有两种类型的注释：单行和多行。单行注释使`#`符号到行尾的所有内容都成为注释；它不会被解释。如果您在行上放置代码，然后在行尾跟上注释，代码仍将被处理。以下是有效的单行注释用法的示例：
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This works, but it may be easier to do the same thing using a multiline comment,
    as there are two lines within the preceding code are comments. Multiline comments
    are created by placing three quotes in each line that begins and ends the comment
    block. The following code shows an example of this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做也可以，但使用多行注释可能更容易，因为在前面的代码中有两行是注释。多行注释是通过在开始和结束注释块的每一行放置三个引号来创建的。以下代码展示了这种情况的一个例子：
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Python style guide
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python风格指南
- en: When writing your scripts, there are a few naming conventions to observe that
    are common to scripting and programming. These conventions are more of guidelines
    and best practices than hard rules, which means that you will hear opinions on
    both sides. As scripting is a form of art, you will see examples that rebut these
    suggestions, but following them will improve readability.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，有一些命名约定是常见的，适用于脚本和编程。这些约定更多是指导方针和最佳实践，而不是硬性规定，这意味着你会听到双方的意见。由于脚本是一种艺术形式，你会看到一些反驳这些建议的例子，但遵循它们会提高可读性。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the suggestions here were borrowed from the style guide for Python,
    which can be found at [http://legacy.python.org/dev/peps/pep-0008/](http://legacy.python.org/dev/peps/pep-0008/),
    and follow-on style guides.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分建议都是从Python的风格指南中借鉴而来的，可以在[http://legacy.python.org/dev/peps/pep-0008/](http://legacy.python.org/dev/peps/pep-0008/)找到，并且有后续的风格指南。
- en: If you see specifics here that do not directly match this guide, keep in mind
    that all assessors develop habits and styles that differ. The trick is to incorporate
    as many of the best practices as possible while not impacting the speed and quality
    of development.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里看到了与本指南不直接匹配的具体内容，请记住，所有的评估者都会养成不同的习惯和风格。关键是尽可能地融入尽可能多的最佳实践，同时不影响开发的速度和质量。
- en: Classes
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Classes typically begin with an uppercase letter, and the rest of the first
    word is lowercase. Each word after that starts with an uppercase letter as well.
    As such, if you see a defined reference being used and it begins with an uppercase
    letter, it is likely a class or module name. No spaces or underscores should be
    used between the words used to define a class, though people typically forget
    or break this rule.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常以大写字母开头，第一个单词的其余部分是小写的。之后的每个单词也以大写字母开头。因此，如果你看到一个定义的引用被使用，并且以大写字母开头，那么它很可能是一个类或模块名。在定义类时，单词之间不应该使用空格或下划线，尽管人们通常会忘记或打破这个规则。
- en: Functions
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: When you are developing functions, remember that the words should be lowercase
    and separated by underscores.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发函数时，记住单词应该是小写的，并用下划线分隔。
- en: Variables and instance names
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和实例名称
- en: Variables and instances should be lowercase with underscores separating the
    words, and if they are private, they must lead with two underscores. `Public`
    and `Private` variables are common in major programming languages, but in Python,
    they are not truly necessary. If you would like to emulate the functionality of
    a `private` variable in Python, you can lead the variable with `__` to define
    it as private. A private member's major benefit in Python is the prevention of
    namespace clashing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和实例应该是小写的，用下划线分隔单词，如果它们是私有的，必须以两个下划线开头。`公共`和`私有`变量在主要的编程语言中很常见，但在Python中并不是真正必要的。如果你想要在Python中模拟`私有`变量的功能，你可以用`__`开头来定义它为私有。在Python中，私有成员的主要好处是防止命名空间冲突。
- en: Arguments and options
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和选项
- en: There are multiple ways in which arguments can be passed to scripts; we will
    cover more on this in future chapters, as they are applicable to specific scripts.
    The simplest way to take arguments is to pass them without options. Arguments
    are the values passed to scripts to give them some dynamic capability.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以传递参数的多种方式；我们将在未来的章节中更多地涵盖这一点，因为它们适用于特定的脚本。获取参数的最简单方式是在没有选项的情况下传递它们。参数是传递给脚本的值，以赋予它们一些动态能力。
- en: Options are flags that represent specific calls to the script, stating the arguments
    that are going to be provided. In other words, if you want to get the help or
    usage instructions for a script, you typically pass the `-h` option. If you write
    a script that accepts both IP addresses and MAC addresses, you could configure
    it to use different options to signify the data that is about to be presented
    to it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是表示对脚本的特定调用的标志，说明将要提供的参数。换句话说，如果你想要获取脚本的帮助或使用说明，通常会传递`-h`选项。如果你编写一个既接受IP地址又接受MAC地址的脚本，你可以配置它使用不同的选项来表示即将提供给它的数据。
- en: Writing scripts to take options is significantly more detailed, but it is not
    as hard as people make it out to be. For now, let's just look at basic argument
    passing. Arguments can be made natively with the `sys` library and the `argv`
    function. When arguments are passed, a list containing them is created in `sys.argv`,
    which starts at position 0.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本以接受选项要详细得多，但并不像人们所说的那么难。现在，让我们只看一下基本的参数传递。参数可以通过`sys`库和`argv`函数本地创建。当参数被传递时，包含它们的列表被创建在`sys.argv`中，从位置0开始。
- en: 'The first argument provided to `argv` is the name of the script run, and each
    argument provided thereafter represents the other argument values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`argv`的第一个参数是运行的脚本的名称，随后提供的每个参数代表其他的参数值：
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of this script produces the following result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的输出产生了以下结果：
- en: '![Arguments and options](img/B04315_02_20.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![参数和选项](img/B04315_02_20.jpg)'
- en: Your first assessor script
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个评估脚本
- en: Now that you have understood the basics of creating scripts in Python, let's
    create a script that will actually be useful to you. In later chapters, you will
    need to know your local and public IP addresses for each interface, hostname,
    **Media Access Control** (**MAC**) addresses, and **Fully Qualified Domain Name**
    (**FQDN**). The script that follows here demonstrates how to execute all of these.
    A few of the concepts here may still seem foreign, especially how IP and MAC addresses
    are extracted from interfaces. Do not worry about that; this is not the script
    you are going to write. You can use this script if you like, but it is here to
    show you that you can salvage components of scripts—even seemingly complex ones—to
    develop your own simple scripts.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了在Python中创建脚本的基础知识，让我们创建一个对您实际有用的脚本。在后面的章节中，您需要了解每个接口的本地和公共IP地址，主机名，**媒体访问控制**（**MAC**）地址和**完全限定域名**（**FQDN**）。接下来的脚本演示了如何执行所有这些操作。这里的一些概念可能仍然显得陌生，特别是如何从接口中提取IP和MAC地址。不要担心这一点；这不是您要编写的脚本。您可以使用这个脚本，但它在这里是为了向您展示，您可以拯救脚本的组件，甚至看似复杂的组件，以开发自己的简单脚本。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This script uses a technique to extract IP addresses for Linux/Unix systems
    by querying the details based on an interface that has been used in several Python
    modules and examples. The specific recipe for this technique can be found in many
    places, but the best documented reference to this technique can be found at [http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/](http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用一种技术，通过查询基于已在多个Python模块和示例中使用的接口的详细信息来提取Linux/Unix系统的IP地址。这种技术的具体方法可以在许多地方找到，但对这种技术的最好记录参考可以在[http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/](http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/)找到。
- en: 'Let''s break down the script into its components. This script uses a few functions
    that make execution cleaner and repeatable. The first function is called `get_ip`.
    It takes an interface name and then tries to identify an IP address for that interface:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将脚本分解为其组件。这个脚本使用了一些函数，使执行更清晰和可重复。第一个函数称为`get_ip`。它接受一个接口名称，然后尝试为该接口识别IP地址：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second function, called `get_mac_address`, identifies the MAC address of
    a specific interface:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个名为`get_mac_address`的函数标识特定接口的MAC地址：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, these functions rely on the low-level network interface language
    of the socket library. Your concentration should not be on understanding every
    detail about this function, but more on the flow of information, the types of
    variables being used, and how the libraries are integrated. The reason for this
    is that you are going to generate a script later that requires fewer components
    and replicates the activity of grabbing a public IP address later.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些函数依赖于socket库的低级网络接口语言。您的注意力不应该放在理解这个函数的每个细节上，而应该放在信息流、使用的变量类型以及库的集成方式上。原因是您将稍后生成一个需要更少组件并复制获取公共IP地址活动的脚本。
- en: 'The third function gets the details of the host and returns them to the main
    part of the script. It determines whether the host is Windows or not so that the
    correct functions are called. The function accepts two lists, one for Ethernet
    interfaces and the wireless interfaces typical in Linux/Unix. These interfaces
    are processed through the previous functions called in this bigger function. This
    allows the decision-making to be handled by the `get_localhost_details` function,
    and then returns the values for the host that will be represented by the `print`
    statements at the end of the script:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数获取主机的详细信息，并将它们返回给脚本的主要部分。它确定主机是否为Windows，以便调用正确的函数。该函数接受两个列表，一个用于Linux/Unix中典型的以太网接口和无线接口。这些接口通过在这个更大的函数中调用的先前函数进行处理。这允许决策由`get_localhost_details`函数处理，然后返回主机的值，这些值将由脚本末尾的`print`语句表示：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The final function in this script is called `get_public_ip`, which queries
    a known website for the IP address that is connected to it. This IP address is
    returned to the web page in a simple, raw format. There are a number of sites
    against which this can be done, but make sure you know the acceptable use and
    terms of service authorized. The function accepts one input, which is the website
    you are executing the query against:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中的最后一个函数称为`get_public_ip`，它查询已知网站的IP地址，并将该IP地址以简单的原始格式返回到网页。有许多网站可以执行此操作，但请确保您知道可接受的使用和授权的服务条款。该函数接受一个输入，即您要执行查询的网站：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For Windows systems, this script utilizes the simple `socket.gethostbyname(socket.gethostname())`
    function request. This does work for Linux, but it relies on the `/etc/hosts`
    file to have the correct information for all interfaces. Much of this script can
    be replaced by the `netifaces` library, as pointed out by the previous reference.
    This would greatly simplify the script, and examples of its use will be shown
    in the following Chapter. The `netifaces` library is not installed by default,
    and so you will have to install it on every host on which you want to run this
    script. Since you typically do not want to make any impact on a host's integrity,
    this specific script is designed to avoid that conflict.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows系统，此脚本利用简单的`socket.gethostbyname(socket.gethostname())`函数请求。这对Linux有效，但它依赖于`/etc/hosts`文件具有所有接口的正确信息。正如前面的参考所指出的，这个脚本的大部分可以被`netifaces`库替代。这将大大简化脚本，并且其使用示例将在下一章中展示。`netifaces`库不是默认安装的，因此您需要在要运行此脚本的每台主机上安装它。由于通常不希望对主机的完整性产生任何影响，因此特定脚本被设计为避免冲突。
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The final version of this script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的最终版本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py)找到。
- en: The following screenshot shows the output of running this script. Components
    of this script will be used in later chapters, and they allow the automated development
    of exploit configurations and reconnaissance of networks.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行此脚本的输出。本脚本的组件将在后续章节中使用，并且它们允许自动化开发利用配置和对网络进行侦察。
- en: '![Your first assessor script](img/B04315_02_21.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![您的第一个评估脚本](img/B04315_02_21.jpg)'
- en: 'So your useful script is going take components of this script and only find
    the public IP address of the system you are on. I recommend that you try doing
    this prior to looking at the following code (which shows what the actual script
    looks like). If you want to skip this step, the solution can be seen here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的有用脚本将使用这个脚本的组件，并且只会找到您所在系统的公共IP地址。我建议您在查看以下代码（显示实际脚本的样子）之前尝试这样做。如果您想跳过这一步，可以在这里看到解决方案：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of your script should look similar to this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您的脚本的输出应该类似于这样：
- en: '![Your first assessor script](img/B04315_02_22.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![您的第一个评估脚本](img/B04315_02_22.jpg)'
- en: Tip
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py)找到。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused on taking you through the basics of how the Python scripting
    language works and developing your own code by example. It also pointed out the
    common pitfalls related to creating scripts for assessments. The final section
    of this chapter focused on how to create useful scripts, even by simply piecing
    together components of already generated examples.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了Python脚本语言的基础知识，并通过示例开发了您自己的代码。它还指出了与创建评估脚本相关的常见陷阱。本章的最后一节重点介绍了如何创建有用的脚本，即使只是简单地拼凑已生成的示例的组件。
- en: In the following chapter, we are going to dive even deeper into this subject
    with a proper reconnaissance of an environment, using `nmap`, `scapy`, and automation
    with Python.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨这个主题，使用`nmap`、`scapy`和Python进行自动化，对环境进行适当的侦察。
