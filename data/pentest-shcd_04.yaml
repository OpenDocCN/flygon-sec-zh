- en: Reverse Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程
- en: In this chapter, we are going to learn what reverse engineering is and how to
    use debuggers to make us really see what is going on behind the scenes. Also,
    we will look at the execution flow of one instruction at a time, and how we are
    going to use and get familiar with debuggers for both Microsoft Windows and Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习什么是逆向工程，以及如何使用调试器使我们真正看到幕后发生了什么。此外，我们将逐条查看每条指令的执行流程，以及如何使用和熟悉Microsoft
    Windows和Linux的调试器。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Debugging in Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中调试
- en: Debugging in Windows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中调试
- en: The flow of execution of any code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何代码的执行流
- en: Detecting and confirming buffer overflow with reverse engineering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逆向工程检测和确认缓冲区溢出
- en: Shall we begin?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧？
- en: Debugging in Linux
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux中调试
- en: Here, we are going to introduce you to one of the most adorable and powerful
    debuggers ever, GDB (GNU debugger). GDB is an open source command-line debugger
    that can work on many languages, such as C/C++, and it's installed on most of
    the Linux distributions by default.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将向您介绍一个最可爱和强大的调试器之一，GDB（GNU调试器）。GDB是一个开源的命令行调试器，可以在许多语言上工作，比如C/C++，并且它默认安装在大多数Linux发行版上。
- en: So why are we using debuggers? We use them to see inside registers, memory,
    or stacks in each step. Also, there is a disassembly inside GDB to help us understand
    the functionality of each function in assembly language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么要使用调试器呢？我们使用它们来查看每一步中寄存器、内存或堆栈的情况。此外，GDB中还有反汇编，帮助我们理解汇编语言中每个函数的功能。
- en: Some people feel that GDB is hard to use because it's a command-line interface,
    that it's hard to remember each command's arguments, and so on. Let's make GDB
    more tolerable for those people by installing PEDA, which is used to enhance GDB's
    interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人觉得GDB难以使用，因为它是一个命令行界面，很难记住每个命令的参数等。让我们通过安装PEDA来使GDB对这些人更容忍，PEDA用于增强GDB的界面。
- en: '**PEDA** stands for **Python Exploit Development Assistance**, which can make
    GDB easier to use and look nicer.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEDA**代表**Python Exploit Development Assistance**，它可以使GDB更易于使用和更美观。'
- en: 'We need to download it first:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要先下载它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, copy that file to `gdbinit` inside your `home` directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将该文件复制到您“home”目录下的“gdbinit”中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, start GDB:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动GDB：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, it looks useless, but wait; let''s try to debug something easy, such as
    our assembly *hello world* example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来毫无用处，但等等；让我们尝试调试一些简单的东西，比如我们的汇编*hello world*示例：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s assemble and link it as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式汇编和链接它：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run `./hello` with GDB as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用GDB运行`./hello`如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/00139.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00139.jpeg)'
- en: 'We are going to set the disassembling mode to Intel:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把反汇编模式设置为Intel：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we are going to set a breakpoint where we want to start our debugging
    step by step because we are going to track all instructions, so let''s put our
    breakpoint at `_start`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在想要逐步调试的地方设置断点，因为我们将跟踪所有指令，所以让我们在`_start`处设置断点：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for the preceding commands is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/00140.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: As we have set the breakpoint, now, let's run our application inside GDB using
    `run`, and it will continue until it hits the breakpoint.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了断点，现在让我们在GDB中运行我们的应用程序使用`run`，它将继续运行直到触发断点。
- en: 'You will see three sections (registers, code, and stack):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到三个部分（寄存器、代码和堆栈）：
- en: '![](img/00141.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: 'The following screenshot is the code section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是代码部分：
- en: '![](img/00142.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: As you can see, the small arrow on the left is pointing to the next instruction,
    which is moving `0x1` to the `eax` register.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，左侧的小箭头指向下一条指令，即将`0x1`移动到`eax`寄存器。
- en: 'The next screenshot is the stack section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图是堆栈部分：
- en: '![](img/00143.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00143.jpeg)'
- en: 'Also, we can find a lot of command options using the command `peda`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用命令`peda`找到许多命令选项：
- en: '![](img/00144.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00144.jpeg)'
- en: 'There are more too:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多：
- en: '![](img/00145.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00145.jpeg)'
- en: All of these are PEDA commands; you can also use GDB commands.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是PEDA命令；您也可以使用GDB命令。
- en: 'Now, let''s continue our work by typing `stepi`, or you can just use `s`, and
    this will begin to execute one instruction, which is `mov eax,0x1`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的工作，输入`stepi`，或者您也可以使用`s`，这将开始执行一条指令，即`mov eax,0x1`：
- en: The `stepi` command will step into instructions such as `call`, which will cause
    the flow of debugging to be switched inside that call, whereas the `s` command
    or step will not do this, and will just get the return values from the `call`
    instruction by stepping into the `call` instruction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`stepi`命令将进入`call`等指令，这将导致调试流程在该调用内部切换，而`s`命令或step不会这样做，它只会通过进入`call`指令来获取返回值。'
- en: '![](img/00146.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00146.jpeg)'
- en: 'On the previous screen, there is `0x1` inside the `RAX` register and the next
    instruction is pointing at `mov edi,0x1`. Now let''s hit *Enter* to move to the
    next instruction:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个屏幕上，`RAX`寄存器内有`0x1`，下一条指令指向`mov edi,0x1`。现在让我们按*Enter*移动到下一条指令：
- en: '![](img/00147.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00147.jpeg)'
- en: 'Also, as you can see, there is `1` inside the RDI register and the next instruction
    is `movabs rsi,0x6000d8`. Let''s try to see what is inside memory address `0x6000d8` 
    using `xprint 0x6000d8`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如您所看到的，RDI寄存器内有`1`，下一条指令是`movabs rsi,0x6000d8`。让我们尝试看看内存地址`0x6000d8`中有什么，使用`xprint
    0x6000d8`：
- en: '![](img/00148.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00148.jpeg)'
- en: 'It''s clear now that this is the location that holds the `hello there` string.
    We also can dump it in hex using `peda hexprint 0x6000d8` or `peda hexdump 0x6000d8`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，这是保存“hello there”字符串的位置。我们还可以使用`peda hexprint 0x6000d8`或`peda hexdump
    0x6000d8`以十六进制转储它：
- en: '![](img/00149.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: 'Let''s move forward using `stepi`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用`stepi`：
- en: '![](img/00150.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: Now the RSI register is holding a pointer to the `hello there` string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在RSI寄存器持有指向“hello there”字符串的指针。
- en: 'The next instruction is `mov edx,0xc`, which is moving `12` to the EDX register,
    which is the length of the `hello there` string. Now, let''s go further by hitting
    *Enter* one more time; the following is displayed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是`mov edx,0xc`，将`12`移动到EDX寄存器，这是`hello there`字符串的长度。现在，让我们再次按下*Enter*键；显示如下：
- en: '![](img/00151.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: 'By looking at the RDX register now, it holds `0xc`, and the next instruction
    is `syscall`.  Let''s move forward using `s`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看RDX寄存器，它持有`0xc`，下一条指令是`syscall`。让我们继续使用`s`向前移动：
- en: '![](img/00152.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00152.jpeg)'
- en: Now the `syscall` is done, and the `hello there` string is printed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`syscall`已经完成，打印了`hello there`字符串。
- en: 'Now we are going to execute the `exit` syscall, and the next instruction is
    `mov eax,0x3c`, which means move `60` to the RAX register. Let''s keep moving
    forward using `s`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要执行`exit`系统调用，下一条指令是`mov eax,0x3c`，意思是将`60`移动到RAX寄存器。让我们继续向前使用`s`：
- en: '![](img/00153.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00153.jpeg)'
- en: 'Instruction, `mov edi,0xb` means move `11` to the RDI register:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`mov edi,0xb`的意思是将`11`移动到RDI寄存器：
- en: '![](img/00154.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: 'RDI is now holding `0xb`, and the next instruction is `syscall`, which will
    execute the `exit` syscall:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RDI现在持有`0xb`，下一条指令是`syscall`，将执行`exit`系统调用：
- en: '![](img/00155.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: Now the program exits normally.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序正常退出。
- en: 'Let''s see another example, which is hello world in C language:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，即C语言中的hello world：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s compile it and debug it using GDB:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译它并使用GDB进行调试：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s set the disassembling mode to Intel:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将反汇编模式设置为Intel：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set our breakpoint at the `main` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数处设置断点：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now if we want to look at the assembly instruction of any function, then we
    should use the `disassemble` command followed by the name of the function. For
    example, we want to disassemble the `main` function, and therefore we can use
    `disassemble main`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想查看任何函数的汇编指令，那么我们应该使用`disassemble`命令，后面跟着函数的名称。例如，我们想要反汇编`main`函数，因此我们可以使用`disassemble
    main`：
- en: '![](img/00156.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00156.jpeg)'
- en: 'The first two instructions are to save the content of the base pointer or the
    frame pointer by pushing RBP to the stack, then, at the end, RBP will be extracted
    back. Let''s run the application to see further using the `run` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条指令是通过将RBP推送到堆栈来保存基指针或帧指针的内容，然后在最后，RBP将被提取回来。让我们运行应用程序，以查看更多，使用`run`命令：
- en: '![](img/00157.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00157.jpeg)'
- en: 'It stops at `lea rdi,[rip+0x9f]  # 0x5555555546e4`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '它停在`lea rdi,[rip+0x9f] # 0x5555555546e4`。'
- en: 'Let''s check what''s inside that location:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下那个位置里面有什么：
- en: '![](img/00158.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00158.jpeg)'
- en: It points to the location of the `hello world` string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它指向`hello world`字符串的位置。
- en: 'Let''s step forward by using `stepi` or `s`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`stepi`或`s`向前迈进：
- en: '![](img/00159.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00159.jpeg)'
- en: As you can see, the RDI register is now loaded with the address of the `hello
    world` string.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，RDI寄存器现在加载了`hello world`字符串的地址。
- en: The next instruction, `call 0x555555554510 <puts@plt>`, which is calling the `printf`
    function, is to print the `hello world` string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令`call 0x555555554510 <puts@plt>`，即调用`printf`函数，用于打印`hello world`字符串。
- en: 'We can also check the contents of `0x555555554510`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查`0x555555554510`的内容：
- en: '![](img/00160.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00160.jpeg)'
- en: 'It''s the `jmp` instruction; let''s check that location too:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`jmp`指令；让我们也检查一下那个位置：
- en: '![](img/00161.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00161.jpeg)'
- en: 'Now, let''s step forward using the `stepi` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`stepi`命令向前迈进：
- en: '![](img/00162.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00162.jpeg)'
- en: 'Let''s step forward again:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次向前迈进：
- en: '![](img/00163.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00163.jpeg)'
- en: 'The next instruction is `push 0x0`; let''s keep going using `stepi`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是`push 0x0`；让我们继续使用`stepi`：
- en: '![](img/00164.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00164.jpeg)'
- en: 'The next instruction is `jmp 0x555555554500`; let''s step forward by entering
    `s`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是`jmp 0x555555554500`；输入`s`向前迈进：
- en: '![](img/00165.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00165.jpeg)'
- en: 'Now we are inside the actual execution of the `printf` function; keep stepping
    forward for the next instruction:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`printf`函数的实际执行内部；继续向前迈进，查看下一条指令：
- en: '![](img/00166.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: The next instruction, `call 0x7ffff7abc650 <strlen>`, means calling the `strlen`
    function to get the length of our string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令`call 0x7ffff7abc650 <strlen>`，意思是调用`strlen`函数来获取我们字符串的长度。
- en: 'Keep stepping forward until you hit the `ret` instruction, then you are back
    to our execution again inside `printf`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向前迈进，直到遇到`ret`指令，然后您又回到了我们的执行中，位于`printf`内部：
- en: '![](img/00167.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00167.jpeg)'
- en: 'Let''s make the program continue debugging until it hits an error using the `continue`
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序继续调试，直到出现错误，使用`continue`命令：
- en: '![](img/00168.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: In the previous example, we didn't follow all instructions but just learned
    how to debug using GDB, and understand and investigate every instruction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有遵循所有指令，而只是学习了如何使用GDB进行调试，并理解和调查每条指令。
- en: Debugging in Windows
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows中调试
- en: Now, let's try something more advanced and yet very simple without going into
    specifics. Here, we will see what is going to happen if we use a buffer overflow
    code in Windows. We are going to detect what will happen inside your CPU if we
    execute that code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些更高级但又非常简单的东西，而不涉及具体细节。在这里，我们将看到如果在Windows中使用缓冲区溢出代码会发生什么。我们将检测如果执行该代码，CPU内部会发生什么。
- en: 'First, open *Code::Block* in Windows 7, then go to File menu | New | Empty
    file. Then, write our buffer overflow:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Windows 7中打开*Code::Block*，然后转到文件菜单 | 新建 | 空文件。然后，编写我们的缓冲区溢出：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, go to File menu | Save file, then save it as `buffer.c`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，转到文件菜单 | 保存文件，然后将其保存为`buffer.c`：
- en: '![](img/00169.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: Then, go to Build menu | Build.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到构建菜单 | 构建。
- en: 'Then, open *Immunity Debugger* as the administrator, and from File menu |Open,
    select the executable buffer file, then specify our input not to crash our code
    but just to see the difference, such as `aaaa`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以管理员身份打开*Immunity Debugger*，从文件菜单 | 打开，选择可执行的缓冲文件，然后指定我们的输入，不是为了使我们的代码崩溃，而是为了看到区别，比如`aaaa`：
- en: '![](img/00170.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: 'Then, hit Open:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击Open：
- en: '![](img/00171.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: To get the functionality of each button, just hover your mouse cursor over it
    and read the status bar.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得每个按钮的功能，请将鼠标悬停在其上并阅读状态栏。
- en: 'For example, if I hover my mouse cursor over the red play button ![](img/00172.jpeg), it
    will show in the status bar its functionality, which is Run program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我将鼠标悬停在红色播放按钮![](img/00172.jpeg)上，它将在状态栏中显示其功能，即运行程序：
- en: '![](img/00173.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: 'Let''s hit the Run program button one time. The program starts and then stops
    at the program entry point, which is the `main` function. Let''s hit that button
    again and notice what happens in the status bar:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击一次运行程序按钮。程序启动，然后停在程序入口点，即`main`函数。让我们再次点击该按钮，并注意状态栏中发生的变化：
- en: '![](img/00174.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00174.jpeg)'
- en: As you can see, the program exited with status zero, which means no errors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序以零状态退出，这意味着没有错误。
- en: 'OK, let''s now try to cause the program to crash to see the difference. Let''s
    close Immunity Debugger and run it again, then open the same program, but we need
    to cause the program to crash, so specify the Arguments, such as 40 of the `a`
    character:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们尝试导致程序崩溃以查看区别。让我们关闭Immunity Debugger并再次运行它，然后打开相同的程序，但我们需要导致程序崩溃，因此指定参数，例如40个`a`字符：
- en: '![](img/00175.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00175.jpeg)'
- en: 'Then hit Open:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击打开：
- en: '![](img/00176.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00176.jpeg)'
- en: 'Let''s hit the Run program button twice and notice what happens in the status
    bar:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击两次运行程序按钮，并注意状态栏中发生的变化：
- en: '![](img/00177.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00177.jpeg)'
- en: The program can't execute `61616161`; do you know why that is? It's our input
    and 61 is a character in hex.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 程序无法执行`61616161`；你知道为什么吗？这是我们的输入，61是十六进制中的一个字符。
- en: 'Let''s have a look at both the register and stack window:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看寄存器和堆栈窗口：
- en: '![](img/00178.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00178.jpeg)'
- en: Notice that the stack has 16 of the `a` characters; the rest of our input filled
    the EAX register and it filled RIP, and that's why our application is complaining
    that it can't execute `61616161`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，堆栈中有16个`a`字符；我们的输入的其余部分填充了EAX寄存器并填充了RIP，这就是为什么我们的应用程序抱怨无法执行`61616161`。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through debugging, and how to use debuggers in both
    Linux and Microsoft Windows. We also looked at how to follow the flow of execution
    and see what is going on behind the scenes. We only scratched the surface of this
    topic because we don''t want to get carried away from our main goal. Now let''s
    keep going to the next chapter, which will cover one of our main goals here: creating
    shellcodes. We will look at how we are going to apply everything we have learned
    so far to create our customized shellcode.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了调试以及如何在Linux和Microsoft Windows中使用调试器。我们还看了如何跟踪执行流程并了解幕后发生了什么。我们只是浅尝辄止这个主题，因为我们不想偏离我们的主要目标。现在让我们继续进行下一章，这一章将涵盖我们的主要目标之一：创建shellcode。我们将看看我们将如何应用到目前为止学到的一切来创建我们定制的shellcode。
