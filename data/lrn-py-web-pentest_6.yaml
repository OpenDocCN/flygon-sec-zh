- en: Detecting and Exploiting SQL Injection Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和利用SQL注入漏洞
- en: In [Chapter 5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password
    Testing*, we learned about the different authentication methods, and we created
    a password brute forcing tool. In this chapter, we're going to learn about one
    of the most dangerous vulnerabilities that can affect web applications, **SQL
    injection** (**SQLi**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80)，*密码测试*中，我们了解了不同的身份验证方法，并创建了一个密码暴力破解工具。在本章中，我们将学习可能影响Web应用程序的最危险的漏洞之一，**SQL注入**（**SQLi**）。
- en: 'In this chapter, we''re going to take a look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下：
- en: Introduction to SQL injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入简介
- en: Detecting SQL injection issues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测SQL注入问题
- en: Exploiting a SQL injection to extract data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用SQL注入提取数据
- en: Advanced SQLi exploiting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级SQLi利用
- en: Introduction to SQL injection
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入简介
- en: What is SQL injection? It is a type of input manipulation vulnerability. As
    the name suggests, it is a vulnerability where the attacker manipulates the web
    application in order to inject arbitrary SQL code into the application database.
    This vulnerability affects mainly web applications that use DBs to store and retrieve
    data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是SQL注入？这是一种输入操纵漏洞。顾名思义，这是一种漏洞，攻击者通过操纵Web应用程序来向应用程序数据库中注入任意的SQL代码。这种漏洞主要影响使用DB存储和检索数据的Web应用程序。
- en: 'Nowadays, most web applications use a DB, thus the united web apps affected
    by this vulnerability are huge. The main cause for this problem is when the web
    application uses data that is coming from an untrusted source to dynamically construct
    a SQL query. If the injection is successful, attackers can:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数Web应用程序使用DB，因此受此漏洞影响的联合Web应用程序数量庞大。这个问题的主要原因是当Web应用程序使用来自不受信任来源的数据动态构造SQL查询时。如果注入成功，攻击者可以：
- en: Extract arbitrary data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取任意数据
- en: Insert tampered data into the database
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将篡改的数据插入数据库
- en: Bypass authentication authorizations, and access controls
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过身份验证授权和访问控制
- en: Take control of the server by executing OS commands
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行操作系统命令来控制服务器
- en: As you can see, it allows you to do a lot of things in the web application,
    which, for an attacker, is pretty good.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它允许你在Web应用程序中做很多事情，对于攻击者来说，这是相当不错的。
- en: 'Imagine we have a login form in our web application. This login form will be
    handled by our server-side code, which will obtain the username and the password
    from the `POST` content. It will be assigned to the variables, a name, and pass.
    Then, these two variables will be used to dynamically construct the SQL statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们的Web应用程序中有一个登录表单。这个登录表单将由我们的服务器端代码处理，它将从`POST`内容中获取用户名和密码。它将分配给变量，一个名字和一个密码。然后，这两个变量将用于动态构造SQL语句：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When our users provide valid usernames and passwords such as `admin` and `superRoot`,
    the login will be successful. But what will happen if a user provides special
    characters and structure to his/her input?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户提供有效的用户名和密码，如`admin`和`superRoot`时，登录将成功。但如果用户提供特殊字符和结构作为输入，会发生什么？
- en: 'Let''s imagine the same example, but this time, the attacker inserts a `''`
    or `1=1` as the name and password. What will happen here? The resulting SQL query
    is valid. It will return all rows from the table users, since `1=1` is always
    true. This means that it will return all the results in the user''s table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象同样的例子，但这次攻击者将`'`或`1=1`插入为用户名和密码。这里会发生什么？生成的SQL查询是有效的。它将从用户表中返回所有行，因为`1=1`始终为真。这意味着它将返回用户表中的所有结果：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the case of this login screen, it will log the attacker in with the first
    users of the table. Many times, the first user is `admin`, except if there are
    some users called `Aaron` and `Charl`, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个登录界面的情况下，它将使用表的第一个用户将攻击者登录。很多时候，第一个用户是`admin`，除非有一些名为`Aaron`和`Charl`等用户。
- en: SQLi versus blind SQLi
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLi与盲SQLi
- en: When a web application is vulnerable to an SQL injection, but the results of
    the injection are not visible to the attacker, is called blind SQLi.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web应用程序容易受到SQL注入攻击，但攻击者看不到注入的结果时，称为盲SQLi。
- en: 'Admins, developers, and frameworks are handling errors in order to avoid leaking
    information. When no results or errors are visible to the attacker, we still have
    some methods that can help exploit the SQL injection in a blind way. They are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员、开发人员和框架正在处理错误，以避免泄露信息。当攻击者看不到结果或错误时，我们仍然有一些方法可以帮助以盲目的方式利用SQL注入。它们是：
- en: '**Boolean**: This method is based on injecting payloads that alter the outcome
    of the original query, which results in different returned page content'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔**：这种方法是基于注入有效负载，改变原始查询的结果，导致返回不同的页面内容'
- en: '**Time based**: This method is based on injecting payloads that trigger a delay
    time for the SQL server while processing our query, which, in turn, slows down
    the response time of our request'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的**：这种方法是基于注入有效负载，触发SQL服务器在处理我们的查询时出现延迟时间，从而减慢我们请求的响应时间'
- en: We're going to learn more about these techniques in more detail later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将更详细地了解这些技术。
- en: Detecting SQL injection issues
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测SQL注入问题
- en: In this section, we're going to learn how to detect SQL injections and how to
    alternate this in Python. We're going to look at what the different methods for
    detecting an SQLi in a web application are. Then, we'll proceed to automate the
    detection of these issues based on one of the methods. Finally, we'll enumerate
    the columns used in the query and also identify valid column names in the table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何检测SQL注入以及如何在Python中进行交替。我们将研究在Web应用程序中检测SQLi的不同方法。然后，我们将根据其中一种方法自动检测这些问题。最后，我们将列举查询中使用的列，并识别表中的有效列名。
- en: Methods for detecting SQLi
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测SQLi的方法
- en: 'In order to detect SQLi, we have three methods available:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测SQLi，我们有三种可用的方法：
- en: '**Error based**: This method injects payloads that break out of the original
    query and generate an SQL error on the server, which can be detected in the content
    of the returned pages:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于错误的**：这种方法注入会打破原始查询并在服务器上生成SQL错误，可以在返回页面的内容中检测到：'
- en: '![](img/00064.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: '**Boolean**: This method injects payloads that alter the outcome of the original
    query, which makes the application return different page content. Basically, we''ll
    identify the size of a valid page versus the size of an invalid page, and then
    we perform Boolean queries like the one we can see here:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔**：这种方法注入会改变原始查询结果的有效负载，使应用程序返回不同的页面内容。基本上，我们将识别有效页面的大小与无效页面的大小，然后执行像我们在这里看到的布尔查询：'
- en: '![](img/00065.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: If the first number of the version of the database is `5`, we're going to get
    the page with the ID `1008`. If not, we're going to get the error page. If we
    want the exact database version, we need to automate this query and guess the
    value for each position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库版本的第一个数字是`5`，我们将得到ID为`1008`的页面。如果不是，我们将得到错误页面。如果我们想要确切的数据库版本，我们需要自动化这个查询并猜测每个位置的值。
- en: '**Time-based**: This method injects a payload that triggers a delay in the
    SQL server while processing the query. If this delay is big enough and there is
    no considerable lag in the network, we can tell whether the query was executed
    correctly:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的**：这种方法注入会触发SQL服务器在处理查询时的延迟。如果这种延迟足够大，并且网络中没有明显的滞后，我们可以判断查询是否正确执行：'
- en: '![](img/00066.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: Automating the detection
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化检测
- en: Let's go back to the editor and open, this in `Section-6`, `SQLinjector-0.py`.
    It's important to highlight that all the content and scripts are based on MySQL
    database and will only work with this database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编辑器并打开`Section-6`中的`SQLinjector-0.py`。重要的是要强调所有的内容和脚本都是基于MySQL数据库的，并且只能在这个数据库上运行。
- en: 'In the `import` section, we have the same content we were using in [Chapter
    5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password Testing*.
    Then, we have the typical `banner` and `usage` functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`部分，我们有与[第5章](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80)中使用的相同内容。然后，我们有典型的`banner`和`usage`函数：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we have the `start` function, which has nothing new. Then, we have the
    common options. We have two parameters, which are the URL to test and the dictionary
    of injections:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`start`函数，没有什么新的。然后，我们有常见的选项。我们有两个参数，一个是要测试的URL，另一个是注入的字典：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we move to the function `launcher`. This will replace the `FUZZ` token,
    with all the `injection` strings provided in the input file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转到`launcher`函数。这将用输入文件中提供的所有`injection`字符串替换`FUZZ`标记：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It will then call the `injector` and print the results. The function `injector`
    is the next SQL injection, based on errors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将调用`injector`并打印结果。`injector`函数是基于错误的下一个SQL注入：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For this purpose, we have the array errors, which has the limited number of
    strings we found in `Mysql` errors. Then, we perform the `requests`, and if we
    find an error, we add the URL to the results array, which, finally, will be printed
    in the launcher function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们有一个错误数组，其中包含我们在`Mysql`错误中找到的有限数量的字符串。然后，我们执行`requests`，如果我们找到一个错误，我们将URL添加到结果数组中，最后将在launcher函数中打印出来。
- en: 'So, let''s try this script. Remember the interesting files that we identified
    with our brute force script in [Chapter 4](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80),
    *Resources Discovery*? There was one file in particular that we needed to focus
    on. It''s `/users.php`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试这个脚本。还记得我们在[第4章](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80)中用我们的暴力脚本识别出来的有趣文件吗？有一个特别需要关注的文件。它是`/users.php`：
- en: '![](img/00067.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: 'This file seems to take an input and return the user and row for that user
    ID. Let''s see what happens if we put `1`. You can see we get a response with
    the `ID: 1`, `Name: johnny`, and `role: test` in this case:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '这个文件似乎接受一个输入并返回该用户ID的用户和行。让我们看看如果我们输入`1`会发生什么。你可以看到在这种情况下，我们得到了一个带有`ID: 1`，`Name:
    johnny`和`role: test`的响应：'
- en: '![](img/00068.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: Excellent! Let's copy the URL to use as the input for our script.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们复制URL作为我们脚本的输入。
- en: 'Let''s go to the console and run the SQL injector with the following parameters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去控制台并使用以下参数运行SQL注入器：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These are the URLs that we copy from the browser and the injection files that
    we created for this exercise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们从浏览器复制的URL和我们为此练习创建的注入文件。
- en: 'Next, press *Enter*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按*Enter*：
- en: '![](img/00069.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: We can see that the script detected the SQL error generated by the following
    characters; single quote and parenthesis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到脚本检测到以下字符生成的SQL错误；单引号和括号。
- en: 'We can check the browser to see the error that these characters generate. Now,
    in the browser, replace this `1` with `''` and press *Enter*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查浏览器以查看这些字符生成的错误。现在，在浏览器中，用`'`替换这个`1`并按*Enter*：
- en: '![](img/00070.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: We can see that when generating an SQL error, we can manipulate that query.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到当生成SQL错误时，我们可以操纵该查询。
- en: Let's move on to improving the SQL injector script.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续改进SQL注入脚本。
- en: 'Now, open the script `SQLinjector-1.py`. You can see that we have two new functions, `detect_columns`
    and `detect_columns_names`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开脚本`SQLinjector-1.py`。你可以看到我们有两个新函数，`detect_columns`和`detect_columns_names`。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`detect_columns` tries to identify how many columns are being used in this
    select and, how many we are trying to manipulate. This information is important
    in order to craft our SQL query. In order to do so, we use the order by technique.
    We can add order by `X`, where `X` is a number. If the number is less than or
    equal to the number of columns, it will return results; if not, it will return
    an error. So, if we try this until we get an error, this will mean that the number
    of columns is less than `X`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`detect_columns`尝试识别在这个select语句中使用了多少列，以及我们试图操纵多少列。这些信息对于构建我们的SQL查询是很重要的。为了做到这一点，我们使用了order
    by技术。我们可以添加order by `X`，其中`X`是一个数字。如果这个数字小于或等于列的数量，它将返回结果；如果不是，它将返回一个错误。因此，如果我们尝试这样做直到出现错误，这将意味着列的数量小于`X`。'
- en: 'Let''s see this in the browser. Now, we try with `a'' order by 1`. We need
    to finish the query with `-- -` to avoid errors:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中看一下。现在，我们尝试使用`a' order by 1`。我们需要用`-- -`结束查询以避免错误：
- en: '![](img/00071.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: 'With `1`, we get results. So, they use at least one column. Let''s try with
    three. We get `Unknown column ''3'' in ''order close''`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用`1`，我们得到了结果。所以，他们至少使用了一列。让我们尝试三列。我们得到了`Unknown column '3' in 'order close'`：
- en: '![](img/00072.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: This means that there are less than three columns.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着少于三列。
- en: 'In this case, it would be `2`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将是`2`：
- en: '![](img/00073.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: We also, have a new function called `detect_columns_names`. This function tries
    to identify valid column names in the table being used by the SQL query. This
    is useful because it will help us to tailor our query to extract data. We're going
    to use the group by technique. We add `group by` and the name of a column. If
    it exists, it will return valid results; if not, we get an error. The array `column_names`
    has a list of interesting names for columns, but in reality, you need an extensive
    dictionary of words to identify as many columns as possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为`detect_columns_names`的新函数。这个函数尝试识别SQL查询中使用的表中的有效列名。这很有用，因为它将帮助我们定制我们的查询以提取数据。我们将使用group
    by技术。我们添加`group by`和列的名称。如果它存在，它将返回有效的结果；如果不是，我们会得到一个错误。数组`column_names`中有一个有趣的列名列表，但实际上，你需要一个广泛的单词字典来识别尽可能多的列。
- en: Let's see an example in the browser. This time, we are going to use `group`
    and we are going to use `password` as a column name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中看一个例子。这一次，我们将使用`group`，并且将`password`作为列名。
- en: 'And then, we hit *Enter*. We can see that it is valid and we are getting the `admin` results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按下*Enter*。我们可以看到它是有效的，我们得到了`admin`的结果：
- en: '![](img/00074.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: 'But what if we use `username` for the column name? We can add `username` in
    the group statement. We can see that the column `username` is not valid:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们使用`username`作为列名呢？我们可以在group语句中添加`username`。我们可以看到列`username`是无效的：
- en: '![](img/00075.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: Hence, we know the error message to identify invalid column names.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道了用于识别无效列名的错误消息。
- en: 'Now, let''s run the script in the command line. We are going to change to `SQLinjection-1.py`
    and run it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在命令行中运行脚本。我们将切换到`SQLinjection-1.py`并运行它：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that we get the same results as before, plus the number of columns:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们得到了与之前相同的结果，加上列的数量：
- en: '![](img/00076.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: In this case, the number of columns is `2` and some of the column names found
    are `name`, `passwd`, `id`, and `role`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列的数量是`2`，找到的一些列名是`name`、`passwd`、`id`和`role`。
- en: Congratulations! You have created an SQL injector detector.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了一个SQL注入检测器。
- en: Exploiting a SQL injection to extract data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SQL注入提取数据
- en: In this section, we're going to learn how to exploit SQL injections and how
    to alternate this in Python. We're going to learn what kind of data we can extract
    with an SQL injection, and then we're going to alternate some of these techniques,
    such as automating basic data extractions in our SQL injector script from the
    previous section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何利用SQL注入以及如何在Python中进行交替。我们将学习可以使用SQL注入提取哪些类型的数据，然后我们将交替一些这些技术，比如在上一节中的SQL注入器脚本中自动化基本数据提取。
- en: What data can we extract with an SQLi?
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以用SQLi提取哪些数据？
- en: 'Once we identify a valid SQL injection, it''s time to decide what we''re going
    to look for. Here, we have a list of the most typical things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了一个有效的SQL注入，就是时候决定我们要寻找什么了。在这里，我们有一个最典型的事物列表：
- en: '**Basic data**: For example, database version, user running the database, current
    database, database directory, and so on'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本数据**：例如，数据库版本、运行数据库的用户、当前数据库、数据库目录等等'
- en: '**Advanced data**: MySQL usernames and passwords, databases, table names, column
    names, and content from tables'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级数据**：MySQL用户名和密码、数据库、表名、列名以及表中的内容'
- en: '**OS files**: We can read any file in the file system as long as the user running
    the database has privileges'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统文件**：只要运行数据库的用户有权限，我们可以读取文件系统中的任何文件'
- en: These are some of the most useful and typically extracted data. I encourage
    you to continue learning what other things you can do once you have a working
    SQL injection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些最有用和通常提取的数据。我鼓励你继续学习一旦你有一个可用的SQL注入后可以做的其他事情。
- en: A good starting point is the pentestmonkey Cheat Sheet ([http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的起点是pentestmonkey的Cheat Sheet ([http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet))。
- en: Automating basic extractions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化基本提取
- en: The first thing we want to obtain after we get a working SQL injection is information
    about the database we're working with, such as the database version, the current
    user, the current database, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得一个可用的SQL注入后，我们想要获取的第一件事是关于我们正在使用的数据库的信息，比如数据库版本、当前用户、当前数据库等等。
- en: In order to do so, we need to use `SELECT @@ version;`. We'll obtain the database
    version. `SELECT user();`, will get you the user that is running the database.
    For our example, we must use the following injection to get the version; `'union
    SELECT1, @@version;-- -`. We need `1` before the `@@version` to match the number
    of columns we have on the query, which is the number of columns that have been
    affected by the SQL injection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要使用`SELECT @@ version;`。我们将获得数据库版本。`SELECT user();`将获得运行数据库的用户。对于我们的示例，我们必须使用以下注入来获取版本；`'union
    SELECT1, @@version;-- -`。我们需要在`@@version`之前加上`1`，以匹配查询中受SQL注入影响的列数，这是受SQL注入影响的列数。
- en: In our case, there were two columns; that's why we add `1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，有两列；这就是为什么我们添加`1`。
- en: 'Let''s go to our editor and continue with the file `SQLinjector-2.py`. We have
    added two new functions in order to obtain the version and current user from the
    database. You will notice that we have the following injection:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去我们的编辑器，并继续处理文件`SQLinjector-2.py`。我们添加了两个新函数，以便从数据库中获取版本和当前用户。您会注意到我们有以下注入：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `%20` is the URL encoded version of the space character. We are using the `CONCAT`
    command to concatenate the string talk at the beginning of the result and at the
    end. The strings will serve as tokens to identify the output of the query in the
    HTML result. Now, we'll see the code we need to extract the version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`%20`是空格字符的URL编码版本。我们正在使用`CONCAT`命令将字符串连接到结果的开头和结尾。这些字符串将作为标记，用于识别HTML结果中的查询输出。现在，我们将看到提取版本所需的代码。'
- en: We do this by processing the results using a regular expression to identify
    the tokens talk and extract the string found between them. We define the regular
    expression, then we use the `findall` function from the `re` library with the
    content of the request response, and then we iterate over the results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用正则表达式处理结果来做到这一点，以识别标记并提取它们之间找到的字符串。我们定义正则表达式，然后使用`re`库的`findall`函数与请求响应的内容一起使用，并遍历结果。
- en: In this case, there should be only one. We will do the same process to get the
    database version by using `@@version` instead of `user`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应该只有一个。我们将使用`@@version`而不是`user`来获得数据库版本。
- en: Now, we want to obtain the MySQL usernames and password hashes. The query we
    need for this is `SELECT user, password from mysql.user;`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要获取MySQL用户名和密码哈希。我们需要的查询是`SELECT user, password from mysql.user;`。
- en: Remember that this will only work if the user that is making the connection
    to the database has the privileges to access the table. Best practices recommend
    the game phase, but many people still do it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有当连接到数据库的用户具有访问表的权限时，此方法才有效。最佳实践建议游戏阶段，但仍有许多人这样做。
- en: 'We added the function `steal_users` to extract this data. We''ll use the same
    techniques as before with the tokens to identify the output in the HTML results.
    Let''s run it in the command line and see the outputs. We''ll use the same command
    line as before:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了函数`steal_users`来提取这些数据。我们将使用与以前相同的技术，以便在HTML结果中识别输出的标记。让我们在命令行中运行它并查看输出。我们将使用与以前相同的命令行：
- en: '![](img/00077.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: Now, we can see the new data that has been extracted. The database version is
    printed. In this case, it is `5.6.28`. It also gives us a hint on the OS; `Ubuntu
    15.10.1`. The user running the database is root, which means that we have high
    privileges that will allow us to do more interesting things such as, for example,
    accessing the table `MySQL.user`, where the usernames and passwords hashes are
    stored.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到提取的新数据。数据库版本已打印。在这种情况下，它是`5.6.28`。它还为我们提供了有关操作系统的提示；`Ubuntu 15.10.1`。运行数据库的用户是root，这意味着我们有高权限，可以做更有趣的事情，比如访问存储用户名和密码哈希的表`MySQL.user`。
- en: We can see the hashes for the user `root`, `debian-sys-maint`, and `phpmyadmin`.
    The repetitions are happening because of the different host entries that are associated
    with each user. These password hashes can be cracked with a tool like John the
    ripper if you need to do so. Great. You have a pretty good idea of the target,
    so let's continue extracting data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户`root`、`debian-sys-maint`和`phpmyadmin`的哈希值。重复发生是因为与每个用户关联的不同主机条目。如果需要，这些密码哈希可以使用John
    the ripper等工具破解。很好。你对目标有了一个很好的想法，所以让我们继续提取数据。
- en: Advanced SQLi exploiting
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级SQLi利用
- en: In this section, we're going to add a function to read all the table names from
    the database, and we are going to add a function to read the files from the database
    server OS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将添加一个函数，以读取数据库中的所有表名，并将添加一个函数，以从数据库服务器操作系统中读取文件。
- en: First, we're going to see how we can obtain all the table names that are in
    the database in order to see if we see something of interest, and then we're going
    to add the capability to reach finals from the OS file system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到如何获取数据库中的所有表名，以便查看是否有感兴趣的内容，然后我们将添加从操作系统文件系统中获取决赛的能力。
- en: 'Now, let''s open the file `SQLinjector-3.py`. We have a new function in here
    that will help us obtain the table names in the different schemas, except the
    ones we are filtering out to reduce the noise in the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开文件`SQLinjector-3.py`。我们在这里添加了一个新函数，它将帮助我们获取不同模式中的表名，除了我们正在过滤以减少输出中的噪音的那些：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The structure is the same as before; we have the query we need, with the tokens
    to help pass the results and the regular expression for passing it, and then we
    print the results. Finally, we have the function call in the `launcher`. Let's
    run it again in the command line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与以前相同；我们有需要的查询，用于帮助传递结果和用于传递结果的正则表达式，然后我们打印结果。最后，在`launcher`中进行函数调用。让我们在命令行中再次运行它。
- en: 'From the command line, let''s run it with the same parameters as before, with `SQLinjector-3.py`
    and the same parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行中，让我们使用与以前相同的参数运行它，使用`SQLinjector-3.py`和相同的参数：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Great, you can now see in the output that we get the schema name and the table
    name:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在您可以在输出中看到我们获得了模式名称和表名称：
- en: '![](img/00078.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: In this case, `pyweb` and `phpmyadmin` are the schema and the others are the
    table `user` and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`pyweb`和`phpmyadmin`是模式，其他的是表`user`等等。
- en: 'Let''s move on to the last example. Let''s go to the editor and open the file
    `SQLinjection-4.py`. This is pretty cool, and it opens a new world of opportunities
    for the attacker. Let''s see the new function, `read_file`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一个例子。让我们转到编辑器并打开文件`SQLinjection-4.py`。这非常酷，它为攻击者打开了一个新的机会。让我们看看新函数`read_file`：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The query we are going to use to read files is highlighted in the preceding
    code. Basically, the new thing here is the use of the function `LOAD_FILE`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自前面代码的查询来读取文件。基本上，这里的新东西是使用`LOAD_FILE`函数。
- en: 'We can use this function, which as the name suggests, will load a file, and
    we will put the content in the column we choose in the query. We are going to
    use it with a union. Then, in the `launcher`, we need to call this function with
    the file we want to read. In this example, we are using `filename="/etc/passwd"`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数，正如其名称所示，它将加载一个文件，并且我们将把内容放在我们在查询中选择的列中。我们将与union一起使用它。然后，在`launcher`中，我们需要调用这个函数并传入我们想要读取的文件。在这个例子中，我们使用`filename="/etc/passwd"`：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This file contains the users for the Linux OS. Let''s run it in the command
    line. Use the same command line as before, just change the file name to `SQLinjector-4.py`.
    And boom, we have the content of the exact password file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含了Linux操作系统的用户。让我们在命令行中运行它。使用与之前相同的命令行，只是将文件名更改为`SQLinjector-4.py`。然后，哇，我们就得到了确切密码文件的内容：
- en: '![](img/00079.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: Now, we can learn a little bit more about the system. Let's take a moment to
    think on all that we have achieved by abusing a simple programming mistake; we
    are obtaining a vast amount of information from the database and the OS - and
    this is still the beginning.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更多地了解这个系统。让我们花点时间思考一下，通过滥用一个简单的编程错误，我们已经取得了什么成就；我们正在从数据库和操作系统中获取大量信息
    - 而这只是个开始。
- en: I recommend playing with this until you're comfortable with the techniques.
    If something doesn't work, review your SQL syntax. It is very common to make mistakes
    at the beginning.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议玩弄这个直到你对这些技术感到舒适。如果有什么不对劲，回顾一下你的SQL语法。在开始阶段犯错误是非常常见的。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to enumerate the table names from the database
    using SQL injection, and we also learned how to read files from the OS file system
    via SQL injection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过SQL注入枚举数据库中的表名，并且还学会了如何通过SQL注入从操作系统文件系统中读取文件。
- en: Remember to review the tools, such as SQL map or SQL brute, to learn more about
    how these tools work.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记得查看工具，比如SQL map或SQL brute，以了解更多关于这些工具如何工作的信息。
- en: In [Chapter 7](part0081.html#2D7TI0-5a228e2885234f4ba832bb786a6d0c80), *Intercepting
    HTTP Requests*, we're going to learn about HTTP proxies, and we're going to create
    our own based on the mitmproxy tool.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0081.html#2D7TI0-5a228e2885234f4ba832bb786a6d0c80)，*拦截HTTP请求*，我们将学习关于HTTP代理的知识，并且我们将基于mitmproxy工具创建我们自己的HTTP代理。
