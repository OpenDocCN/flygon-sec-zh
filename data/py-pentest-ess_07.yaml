- en: Foot Printing a Web Server and a Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 足迹定位Web服务器和Web应用程序
- en: 'So far, we have read four chapters that are related, from the data link layer
    to the transport layer. Now, we move on to application-layer penetration testing.
    In this chapter, we will go through the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经阅读了与数据链路层到传输层相关的四章内容。现在，我们将转向应用层渗透测试。在本章中，我们将讨论以下主题：
- en: The concept of foot printing a web server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足迹定位Web服务器的概念
- en: Introducing information gathering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入信息收集
- en: HTTP header checking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头检查
- en: Information gathering of a website from smartwhois.com by the BeautifulSoup
    parser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过BeautifulSoup解析器从smartwhois.com获取网站的信息收集
- en: Banner grabbing of a website
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站的横幅抓取
- en: Hardening of a web server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器的加固
- en: The concept of foot printing a web server
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 足迹定位Web服务器的概念
- en: The concept of penetration testing cannot be explained or performed in a single
    step; therefore, it has been divided into several steps. Foot printing is the
    first step in pentesting, where an attacker tries to gather information about
    a target. In today's world, e-commerce is growing rapidly. Due to this, web servers
    have become a prime target for hackers. In order to attack a web server, we must
    first know what a web server is. We also need to know about the web-server hosting
    software, hosting operating system, and what applications are running on the web
    server. After getting this information, we can build our exploits. Obtaining this
    information is known as foot printing a web server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试的概念不能用单一步骤来解释或执行，因此它被分成了几个步骤。足迹定位是渗透测试的第一步，攻击者试图收集有关目标的信息。在今天的世界中，电子商务正在迅速增长。因此，Web服务器已成为黑客的主要目标。为了攻击Web服务器，我们必须首先了解什么是Web服务器。我们还需要了解Web服务器托管软件、托管操作系统以及Web服务器上运行的应用程序。获取这些信息后，我们可以构建我们的攻击。获取这些信息被称为足迹定位Web服务器。
- en: Introducing information gathering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入信息收集
- en: In this section, we will try to glean information about the web software, operating
    system, and applications that run on the web server, by using error-handling techniques.
    From a hacker's point of view, it is not that useful to gather information from
    error handling. However, from a pentester's point of view, it is very important
    because in the pentesting final report that is submitted to the client, you have
    to specify the error-handling techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将尝试通过使用错误处理技术来获取有关Web软件、操作系统和运行在Web服务器上的应用程序的信息。从黑客的角度来看，从错误处理中获取信息并不那么有用。然而，从渗透测试人员的角度来看，这非常重要，因为在提交给客户的渗透测试最终报告中，您必须指定错误处理技术。
- en: 'The logic behind error handling is to try to produce an error in a web server,
    which returns the code `404`, and to see the output of the error page. I have
    written a small code to obtain the output. We will go through the following code
    line by line:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理背后的逻辑是尝试在Web服务器中产生一个返回代码`404`的错误，并查看错误页面的输出。我编写了一个小代码来获取输出。我们将逐行查看以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I have imported three modules, `re`, `random`, and `urllib`, that are responsible
    for regular expressions, generating random numbers, and URL-related activities,
    respectively. The `url1 = raw_input("Enter the URL ")` statement asks for the
    URL of the website and stores this URL in the `url1` variable. Then, the `u =
    chr(random.randint(97,122))` statement creates a random character. The next statement
    adds this character to the URL and stores it in the `url2` variable. Then, the
    `http_r = urllib.urlopen(url2)` statement opens the `url2` page, and this page
    is stored in the `http_r` variable. The `content= http_r.read()` statement transfers
    all the contents of the web page into the content variable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入了三个模块，`re`、`random`和`urllib`，它们分别负责正则表达式、生成随机数和与URL相关的活动。`url1 = raw_input("Enter
    the URL ")`语句要求输入网站的URL，并将此URL存储在`url1`变量中。然后，`u = chr(random.randint(97,122))`语句创建一个随机字符。下一条语句将此字符添加到URL中，并将其存储在`url2`变量中。然后，`http_r
    = urllib.urlopen(url2)`语句打开`url2`页面，并将此页面存储在`http_r`变量中。`content= http_r.read()`语句将网页的所有内容传输到content变量中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding piece of code defines the `i` variable flag and an empty list
    whose significance we will discuss later. The `a_tag` variable takes a value of `"<*address>"`.
    A `file_text` variable is a file object that opens the `result.txt` file in the
    append mode. The `result.txt` file stores the results. The while `flag ==0:` statement
    indicates that we want the `while` loop to run at least once. The `http_r.code`
    statement returns the status code from the web server. If the page is not found,
    it will return a `404` code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段定义了`i`变量标志和一个空列表，我们将在后面讨论它的重要性。`a_tag`变量取值为`"<*address>"`。`file_text`变量是一个打开`result.txt`文件的文件对象，以附加模式打开。`result.txt`文件存储了结果。`while
    flag ==0:`语句表示我们希望`while`循环至少运行一次。`http_r.code`语句从Web服务器返回状态代码。如果页面未找到，它将返回`404`代码。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding piece of code writes the output of the page in the `result.txt`
    file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将页面的输出写入`result.txt`文件。
- en: 'The `for match in re.finditer(a_tag,content)`: statement finds the `a_tag`
    pattern, which means the `<address>` tag in the error page, since we are interested
    in the information between the `<address>` `</address>` tag. The `s= match.start()`
    and `e= match.end()` statements indicate the starting and ending points of the
    `<address>` tag and `list1.append(s)`. The `list1.append(e)` statement stores
    these points in the list so that we can use them later. The `i` variable becomes
    greater than `0`, which indicates the presence of the `<address>` tag in the error
    page. This means that the code is not good. The `if len(list1)>0`: statement indicates
    that if the list has at least one element, then variables `a` and `b` will be
    points of interest. The following diagram shows these points of interest:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`for match in re.finditer(a_tag,content)`:语句找到`a_tag`模式，这意味着错误页面中的`<address>`标签，因为我们对`<address>`
    `</address>`标签之间的信息感兴趣。`s= match.start()`和`e= match.end()`语句表示`<address>`标签的起点和终点，`list1.append(s)`。`list1.append(e)`语句将这些点存储在列表中，以便以后使用。`i`变量变得大于`0`，这表明错误页面中存在`<address>`标签。这意味着代码不好。`if
    len(list1)>0`:语句表示如果列表至少有一个元素，则变量`a`和`b`将成为关注点。下图显示了这些关注点：'
- en: '![](img/62de1d49-6b25-4653-a067-899b5f80106a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62de1d49-6b25-4653-a067-899b5f80106a.png)'
- en: Fetching address tag values
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 获取地址标签值
- en: The `print content[a:b]` statement reads the output between the **a** and **b**
    points and sets `flag = 1` to break the `while` loop. The `elif http_r.code ==
    200:` statement indicates that if the HTTP status code is `200`, then it will
    print the `"Web page is using custom Error page"` message. In this case, if code
    `200` returns for the error page, it means the error is being handled by the custom
    page.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`print content[a:b]`语句读取**a**和**b**点之间的输出，并设置`flag = 1`以终止`while`循环。`elif http_r.code
    == 200:`语句表示如果HTTP状态码为`200`，则将打印`"Web page is using custom Error page"`消息。在这种情况下，如果错误页面返回代码`200`，则意味着错误正在由自定义页面处理。'
- en: Now it is time to run the output, and we will run it twice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行输出了，我们将运行两次。
- en: 'The outputs when the server signature is on and when the server signature is
    off:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器签名打开和关闭时的输出：
- en: '![](img/4e36a9eb-7264-4acc-a547-99b18b1d56ab.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e36a9eb-7264-4acc-a547-99b18b1d56ab.png)'
- en: The two outputs of the program
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的两个输出
- en: 'The preceding screenshot shows the output when the server signature is on.
    By viewing this output, we can say that the web software is Apache, the version
    is 2.2.3, and the operating system is Red Hat. In the next output, no information
    from the server means the server signature is off. Sometimes someone uses a web
    application firewall, such as mod-security, which gives a fake server signature.
    In this case, you need to check the `result.txt` file for the full, detailed output.
    Let''s check the output of `result.txt`, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了服务器签名打开时的输出。通过查看此输出，我们可以说Web软件是Apache，版本是2.2.3，操作系统是Red Hat。在下一个输出中，服务器没有来自服务器的信息，这意味着服务器签名已关闭。有时候，有人使用Web应用程序防火墙，例如mod-security，它会提供一个虚假的服务器签名。在这种情况下，您需要检查`result.txt`文件以获取完整的详细输出。让我们检查`result.txt`的输出，如下图所示：
- en: '![](img/7ed8bc70-6e70-48b6-8ea7-d934ac05996e.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ed8bc70-6e70-48b6-8ea7-d934ac05996e.png)'
- en: Output of result.txt
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结果.txt的输出
- en: When there are several URLs, you can make a list of all these URLs and supply
    them to the program, and this file will contain the output of all the URLs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个URL时，您可以列出所有这些URL并将它们提供给程序，这个文件将包含所有URL的输出。
- en: Checking the HTTP header
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查HTTP头
- en: 'By viewing the header of the web pages, you can get the same output. Sometimes,
    the server error output can be changed by programming. However, checking the header
    might provide lots of information. A very small code can give you some very detailed
    information, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看网页的头部，您可以获得相同的输出。有时，服务器错误输出可以通过编程进行更改。但是，检查头部可能会提供大量信息。一小段代码可以给您一些非常详细的信息，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `print http_r.headers` statement provides the header of the web server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`print http_r.headers`语句提供了Web服务器的头部。'
- en: 'The output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/16d61af6-6978-4c44-bbcf-839c5bc0a245.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16d61af6-6978-4c44-bbcf-839c5bc0a245.png)'
- en: Getting header information
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 获取头部信息
- en: 'You will notice that we have taken two outputs from the program. In the first
    output, we entered `http://www.juggyboy.com/` as the URL. The program provided
    lots of interesting information, for example `Server: Microsoft-IIS/6.0` and `X-Powered-By:
    ASP.NET`; it infers that the website is hosted on a Windows machine, the web software
    is IIS 6.0, and ASP.NET is used for web application programming.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到我们从程序中获得了两个输出。在第一个输出中，我们输入了`http://www.juggyboy.com/`作为URL。程序提供了许多有趣的信息，例如`Server:
    Microsoft-IIS/6.0`和`X-Powered-By: ASP.NET`；它推断出网站托管在Windows机器上，Web软件是IIS 6.0，并且ASP.NET用于Web应用程序编程。'
- en: In the second output, I delivered my local machine's IP address, which is `http://192.168.0.5/`.
    The program revealed some secret information, such as the web software is Apache
    2.2.3, it is running on a Red Hat machine, and PHP 5.1 is used for web application
    programming. In this way, you can obtain information about the operating system,
    web server software, and web applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个输出中，我提供了我的本地机器的IP地址，即`http://192.168.0.5/`。程序揭示了一些秘密信息，例如Web软件是Apache 2.2.3，运行在Red
    Hat机器上，并且PHP 5.1用于Web应用程序编程。通过这种方式，您可以获取有关操作系统、Web服务器软件和Web应用程序的信息。
- en: 'Now, let''s look at what output we will get if the server signature is off:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果服务器签名关闭会得到什么输出：
- en: '![](img/497d0456-eb7f-42a2-9c56-93bf1da1758f.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/497d0456-eb7f-42a2-9c56-93bf1da1758f.png)'
- en: When the server signature is off
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器签名关闭时
- en: From the preceding output, we can see that Apache is running. However, it shows
    neither the version nor the operating system. For web application programming,
    PHP has been used, but sometimes, the output does not show the programming language.
    For this, you have to parse the web pages to get any useful information, such
    as hyperlinks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到Apache正在运行。但是，它既没有显示版本，也没有显示操作系统。对于Web应用程序编程，使用了PHP，但有时输出不会显示编程语言。为此，您必须解析网页以获取任何有用的信息，比如超链接。
- en: 'If you want to get the details on headers, open dir of headers, as shown in
    the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获取标题的详细信息，请打开标题目录，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Information gathering of a website from whois.domaintools.com
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从whois.domaintools.com获取网站信息
- en: Consider a situation where you want to glean all the hyperlinks from a web page.
    In this section, we will do this by programming. On the other hand, this can also
    be done manually by viewing the source of the web page. However, that will take
    some time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想从网页中获取所有超链接。在这一部分，我们将通过编程来实现这一点。另一方面，也可以通过查看网页源代码来手动完成。但是，那将需要一些时间。
- en: So let's get acquainted with a very beautiful parser called lxml.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来了解一个非常漂亮的解析器叫做lxml。
- en: 'Let''s see the code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: 'The following modules will be used:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用以下模块：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you enter the desired website, the `request` module obtains the data of
    the website:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您输入所需的网站时，`request`模块获取网站的数据：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following piece of code gets the table from the website data:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段从网站数据中获取表格：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following `for` loop removes the space and null string from the table data:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下`for`循环从表格数据中删除空格和空字符串：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code lines find the index of the `''IP Address''` string:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码行找到了“IP地址”字符串的索引：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next lines find the location of the website:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的行找到了网站的位置：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, I am printing just the IP address and location of the
    website. The following output shows I have used the program three times on three
    different websites: my college''s website, my website and the publisher''s website.
    In the three outputs, we are getting the IP address and location:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我只打印了网站的IP地址和位置。以下输出显示我在三个不同的网站上分别使用了三次该程序：我的学院网站、我的网站和出版商的网站。在这三个输出中，我们得到了IP地址和位置：
- en: '![](img/51ee9d73-67e8-4d9c-9bfa-a59462590424.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51ee9d73-67e8-4d9c-9bfa-a59462590424.png)'
- en: Email address gathering from a web page
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网页中收集电子邮件地址
- en: 'In this section, we will learn how to find the email addresses from a web page.
    In order to find the email addresses, we will use the regular expressions. The
    approach is very simple: first, get all the data from a given web page, then use
    email regular expression to obtain email addresses.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何从网页中找到电子邮件地址。为了找到电子邮件地址，我们将使用正则表达式。方法非常简单：首先，从给定的网页获取所有数据，然后使用电子邮件正则表达式来获取电子邮件地址。
- en: 'Let''s see the code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is very simple. The `html_page` variable contains all the
    web page data. The `r'\b[\w.-]+?@\w+?\.\w+?\b'` regular expression represents
    the email address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单。`html_page`变量包含了所有的网页数据。`r'\b[\w.-]+?@\w+?\.\w+?\b'`正则表达式表示电子邮件地址。
- en: 'Now let''s see the output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看输出：
- en: '![](img/951e4517-bfe3-40b6-8c77-d0cd5e690e4d.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/951e4517-bfe3-40b6-8c77-d0cd5e690e4d.png)'
- en: The preceding result is absolutely correct. The given URL web page was made
    by me for testing purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果是绝对正确的。给定的URL网页是我为测试目的制作的。
- en: Banner grabbing of a website
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网站的横幅抓取
- en: In this section, we will grab the HTTP banner of a website. Banner grabbing,
    or OS fingerprinting, is a method to determine the operating system that is running
    on a target web server. In the following program, we will sniff the packets of
    a website on our computer, as we did in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将抓取网站的HTTP横幅。横幅抓取，或者操作系统指纹识别，是一种确定目标Web服务器上运行的操作系统的方法。在下面的程序中，我们将嗅探我们计算机上网站的数据包，就像我们在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)中所做的那样，*嗅探和渗透测试*。
- en: 'The code for the banner grabber is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅抓取器的代码如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since you have read [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*, you should be familiar with this code. The
    `banner = pkt[0][54:533]` statement is new here. Before `pkt[0][54:]`, the packet
    contains TCP, IP, and Ethernet information. After doing some trail and error,
    I found that the banner-grabbing information resides between `[54:533]`.You can
    do trail and error by taking slices `[54:540], [54:545], [54:530]`, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经阅读了[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)，*嗅探和渗透测试*，您应该对这段代码很熟悉。`banner
    = pkt[0][54:533]`语句是新的。在`pkt[0][54:]`之前，数据包包含TCP、IP和以太网信息。经过一些试验和错误，我发现横幅抓取信息位于`[54:533]`之间。您可以通过取片段`[54:540]`、`[54:545]`、`[54:530]`等进行试验和错误。
- en: 'To get the output, you have to open the website in a web browser while the
    program is running, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得输出，您必须在程序运行时在Web浏览器中打开网站，如下面的屏幕截图所示：
- en: '![](img/31b27118-6e4f-4b18-baea-1919aed3d685.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b27118-6e4f-4b18-baea-1919aed3d685.png)'
- en: Banner grabbing
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅抓取
- en: So, the preceding output shows that the server is Microsoft-IIS.6.0, and ASP.NET
    is the programming language being used. We get the same information as we received
    in the header-checking process. Try this code and get some more information with
    different status codes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的输出显示服务器是Microsoft-IIS.6.0，使用的编程语言是ASP.NET。我们得到了与我们在检查标题过程中收到的相同的信息。尝试这段代码，并使用不同的状态代码获取更多信息。
- en: By using the previous code, you can prepare information-gathering reports for
    yourself. When I apply information-gathering methods to websites, I generally
    find lots of mistakes made by clients. In the next section, you will see the most
    common mistakes found on a web server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的代码，您可以为自己准备信息收集报告。当我将信息收集方法应用于网站时，我通常会发现客户犯了很多错误。在下一节中，您将看到在Web服务器上发现的最常见的错误。
- en: Hardening of a web server
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器的加固
- en: 'In this section, let''s shed some light on common mistakes observed on a web
    server. We will also discuss some points to harden the web server:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们揭示一些在Web服务器上观察到的常见错误。我们还将讨论一些加固Web服务器的要点：
- en: Always hide your server signature.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终隐藏您的服务器签名。
- en: If possible, set a fake server signature to mislead attackers.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，设置一个虚假的服务器签名来误导攻击者。
- en: Handle the errors.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误。
- en: If possible, use a virtual environment (jailing) to run the application.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，使用虚拟环境（监禁）来运行应用程序。
- en: Try to hide the programming language page extensions, because it will be difficult
    for the attacker to see the programming language of the web applications.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量隐藏编程语言页面扩展名，因为这样攻击者将很难看到Web应用程序的编程语言。
- en: Update the web server with the latest patch from the vendor. It avoids any chance
    of exploitation of the web server. The server can at least be secured for known
    vulnerabilities.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自供应商的最新补丁更新Web服务器。这样可以避免对Web服务器的任何利用机会。服务器至少可以针对已知的漏洞进行保护。
- en: Don't use a third-party patch to update the web server. A third-party patch
    may contain trojans or viruses.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用第三方补丁来更新Web服务器。第三方补丁可能包含木马或病毒。
- en: Do not install other applications on the web server. If you install an OS, such
    as RHEL or Windows, don't install other unnecessary software, such as Office or
    editors, because they might contain vulnerabilities.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在Web服务器上安装其他应用程序。如果您安装了操作系统，比如RHEL或Windows，请不要安装其他不必要的软件，比如Office或编辑器，因为它们可能包含漏洞。
- en: Close all ports except `80` and `443`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭除`80`和`443`之外的所有端口。
- en: Don't install any unnecessary compilers, such as gcc, on the web server. If
    an attacker compromised a web server and they wanted to upload an executable file,
    the IDS or IPS can detect that file. In this situation, the attacker will upload
    the code file (in the form of a text file) on the web server and will execute
    the file on the web server. This execution can damage the web server.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在Web服务器上安装任何不必要的编译器，比如gcc。如果攻击者入侵了Web服务器并且想要上传可执行文件，IDS或IPS可以检测到该文件。在这种情况下，攻击者将在Web服务器上上传代码文件（以文本文件的形式）并在Web服务器上执行该文件。这种执行可能会损坏Web服务器。
- en: Set a limit on the number of active users in order to prevent a DDoS attack.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置活跃用户数量的限制，以防止DDoS攻击。
- en: Enable the firewall on the web server. The firewall does many things, such as
    closing the port and filtering the traffic.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web服务器上启用防火墙。防火墙可以做很多事情，比如关闭端口和过滤流量。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the importance of a web server signature,
    and that obtaining the server signature is the first step in hacking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Web服务器签名的重要性，并且获得服务器签名是黑客攻击的第一步。
- en: '"Give me six hours to chop down a tree and I will spend the first four sharpening
    the axe."'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “给我六个小时砍倒一棵树，我将花前四个小时磨斧头。”
- en: – Abraham Lincoln
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亚伯拉罕·林肯'
- en: The same thing applies in our case. Before the start of an attack on a web server,
    it is better to check exactly which services are running on it. This is done by
    foot printing the web server. Error-handling techniques are a passive process.
    Header checking and banner grabbing are active processes to gather information
    about the web server. In this chapter, we have also learned about the BeautifulSoup
    parser. Sections such as hyperlinks, tags, and IDs can be obtained from BeautifulSoup.
    In the last section, we covered some guidelines for hardening a web server. If
    you follow those guidelines, you can make your web server difficult to attack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下也是一样的。在对Web服务器进行攻击之前，最好检查一下它到底运行了哪些服务。这是通过对Web服务器进行足迹识别来完成的。错误处理技术是一种被动的过程。头部检查和横幅抓取是主动的过程，用于收集有关Web服务器的信息。在本章中，我们还学习了关于BeautifulSoup解析器的内容。可以从BeautifulSoup中获取超链接、标签和ID等部分。在最后一节中，我们介绍了一些加固Web服务器的指南。如果您遵循这些指南，您可以使您的Web服务器难以受到攻击。
- en: In the next chapter, you will learn about client-side validation and parameter
    tampering. You will learn how to generate and detect DoS and DDOS attacks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习有关客户端验证和参数篡改的内容。您将学习如何生成和检测DoS和DDOS攻击。
