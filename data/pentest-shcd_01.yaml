- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Welcome to the first chapter of *Penetration Testing with Shellcode*. The term
    **penetration testing** refers to attacking a system without causing any damage
    to the system. The motive behind the attack is to find the system's flaws or vulnerabilities
    before attackers also find ways to get inside the system. Hence, to measure how
    the system resists exposing sensitive data, we try collecting as much data as
    possible and to perform penetration testing using shellcode, we have to first
    understand overflow attacks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*Shellcode渗透测试*的第一章。术语**渗透测试**指的是攻击系统而不对系统造成任何损害。攻击背后的动机是在攻击者找到进入系统的方法之前，找到系统的缺陷或漏洞。因此，为了衡量系统抵抗暴露敏感数据的能力，我们尽可能收集尽可能多的数据，并使用shellcode执行渗透测试，我们必须首先了解溢出攻击。
- en: Buffer overflow is one of the oldest and the most destructive vulnerabilities
    that could cause critical damage to an operating system, remotely or locally.
    Basically, it's a serious problem because certain functions don't know whether
    the input data can fit inside the preallocated space or not. So, if we add more
    data than the allocated space can hold, then this will cause overflow. With shellcode
    in the picture, we can change the execution flow of the same application. The
    main core of that damage is the payload generated by shellcode. With the spread
    of all kinds of software, even with a strong support like Microsoft, it could
    leave you vulnerable to such attacks. Shellcode is exactly what we want to be
    executed after we control the flow of execution, which we will talk about later
    in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出是最古老且最具破坏性的漏洞之一，可能对操作系统造成严重损害，无论是远程还是本地。基本上，这是一个严重的问题，因为某些函数不知道输入数据是否能够适应预分配的空间。因此，如果我们添加的数据超过了分配的空间，那么这将导致溢出。有了shellcode的帮助，我们可以改变同一应用程序的执行流程。造成损害的主要核心是shellcode生成的有效载荷。随着各种软件的传播，即使有像微软这样的强大支持，也可能使您容易受到此类攻击。Shellcode正是我们希望在控制执行流程后执行的内容，我们稍后将详细讨论。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: What is a stack?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是堆栈？
- en: What is a buffer?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是缓冲区？
- en: What is stack overflow?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是堆栈溢出？
- en: What is a heap?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是堆？
- en: What is heap corruption?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是堆破坏？
- en: What is shellcode?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是shellcode？
- en: Introduction to computer architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机体系结构介绍
- en: What is a system call?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是系统调用？
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: What is a stack?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是堆栈？
- en: A **stack** is an allocated space in the memory for each running application,
    used to hold all the variables inside it. The operating system is responsible
    for creating a memory layout for each running application, and within each memory
    layout, there is a stack. A stack is also used to save the return address so that
    the code can go back to the calling function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈**是内存中为每个运行的应用程序分配的空间，用于保存其中的所有变量。操作系统负责为每个运行的应用程序创建内存布局，在每个内存布局中都有一个堆栈。堆栈还用于保存返回地址，以便代码可以返回到调用函数。'
- en: A stack uses **Last Input First Output **(**LIFO**) to store elements in it,
    and there is a stack pointer (we will talk about it later), which points to the
    top of the stack and also uses *push* to store an element at the top of stack
    and *pop* to extract the element from the top of the stack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈使用**后进先出**（**LIFO**）来存储其中的元素，并且有一个堆栈指针（稍后我们会讨论它），它指向堆栈的顶部，并使用*push*将元素存储在堆栈顶部，使用*pop*从堆栈顶部提取元素。
- en: 'Let''s look at the following example to understand this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子来理解这一点：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how the preceding code works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是上述代码的工作原理：
- en: 'The `main` function will start first, the variable `x` will be pushed into
    the stack, and it will print out the sentence `This is the main function`, as
    shown here:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`函数将首先启动，将变量`x`推入堆栈，并打印出句子`This is the main function`，如下所示：'
- en: '![](img/00005.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: 'The `main` function will call `function1` and before moving forward to `function1`,
    the address of `printf("After calling function1\n")` will be saved into the stack
    in order to continue the execution flow. After finishing `function1` by pushing
    variable `y` in the stack, it will execute `printf("This is function1\n")`, as
    shown here:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`函数将调用`function1`，在继续执行`function1`之前，将`printf("After calling function1\n")`的地址保存到堆栈中，以便继续执行流程。通过将变量`y`推入堆栈来完成`function1`后，它将执行`printf("This
    is function1\n")`，如下所示：'
- en: '![](img/00006.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: 'Then, go back to the `main` function again to execute `printf("After calling
    function1\n")`, and push the address of `printf("After calling function2")` in
    the stack, as shown:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，再次返回到`main`函数执行`printf("After calling function1\n")`，并将`printf("After calling
    function2")`的地址推入堆栈，如下所示：
- en: '![](img/00007.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: 'Now control will move forward to execute `function2` by pushing the variable
    `z` into the stack and then execute `printf("This is function2\n")`, as shown
    in the following diagram:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在控制将继续执行`function2`，通过将变量`z`推入堆栈，然后执行`printf("This is function2\n")`，如下图所示：
- en: '![](img/00008.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: Then, go back to the `main` function to execute `printf("After calling function2")` and
    exit.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，返回到`main`函数执行`printf("After calling function2")`并退出。
- en: What is a buffer?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是缓冲区？
- en: A **buffer** is a temporary section of the memory used to hold data, such as
    variables. A buffer is only accessible or readable inside its function until it
    is declared global; when a function ends, the buffer ends with it; and all programs
    have to deal with the buffer when there is data storing or retrieving.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲区**是用于保存数据（如变量）的临时内存部分。缓冲区只能在其函数内部访问或读取，直到它被声明为全局；当函数结束时，缓冲区也随之结束；当存在数据存储或检索时，所有程序都必须处理缓冲区。'
- en: 'Let''s look at the following line of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的代码行：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What does this section of C code mean? It tells the computer to allocate a
    temporary space (buffer) with the size of `char`, which can hold up to 1 byte.
    You can use the `sizeof` function to confirm the size of any data type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段C代码的含义是什么？它告诉计算机分配一个临时空间（缓冲区），大小为`char`，可以容纳1个字节。您可以使用`sizeof`函数来确认任何数据类型的大小：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course, you can use the same code to get the size of other data types such
    as the `int` data type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以使用相同的代码来获取其他数据类型的大小，比如`int`数据类型。
- en: What is stack overflow?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是堆栈溢出？
- en: '**Stack overflow** occurs when you put more data into a buffer than it can
    hold, which causes the buffer to be filled up and overwrite neighboring places
    in memory with what''s left over of the input. This occurs when the function,
    which is responsible for copying data, doesn''t check if the input can fit inside
    the buffer or not, such as `strcpy`. We can use stack overflow to change the execution
    flow of a code to another code using shellcode.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈溢出**发生在将更多数据放入缓冲区中而它无法容纳时，这导致缓冲区被填满并覆盖内存中的相邻位置，剩下的输入。当负责复制数据的函数不检查输入是否能够适合缓冲区时，就会发生这种情况，比如`strcpy`。我们可以使用堆栈溢出来改变代码的执行流到另一个代码，使用shellcode。'
- en: 'Here is an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code works as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作方式如下：
- en: In the `copytobuffer` function, it allocates a buffer with the size of `15`
    characters, but this buffer can only hold 14 characters and a null-terminated
    string `\0`, which indicates the end of the array
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`copytobuffer`函数中，它分配了一个大小为`15`个字符的缓冲区，但这个缓冲区只能容纳14个字符和一个空终止字符串`\0`，表示数组的结尾
- en: You don't have to end arrays with a null-terminated string; the compiler will
    do it for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必以空终止字符串结束数组；编译器会为您完成。
- en: Then, there is `strcpy`, which takes input from the user and copies it into
    the allocated buffer
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是`strcpy`，它从用户那里获取输入并将其复制到分配的缓冲区中
- en: In the `main` function, it calls `copytobuffer` and passes the `argv` argument
    to `copytobuffer`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main`函数中，它调用`copytobuffer`并将`argv`参数传递给`copytobuffer`
- en: What really happens when the `main` function calls the `copytobuffer` function?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当`main`函数调用`copytobuffer`函数时，实际发生了什么？
- en: 'Here are the answers to this question:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个问题的答案：
- en: The **return address** of the `main` function will be pushed in memory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`函数的**返回地址**将被推送到内存中'
- en: The **old base pointer** (explained in the next section) will be saved in memory
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旧基址指针**（在下一节中解释）将保存在内存中'
- en: 'A section of memory will be allocated as the buffer with a size of 15 bytes
    or *15*8 *bits:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分配一个大小为15字节或*15*8*位的缓冲区的内存部分：
- en: '![](img/00009.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: Now, we agreed that this buffer will take only 14 characters but the real problem
    is inside the `strcpy` function, because it doesn't check for the size of the
    input, it just copies the input into the allocated buffer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们同意这个缓冲区只能容纳14个字符，但真正的问题在于`strcpy`函数内部，因为它没有检查输入的大小，它只是将输入复制到分配的缓冲区中。
- en: 'Let''s try now to compile and run this code with 14 characters:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用14个字符编译和运行此代码：
- en: '![](img/00010.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: 'Let''s take a look at the stack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆栈：
- en: '![](img/00011.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: 'As you can see, the program exited without error. Now, let''s try it again
    but with 15 characters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序在没有错误的情况下退出。现在，让我们再试一次，但使用15个字符：
- en: '![](img/00012.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: 'And now let''s take another look at the stack:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再看看堆栈：
- en: '![](img/00013.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: This is a stack overflow, and a segmentation fault is an indication that there
    is a violation in memory; what happened is the user's input overflowed the allocated
    buffer, thus filling the old base pointer and **return address**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是堆栈溢出，分段错误是内存违规的指示；发生的情况是用户的输入溢出了分配的缓冲区，从而填充了旧的基址指针和**返回地址**。
- en: A **segmentation fault** means a violation in the user space memory, and **kernel
    panic** means a violation in kernel-space.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**分段错误**意味着用户空间内存中的违规，**内核恐慌**意味着内核空间中的违规。'
- en: What is a heap?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是堆？
- en: 'A **heap** is a portion of memory that is dynamically allocated by the application
    at runtime. A heap can be allocated using the `malloc` or `calloc` function in
    C. A heap is different from a stack as a heap remains until:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是应用程序在运行时动态分配的一部分内存。堆可以使用C语言中的`malloc`或`calloc`函数进行分配。堆与堆栈不同，因为堆会一直保留，直到：'
- en: The program exits
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序退出
- en: It will be deleted using the `free` function
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使用`free`函数删除
- en: A heap is different from a stack because in a heap, a very large space can be
    allocated, and there is no limit on the allocated spaces such as in a stack, where
    there is a limited space depending on the operating system. You can also resize
    a heap using the `realloc` function, but you can't resize the buffer. When using
    the heap, you must deallocate the heap after finishing by using the `free` function,
    but not in the stack; also, the stack is faster than the heap.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 堆与堆栈不同，因为在堆中可以分配非常大的空间，并且在分配的空间上没有限制，例如在堆栈中，根据操作系统的不同，分配的空间是有限的。您还可以使用`realloc`函数调整堆的大小，但无法调整缓冲区的大小。在使用堆时，您必须在完成后使用`free`函数释放堆，但在堆栈中不需要；此外，堆栈比堆更快。
- en: 'Let''s look at the following line of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码行：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What does this section of C code mean?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段C代码的含义是什么？
- en: It tells the computer to allocate a section in heap memory with a size of `15`
    bytes and it should also hold 14 characters plus a null-terminated string `\0`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉计算机在堆内存中分配一个大小为`15`字节的部分，并且还应该容纳14个字符加上一个空终止字符串`\0`。
- en: What is heap corruption?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是堆损坏？
- en: 'Heap corruption occurs when data copied or pushed into a heap is larger than
    the allocated space. Let''s look at a full heap example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 堆损坏发生在复制或推送到堆中的数据大于分配的空间时。让我们看一个完整的堆示例：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first line of code, it allocates a heap with a size of `15` bytes using
    the `malloc` function; in the second line of code, it copies the user's input
    into the heap using the `strcpy` function; in the third line of code, it sets
    the heap free using the `free` function, back to the system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行代码中，使用`malloc`函数分配了一个大小为`15`字节的堆；在第二行代码中，使用`strcpy`函数将用户输入复制到堆中；在第三行代码中，使用`free`函数释放了堆，返回给系统。
- en: 'Let''s compile and run it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它：
- en: '![](img/00014.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 'Now, let''s try to crash it using a larger input:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用更大的输入来使其崩溃：
- en: '![](img/00015.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: This crash is a heap corruption, which forced the program to terminate.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个崩溃是堆破坏，迫使程序终止。
- en: Memory layout
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存布局
- en: 'This is the complete memory layout for a program that contains:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含以下内容的程序的完整内存布局：
- en: The `.text` section which is used to hold the **program code**
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`部分用于保存**程序代码**'
- en: The `.data` section which is used to hold **initialized data**
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`部分用于保存**初始化的数据**'
- en: The `.BSS` section which is used to hold **uninitialized data**
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.BSS`部分用于保存**未初始化的数据**'
- en: The **heap** section which is used to hold ****dynamically allocated variables****
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**部分用于保存**动态分配的变量**'
- en: 'The **stack** section which is used to hold non-dynamically allocated variables
    such as buffers:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**部分用于保存非动态分配的变量，如缓冲区：'
- en: '![](img/00016.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Look at how the **heap** and **stack** are growing; the **stack** grows from
    **high memory** to **low memory**, whereas the **heap** grows from **low memory**
    to **high memory**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**堆**和**栈**是如何增长的；**栈**从**高内存**增长到**低内存**，而**堆**从**低内存**增长到**高内存**。
- en: What is shellcode?
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是shellcode？
- en: Shellcode is like a payload that is used in overflow exploitation written in
    machine language. Hence, the shellcode is used to override the flow of execution
    after exploiting a vulnerable process, such as making the victim's machine connect
    back to you to spawn a shell.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode就像是用机器语言编写的溢出利用中使用的有效载荷。因此，shellcode用于在利用易受攻击的进程后覆盖执行流程，比如让受害者的机器连接回您以生成一个shell。
- en: 'The next example is a shellcode for Linux x86 SSH Remote port forwarding which
    executes the `ssh -R 9999:localhost:22 192.168.0.226` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是用于Linux x86 SSH远程端口转发的shellcode，执行`ssh -R 9999:localhost:22 192.168.0.226`命令：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this is the assembly language of that shellcode:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该shellcode的汇编语言：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Computer architecture
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机架构
- en: 'Let''s walk through some concepts in computer architecture (Intel x64). The
    major components of a computer are shown in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解一些计算机架构（Intel x64）中的概念。计算机的主要组件如下图所示：
- en: '![](img/00017.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'Let''s dive a little more inside the CPU. There are three parts to the CPU:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解CPU。CPU有三个部分：
- en: '**Arithmetic logic unit** (**ALU**): This part is responsible for performing
    arithmetic operations, such as addition and subtraction and logic operations,
    such as ADD and XOR'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术逻辑单元**（**ALU**）：这部分负责执行算术运算，如加法和减法，以及逻辑运算，如ADD和XOR'
- en: '**Registers**: This is what we really care about in this book, they are a superfast
    memory for the CPU that we will discuss in the next section'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器**：这是我们在本书中真正关心的内容，它们是CPU的超快速内存，我们将在下一节中讨论'
- en: '**Control unit** (**CU**): This part is responsible for communications between
    the ALU and the registers, and between the CPU itself and other devices'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制单元**（**CU**）：这部分负责ALU和寄存器之间的通信，以及CPU本身和其他设备之间的通信'
- en: Registers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器
- en: As we said earlier, registers are like a superfast memory for the CPU to store
    or retrieve data in processing, and they are divided into the following sections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，寄存器就像是CPU的超快速内存，用于存储或检索处理中的数据，并分为以下几个部分。
- en: General purpose registers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用寄存器
- en: 'There are 16 general purpose registers in the Intel x64 processor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Intel x64处理器中有16个通用寄存器：
- en: 'The accumulator register (**RAX**) is used in arithmetic operations—**RAX**
    holds **64** bits, **EAX** holds **32** bits, **AX** holds **16** bits, **AH**
    holds **8** bits, and **AL** holds **8** bits:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器寄存器（**RAX**）用于算术运算—**RAX**持有**64**位，**EAX**持有**32**位，**AX**持有**16**位，**AH**持有**8**位，**AL**持有**8**位：
- en: '![](img/00018.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: 'The base register (**RBX**) is used as a pointer to data—**RBX** holds **64**
    bits, **EBX** holds **32** bits, **BX** holds **16** bits, **BH** holds **8**
    bits, and **BL** holds **8** bits:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址寄存器（**RBX**）用作数据指针—**RBX**持有**64**位，**EBX**持有**32**位，**BX**持有**16**位，**BH**持有**8**位，**BL**持有**8**位：
- en: '![](img/00019.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: 'The counter register (**RCX**) is used in loops and shift operations—**RCX**
    holds **64** bits, **ECX** holds **32** bits, **CX** holds **16** bits, **CH**
    holds **8** bits, and **CL** holds **8** bits:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器寄存器（**RCX**）用于循环和移位操作—**RCX**持有**64**位，**ECX**持有**32**位，**CX**持有**16**位，**CH**持有**8**位，**CL**持有**8**位：
- en: '![](img/00020.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: 'The data register (**RDX**) is used as a data holder and in arithmetic operations—**RDX**
    holds **64** bits, **EDX** holds **32** bits, **DX** holds **16** bits, **DH**
    holds **8** bits, and **DL** holds **8** bits:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据寄存器（**RDX**）用作数据持有者和算术运算—**RDX**持有**64**位，**EDX**持有**32**位，**DX**持有**16**位，**DH**持有**8**位，**DL**持有**8**位：
- en: '![](img/00021.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: 'The source index register (**RSI**) is used as a pointer to a source—**RSI**
    holds **64** bits, **ESI** holds **32** bits, **DI** holds **16** bits, and **SIL**
    holds **8** bits:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源索引寄存器（**RSI**）用作源指针—**RSI**持有**64**位，**ESI**持有**32**位，**DI**持有**16**位，**SIL**持有**8**位：
- en: '![](img/00022.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'The destination index register (**RDI**) is used as a pointer to a destination—**RDI**
    holds **64** bits, **EDI** holds **32** bits, **DI** holds **16** bits, and **DIL**
    hold **8** bits:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的索引寄存器（**RDI**）用作目的指针—**RDI**持有**64**位，**EDI**持有**32**位，**DI**持有**16**位，**DIL**持有**8**位：
- en: '![](img/00023.jpeg)**RSI** and **RDI** are both used in stream operations and
    string manipulation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00023.jpeg)**RSI**和**RDI**都用于流操作和字符串操作。'
- en: 'The stack pointer register (**R****SP**) is used as a pointer to the top of
    the stack—**RSP** holds **64** bits, **ESP** holds **32** bits, **SP** holds **16**
    bits, and **SPL** holds **8** bits:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈指针寄存器（**R****SP**）用作指向栈顶的指针—**RSP**持有**64**位，**ESP**持有**32**位，**SP**持有**16**位，**SPL**持有**8**位：
- en: '![](img/00024.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: 'The base pointer register (**RBP**) is used as a pointer to the base of the
    stack—**RBP** holds **64** bits, **EBP** holds **32** bits, **BP** holds **16**
    bits, and **BPL** holds **8** bits:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基指针寄存器（**RBP**）用作栈的基址指针—**RBP**持有**64**位，**EBP**持有**32**位，**BP**持有**16**位，**BPL**持有**8**位：
- en: '![](img/00025.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: 'The registers R8, R9, R10, R11, R12, R13, R14, and R15 have no specific operations,
    but they do not have the same architecture as the previous registers, such as
    **high** (**H**) value or **low** (**L**) value. However, they can be used as
    **D** for **double-word**, **W** for **word**, or **B** for **byte**. Let''s look
    at **R8** for example:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器R8、R9、R10、R11、R12、R13、R14和R15没有特定的操作，但它们的架构与先前的寄存器不同，比如**高**（**H**）值或**低**（**L**）值。但是，它们可以用作**D**表示**双字**，**W**表示**字**，或**B**表示**字节**。让我们以**R8**为例：
- en: '![](img/00026.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Here, **R8** holds **64** bits, **R8D** holds **32** bits, **R8W** holds **16**
    bits, and **R8B** holds **8** bits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，R8保存64位，R8D保存32位，R8W保存16位，R8B保存8位。
- en: R8 through R15 only exist in Intel x64 but not in x84.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: R8到R15只存在于Intel x64而不是x84。
- en: Instruction pointer
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令指针
- en: The instruction pointer register or RIP is used to hold the next instruction.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针寄存器或RIP用于保存下一条指令。
- en: 'Let''s look at the following example first:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看以下示例：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing that will be executed is the `main` function, then it will
    call the `printsomething` function. But before it calls the `printsomething` function,
    the program needs to know exactly what the next operation is after executing the
    `printsomething` function. So before calling `printsomething`, the next instruction
    that is `printf("This is after print something function\n")` will have its location
    pushed into the **RIP** and so on:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行的第一件事是`main`函数，然后它将调用`printsomething`函数。但在调用`printsomething`函数之前，程序需要确切地知道在执行`printsomething`函数后的下一个操作是什么。因此，在调用`printsomething`之前，下一条指令`printf("This
    is after print something function\n")`的位置将被推送到RIP等等：
- en: '![](img/00027.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: Here, **RIP** holds **64** bits, **EIP** holds **32** bit, and **IP** holds
    **16** bits.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，RIP保存64位，EIP保存32位，IP保存16位。
- en: 'The following table sums up all the general-purpose registers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了所有通用寄存器：
- en: '| **64-bit register** | **32-bit register** | **16-bit register** | **8-bit
    register** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **64位寄存器** | **32位寄存器** | **16位寄存器** | **8位寄存器** |'
- en: '| RAX | EAX | AX | AH,AL |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| RAX | EAX | AX | AH,AL |'
- en: '| RBX | EBX | BX | BH, BL |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| RBX | EBX | BX | BH, BL |'
- en: '| RCX | ECX | CX | CH, CL |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| RCX | ECX | CX | CH, CL |'
- en: '| RDX | EDX | DX | DH,DL |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| RDX | EDX | DX | DH,DL |'
- en: '| RSI | ESI | SI | SIL |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| RSI | ESI | SI | SIL |'
- en: '| RDI | EDI | DI | DIL |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| RDI | EDI | DI | DIL |'
- en: '| RSP | ESP | SP | SPL |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| RSP | ESP | SP | SPL |'
- en: '| RBP | EBP | BP | BPL |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| RBP | EBP | BP | BPL |'
- en: '| R8 | R8D | R8W | R8B |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| R8 | R8D | R8W | R8B |'
- en: '| R9 | R9D | R9W | R9B |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| R9 | R9D | R9W | R9B |'
- en: '| R10 | R10D | R10W | R10B |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| R10 | R10D | R10W | R10B |'
- en: '| R11 | R11D | R11W | R11B |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| R11 | R11D | R11W | R11B |'
- en: '| R12 | R12D | R12W | R12B |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| R12 | R12D | R12W | R12B |'
- en: '| R13 | R13D | R13W | R13B |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| R13 | R13D | R13W | R13B |'
- en: '| R14 | R14D | R14W | R14B |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| R14 | R14D | R14W | R14B |'
- en: '| R15 | R15D | R15W | R15B |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| R15 | R15D | R15W | R15B |'
- en: Flags registers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志寄存器
- en: 'These are registers that the computer uses to control the execution flow. For
    example, the JMP operation in assembly will be executed based on the value of
    flag registers such as the **jump if zero** (**JZ**) operation, meaning that the
    execution flow will be changed to another flow if the zero flag contains 1\. We
    are going to talk about the most common flags:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是计算机用来控制执行流程的寄存器。例如，汇编中的JMP操作将根据标志寄存器的值执行，比如“跳转如果为零”（JZ）操作，这意味着如果零标志包含1，执行流程将被改变到另一个流程。我们将讨论最常见的标志：
- en: '![](img/00028.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: The **c****arry flag** (**CF**) is set in arithmetic operations if there is
    a carry in addition or borrow in subtraction
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在算术运算中有加法进位或减法借位，则设置进位标志（CF）。
- en: The **parity flag** (**PF**) is set if the number of set bits is even
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置位的数量为偶数，则设置奇偶标志（PF）。
- en: The **adjust flag** (**AF**) is set in arithmetic operations if there is a carry
    of binary code decimal
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在算术运算中有二进制代码十进位的进位，则设置调整标志（AF）。
- en: The **zero flag** (**ZF**) is set if the result is zero
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果为零，则设置零标志（ZF）。
- en: The **sign flag** (**SF**) is set if the most significant bit is one (the number
    is negative)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最高有效位为1（数字为负数），则设置符号标志（SF）。
- en: The **overflow flag** (**OF**) is set in arithmetic operations if the result
    of the operation is too large to fit in a register
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在算术运算中，如果操作的结果太大而无法容纳在寄存器中，将设置溢出标志（OF）。
- en: Segment registers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 段寄存器
- en: 'There are six segment registers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 共有六个段寄存器：
- en: '![](img/00029.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: The **c****ode segment** (**CS**) points to the starting address of the **code
    segment** in the **stack**
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码段（CS）指向堆栈中代码段的起始地址
- en: The **stack segment** (**SS**) points to the starting address of the **stack**
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈段（SS）指向堆栈的起始地址
- en: The **data segment** (**DS**) points to the starting address of the **data segment**
    in the **stack**
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据段（DS）指向堆栈中数据段的起始地址
- en: The **extra segment** (**ES**) points to **extra data**
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外段（ES）指向额外数据
- en: The **F segment** (**FS**) points to **extra data**
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F段（FS）指向额外数据
- en: The **G segment** (**GS**) points to **extra data**
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G段（GS）指向额外数据
- en: The F in FS means F after E in ES; and, the G in GS means G after F.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: FS中的F表示E后的F；而GS中的G表示F后的G。
- en: Endianness
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端序
- en: 'Endianness describes the sequence of allocating bytes in memory or registers,
    and there are the following two types:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端序描述了在内存或寄存器中分配字节的顺序，有以下两种类型：
- en: '**Big-endian** means allocating bytes from left to right. Let''s see how a
    word like *shell* (which in hex **73** **68** **65** **6c** **6c**) will be allocated
    in memory:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “大端”意味着从左到右分配字节。让我们看看像*shell*这样的单词（十六进制为**73** **68** **65** **6c** **6c**）将如何在内存中分配：
- en: '![](img/00030.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: It pushed as you can read it from left to right.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它按从左到右的顺序推送。
- en: '**Little-endian** means allocating bytes from right to left. Let''s look at
    the previous example with little-endian:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “小端”意味着从右到左分配字节。让我们看看以小端方式处理前面的例子：
- en: '![](img/00031.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: As you can see, it pushed backward *llehs*, and the most important thing is
    Intel processors are little-endian.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它向后推了*llehs*，而最重要的是英特尔处理器是小端序的。
- en: System calls
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用
- en: 'There are two spaces under Linux in memory (RAM): **user space** and **kernel
    space**. Kernel space is responsible for running kernel codes and system processes
    with full access to memory, whereas user space is responsible for running user
    processes and applications with restricted access to memory, and this separation
    is to protect the kernel space.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内存（RAM）中有两个空间：用户空间和内核空间。内核空间负责运行内核代码和系统进程，并具有对内存的完全访问权限，而用户空间负责运行用户进程和应用程序，并具有对内存的受限访问权限，这种分离是为了保护内核空间。
- en: When a user wants to execute a code (in user space), then user space sends requests
    to the kernel space using **system calls**, also known as **syscalls** through
    libraries such as glibc, and then kernel space executes it on behalf of the user
    space using the **fork-exec** technique.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要执行一个代码（在用户空间），用户空间通过系统调用发送请求给内核空间，也被称为syscalls，通过诸如glibc的库，然后内核空间使用fork-exec技术代表用户空间执行它。
- en: What are syscalls?
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是系统调用？
- en: 'Syscalls are like requests that the user space uses to ask the kernel to execute
    on behalf of the user space. For example, if a code wants to open a file then
    **user space** sends the open syscall to the **kernel** to open the file on behalf
    of the **user space**, or when a C code contains the `printf` function, then the
    **user space** sends the write system call to the **kernel**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用就像用户空间用来请求内核代表用户空间执行的请求。例如，如果一个代码想要打开一个文件，那么用户空间会发送打开系统调用给内核，代表用户空间打开文件，或者当一个C代码包含`printf`函数时，用户空间会发送写系统调用给内核：
- en: '![](img/00032.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: The fork-exec technique is how Linux runs processes or applications by forking
    (copy) parent's resources located in memory using fork syscall, then running the
    executable code using exec syscall.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: fork-exec技术是Linux通过fork系统调用复制父进程在内存中的资源，然后使用exec系统调用运行可执行代码的方式来运行进程或应用程序。
- en: Syscalls are like kernel API or how you are going to talk to the kernel itself
    to tell it to do something for you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用就像内核API，或者说你要如何与内核本身交流，告诉它为你做一些事情。
- en: User space is an isolated environment or a sandbox to protect the kernel space
    and its resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间是一个隔离的环境或沙盒，用来保护内核空间及其资源。
- en: 'So how can we get the full list of x64 kernel syscalls ? Actually it''s easy,
    all syscalls are located inside this file: `/usr/include/x86_64-linux-gnu/asm/unistd_64.h`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何获取x64内核系统调用的完整列表呢？实际上很容易，所有系统调用都位于这个文件中：`/usr/include/x86_64-linux-gnu/asm/unistd_64.h`：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/00033.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: This is just a small portion of my kernel syscalls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我的内核系统调用的一小部分。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about some definitions in computer science, such
    as stack, buffer, and heap, and also gave a quick hint about buffer overflow and
    heap corruption. Then, we moved on to some definitions in computer architecture
    such as register, which is very important in debugging and understanding how execution
    is done inside the processor. Finally, we talked briefly about syscalls, which
    is also important in assembly language on Linux (we will see that in the next
    part), and how the kernel executes codes on Linux. At this point, we are ready
    to move on to another level, which is building an environment to test overflow
    attacks, and also creating and injecting shellcodes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了计算机科学中的一些定义，如堆栈、缓冲区和堆，还简要提到了缓冲区溢出和堆破坏。然后，我们转向了计算机体系结构中的一些定义，比如寄存器，在调试和理解处理器内部执行方式方面非常重要。最后，我们简要讨论了系统调用，在Linux汇编语言中也很重要（我们将在下一部分中看到），以及内核如何在Linux上执行代码。在这一点上，我们已经准备好进入另一个层次，即构建一个环境来测试溢出攻击，并创建和注入shellcode。
