- en: Chapter 9. Automating Reports and Tasks with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用Python自动化报告和任务
- en: 'We covered in previous chapters a good amount of information that highlights
    where Python can help optimize technical fieldwork. We even showed methods in
    which Python can be used to automate follow-on tasks from one process to another.
    Each of these will help you better spend your time on priority tasks. This is
    important because there are three things that potentially limit the successful
    completion of a penetration test: the time an assessor has to complete the assessment,
    the limits of the scope of the penetration test, and the skill of the assessor.
    In this chapter, we are going to show you how to automate tasks such as parsing
    **eXtensible Markup Language** (**XML**) to generate reports from tool data.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们涵盖了大量信息，突出了Python在优化技术领域工作中的作用。我们甚至展示了Python可以用于自动化从一个过程到另一个过程的后续任务的方法。这些方法将帮助您更好地花费时间在优先任务上。这很重要，因为有三件事可能限制渗透测试的成功完成：评估员完成评估的时间，渗透测试范围的限制，以及评估员的技能。在本章中，我们将向您展示如何自动化诸如解析**可扩展标记语言**（**XML**）以从工具数据生成报告的任务。
- en: Understanding how to parse XML files for reports
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解如何解析XML文件以生成报告
- en: We are going to use `nmap` XMLs as an example to show how you can parse data
    into a useable format. Our end goal will be to place the data in a Python dictionary
    of unique results. We can then use that data to build structured outputs that
    we find useful. To begin, we need an XML file that can be parsed and reviewed.
    Run an `nmap` scan of your localhost with the `nmap -oX test 127.0.0.1` command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`nmap` XML为例，展示如何将数据解析为可用格式。我们的最终目标是将数据放入一个Python字典中，以便使用该数据构建我们发现有用的结构化输出。首先，我们需要一个可以解析和审查的XML文件。使用`nmap
    -oX test 127.0.0.1`命令对本地主机运行`nmap`扫描。
- en: 'This will produce a file that highlights the two open ports using XML markup
    language, as shown here:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个文件，其中使用XML标记语言突出显示了两个开放端口，如下所示：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_01.jpg)'
- en: With an actual XML file, we can review the components of the data structure.
    Understanding how an XML file is designed will better prepare you to generate
    the code that will read it. Specifically, the descriptions here are based on what
    the `etree` library classifies the components of an XML file as. The `etree` library
    handles the XML data conceptually like a tree, with relevant branches, subbranches,
    and even twigs. In computer science terms, we call this a parent-child relationship.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有了实际的XML文件，我们可以审查数据结构的组成部分。了解XML文件的设计方式将更好地为您准备生成读取它的代码。具体来说，这里的描述是基于`etree`库对XML文件组件的分类。`etree`库在概念上处理XML数据，就像一棵树，具有相关的分支、子分支，甚至小枝。在计算机科学术语中，我们称之为父子关系。
- en: 'Using the `etree` library, you are going to load the data into variables. These
    variables will hold composite pieces of data within themselves. These are referred
    to as **elements**, which can be further dissected to find useful information.
    For example, if you load the root of an XML nmap structure into a variable and
    then print it, you will see the reference and a tag that describes the element
    and the data within it, as seen in the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`etree`库，您将把数据加载到变量中。这些变量将保存数据的复合部分。这些被称为**元素**，可以进一步解剖以找到有用的信息。例如，如果将XML
    nmap结构的根加载到一个变量中，然后打印它，您将看到引用和描述元素及其中数据的标记，如下面的屏幕截图所示：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_02.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_02.jpg)'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Additional details related to the `etree` library can be found at [https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`etree`库的其他详细信息可以在[https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html)找到。
- en: 'Each element can have a parent-child relationship with other nodes and even
    sub-children nodes, known as grandchildren. Each node holds the information that
    we are trying to parse. A node typically has a tag, which is the description of
    the data it holds, and an attribute, which is the actual data. To better highlight
    how this information is presented in XML, we have captured an element of the nmap
    XML, the hostname''s node, and a single resulting child, as seen here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都可以与其他节点以及子节点（称为孙节点）存在父子关系。每个节点都保存了我们试图解析的信息。节点通常有一个标记，这是它所持有数据的描述，还有一个属性，这是实际的数据。为了更好地突出这些信息在XML中的呈现方式，我们捕获了nmap
    XML的一个元素，主机名节点和一个单一的结果子节点，如下所示：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_03.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_03.jpg)'
- en: As you look at an XML file, you may notice that you can have multiple nodes
    within an element. For example, a host may have a number of different hostnames
    for the same **Internet Protocol** (**IP**) address due to multiple references.
    As such, to iterate over all the nodes of an element, you need to use a for loop
    to capture all the possible data components. The parsing of this data is for producing
    an output, which is only as good as the data samples you have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看XML文件时，您可能会注意到一个元素中可以有多个节点。例如，由于多个引用，一个主机可能对应同一**Internet Protocol**（**IP**）地址的多个不同主机名。因此，为了迭代元素的所有节点，您需要使用for循环来捕获所有可能的数据组件。对这些数据的解析是为了生成输出，这取决于您拥有的数据样本的质量。
- en: This means that you should take multiple sample XML files to get a better cross-section
    of information. The point is to get the majority of the possible data combinations.
    Even with samples that should cover the majority of issues that you will run into,
    there will be examples that are not accounted for. So, do not get discouraged
    if your script breaks in the middle of its use. Trace the errors and determine
    what needs to be adjusted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你应该获取多个样本XML文件，以获得更好的信息横截面。重点是获得可能的数据组合的大部分。即使使用了应该涵盖你遇到的大部分问题的样本，也会有一些未考虑的例子。因此，如果你的脚本在使用过程中中断，不要灰心。追踪错误并确定需要调整什么。
- en: For our tests, we are going to use multiple `nmap` scans and our Kali instance
    and output the details to XML file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试，我们将使用多个`nmap`扫描和我们的Kali实例，并将详细信息输出到XML文件中。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Python has a fantastic library, called `libnmap`, that can be used to run and
    schedule scans and even help parse output files to generate reports. More details
    on this can be found at [https://libnmap.readthedocs.org/en/latest/](https://libnmap.readthedocs.org/en/latest/).
    We could use this library to parse the output and generate a report, but this
    library works only for `nmap`. If you want to parse other XML outputs from other
    tools to add details to a more manageable format, this library will not help you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个名为`libnmap`的奇妙库，可以用来运行和安排扫描，甚至帮助解析输出文件以生成报告。更多详情可以在[https://libnmap.readthedocs.org/en/latest/](https://libnmap.readthedocs.org/en/latest/)找到。我们可以使用这个库来解析输出并生成报告，但这个库只适用于`nmap`。如果你想解析其他工具的XML输出以将细节添加到更可管理的格式中，这个库将无法帮助你。
- en: When we are getting ready to write a parser, the first stage is to map the file
    that we are going to parse. So, we take notes of the likely ways in which we need
    to have our script interact with the output. After mapping the file, we place
    several `print` statements throughout the file to show what elements our script
    has stopped or broken its processing at. To better understand each element, you
    should load the example XMLs into a tool that allows proper XML viewing. Notepad++
    works very well, provided you have the XML tools plugin installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备编写解析器时，第一阶段是映射我们要解析的文件。因此，我们需要注意我们的脚本与输出交互的可能方式。在映射文件之后，我们在整个文件中放置了几个`print`语句，以显示我们的脚本在哪些元素停止或中断处理。为了更好地理解每个元素，你应该将示例XML加载到一个允许正确查看XML的工具中。Notepad++非常适用，只要安装了XML工具插件。
- en: 'Once you have loaded the file into Notepad++, you should collapse the XML tree
    down to its root. The following screenshot shows that the root of this tree is
    `nmaprun`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你把文件加载到Notepad++中，你应该将XML树折叠到其根部。以下截图显示了这棵树的根是`nmaprun`：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_04.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_04.jpg)'
- en: After you expand it once, you get a number of subnodes, which can be further
    expanded and broken down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 展开一次后，你会得到许多子节点，可以进一步展开和分解。
- en: '![Understanding how to parse XML files for reports](img/B04315_09_05.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_05.jpg)'
- en: From these details, we see that we have to load the XML file into the handler
    and then walk through the host element. We should, however, consider the fact
    that this is a single host, so there will only be one host element. As such, we
    should iterate through the host element with a `for` loop to capture other hosts
    that would be scanned in future iterations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些细节中，我们看到我们需要将XML文件加载到处理程序中，然后遍历主机元素。然而，我们应该考虑到这是一个单一的主机，所以只会有一个主机元素。因此，我们应该通过`for`循环迭代主机元素，以捕获将来迭代中可能被扫描的其他主机。
- en: When the host element is expanded, we can find that there are nodes for the
    address, hostnames, ports, and the time. The nodes we are interested in would
    be the address, hostnames, and ports. Both the hostnames and ports nodes are expandable,
    which means that they probably need to be iterated as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机元素被展开时，我们可以发现有地址、主机名、端口和时间的节点。我们感兴趣的节点将是地址、主机名和端口。主机名和端口节点都是可展开的，这意味着它们可能也需要被迭代。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can iterate through any node with a for loop even if there is only one entry.
    This ensures you will capture all the information in child nodes and prevent the
    breaking of the parser.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一个条目，你也可以用for循环迭代任何节点。这样可以确保你捕获所有子节点中的信息，并防止解析器中断。
- en: 'This screenshot highlights the details of the expanded XML tree, with the details
    that we care about:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图突出显示了展开的XML树的细节，这些细节是我们关心的：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_06.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以生成报告](img/B04315_09_06.jpg)'
- en: For the address, we can see there are different address types, as highlighted
    by the `addrtype` tag. In nmap XML outputs, you will find the `ipv4`, `ipv6`,
    and `mac` addresses. If you want different address types in your output, you can
    get them by pulling the data with simple `if-then` statements and then loading
    it into the appropriate variables. If you just want an address to be loaded into
    a variable regardless of the type, you will have to create an order of precedence.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地址，我们可以看到有不同的地址类型，如`addrtype`标签所示。在nmap XML输出中，你会发现`ipv4`、`ipv6`和`mac`地址。如果你想在输出中获得不同的地址类型，你可以通过简单的`if-then`语句来获取它们，然后将其加载到适当的变量中。如果你只想要一个地址被加载到一个变量中，而不管类型是什么，你将不得不创建一个优先顺序。
- en: 'The `nmap` tool may or may not find a hostname for each target scanned. This
    depends on how the scanner attempted to retrieve the information. For example,
    if **Domain Name Service** (**DNS**) requests were enabled or the scan was against
    the localhost, a hostname may have been identified. Other instances of scans may
    not identify an actual hostname. We have to build our script to take into consideration
    the different outputs that may be provided depending on the scan. Our localhost
    scan, as seen in the following screenshot, did provide a hostname, so we have
    information that we can extract in this example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap`工具可能会找到每个扫描目标的主机名，也可能找不到。这取决于扫描器尝试检索信息的方式。例如，如果启用了**域名服务**（**DNS**）请求，或者扫描针对本地主机进行，可能已经识别出主机名。其他情况下的扫描可能无法识别实际的主机名。我们必须编写脚本，考虑到可能根据扫描提供的不同输出来提取信息。如下面的截图所示，我们的本地主机扫描确实提供了主机名，因此我们可以在这个例子中提取信息：'
- en: '![Understanding how to parse XML files for reports](img/B04315_09_07.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以进行报告](img/B04315_09_07.jpg)'
- en: 'Thus, we have determined that we are going to load the hostnames and addresses
    into variables. We are going to look at the `ports` element to identify the parent
    and child node data we are going to extract. The XML nodes in this area of the
    tree have a large amount of data since they have to be represented by numerous
    tags and attributes, as shown in this screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们决定将主机名和地址加载到变量中。我们将查看`ports`元素，以识别我们将要提取的父节点和子节点数据。树的这个区域的XML节点包含大量数据，因为它们必须由许多标签和属性表示，如下面的截图所示：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_08.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以进行报告](img/B04315_09_08.jpg)'
- en: While looking at the details of these nodes, we should consider what components
    we would like to extract. We know that we will have to iterate all the ports,
    and we can uniquely identify the ports by the `portid` tag, which represents the
    port number, but we have to consider what data is useful to us as assessors. The
    protocol of the port, such as **Transmission Control Protocol** (**TCP**) and
    **User Datagram Protocol** (**UDP**), is useful. Also, the state of the port and
    whether it is `open`, `closed`, `filtered`, or `open|filtered` is important. Finally,
    the name of the service that may have been identified would be good to catalogue
    in a report.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些节点的细节时，我们应该考虑我们想要提取的组件。我们知道我们将不得不迭代所有端口，并且可以通过`portid`标签唯一标识端口，该标签表示端口号，但我们必须考虑对我们作为评估者有用的数据。端口的协议，如**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**），是有用的。此外，端口的状态以及它是`打开`、`关闭`、`过滤`还是`打开|过滤`也很重要。最后，可能已经识别的服务名称在报告中也很有用。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that a service name may be inaccurate, depending on the type of scan.
    If there is no service detection, nmap uses the defaults described in Linux's
    `/etc/services` file for those ports. So, if you are generating reports for a
    client as part of a footprinting exercise, make sure that you enable some form
    of service detection. Otherwise, the data that you provide could be considered
    inaccurate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，服务名称可能不准确，这取决于扫描的类型。如果没有服务检测，nmap将使用Linux的`/etc/services`文件中描述的默认值。因此，如果您正在为客户生成报告作为足迹练习的一部分，请确保启用某种形式的服务检测。否则，您提供的数据可能被视为不准确。
- en: After reviewing the XML file, we have determined that in addition to the addresses
    and hostnames, we are also going to capture every port number, the protocol, the
    service attached to it, and the state. With these details, we can consider how
    we want to format our report. As previous images have shown, data from the nmap
    XMLs is not narrative in format, so a Microsoft Word document will not be as useful
    as a spreadsheet—potentially.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查XML文件后，我们确定除了地址和主机名之外，还将捕获每个端口号、协议、附加的服务以及状态。有了这些细节，我们可以考虑如何格式化我们的报告。正如之前的图像所显示的，nmap
    XML的数据格式不是叙述性的，因此Microsoft Word文档可能不如电子表格有用。
- en: 'Therefore, we have to consider the manner in which the data will be represented
    in the report: a line per host or a line per port. There are benefits and trade-offs
    for each of these representations. A line-by-line host representation means that
    composite information is easy to represent, but if we want to filter our data,
    we can only filter on unique information about the host or port groups, and not
    on individual ports.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须考虑数据在报告中的表示方式：每个主机一行还是每个端口一行。每种表示方式都有利弊。逐行主机表示意味着复合信息易于表示，但如果我们想要过滤数据，只能过滤关于主机或端口组的唯一信息，而不能过滤单个端口。
- en: 'To make this more useful, each line in the spreadsheet will represent a port,
    which means that the particulars of each port can be represented on a line. This
    can help our clients filter on each item that we extract from the XML to include
    the hostname, address, port, service name, protocol, and port state. The following
    screenshot shows what we will be working towards:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更有用，电子表格中的每一行将代表一个端口，这意味着每个端口的详细信息可以在一行上表示。这可以帮助我们的客户过滤我们从XML中提取的每个项目，包括主机名、地址、端口、服务名称、协议和端口状态。下面的截图显示了我们将要努力实现的目标：
- en: '![Understanding how to parse XML files for reports](img/B04315_09_09.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![了解如何解析XML文件以进行报告](img/B04315_09_09.jpg)'
- en: Since we are writing a parser and a report generator, it would be good to create
    two separate classes to handle this information. The added benefit is that the
    XML parser can be instantiated, which means that we can use the parser to run
    against more than one XML file and then combine combine each iteration into holistic
    and unique results. This is extremely beneficial for us, since we typically run
    more than one `nmap` scan during an engagement, and combining results and eliminating
    duplicates can be a rather laborious process. Again, this is an ideal example
    in which scripting can make our lives easier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写解析器和报告生成器，因此最好创建两个单独的类来处理这些信息。增加的好处是可以实例化XML解析器，这意味着我们可以使用解析器对多个XML文件进行运行，然后将每次迭代组合成整体和独特的结果。这对我们非常有益，因为我们通常在参与过程中运行多个`nmap`扫描，并且合并结果和消除重复项可能是一个相当费力的过程。再次，这是一个理想的例子，脚本化可以让我们的生活更轻松。
- en: Understanding how to create a Python class
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何创建Python类
- en: There is a lot of misunderstanding among new Python enthusiasts regarding how
    to generate Python classes. Python's manner of dealing with classes and instance
    variables is slightly different from that of many other languages. This is not
    a bad thing; in fact, once you get used to the way the language works, you can
    start understanding the reasons for the way the classes are defined as well thought
    out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Python爱好者之间存在很多关于如何生成Python类的误解。Python处理类和实例变量的方式与许多其他语言略有不同。这并不是一件坏事；事实上，一旦你习惯了语言的工作方式，你就可以开始理解类的定义方式是经过深思熟虑的原因。
- en: If you search for the topic of Python and self on the Internet, you will find
    extensive opinions on the use of the defined variable that is placed at the beginning
    of nonstatic functions in Python classes, you will see extensive opinions about
    it. These range from why it is a great concept that makes life easier, to the
    fact that it is difficult to contend with and makes creating multithreaded scripts
    a chore. Typically, confusion originates from developers who move from another
    language to Python. Regardless of which side of the fence you will fall on, the
    examples provided in this chapter are a way of building Python classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在互联网上搜索Python和self的主题，你会发现关于在Python类中非静态函数的开头放置的定义变量的使用的广泛意见。这些意见从认为这是一个使生活更轻松的好概念，到认为这很难应付，使得创建多线程脚本成为一项苦差事。通常，混淆源于从其他语言转移到Python的开发人员。无论你站在哪一边，本章提供的示例都是构建Python类的一种方式。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we will highlight the multithreading of scripts, which
    requires a fundamental understanding of how Python classes work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点介绍脚本的多线程，这需要对Python类的工作方式有基本的理解。
- en: Guido van Rossum, the creator of Python, has responded to some of the criticism
    related to self in a blog post, available at [http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html](http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html).
    To help you stay focused on this section of the book, extensive definitions of
    Python classes, imports, and objects will not be repeated, as they are already
    well-defined. If you would like additional detailed information related to Python
    classes, you can find it at [http://learnpythonthehardway.org/book](http://learnpythonthehardway.org/book).
    Specifically, exercises 40 through 44 do a pretty good job at explaining the "Pythonic"
    concepts about classes and object-oriented principles, which include inheritance
    and composition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python的创始人Guido van Rossum在一篇博客文章中回应了一些与self有关的批评，该文章可在[http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html](http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html)上找到。为了帮助你专注于本书的这一部分，Python类、导入和对象的广泛定义将不会重复，因为它们已经被很好地定义了。如果你想了解与Python类相关的更多详细信息，你可以在[http://learnpythonthehardway.org/book](http://learnpythonthehardway.org/book)上找到。具体来说，练习40到44非常好地解释了关于类和面向对象原则的“Pythonic”概念，其中包括继承和组合。
- en: Previously, we described how to write the naming conventions for a class that
    is Pythonic, so we will not repeat that here. Instead, we are going to focus on
    a couple of items that will be required in our script. First, we are going to
    define our class and our first function—the `__init__` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了如何编写Pythonic类的命名约定，因此我们不会在这里重复。相反，我们将专注于我们脚本中需要的一些项目。首先，我们将定义我们的类和我们的第一个函数——`__init__`函数。
- en: The `__init__` function is what is used during the instantiation of the class.
    This means that a class is called to create an object that can be referenced through
    the running script as a variable. The `__init__` function helps define the initial
    details of that object, where it basically acts as the constructor for a Python
    class. To help put this in perspective, the `__del__` function is the opposite,
    as it is the destructor in Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`函数是在类实例化时使用的。这意味着调用类来创建一个可以在运行脚本中作为变量引用的对象。`__init__`函数有助于定义该对象的初始细节，它基本上充当Python类的构造函数。为了帮助理解，`__del__`函数则相反，它是Python中的析构函数。'
- en: If a function is going to use the details of the instance, the first parameter
    passed has to be a consistent variable, which is typically called `self`. If you
    want, you can call it something else, but that is not Pythonic. If a function
    does not have this variable, then the instantiated values cannot be used directly
    within that function. All values that follow the `self` variable in the `__init__`
    function are what would be directly passed to the class during its instantiation.
    Other languages pass these values through hidden parameters; Python does this
    using `self`. Now that you have understood the basics of a Python script, we can
    start building our parsing script.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数要使用实例的细节，那么传递的第一个参数必须是一个一致的变量，通常称为`self`。如果你愿意，你可以给它取别的名字，但这不是Pythonic的。如果一个函数没有这个变量，那么实例化的值就不能直接在该函数内部使用。在`__init__`函数中跟随`self`变量的所有值都将直接传递给类。其他语言通过隐藏参数传递这些值；Python使用`self`来实现这一点。现在你已经了解了Python脚本的基础知识，我们可以开始构建我们的解析脚本。
- en: Creating a Python script to parse an Nmap XML
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个解析Nmap XML的Python脚本
- en: 'The class we are defining for this example is extremely simple in nature. It
    will have only three functions: `__init__`, a function that processes the passed
    data, and finally, a function that returns the processed data. We are going to
    set up the class to accept the nmap XML file and the verbosity level, and if none
    of it is passed, it defaults to `0`. The following is the definition of the actual
    class and the `__init__` function for the nmap parser:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个示例定义的类非常简单。它只有三个函数：`__init__`，一个处理传递数据的函数，最后是一个返回处理后数据的函数。我们将设置类来接受nmap
    XML文件和详细级别，如果没有传递，则默认为`0`。以下是实际类和nmap解析器的`__init__`函数的定义：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we are going to define the function that will do the work for this class.
    As you will notice, we do not need to pass any variables in the function, as they
    are contained within `self`. In larger scripts, I personally add comments to the
    beginning of functions to explain what is being done. In this way, when I have
    to add some more functionality into them years later, I do not have to lose time
    deciphering hundreds of lines of code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要定义这个类的工作函数。正如你会注意到的，我们不需要在函数中传递任何变量，因为它们都包含在`self`中。在更大的脚本中，我个人会在函数开头添加注释来解释正在做什么。这样，当我以后需要在其中添加更多功能时，我就不必花时间解密数百行代码。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with the previous chapters, the full script can be found on the GitHub page
    at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_parser.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_parser.py).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，完整的脚本可以在GitHub页面上找到：[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_parser.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_parser.py)。
- en: 'The run function tests to make sure that it can open the XML file, and then
    loads it into a variable using the `etree` library''s `parse` function. The function
    then defines the initial necessary variables and gets the root of the XML tree:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行函数测试确保它可以打开XML文件，然后使用`etree`库的`parse`函数将其加载到变量中。然后，函数定义了初始必要变量并获取了XML树的根：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we build a `for` loop that iterates through each host and defines the
    hostname as `Unknown hostname` for each cycle initially. This is done to prevent
    a hostname from one host from being recorded for another host. Similar blanking
    is done for the addresses prior to trying to retrieve them. You can see in the
    following code that a nested `for` loop iterates through the host address node.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个`for`循环，遍历每个主机，并为每个周期最初将主机名定义为`Unknown hostname`。这样做是为了防止一个主机的主机名被记录为另一个主机的主机名。在尝试检索地址之前，对地址进行了类似的清空处理。你可以在以下代码中看到，嵌套的`for`循环遍历主机地址节点。
- en: 'Each attribute of each `addrtype` tag is loaded into the `temp` variable. This
    value is then tested to see what type of address will be extracted. Next, the
    `addr` tag''s attribute is loaded into the variables appropriate for its address
    type, such as `hwaddress`, and `address` for **Internet Protocol version 4 (IPv4)**,
    and `addressv6` for **IP version 6 (IPv6)**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`addrtype`标签的每个属性都加载到`temp`变量中。然后测试这个值，看看将提取什么类型的地址。接下来，将`addr`标签的属性加载到适用于其地址类型的变量中，比如对于**Internet
    Protocol version 4 (IPv4)**，加载到`hwaddress`和`address`变量，对于**IP version 6 (IPv6)**，加载到`addressv6`变量中：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For hostnames, we did something slightly different. We could have created another
    `for` loop to try and identify all available hostnames per host, but most scans
    have only one or no hostname. To show a different way to grab data from an XML
    file, you can see that the `hostname` node is loaded into the appropriately named
    variable by first identifying the parent elements `hostnames`, and then the child
    element `hostname`. If the script does not find a `hostname`, we again set the
    variable to `Unknown hostname`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主机名，我们做了一些略有不同的事情。我们可以创建另一个`for`循环来尝试识别每个主机的所有可用主机名，但大多数扫描只有一个或没有主机名。为了展示从XML文件中获取数据的不同方式，你可以看到`hostname`节点首先被加载到适当命名的变量中，首先识别父元素`hostnames`，然后是子元素`hostname`。如果脚本找不到`hostname`，我们再次将变量设置为`Unknown
    hostname`：
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This script is set up as a teaching concept, but we also want to be prepared
    for future changes, if necessary. Keeping this in mind, if we wish to later change
    the way we extract the hostname direct node extraction to a `for` loop, we can.
    This was prepared in the script by loading the identified hostname into a hostname
    list prior to the next code section. Normally, this would not be needed for the
    way in which we extracted the hostname. It is easier to prepare the script for
    a future change here than to go back and change everything related to the loading
    of the attribute throughout the rest of the code afterwards.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本被设置为一个教学概念，但我们也希望为以后的更改做好准备。牢记这一点，如果我们希望以后改变提取主机名直接节点提取为`for`循环的方式，我们可以。在脚本中通过将识别的主机名加载到主机名列表中来做好准备，以便在下一段代码之前。通常，这对于我们提取主机名的方式是不需要的。在这里为未来的更改准备脚本比在之后的代码中改变加载属性相关的一切要容易得多。
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have captured how to identify the hostname, we are going to try
    and capture all the ports for each host. We do this by iterating over all the
    `port` nodes and loading them into the item variable. Next, we extract from the
    node the attributes of `state`, `servicename`, `protocol`, and `portid`. Then,
    these values are loaded into a `services` list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了如何识别主机名，我们将尝试捕获每个主机的所有端口。我们通过迭代所有`port`节点并将它们加载到item变量中来实现这一点。接下来，我们从节点中提取`state`、`servicename`、`protocol`和`portid`的属性。然后，这些值被加载到`services`列表中：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, there is a list of values with all the services for each host. We are
    going to break it out to a dictionary for easy reference. So, we generate a `for`
    loop that iterates through the length of the list, reloads each `services` value
    into a temporary variable, and then loads it into the instance''s `self.hosts`
    dictionary using the value of the iteration as a key:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个包含每个主机所有服务的值列表。我们将其拆分为一个字典以便参考。因此，我们生成一个`for`循环，遍历列表的长度，将每个`services`值重新加载到临时变量中，然后使用迭代的值作为键将其加载到实例的`self.hosts`字典中：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the end of this function, we add a simple test case to verify that the data
    was discovered, and it can be presented if the verbosity is turned up:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数的结尾，我们添加了一个简单的测试用例来验证数据是否被发现，并且如果verbosity被打开，它可以被呈现出来：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the primary processing function complete, the next step is to create a
    function that can return the specific instance''s `hosts` data. This function
    simply returns the value of `self.hosts` when called:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主要处理函数完成后，下一步是创建一个可以返回特定实例`hosts`数据的函数。这个函数在调用时简单地返回`self.hosts`的值：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have shown repeatedly the basic variable value setting through arguments
    and options, so to save space, the details of this code in the `nmap_parser.py`
    script are not covered here; they can be found online. Instead of that, we are
    going to show how we to process multiple XML files through our class instances.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经反复展示了通过参数和选项设置基本变量值，为了节省空间，这里不涵盖`nmap_parser.py`脚本中的代码细节；它们可以在线找到。相反，我们将展示如何通过我们的类实例处理多个XML文件。
- en: It starts out very simply. We test to see whether our XML files that were loaded
    by arguments have any commas in the variable `xml`. If they do, it means that
    the user has provided a comma-delimitated list of XML files to be processed. So,
    we are going to split by the comma and load the values into `xml_list` for processing.
    Then, we are going to test each XML file and verify that it is an `nmap` XML file
    by loading the XML file into a variable with `etree.parse`, getting the root of
    the file, and then checking the attribute value of the `scanner` tag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始非常简单。我们测试一下我们的XML文件是否在变量`xml`中有逗号。如果有，这意味着用户提供了一个用逗号分隔的XML文件列表进行处理。因此，我们将按逗号拆分并将值加载到`xml_list`中进行处理。然后，我们将测试每个XML文件并验证它是否是一个`nmap`
    XML文件，方法是将XML文件加载到一个变量中，然后检查`scanner`标签的属性值。
- en: 'If we get `nmap`, we know that the file is an nmap XML. If not, we exit the
    script with an appropriate error message. If there are no errors, we call the
    `Nmap_parser` class and instantiate it as an object with the current XML file
    and the verbosity level. Then, we append it to a list. So basically, the XML file
    is passed to the `Nmap_parser` class and the object itself is stored in the hosts
    list. This allows us to easily process multiple XML files and store the object
    for later manipulation, as necessary:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到`nmap`，我们知道文件是nmap XML。如果不是，我们用适当的错误消息退出脚本。如果没有错误，我们调用`Nmap_parser`类并将其实例化为一个具有当前XML文件和verbosity级别的对象。然后，我们将其附加到列表中。所以基本上，XML文件被传递给`Nmap_parser`类，对象本身被存储在hosts列表中。这使我们能够轻松处理多个XML文件并存储对象以供以后操作，如有必要：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each of these instances' data that was loaded into the dictionary may have duplicate
    information within it. Just think of what it is like during a penetration test;
    when you scan for specific weaknesses, you often look over the same IP addresses.
    Each time you run the scan, you may find the same ports and services and the relevant
    states. For that data to be normalized, it needs to be combined and duplicates
    need to be eliminated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 加载到字典中的每个实例的数据可能在其中具有重复信息。想象一下在渗透测试期间的情况；当您扫描特定弱点时，您经常会查看相同的IP地址。每次运行扫描时，您可能会找到相同的端口和服务以及相关状态。为了使数据规范化，需要将其合并并消除重复项。
- en: Of course, when dealing with typical internal IP addresses or **Request For
    Comment** (**RFC**) 1918 addresses, a `10.0.0.1` address could be in many different
    internal networks. So, if you use this script to combine results from multiple
    networks, you may be combining results that are not actually duplicates. Keep
    this in mind when you actually execute the script.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理典型的内部IP地址或**请求评论**（**RFC**）1918地址时，`10.0.0.1`地址可能在许多不同的内部网络中。因此，如果您使用此脚本来合并来自多个网络的结果，您可能会合并实际上不是重复的结果。在实际执行脚本时，请记住这一点。
- en: 'So now, we load a temporary variable with each instance of data in a `for`
    loop. This will create a `count` of all the values in the dictionary and, in turn,
    use this as the reference for each value set. A new dictionary called `hosts_dict`
    is used to store this data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`for`循环中用每个数据实例加载一个临时变量。这将创建字典中所有值的`count`，并将其用作每个值集的参考。一个名为`hosts_dict`的新字典用于存储这些数据：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have a dictionary with data that is ordered by a simple reference,
    we can use it to eliminate duplicates. What we do now is iterate through the newly
    formed dictionary and create key-value pairs within tuples. Each tuple is then
    loaded into the list, which allows the data to be sorted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个按简单引用排序的数据字典，我们可以使用它来消除重复项。现在我们要做的是遍历新形成的字典，并在元组中创建键值对。然后将每个元组加载到列表中，这样可以对数据进行排序。
- en: We again iterate through the list, which breaks down the two values stored in
    the tuple into a new key-value pair. Functionally, we are manipulating the way
    we normally store data in Python data structures to easily remove duplicates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次遍历列表，将元组中存储的两个值分解为新的键值对。从功能上讲，我们正在操纵我们通常在Python数据结构中存储数据的方式，以便轻松地去除重复项。
- en: Then, we perform a straight comparison of the current value, which is the list
    of port data with the `processed_hosts` dictionary values. This is the new and
    final dictionary that contains the verified unique values discovered from all
    the XML files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对当前值进行直接比较，即端口数据列表与`processed_hosts`字典值的比较。这是包含从所有XML文件中发现的经过验证的唯一值的新的最终字典。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This list of port data was stored as the second value in a tuple that was nested
    within the `temp` list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 端口数据列表存储在`temp`列表中嵌套的元组的第二个值中。
- en: 'If a value has already been found in the `processed_hosts` dictionary, we continue
    the loop with `continue`, without loading the details into the dictionary. Had
    the value not been in the dictionary, we would have added it to the dictionary
    using the new counter, `key`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值已经在`processed_hosts`字典中找到，我们将使用`continue`继续循环，而不将详细信息加载到字典中。如果值不在字典中，我们将使用新的计数器`key`将其添加到字典中：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we test and make sure that the data is properly ordered and presented in
    our new data structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试并确保数据在我们的新数据结构中被正确排序和呈现：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the script produces the following results, which show that we have
    successfully extracted the data and formatted it into a useful structure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本会产生以下结果，显示我们已成功提取数据并将其格式化为有用的结构：
- en: '![Creating a Python script to parse an Nmap XML](img/B04315_09_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个Python脚本来解析Nmap XML](img/B04315_09_10.jpg)'
- en: 'We can now comment out the loop that prints the data and use our data structure
    to create an Excel spreadsheet. To do this, we are going to create our own local
    module, which can then be used within this script. The script will be called to
    generate the Excel spreadsheet. To do this, we need to know the name by which
    we are going to call it and how we would like to reference it. Then, we create
    the relevant `import` statement at the top of the `nmap_parser.py` for the Python
    module, which we will call `nmap_doc_generator.py`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以注释掉打印数据的循环，并使用我们的数据结构来创建一个Excel电子表格。为此，我们将创建我们自己的本地模块，然后在此脚本中使用它。脚本将被调用来生成Excel电子表格。为此，我们需要知道我们将如何调用它的名称以及我们希望如何引用它。然后，在`nmap_parser.py`的顶部创建相关的`import`语句，我们将称之为`nmap_doc_generator.py`的Python模块：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we replace the printing of the dictionary at the bottom of the `nmap_parser.py`
    script with the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们用以下代码替换`nmap_parser.py`脚本底部的字典打印：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The simple flag was added to the list of options to allow the spreadsheet to
    be output in different formats, if you like. This tool can be useful in real penetration
    tests and for final reports. Everyone has a preference when it comes to what output
    is easier to read and what colors are appropriate for the branding of their reports
    for whatever organization they work for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简单标志被添加到选项列表中，以允许以不同格式输出电子表格，如果需要的话。这个工具在真实的渗透测试和最终报告中都很有用。当涉及到哪种输出更容易阅读以及什么颜色适合他们所工作的组织的品牌报告时，每个人都有自己的偏好。
- en: Creating a Python script to generate Excel spreadsheets
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Python脚本来生成Excel电子表格
- en: 'Now we create our new module. It can be imported into the `nmap_parser.py`
    script. The script is very simple thanks the `xlsxwriter` library, which we can
    again install with `pip`. The following code brings the script by setting up the
    necessary libraries so that we can generate the Excel spreadsheet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建我们的新模块。它可以被导入到`nmap_parser.py`脚本中。这个脚本非常简单，感谢`xlsxwriter`库，我们可以再次使用`pip`安装它。以下代码通过设置必要的库来带来脚本，以便我们可以生成Excel电子表格：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we create the class and the constructor for `Nmap_doc_generator`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`Nmap_doc_generator`的类和构造函数：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we create the function that will be executed for the instance. From this
    function, a secondary function called `generate_xlsx` is executed. This function
    is created in this manner so that we can use this very module for other report
    types in future, if desired. All that we would have to do is create additional
    functions that can be invoked with options supplied when the `nmap_parser.py`
    script is run. That''s beyond the scope of this example, however, so the extent
    of the `run` function is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建将在实例中执行的函数。从这个函数中，会执行一个名为`generate_xlsx`的次要函数。这样创建这个函数是为了以后如果需要，我们可以使用这个模块来处理其他报告类型。我们只需要创建额外的函数，并在运行`nmap_parser.py`脚本时提供选项来调用这些函数。然而，这超出了本示例的范围，所以`run`函数的范围如下：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next function we define is `generate_xlsx`, which includes all the features
    required to generate the Excel spreadsheet. The first thing we need to do is define
    the actual workbook, the worksheet, and the formatting within. We begin this by
    setting the actual filename extension, if none exists:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一个函数是`generate_xlsx`，其中包括生成Excel电子表格所需的所有功能。我们需要做的第一件事是定义实际的工作簿、工作表和格式。如果没有文件扩展名，我们首先需要设置实际的文件名扩展名：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we start creating the actual row formats, beginning with the header row.
    We highlight it as a bold row with two different possible colors, depending on
    whether the simple flag is set or not:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始创建实际的行格式，从标题行开始。我们将其突出显示为粗体行，具有两种不同的可能颜色，具体取决于是否设置了简单标志：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can identify the actual color number that you want in your spreadsheet using
    a Microsoft-like color selection tool. It can be found at [http://www.w3schools.com/tags/ref_colorpicker.asp](http://www.w3schools.com/tags/ref_colorpicker.asp).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似于微软的颜色选择工具在电子表格中找到您想要的实际颜色编号。它可以在[http://www.w3schools.com/tags/ref_colorpicker.asp](http://www.w3schools.com/tags/ref_colorpicker.asp)找到。
- en: 'Since we want to configure this as a spreadsheet—so that it can have alternating
    colors—we are going to set two additional formatting configurations. Like the
    previous formatting configuration, this will be saved as variables that can easily
    be referenced depending on the whether the row is even or odd. Even rows will
    be white, since the header row has a color fill, and odd rows will have a color
    fill. So, when the `simple` variable is set, we are going to change the color
    of the odd row. The following code highlights this logic structure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想将其配置为电子表格，以便它可以具有交替的颜色，我们将设置两个额外的格式配置。与之前的格式配置一样，这将被保存为变量，可以根据行是偶数还是奇数轻松引用。偶数行将是白色，因为标题行有颜色填充，奇数行将有颜色填充。因此，当设置`simple`变量时，我们将改变奇数行的颜色。以下代码突出显示了这种逻辑结构：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the formatting defined, we now have to set the column widths and headings,
    and these will be used throughout the rest of the spreadsheet. There is a bit
    of trial and error here, as the column widths should be wide enough for the data
    that will be populated in the spreadsheet and properly represent the headings
    without unnecessarily scaling out off the screen. Defining the column width is
    done by range, the starting column number, the ending column number, and finally
    the size of the column width. These three comma-delimited values are placed in
    the `set_column` function parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了格式后，我们现在必须设置列宽和标题，这些将在整个电子表格中使用。这里有一些试错，因为列宽应该足够宽，可以容纳电子表格中填充的数据，并正确表示标题，而不会不必要地扩展到屏幕外。通过范围、起始列号、结束列号和最后列宽的大小来定义列宽。这三个逗号分隔的值放在`set_column`函数参数中：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the columns defined, set the starting location for the rows and the columns,
    populate the header rows, and make the data present in them filterable. Think
    about how useful it is to look for hosts with open JBoss ports or if a client
    wants to know the ports that have been successfully filtered by the perimeter
    firewall:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了列之后，设置行和列的起始位置，填充标题行，并使其中的数据可过滤。想想查找具有开放的JBoss端口的主机有多有用，或者客户想要知道已成功被周界防火墙过滤的端口是哪些：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, with the formatting defined, we can actually start populating the spreadsheet
    with the relevant data. To do this we create a `for` loop that populates the `key`
    and `value` variables. In this instance of report generation, key is not useful
    for the spreadsheet, since none of the data from it is used to generate the spreadsheet.
    On the other hand, the `value` variable contains the list of results from the
    `nmap_parser.py` script. So, we populate the six relevant value representations
    in positional variables:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义了格式后，我们可以开始填充相关数据到电子表格中。为此，我们创建一个`for`循环来填充`key`和`value`变量。在这个报告生成的实例中，`key`对于电子表格来说并不有用，因为它的数据没有用于生成电子表格。另一方面，`value`变量包含了`nmap_parser.py`脚本的结果列表。因此，我们将六个相关的值表示填充到位置变量中：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At the end of each iteration, we are going to increment the row counter. Otherwise,
    if we did this at the beginning, we would be writing blank rows between data rows.
    To start the processing, we need to determine whether the row is even or odd,
    as this changes the formatting, as mentioned before. The easiest way to do this
    is to use the modulus operator, or `%`, which divides the left operand by the
    right operand and returns the remainder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代结束时，我们将增加行计数器。否则，如果我们在开始时这样做，我们将在数据行之间写入空白行。要开始处理，我们需要确定行是偶数还是奇数，因为这会改变格式，如前所述。最简单的方法是使用模运算符`%`，它将左操作数除以右操作数并返回余数。
- en: 'If there is no remainder, we know that it is even, and as such, so is the row.
    Otherwise, the row is odd and we need to use the requisite format. Instead of
    writing the entire function row writing operation twice, we are again going to
    use a temporary variable that will hold the current row format, called `temp_format`,
    as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有余数，我们知道它是偶数，因此行也是偶数。否则，行是奇数，我们需要使用相应的格式。我们不再将整个函数行写操作写两次，而是再次使用一个临时变量来保存当前行格式，称为`temp_format`，如下所示：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can write the data from left to right. Each component of the data goes
    into the next column, which means that we take the column value of `0` and add
    `1` to it each time we write data to the row. This allows us to easily span the
    spreadsheet from left to right without having to manipulate multiple values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从左到右写入数据。数据的每个组件都进入下一列，这意味着我们将列值为`0`，并且每次写入数据到行时都加`1`。这样可以让我们轻松地从左到右跨越电子表格，而不必操作多个值：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we close the workbook that writes the file to the current working
    directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭写入文件到当前工作目录的工作簿：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All the necessary script components and modules have been created, which means
    that we can generate our Excel spreadsheet from the `nmap` XML outputs. In the
    arguments of the `nmap_parser.py` script, we set a default filename to `xml_output`,
    but we can pass other values as necessary. The following is the output from the
    help of the `nmap_parser.py` script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的脚本组件和模块都已创建，这意味着我们可以从`nmap` XML输出生成我们的Excel电子表格。在`nmap_parser.py`脚本的参数中，我们将默认文件名设置为`xml_output`，但根据需要可以传递其他值。以下是`nmap_parser.py`脚本的帮助输出：
- en: '![Creating a Python script to generate Excel spreadsheets](img/B04315_09_11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个用于生成Excel电子表格的Python脚本](img/B04315_09_11.jpg)'
- en: 'With this detailed information we can now execute the script against the four
    different `nmap` scan XMLs that we have created as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些详细信息，我们现在可以针对我们创建的四个不同的`nmap`扫描XML执行脚本，如下截图所示：
- en: '![Creating a Python script to generate Excel spreadsheets](img/B04315_09_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个用于生成Excel电子表格的Python脚本](img/B04315_09_12.jpg)'
- en: 'The output of the script is this Excel spreadsheet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出是这个Excel电子表格：
- en: '![Creating a Python script to generate Excel spreadsheets](img/B04315_09_13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个用于生成Excel电子表格的Python脚本](img/B04315_09_13.jpg)'
- en: 'Instead, if we set the simple flag and create a new spreadsheet with a different
    filename, we get the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们设置简单标志并创建一个带有不同文件名的新电子表格，我们会得到以下输出：
- en: '![Creating a Python script to generate Excel spreadsheets](img/B04315_09_14.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个用于生成Excel电子表格的Python脚本](img/B04315_09_14.jpg)'
- en: 'This creates the new spreadsheet, `xml_output2.xlsx`, with the simple format,
    as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建新的电子表格`xml_output2.xlsx`，采用简单格式，如下所示：
- en: '![Creating a Python script to generate Excel spreadsheets](img/B04315_09_15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个用于生成Excel电子表格的Python脚本](img/B04315_09_15.jpg)'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this module can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_doc_generator.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_doc_generator.py).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的代码可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_doc_generator.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_doc_generator.py)找到。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Parsing nmap XML is extremely useful, but consider how helpful this capability
    is for reading and organizing other security tool outputs as well. We showed you
    how to create Python classes, parse XML structures, and generate unique datasets.
    By the end of all of this, we were able to create an Excel spreadsheet that can
    represent data in a filterable format. In the next chapter, we will highlight
    how to add multithreading capabilities and permanency to our Python scripts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解析nmap XML非常有用，但请考虑这种能力对于阅读和组织其他安全工具输出的帮助有多大。我们向您展示了如何创建Python类，解析XML结构并生成独特的数据集。在所有这些之后，我们能够创建一个可以以可过滤格式表示数据的Excel电子表格。在下一章中，我们将介绍如何为我们的Python脚本添加多线程能力和永久性。
