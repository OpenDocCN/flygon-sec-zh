- en: Firmware Security Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件安全最佳实践
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Preventing memory-corruption vulnerabilities
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止内存损坏漏洞
- en: Preventing injection attacks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止注入攻击
- en: Securing firmware updates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护固件更新
- en: Securing sensitive information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护敏感信息
- en: Hardening embedded frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固嵌入式框架
- en: Securing third-party code and components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护第三方代码和组件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Embedded software is the core of all that is considered IoT, although embedded
    application security is often not thought of as a high priority for embedded developers
    and IoT device makers. This may be due to the lack of secure coding knowledge
    or other challenges outside of a team''s code base. Other challenges developers
    face may include, but are not limited to, the **Original Design Manufacturer**
    (**ODM**) supply chain, limited memory, a small stack, and the challenge of pushing
    firmware updates securely to an endpoint. This chapter provides practical best
    practice guidance developers can incorporate in embedded firmware applications.
    As per OWASP''s Embedded Application Security project ([https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)),
    embedded best practices consist of:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式软件是被认为是物联网的核心，尽管嵌入式应用安全通常不被视为嵌入式开发人员和物联网设备制造商的高优先级。这可能是由于缺乏安全编码知识或团队代码库之外的其他挑战。开发人员面临的其他挑战可能包括但不限于**原始设计制造商**（ODM）供应链、有限的内存、小堆栈以及安全地向端点推送固件更新的挑战。本章提供了开发人员可以在嵌入式固件应用中采用的实用最佳实践指南。根据OWASP的嵌入式应用安全项目（[https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)），嵌入式最佳实践包括：
- en: Buffer and stack overflow protection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区和堆栈溢出保护
- en: Injection attack prevention
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止注入攻击
- en: Securing firmware updates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护固件更新
- en: Securing sensitive information
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护敏感信息
- en: Identity management controls
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份管理控制
- en: Embedded framework and C-based toolchain hardening
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固嵌入式框架和基于C的工具链
- en: Usage of debugging code and interfaces
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试代码和接口
- en: Securing device communications
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护设备通信
- en: Usage of data collection and storage
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集和存储的使用
- en: Securing third-party code
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护第三方代码
- en: Threat modeling
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 威胁建模
- en: This chapter will address several of the preceding mentioned best practices
    mostly tailored towards a POSIX environment, however the principles are designed
    to be platform agnostic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论前述的几种最佳实践，主要针对POSIX环境，但原则上设计为平台无关。
- en: Preventing memory-corruption vulnerabilities
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止内存损坏漏洞
- en: 'While using lower level languages such as C, there is a high chance of memory
    corruption bugs arising if bounds are not properly checked and validated by developers
    programmatically. Preventing the use of known dangerous functions and APIs aids
    against memory-corruption vulnerabilities within firmware. For example, a non-exhaustive
    list of known, unsafe C functions consists of: `strcat`, `strcpy`, `sprintf`,
    `scanf`, and `gets`. Common memory-corruption vulnerabilities such as buffer overflows
    or heap overflows can consist of overflowing the stack or the heap. The impact
    of these specific memory-corruption vulnerabilities when exploited differ per
    the operating system platform. For example, commercial RTOS platforms such as
    QNX Neutrino isolates each process and its stack from the filesystem minimizing
    the attack surface. However, for common Embedded Linux distributions this may
    not be the case. Buffer overflows in Embedded Linux may result in arbitrary execution
    of malicious code and modification to the operating system by an attacker. In
    this recipe, we will show how tools can help with detecting vulnerable C functions
    and also provide security controls along with best practices for preventing memory
    corruption vulnerabilities.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用C等低级语言时，如果开发人员没有正确检查和验证边界，就有很高的可能性出现内存损坏错误。防止使用已知的危险函数和API有助于防止固件内的内存损坏漏洞。例如，已知的不安全C函数的非穷尽列表包括：`strcat`、`strcpy`、`sprintf`、`scanf`和`gets`。常见的内存损坏漏洞，如缓冲区溢出或堆溢出，可能包括堆栈或堆的溢出。利用这些特定的内存损坏漏洞的影响因操作系统平台而异。例如，商业RTOS平台如QNX
    Neutrino将每个进程及其堆栈与文件系统隔离，最小化攻击面。然而，对于常见的嵌入式Linux发行版可能并非如此。在嵌入式Linux中，缓冲区溢出可能导致恶意代码的任意执行和对操作系统的修改。在本教程中，我们将展示工具如何帮助检测易受攻击的C函数，并提供防止内存损坏漏洞的安全控制和最佳实践。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, the following tool will be used:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，将使用以下工具：
- en: '**Flawfinder**: Flawfinder is a free C/C++ static code analysis tool that reports
    potential security vulnerabilities.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flawfinder**：Flawfinder是一个免费的C/C++静态代码分析工具，报告潜在的安全漏洞。'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作方法...
- en: Common Linux utilities are helpful to search through C/C++ code files. Although,
    there are commercially available source code analysis tools available that do
    a much better job than common utilities to prevent from memory corruption vulnerabilities
    with IDE plugins developers can use. For demonstration purposes, we will show
    how to search through code files for a list of predefined function vulnerable
    calls and rules with grep as well as flawfinder in the following steps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的Linux实用工具对于搜索C/C++代码文件非常有帮助。尽管商业上可用的源代码分析工具可以比常见实用工具更好地防止内存损坏漏洞，并且开发人员可以使用IDE插件。为了演示目的，我们将展示如何使用grep和flawfinder搜索代码文件中的预定义函数易受攻击的调用和规则。
- en: 'To discover unsafe C functions, there are several methods that can be used.
    The simplest form is using a `grep`expression similar to the example shown as
    follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发现不安全的C函数，有几种方法可以使用。最简单的形式是使用类似于以下示例的`grep`表达式：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This expression can be tweaked to be more intelligent or wrapped in a script
    that can be executed per build or on an ad-hoc basis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达可以调整得更智能一些，或者包装成一个脚本，可以在每次构建时执行，或者按需执行。
- en: 'Alternatively, free tools such as `flawfinder` can be used to search for vulnerable
    functions by calling `flawfinder` and the path to the piece of code as shown in
    the following example:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，可以使用`flawfinder`等免费工具来搜索易受攻击的函数，方法是调用`flawfinder`和代码片段的路径，如以下示例所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upon discovery of vulnerable C functions in use, you must incorporate safe
    alternatives. For example, the following vulnerable code uses the unsafe `gets()`
    function that does not check buffer lengths:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发现正在使用的易受攻击的C函数时，必须合并安全替代方案。例如，以下易受攻击的代码使用不安全的`gets()`函数，不检查缓冲区长度：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `userid` can be overrun using any number of characters over `8` such as
    the **Buffer Overflow Exploit** (**BoF**) payload with custom execution functions.
    To mitigate overrunning the buffer, the `fgets()` function can be used as a safe
    alternative. The following example code shows how to securely use `fgets()` and
    allocate memory correctly:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`userid`可以使用超过`8`个字符的任意数量进行溢出，例如具有自定义执行函数的缓冲区溢出利用（BoF）有效负载。为了减轻缓冲区溢出的影响，可以使用`fgets()`函数作为安全的替代方法。以下示例代码显示了如何安全地使用`fgets()`并正确分配内存：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same mitigations can be used with other safe alternative functions such
    as `snprintf()`, `strlcpy()`, and `strlcat()`. Depending on the operating system
    platform, some of the safe alternatives may not be available. It is important
    to perform your own research to determine safe alternatives for your specific
    architecture and platform. Intel has created an open source cross-platform library
    called `safestringlib` to prevent the use of these insecure banned functions;
    use an alternative safe replacement function. For more details on `safestringlib`,
    visit the GitHub page at: [https://github.com/01org/safestringlib](https://github.com/01org/safestringlib).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同的缓解措施来使用其他安全替代函数，如`snprintf()`，`strlcpy()`和`strlcat()`。根据操作系统平台的不同，某些安全替代方案可能不可用。重要的是要进行自己的研究，以确定特定架构和平台的安全替代方案。英特尔创建了一个名为`safestringlib`的开源跨平台库，以防止使用这些不安全的禁止函数；使用替代的安全替换函数。有关`safestringlib`的更多详细信息，请访问GitHub页面：[https://github.com/01org/safestringlib](https://github.com/01org/safestringlib)。
- en: 'Other memory security controls can be used to prevent from memory-corruption
    vulnerabilities such as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用其他内存安全控件来防止内存腐败漏洞，例如以下控件：
- en: Make use of secure compiler flags such as -fPIE, -fstack-protector-all, -Wl,-z,noexecstack,
    -Wl,-z,noexecheap and others that may depend on your specific compiler version.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全编译器标志，如-fPIE，-fstack-protector-all，-Wl，-z，noexecstack，-Wl，-z，noexecheap等，这些可能取决于您特定的编译器版本。
- en: Prefer system-on-chips (SoC) and microcontrollers (MCU) that contain memory
    management units (MMU). MMUs isolate threads and processes to lessen the attack
    surface if a memory bug is exploited.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选包含内存管理单元（MMU）的系统芯片（SoC）和微控制器（MCU）。MMU将线程和进程隔离，以减少攻击面，如果内存错误被利用。
- en: Prefer **system-on-chips** (**SoC**) and **microcontrollers** (**MCU**) that
    contain **memory protection units** (**MPU**). MPUs enforce access rules for memory
    and separate processes as well as enforce privilege rules.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选包含内存保护单元（MPU）的系统芯片（SoC）和微控制器（MCU）。MPU强制执行内存的访问规则，并分离进程，同时执行特权规则。
- en: If no MMU or MPU is available, monitor the stack using a known bit to monitor
    how much the stack is being consumed by determining how much of the stack no longer
    contains the known bit.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有MMU或MPU可用，可以使用已知位来监视堆栈，以确定堆栈的多少被消耗掉。
- en: Be mindful what is being placed in buffers and free buffer locations after-use.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在放置缓冲区和释放缓冲区位置后，要注意放置什么。
- en: Exploiting memory vulnerabilities with **address space layout randomization**
    (**ASLR**) and other stack controls does take a lot of effort for attackers to
    exploit. Although, it is still possible under certain circumstances. Ensuring
    code is resilient and incorporates a defense-in-depth approach for data placed
    in memory will help the secure posture of the embedded device.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 利用地址空间布局随机化（ASLR）和其他堆栈控件的内存漏洞需要攻击者付出大量努力才能利用。尽管在某些情况下仍然可能发生。确保代码具有弹性，并采用深度防御方法，以便将数据放置在内存中有助于嵌入式设备的安全姿态。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further secure memory management guidelines, reference Carnegie Mellon's
    Secure CERT C Coding Standard ([https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard)).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更安全的内存管理指南，请参考卡内基梅隆大学的安全CERT C编码标准（[https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard)）。
- en: For further secure memory management guidelines, reference Carnegie Mellon's
    Secure CERT C++ Coding Standard ([https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637))
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更安全的内存管理指南，请参考卡内基梅隆大学的安全CERT C++编码标准（[https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637)）
- en: Preventing injection attacks
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防注入攻击
- en: Injection attacks are one of the top vulnerabilities in any web application
    but especially in IoT systems. In fact, injection has been rated in the top 2
    of the OWASP Top 10 since 2010\. There are many types of injection attacks such
    as **operating system** (**OS**) command injection, cross-site scripting (for
    example, JavaScript injection), SQL injection, log injection, as well as others
    such as expression language injection. In IoT and embedded systems, the most common
    types of injection attacks are OS command injection; when an application accepts
    an untrusted user input and passes that value to perform a shell command without
    input validation or proper escaping and cross-site scripting (XSS). This recipe
    will show you how to mitigate command injection attacks by ensuring all untrusted
    data and user input is validated, sanitized, and alternative safe functions are
    used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击是任何Web应用程序中最严重的漏洞之一，尤其是在物联网系统中。事实上，自2010年以来，注入一直是OWASP十大漏洞中排名前两位。有许多类型的注入攻击，如**操作系统**（OS）命令注入、跨站脚本（例如JavaScript注入）、SQL注入、日志注入，以及其他类型的表达式语言注入。在物联网和嵌入式系统中，最常见的注入攻击类型是操作系统命令注入；当应用程序接受不受信任的用户输入并将该值传递以执行shell命令而没有输入验证或适当的转义时，以及跨站脚本（XSS）。本文将向您展示如何通过确保所有不受信任的数据和用户输入都经过验证、经过清理，并使用替代安全函数来减轻命令注入攻击。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Command injection vulnerabilities are not difficult to test for statics and
    dynamics when an IoT device is running. Firmware can call `system()`, `exec()` and
    similar variants to execute OS commands, or call an external script that runs
    OS calls from interpreted languages such as Lua. Command injection vulnerabilities
    can arise from buffer overflows as well. The following steps and examples show
    code vulnerable to command injection as well as how to mitigate from a command
    injection. Afterwards, we will list common security controls to prevent common
    injection attacks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当物联网设备运行时，注入攻击的静态和动态测试并不难。固件可以调用`system()`、`exec()`和类似的变体来执行操作系统命令，或者调用从解释语言（如Lua）运行OS调用的外部脚本。命令注入漏洞也可能由缓冲区溢出引起。以下步骤和示例显示了易受命令注入攻击的代码，以及如何减轻命令注入攻击。之后，我们将列出常见的安全控制措施，以防止常见的注入攻击。
- en: 'The following snippet of code invokes the dangerous `system()` C function to
    remove the `.cfg` file in the `home` directory. In the event an attacker has the
    ability to control the function, subsequent shell commands may be concatenated
    to perform unauthorized actions. Additionally, an attacker can manipulate environment
    variables to delete any files ending in `.cfg`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段调用危险的`system()` C函数来删除`home`目录中的`.cfg`文件。如果攻击者能够控制该函数，则可以连接后续的shell命令来执行未经授权的操作。此外，攻击者可以操纵环境变量来删除任何以`.cfg`结尾的文件：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To mitigate the preceding vulnerable code, the `unlink()` function will be
    used instead of the `system()` function. The `unlink()` function is not susceptible
    to symlink and command injection attacks. The `unlink()` function removes the
    symlink and does not affect files or directories named by the contents of the
    symlink. This reduces the susceptibility of the `unlink()` function to symlink
    attacks, however it does not thwart symlink attacks in their entirety; if a named
    directory is the same, it could also be deleted. The `unlink()` function does
    thwart from command injection attacks and similar contextual functions should
    be used rather than executing operating system calls:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了减轻前面的易受攻击的代码，将使用`unlink()`函数而不是`system()`函数。`unlink()`函数不容易受到符号链接和命令注入攻击。`unlink()`函数删除符号链接，不会影响符号链接内容命名的文件或目录。这减少了`unlink()`函数易受符号链接攻击的可能性，但并不能完全阻止符号链接攻击；如果命名目录相同，也可能被删除。`unlink()`函数可以防止命令注入攻击，应该使用类似的上下文函数而不是执行操作系统调用：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several other methods to mitigate from injection attacks. Below are
    a list of common best practices and controls for preventing injection attacks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种方法可以减轻注入攻击。以下是一些常见的防止注入攻击的最佳实践和控制措施的列表：
- en: Avoid invoking OS calls directly if possible.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免直接调用操作系统调用。
- en: If needed, whitelist accepted commands and validate the input values prior to
    execution.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，列出接受的命令并在执行之前验证输入值。
- en: Use lookup maps of numbers-to-command-strings for user driven strings that may
    be passed to the operating system such as `{1:ping -c 5}`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户驱动的字符串使用数字到命令字符串的查找映射，这些字符串可能会传递给操作系统，例如`{1:ping -c 5}`。
- en: Perform static code analysis on code bases and alert when languages us OS commands
    such as `os.system()`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码库进行静态代码分析，并在使用OS命令（如`os.system()`）时发出警报。
- en: Consider all user input as untrusted and output encode characters for data rendered
    back to the user. (for example, `Convert & to &amp`, `Convert < to &lt`, `Convert
    > to &gt`, and so on.)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有用户输入视为不受信任，并对返回给用户的数据进行输出编码（例如，`将&转换为&amp`，`将<转换为&lt`，`将>转换为&gt`等）。
- en: For XSS, use HTTP response headers such as X-XSS-Protection and Content-Security-Policy
    with the appropriate directives configured.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于XSS，使用HTTP响应头，如X-XSS-Protection和Content-Security-Policy，并配置适当的指令。
- en: Ensure debug interfaces with command execution are disabled on production firmware
    builds (for example, [http://example.com/command.php](http://example.com/command.php)).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在生产固件版本中禁用带有命令执行的调试接口（例如，[http://example.com/command.php](http://example.com/command.php)）。
- en: The preceding mentioned controls always require testing prior to firmware being
    used in a production environment. With injection attacks, devices and users are
    put at risk of being taken over by attackers as well as rouge devices. We are
    seeing such events happening in 2017 with IoT Reaper and Persirai botnets. This
    is only the beginning.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的控制措施在生产环境中使用固件之前都需要进行测试。在注入攻击中，设备和用户面临被攻击者接管的风险，以及流氓设备。我们在2017年看到了物联网Reaper和Persirai僵尸网络发生的事件。这只是开始。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further injection prevention guidelines and considerations, reference OWASP's
    Embedded Application Security Project ([https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security))
    and OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet [https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关进一步的注入预防指南和注意事项，请参考OWASP的嵌入式应用安全项目（[https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)）和OWASP
    XSS（跨站脚本）预防备忘单[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)。
- en: Securing firmware updates
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护固件更新
- en: Depending on the industry, only authorized firmware from the manufacturer, supplier,
    or enterprise should be flashed onto the device. To ensure this takes place, a
    robust update mechanism must be used upon download, of firmware and when applicable,
    for updating functions pertaining to third-party software or libraries. A cryptographic
    signature should be used for all firmware to allow for verification that files
    have not been modified or otherwise tampered with since the developer created
    and signed them. The signing and verification process uses public-key cryptography
    and it is difficult to forge a digital signature (for example, a PGP signature)
    without first gaining access to the private key. When using public-key cryptography,
    it must be stored securely and not exposed to unintended parties. In the event
    a private key is compromised, developers of the software must revoke the compromised
    key and will need to re-sign all previous firmware releases with the new key.
    This has been a problem for many IoT products already requiring users to send
    back their device or towing vehicles into service shops. The implementation for
    securing firmware updates does vary depending on the industry in which an IoT
    device is being deployed. For instance, some products may have **over the air**
    (**OTA**) updates while others may need to be updated manually via a USB or through
    an interface that loads the new firmware image. For some common consumer grade
    IoT devices, this may not be as big of an issue, however if unauthorized malicious
    firmware is loaded onto a connected vehicle or medical device, the repercussions
    can be deadly. This recipe will list features that can be used to secure firmware
    updates.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据行业，只有来自制造商、供应商或企业的授权固件才能刷入设备。为确保这一点，必须在下载固件时使用强大的更新机制，并在适用时，用于更新与第三方软件或库相关的功能。所有固件都应使用加密签名，以便验证文件自开发者创建并签名以来未被修改或篡改。签名和验证过程使用公钥加密，很难在未获得私钥的情况下伪造数字签名（例如PGP签名）。使用公钥加密时，必须将其安全存储，并且不暴露给意外的第三方。如果私钥被泄露，软件开发人员必须撤销受损的密钥，并需要使用新密钥重新签署所有先前的固件版本。这已经成为许多物联网产品的问题，用户需要将设备送回或将牵引车辆送到服务商店。保护固件更新的实施因部署物联网设备的行业而异。例如，一些产品可能具有**空中**（**OTA**）更新，而其他产品可能需要通过USB手动更新或通过加载新的固件映像的界面进行更新。对于一些普通的消费级物联网设备来说，这可能不是一个大问题，但是如果未经授权的恶意固件加载到连接的车辆或医疗设备上，后果可能是致命的。本文将列出可用于保护固件更新的功能。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: There are many variables and considerations to take into account when implementing
    a secure update ecosystem for embedded IoT devices. Certain architectures, SoCs,
    or bootloaders may not have the ability to perform all the required actions to
    employ a resilient firmware update system. Due to the complexity and variations
    in employing a secure update system, we will address high-level actions manufacturers
    should incorporate into their firmware update design. For simplicity, we will
    use Embedded Linux as our platform and provide the requirements needed for a secure
    update system. Again, not all the following requirements may be feasible, however
    it is important for the device manufacturer to perform their due diligence and
    understand the risks when employing a secure update system. The following list
    are security controls and requirements for securing firmware updates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在为嵌入式物联网设备实施安全更新生态系统时，需要考虑许多变量和因素。某些架构、SoC或引导加载程序可能无法执行所有必需的操作，以实现弹性固件更新系统。由于实施安全更新系统的复杂性和变化，我们将讨论制造商应该将哪些高级操作纳入其固件更新设计中。为简单起见，我们将以嵌入式Linux作为平台，并提供安全更新系统所需的要求。再次强调，并非所有以下要求都可能可行，但对于设备制造商来说，进行尽职调查并了解实施安全更新系统时的风险是很重要的。以下是用于保护固件更新的安全控制和要求。
- en: Implement secure boot or verified boot for bootloaders.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为引导加载程序实施安全启动或验证启动。
- en: Safeguard secure boot keys using a secure hardware chip (for example, TPM, HSM,
    secure element).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用安全硬件芯片（例如TPM、HSM、安全元件）保护安全启动密钥。
- en: Ensure robust update mechanisms utilize cryptographically signed firmware images
    for updating functions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保强大的更新机制利用加密签名的固件图像进行更新功能。
- en: Images must be validated after download and upon flashing.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载和刷写图像后必须进行验证。
- en: 'Ensure updates are downloaded over the most recent secure TLS version possible
    (at time of writing, this is TLS 1.2):'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保更新是通过最新的安全TLS版本下载的（在撰写本文时，这是TLS 1.2）：
- en: Ensure updates validate the public key and certificate the chain of the update
    server
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保更新验证更新服务器的公钥和证书链
- en: 'Include a feature to utilize automatic firmware updates on a predefined schedule:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括利用预定时间表的自动固件更新功能：
- en: Force updates in highly vulnerable use cases
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高度脆弱的用例中强制更新
- en: Scheduled push updates should be taken into consideration for certain devices,
    such as medical devices, to prevent forced updates from creating possible issues
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应考虑定期推送更新，以防止强制更新可能造成的问题，特别是对于某些设备，如医疗设备。
- en: Ensure firmware versions are clearly displayed.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保固件版本清晰显示。
- en: Ensure firmware updates include changelogs with security related vulnerabilities
    included.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保固件更新包括包含安全相关漏洞的更改日志。
- en: Notify customers of new firmware when available via emails, app notifications,
    or upon login to applications.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在固件可用时通过电子邮件、应用程序通知或登录应用程序通知客户新的固件。
- en: Ensure an anti-downgrade protection (anti-rollback) mechanism is employed so
    that the device cannot be reverted to a vulnerable firmware version.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保采用反降级保护（反回滚）机制，以防设备被恢复到一个易受攻击的固件版本。
- en: Consider implementing an **Integrity Measurement Architecture** (**IMA**) which
    allows the kernel to check that a file has not been changed by validating it against
    a stored/calculated hash (called a label). An **Extended Verification Module**
    (**EVM**) checks the file attributes (including the extended ones).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑实施**完整性测量架构**（**IMA**），允许内核通过验证文件的哈希（称为标签）来检查文件是否未被更改。**扩展验证模块**（**EVM**）检查文件属性（包括扩展属性）。
- en: 'There are two types of labels available:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的标签可用：
- en: Immutable and signed
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变和签名
- en: Simple
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Consider implementing a read-only root file system with an overlay that can
    be created for directories which need local persistence.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑实施一个只读的根文件系统，并为需要本地持久性的目录创建一个覆盖层。
- en: A secure update system is heavily dependent on public key cryptography for signing
    and verifying firmware images. This requires infrastructure and administration
    to maintain the lifecycle of the device's signing and verification keys. In the
    event a key is compromised or needs to be updated, it should be tested prior to
    production deployment to prevent the bricking of a device. With that being said,
    there are third-party companies that offer **firmware over the air** (**FOTA**)
    update services that shift liability to the service provider. This can be expensive
    for products such as connected vehicles with manufacturers having to foot the
    network data bill. There are frameworks that should be considered when choosing
    an update mechanism such as The Update Framework ([https://theupdateframework.github.io/](https://theupdateframework.github.io/))
    and Uptane ([https://uptane.github.io/](https://uptane.github.io/)) for connected
    vehicles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的更新系统严重依赖于公钥密码学来签名和验证固件图像。这需要基础设施和管理来维护设备签名和验证密钥的生命周期。如果密钥被 compromise 或需要更新，应在生产部署之前进行测试，以防止设备变砖。话虽如此，有第三方公司提供**空中固件更新**（**FOTA**）服务，将责任转移到服务提供商。对于像连接车辆这样的产品来说，这可能会很昂贵，制造商需要支付网络数据费用。在选择更新机制时，应考虑一些框架，如The
    Update Framework ([https://theupdateframework.github.io/](https://theupdateframework.github.io/))和Uptane
    ([https://uptane.github.io/](https://uptane.github.io/))。
- en: Securing sensitive information
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护敏感信息
- en: With limited storage and slim margins, securing sensitive data can be a challenge
    for IoT devices. Often, sensitive data is stored on a client application or device
    so an IoT service can function without an internet connection. There are secure
    principles to be followed when securing sensitive data on a device. First, never
    hardcode secrets into firmware images such as passwords, usernames, tokens, private
    keys, or similar variants, into firmware release images. This also includes the
    storage of sensitive data that is written to a disk. This data will be accessible
    to attackers upon extracting firmware filesystems as well as when accessing the
    operating system during runtime. If hardware such as a **security element** (**SE**)
    or **Trusted Execution Environment** (**TEE**) is available, it is recommended
    to use such features for storing sensitive data during runtime. Otherwise, use
    of strong cryptography should be evaluated to protect the data using server-side
    computations to compensate for hardware limitations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限的存储空间和薄利多销的情况下，保护敏感数据对于IoT设备来说可能是一个挑战。通常，敏感数据存储在客户端应用程序或设备上，以便IoT服务可以在没有互联网连接的情况下运行。在保护设备上的敏感数据时，应遵循一些安全原则。首先，永远不要将秘密硬编码到固件图像中，比如密码、用户名、令牌、私钥或类似的变体。这也包括写入磁盘的敏感数据。这些数据将在提取固件文件系统时对攻击者可见，也会在运行时访问操作系统时对攻击者可见。如果有硬件，如**安全元素**（**SE**）或**可信执行环境**（**TEE**）可用，建议在运行时使用这些功能来存储敏感数据。否则，应评估使用强大的密码学来保护数据，使用服务器端计算来弥补硬件限制。
- en: If possible, all sensitive data in clear-text should be ephemeral by nature
    and reside in a volatile memory only. This recipe will give you some scenarios
    where data is used insecurely and how you can mitigate the insecure C code within
    an IoT device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，所有明文中的敏感数据应该是短暂的，并且只驻留在易失性内存中。这个配方将为您提供一些数据被不安全使用的场景，以及如何在IoT设备中减轻不安全的C代码。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Using programmatic examples, we will show how data is stored insecurely and
    how to remediate storage vulnerabilities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编程示例，我们将展示数据如何被不安全地存储以及如何纠正存储漏洞。
- en: 'In the following example, sensitive information is insecurely stored in the
    dynamically allocated memory referenced by `key`, which is copied to the dynamically
    allocated buffer, `new_key`, then processed and eventually deallocated by a call
    to `free()`. Because the memory is not cleared, it may be reallocated to another
    section of the program where the information stored in `new_key` may be inadvertently
    leaked:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，敏感信息不安全地存储在由`key`引用的动态分配的内存中，然后被复制到动态分配的缓冲区`new_key`中，然后通过调用`free()`最终被处理和释放。由于内存没有被清除，它可能被重新分配到程序的另一个部分，其中存储在`new_key`中的信息可能会被意外泄露：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To prevent this information leakage from occurring, dynamic memory containing
    sensitive information should be sanitized before being freed. Sanitization is
    commonly carried out by clearing the allocated space with `''\0''` characters,
    also known as zero out:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为防止发生信息泄漏，包含敏感信息的动态内存在被释放之前应该进行消毒。消毒通常是通过用`'\0'`字符清除分配的空间来进行的，也被称为清零：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example can be used in cases where devices do not have a hardware
    security chip available to separate OS processes and memory locations. Without
    a hardware security chip (for example, TPM or SE), or a TEE environment for ARM
    architectures, storing data securely is a challenge for embedded devices. Sometimes
    developers may store sensitive data in different storage partitions not available
    to the platform operating system however this is not a safe storage location either.
    Often, flash chips can be removed from PCB boards and taken to an offline location
    to be reviewed or data exfiltrated.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备没有硬件安全芯片用于分离操作系统进程和内存位置的情况下，可以使用上述示例。没有硬件安全芯片（例如TPM或SE），或者ARM架构的TEE环境，对于嵌入式设备来说，安全存储数据是一个挑战。有时开发人员可能会将敏感数据存储在对平台操作系统不可用的不同存储分区中，但这也不是一个安全的存储位置。通常，闪存芯片可以从PCB板上取下，并带到离线位置进行审查或数据外泄。
- en: New frameworks and OS platforms are being created to help solve this problem
    to store sensitive data. If an ARM Mbed OS is used, a device security layer called
    uVisor can be leveraged to isolate code blocks by limiting access to memory via
    hardware security features. Although Mbed is in its infancy, it has strong backing
    from large semiconductor companies and contains a platform for not only its operating
    system, but also cloud services.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建新的框架和操作系统平台，以帮助解决存储敏感数据的问题。如果使用ARM Mbed OS，则可以利用名为uVisor的设备安全层，通过硬件安全功能限制对内存的访问，从而隔离代码块。尽管Mbed还处于起步阶段，但它得到了大型半导体公司的大力支持，并包含了一个平台，不仅包括其操作系统，还包括云服务。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Details on uVisor can be found at the following site:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关uVisor的详细信息可以在以下网站找到：
- en: '[https://www.mbed.com/en/technologies/security/uvisor/](https://www.mbed.com/en/technologies/security/uvisor/)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.mbed.com/en/technologies/security/uvisor/](https://www.mbed.com/en/technologies/security/uvisor/)'
- en: 'Example code usage for uVisor can be found in the GitHub repository via the
    following URL:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uVisor的示例代码用法可以在GitHub存储库中找到，通过以下URL：
- en: '[https://github.com/ARMmbed/mbed-os-example-uvisor-number-store](https://github.com/ARMmbed/mbed-os-example-uvisor-number-store)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ARMmbed/mbed-os-example-uvisor-number-store](https://github.com/ARMmbed/mbed-os-example-uvisor-number-store)'
- en: 'For more information on Mbed OS, visit their site at the following URL:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Mbed OS的更多信息，请访问以下网址：
- en: '[https://www.mbed.com](https://www.mbed.com/)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.mbed.com](https://www.mbed.com/)'
- en: Hardening embedded frameworks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固嵌入式框架
- en: Designing and building embedded firmware can be complex, with all its dependencies
    and spaghetti makefiles that have not been touched for decades. Despite these
    common complexities, establishing a foundation to build secure software starts
    with the hardening of the platform and toolchain. Many Embedded Linux devices
    use BusyBox which contains common GNU utilities. There are certain configurations
    to be made to BusyBox and also updates for it as well. In addition to BusyBox,
    embedded frameworks, and toolchains should be modified to only those libraries
    and functions being used when configuring firmware builds. RTOS systems often
    have POSIX utilities available as well but configured by SoC, MCU, and chip vendors
    who have modified versions of common utilities. Embedded Linux build systems such
    as Buildroot, Yocto, and others perform the task of setting up and configuring
    the toolchain environment. Removal of known insecure libraries and protocols such
    as Telnet not only minimize attack entry points in firmware builds, but also provide
    a secure-by-design approach to building software an effort to thwart potential
    security threats. In this recipe, we will show how to use Buildroot to select
    and deselect network services and configurations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和构建嵌入式固件可能会很复杂，因为它涉及所有的依赖关系和几十年未被触及的混乱makefile。尽管存在这些常见的复杂性，但建立安全软件的基础始于加固平台和工具链。许多嵌入式Linux设备使用包含常见GNU实用程序的BusyBox。对BusyBox需要进行某些配置，也需要进行更新。除了BusyBox，嵌入式框架和工具链应该被修改为只包括在配置固件构建时使用的库和函数。RTOS系统通常也有POSIX实用程序可用，但由SoC、MCU和芯片供应商进行配置，他们拥有修改版本的常见实用程序。嵌入式Linux构建系统，如Buildroot、Yocto等，执行设置和配置工具链环境的任务。删除已知的不安全库和协议，如Telnet，不仅可以减少固件构建中的攻击入口点，还可以提供一种安全设计的方法来构建软件，以防范潜在的安全威胁。在本教程中，我们将展示如何使用Buildroot来选择和取消选择网络服务和配置。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, Buildroot will be used to demonstrate hardening.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，将使用Buildroot来演示加固。
- en: '**Buildroot** is a tool used to generate Embedded Linux systems through cross-compilation.
    Buildroot can be downloaded via the following site:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Buildroot**是通过交叉编译生成嵌入式Linux系统的工具。可以通过以下网站下载Buildroot：'
- en: '[https://buildroot.uclibc.org/download.html](https://buildroot.uclibc.org/download.html).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://buildroot.uclibc.org/download.html](https://buildroot.uclibc.org/download.html).'
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will first start with using Buildroot and opening up its menu options for
    configurations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Buildroot，并打开其菜单选项进行配置。
- en: 'Once Buildroot is downloaded, run the following command in the root of the
    Buildroot folder to show Buildroot''s configuration options:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Buildroot后，在Buildroot文件夹的根目录中运行以下命令，以显示Buildroot的配置选项：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other configuration user interfaces are available depending on preference,
    such as `xconfig`, and `gconfig`. For additional details, review Buildroot''s
    user manual at: [https://buildroot.uclibc.org/downloads/manual/manual.html](https://buildroot.uclibc.org/downloads/manual/manual.html).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据偏好，还可以使用其他配置用户界面，如`xconfig`和`gconfig`。有关更多详细信息，请查阅Buildroot的用户手册：[https://buildroot.uclibc.org/downloads/manual/manual.html](https://buildroot.uclibc.org/downloads/manual/manual.html)。
- en: 'The following screen should appear:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该出现以下屏幕：
- en: '![](img/b940eca2-6c98-4eb7-bb84-81d5036264c8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b940eca2-6c98-4eb7-bb84-81d5036264c8.png)'
- en: Here, configurations to a Linux firmware image can be made. For our purposes,
    we will walk you through how to choose secure daemons and secure defaults.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，可以对Linux固件映像进行配置。对于我们的目的，我们将向您展示如何选择安全的守护程序和安全的默认设置。
- en: 'Next, navigate to the Toolchain menu and enable stack protection support which
    uses the `-fstack-protector-all` build flag:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到工具链菜单，并启用堆栈保护支持，使用`-fstack-protector-all`构建标志：
- en: '![](img/98ad6f32-da38-4355-bcc3-5bf03a4093b2.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98ad6f32-da38-4355-bcc3-5bf03a4093b2.png)'
- en: 'Navigate to the home menu screen and enter the System configuration menu. Select
    Passwords encoding and choose sha-512:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到主菜单屏幕，并进入系统配置菜单。选择密码编码，并选择sha-512：
- en: '![](img/8429a2f7-cb90-4549-b4c2-af3060a1aeaf.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8429a2f7-cb90-4549-b4c2-af3060a1aeaf.png)'
- en: 'While in the System configuration page, we can create the root password for
    the firmware image. Here, we want to use a long alphanumeric password such as
    the one shown in the screenshot:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统配置页面，我们可以为固件映像创建根密码。在这里，我们希望使用一个长的字母数字密码，就像屏幕截图中显示的那样：
- en: '![](img/02cc8e17-c5c0-4e6b-a11d-4f31a8229a4b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02cc8e17-c5c0-4e6b-a11d-4f31a8229a4b.png)'
- en: 'Exit the System configuration menu and navigate to the Target packages menu
    option. Here, we can specify tools, libraries, daemons, and third-party code to
    include in a firmware image. There are many selections available depending on
    the device, so we will only use an example. The following screenshot shows openssh
    selected rather than Telnet:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出系统配置菜单，转到目标软件包菜单选项。在这里，我们可以指定要包含在固件映像中的工具、库、守护程序和第三方代码。根据设备的不同，可以选择许多选项，所以我们只使用一个示例。以下屏幕截图显示了选择openssh而不是Telnet：
- en: Only enable FTP if TLS is to be used. For Pure-FTPd, this requires custom compilation
    by passing `./configure --with-tls`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在要使用TLS时才启用FTP。对于Pure-FTPd，这需要通过传递`./configure --with-tls`进行自定义编译。
- en: '![](img/8d0fd502-8aa7-42d4-9f97-4fb750e13a5e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d0fd502-8aa7-42d4-9f97-4fb750e13a5e.png)'
- en: 'Navigate back to the Target packages menu and select the Shell and utilities
    submenu. Here, ensure only one shell interpreter is selected to decrease the attack
    surface:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到目标软件包菜单，并选择Shell和实用程序子菜单。在这里，确保只选择一个shell解释器，以减少攻击面：
- en: '![](img/2ee86680-4a80-4eb3-9ea8-418ed861e5cb.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ee86680-4a80-4eb3-9ea8-418ed861e5cb.png)'
- en: After all options have been selected, you would save your configuration, and
    select exit to leave the menuconfig options. Then, enter `make` from the Buildroot
    folder to build your configuration and toolchain.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有选项后，保存配置，并选择退出以离开menuconfig选项。然后，从Buildroot文件夹输入`make`来构建您的配置和工具链。
- en: 'Similar steps can be taken when using the Yocto build system by ensuring recipes
    are updated and configured with only the required packages. There are several
    other configurations that can be made to harden the Linux build environment, that
    consist of the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Yocto构建系统时，可以采取类似的步骤，确保食谱已更新并配置为仅包含所需的软件包。还有其他几个配置可以用来加固Linux构建环境，包括以下内容：
- en: Removing unused language interpreters such as Perl, Python, and Lua.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除未使用的语言解释器，如Perl、Python和Lua。
- en: Removing dead code from unused library functions.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从未使用的库函数中删除死代码。
- en: Removing legacy insecure daemons, which includes but is not limited to Telnet,
    FTP, and TFTP.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除遗留的不安全守护程序，包括但不限于Telnet、FTP和TFTP。
- en: Remove unused shell utilities from Busybox such as grep, awk, wget, curl and
    sed.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Busybox中删除未使用的shell实用程序，如grep、awk、wget、curl和sed。
- en: Hardening a library or service to support encryption.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加固库或服务以支持加密。
- en: Ensuring all packages and libraries chosen for a build are using the most up-to-date
    versions.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保构建所选的所有软件包和库都使用最新版本。
- en: Use the latest Linux kernel.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最新的Linux内核。
- en: Disable IPv4 Forwarding
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用IPv4转发
- en: Disable IP Source Routing
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用IP源路由
- en: Disable ICMP
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用ICMP
- en: Ignore all broadcast message
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略所有广播消息
- en: Disable IPV6
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用IPV6
- en: Enable TCP SYN Cookie Protection
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用TCP SYN Cookie保护
- en: Use Linux Security Modules (including SELinux).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Linux安全模块（包括SELinux）。
- en: Use free tools such as Lynis ([https://raw.githubusercontent.com/CISOfy/lynis/master/lynis](https://raw.githubusercontent.com/CISOfy/lynis/master/lynis))
    for hardening suggestions after the build.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建后使用免费工具，如Lynis ([https://raw.githubusercontent.com/CISOfy/lynis/master/lynis](https://raw.githubusercontent.com/CISOfy/lynis/master/lynis))，以获得加固建议。
- en: The preceding list is by no means exhaustive. Performing iterative threat model
    exercises with developers, as well as relative stakeholders, on software running
    on the embedded device ensures low hanging fruit such as vulnerable outdated software,
    and is not introduced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并不是详尽无遗的。与开发人员以及相关利益相关者一起进行迭代的威胁模型练习，以确保嵌入式设备上运行的软件不会引入易受攻击的过时软件等低挂果。
- en: Securing third-party code and components
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护第三方代码和组件
- en: Following the setup of the toolchain, it is important to ensure that the software
    packages and third-party upstream libraries remain updated to protect against
    publicly known vulnerabilities once the IoT device is in production. Black box
    third-party software such as RomPager, NetUSB, and embedded build tools such as
    Buildroot, should be checked against vulnerability databases as well as their
    changelogs to decide when and if an update is needed. using upstream BSP drivers
    is not an easy task; changes to libraries and upstream BSP drivers should be tested
    by development teams prior to release builds, as updates can cause unforeseen
    dependency issues.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置工具链之后，重要的是确保软件包和第三方上游库保持更新，以防止在物联网设备投入生产后出现已知的公开漏洞。黑盒第三方软件，如RomPager、NetUSB和嵌入式构建工具，如Buildroot，也应该根据漏洞数据库以及它们的变更日志进行检查，以决定何时以及是否需要更新。使用上游BSP驱动程序并不是一件容易的事；在发布构建之前，开发团队应该测试库和上游BSP驱动程序的更改，因为更新可能会导致意想不到的依赖问题。
- en: Embedded projects and applications should maintain a Bill of Materials (BOM)
    of the third-party libraries and open source software included in its firmware
    images. This is sometimes a requirement for certain regulated regions of the world
    and also for GPL but maintaining a BOM also improves management of assets as well
    as libraries. This Bill of Materials should be checked to confirm that none of
    the third-party software included has any unpatched vulnerabilities or known issues.
    Up-to-date vulnerability information may be found through the **National Vulnerability
    Database** (**NVD**), Open Hub or similar third-party sites.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式项目和应用程序应该维护一个包含固件镜像中包含的第三方库和开源软件的清单（BOM）。这在世界某些受监管地区和GPL中有时是一个要求，同时维护BOM也有助于改善资产和库的管理。应该检查这个清单，以确认其中没有包含任何未修补的漏洞或已知问题的第三方软件。最新的漏洞信息可以通过**国家漏洞数据库**（**NVD**）、Open
    Hub或类似的第三方网站找到。
- en: It is important to ensure all unnecessary pre-production build code, as well
    as dead and unused application code, have been removed prior to firmware release
    to all market segments. This includes, but is not limited to, potential backdoor
    code and root privilege accounts that may have been left by parties such as **Original
    Design Manufacturers** (**ODMs**), suppliers, and third-party contractors for
    testing or customer support purposes. Generally, this falls within the scope of
    **Original Equipment Manufacturers** (**OEMs**) to perform, via reverse engineering
    of binaries using the methodology described in [Chapter 3](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml),
    *Analyzing and Exploiting Firmware*. To prevent the extra labor overhead by OEMs,
    ODMs should agree to a **Master Service Agreements** (**MSAs**), ensuring that
    no backdoor code or user accounts are included and that all code has been reviewed
    for software security vulnerabilities holding third-party developer companies
    accountable for devices that are mass deployed to the market. Additionally, consider
    verbiage that requires ODMs to have information security personnel on staff as
    well as establishing a service level agreement (SLA) to fix critical security
    vulnerabilities. This recipe will show you the methods of securing third-party
    code and components using freely available tools.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在固件发布到所有市场细分之前，确保删除所有不必要的预生产构建代码，以及死代码和未使用的应用程序代码非常重要。这包括但不限于可能由**原始设计制造商**（**ODMs**）、供应商和第三方承包商留下的用于测试或客户支持目的的后门代码和根权限帐户。通常，这是**原始设备制造商**（**OEMs**）的职责，通过使用[第3章](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml)中描述的方法对二进制文件进行逆向工程，即*分析和利用固件*。为了防止OEMs的额外劳动力开销，ODMs应同意**主服务协议**（**MSAs**），确保不包括后门代码或用户帐户，并且所有代码都已经过审查，以查找软件安全漏洞，并追究第三方开发公司对大规模部署到市场上的设备的责任。此外，还要考虑要求ODMs有信息安全人员，并建立服务级别协议（SLA）来修复关键的安全漏洞。这个食谱将向您展示如何使用免费可用的工具来保护第三方代码和组件。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following tools are required for this recipe:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要以下工具：
- en: '**RetireJS**: RetireJS detects the use of JavaScript libraries with known vulnerabilities.
    RetireJS can be downloaded via its GitHub repository ([https://github.com/RetireJS/retire.js](https://github.com/RetireJS/retire.js))
    or via `npm` using the following command:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RetireJS**：RetireJS可以检测使用已知漏洞的JavaScript库。RetireJS可以通过其GitHub存储库（[https://github.com/RetireJS/retire.js](https://github.com/RetireJS/retire.js)）或通过`npm`使用以下命令进行下载：'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Node Security Platform** (**NSP**): NSP detects the use of known vulnerable
    NodeJS packages for a project. NSP can be installed via its GitHub repository
    ([https://github.com/nodesecurity/nsp](https://github.com/nodesecurity/nsp)) or
    via `npm` using the following command:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node Security Platform**（**NSP**）：NSP可以检测项目中使用的已知有漏洞的NodeJS软件包。NSP可以通过其GitHub存储库（[https://github.com/nodesecurity/nsp](https://github.com/nodesecurity/nsp)）或通过`npm`使用以下命令进行安装：'
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**LibScanner**: LibScanner is a free tool that parses RPM or SWID package lists
    against the NVD databases used for Yocto build environments. LibScanner can be
    downloaded from its GitHub repository at [https://github.com/DanBeard/LibScanner](https://github.com/DanBeard/LibScanner).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LibScanner**：LibScanner是一个免费工具，用于对Yocto构建环境中使用的RPM或SWID软件包列表进行解析，并与NVD数据库进行比对。LibScanner可以从其GitHub存储库下载，网址为[https://github.com/DanBeard/LibScanner](https://github.com/DanBeard/LibScanner)。'
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Many IoT devices run variations of JavaScript code to help alleviate hardware
    resource consumption. Sometimes, this code is also running on the device when
    it needs to act as a server for certain use cases. There are great tools that
    scan project directories for known vulnerable JavaScript versions used in the
    project. First, we will have a look at RetireJS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多物联网设备运行各种JavaScript代码，以帮助减轻硬件资源消耗。有时，当设备需要作为某些用例的服务器时，这些代码也会在设备上运行。有一些很好的工具可以扫描项目目录，查找项目中使用的已知有漏洞的JavaScript版本。首先，我们来看一下RetireJS。
- en: 'To run RetireJS, simply run the `retire` command and specify the JavaScript
    directory as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行RetireJS，只需运行`retire`命令，并指定JavaScript目录如下：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The scan found two vulnerable jQuery libraries used in the project, along with
    supplemental reading as well as explanations. These findings may have opened up
    the device to an attack in the future, but it is much cheaper to discover these
    types of issues prior to production.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描发现项目中使用了两个有漏洞的jQuery库，以及相关的阅读和解释。这些发现可能会在未来打开设备的漏洞，但在生产之前发现这些问题要便宜得多。
- en: 'A great NodeJS vulnerability scanner is NSP. Like RetireJS, NSP can be executed
    by calling `nsp` and the path to the NodeJS project directory or `packages.json`,
    as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个很好的NodeJS漏洞扫描工具是NSP。与RetireJS一样，可以通过调用`nsp`并指定NodeJS项目目录或`packages.json`来执行NSP，如下：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: NSP discovered a vulnerable library that could have exposed the device to a
    commend injection, a common vulnerability in IoT.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: NSP发现了一个有漏洞的库，可能会导致设备受到命令注入攻击，这是物联网中常见的漏洞。
- en: 'If the IoT device''s build system is using Yocto, the free LibScanner tool
    can be used to query the NVD database against known vulnerable libraries that
    are in the project''s installed packages list. To get started with LibScanner,
    update the vulnerability database by running the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果IoT设备的构建系统使用Yocto，则可以使用免费的LibScanner工具来查询NVD数据库，以查找项目安装的软件包列表中已知的易受攻击的库。要开始使用LibScanner，请通过运行以下命令更新漏洞数据库：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the NVD database is updated, run LibScanner against the Yocto `installed-packages.txt`
    file as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新NVD数据库后，可以按照以下方式运行LibScanner来对Yocto的`installed-packages.txt`文件进行扫描：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Upon execution, review the `cve_results.xml` file which contains not only the
    scan results of vulnerable files but also unit tests in xUnit format:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，请查看`cve_results.xml`文件，其中包含易受攻击文件的扫描结果以及xUnit格式的单元测试：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are several tools that can perform static tasks prior to a device's build
    or dynamic checks that run after a device build and during the device's runtime.
    In previous chapters, dynamic tools have been discussed such as OWASP ZAP for
    web application testing, as well as tools such as Lynis, which can be run directly
    on the device's command-line interface. All of these tighten up the security posture
    of the device and minimize the likelihood of a successful attack on the device.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备构建之前可以使用几种工具执行静态任务，或者在设备构建后和设备运行时执行动态检查。在之前的章节中，已经讨论了动态工具，比如用于Web应用程序测试的OWASP
    ZAP，以及可以直接在设备命令行界面上运行的Lynis等工具。所有这些都可以加强设备的安全性，并最大程度地减少设备遭受成功攻击的可能性。
- en: In this chapter, we discussed several best practices to be incorporated in building
    as well as writing firmware. It is recommended to perform your own due diligence
    according to your operating system platform (that is, Embedded Linux, RTOS, Windows
    IoT, and so on.) for specific security controls relevant to your IoT device.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在构建和编写固件中应该纳入的几种最佳实践。建议根据您的操作系统平台（即嵌入式Linux、RTOS、Windows IoT等）执行自己的尽职调查，以获取与您的IoT设备相关的特定安全控制。
