- en: Reverse Engineering Linux Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程Linux应用程序
- en: 'Reverse engineering, as we already know, is the process of taking an executable
    program and obtaining its source or machine-level code to see how the tool was
    built and to potentially exploit vulnerabilities. The vulnerabilities in the context
    of reverse engineering are typically software bugs that the programmers deal with
    when they are found by development and security researchers. In this chapter,
    we will look at how we can perform reverse engineering with Linux applications.
    We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程，正如我们已经知道的，是获取可执行程序并获取其源代码或机器级代码的过程，以查看工具是如何构建的，并可能利用漏洞。逆向工程的上下文中的漏洞通常是开发人员和安全研究人员发现的软件错误。在本章中，我们将看看如何使用Linux应用程序进行逆向工程。本章将涵盖以下主题：
- en: Fuzzing Linux applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊化Linux应用程序
- en: Linux and assembly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux和汇编
- en: Linux and stack buffer overflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux和堆栈缓冲区溢出
- en: Linux and heap buffer overflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux和堆缓冲区溢出
- en: Formatting string bugs in Linux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中格式化字符串错误
- en: Debugger
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试器
- en: The usual approach to understanding the behavior of an executable program is
    to attach it to a debugger and to set break points at various locations to interpret
    the code flow of the software under test. A **debugger**, as the name suggests,
    is a software utility or a computer program that can be used by programmers to
    debug their programs or software. It also lets programmers see the assembly of
    the code that is being executed. A debugger is capable of displaying the exact
    stack on which the code is executed. A debugger is capable of displaying the assembly
    level equivalent of the high-level programming language code written. Thus, a
    debugger shows the execution flow of the program in terms of execution stack for
    function calls, registers, and their addresses/values for program variables, and
    so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解可执行程序行为的常规方法是将其附加到调试器，并在各个位置设置断点，以解释测试软件的代码流。**调试器**是一个软件实用程序或计算机程序，程序员可以使用它来调试他们的程序或软件。它还允许程序员查看正在执行的代码的汇编。调试器能够显示代码执行的确切堆栈。调试器能够显示高级编程语言代码的汇编级等效。因此，调试器以执行堆栈的形式显示程序的执行流程，用于函数调用的寄存器，以及程序变量的地址/值等。
- en: 'Let''s take a look at the debuggers that we are going to cover in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将在本章中涵盖的调试器：
- en: 'The Evans Linux debugger: This is a native Linux debugger, and we don''t need
    wine to run it; it comes in a `tar.gz` file. Download the source code, extract
    it, and copy it to your computer. The installation steps required are shown here:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Evans Linux调试器：这是一个本地Linux调试器，我们不需要wine来运行它；它以`tar.gz`文件的形式提供。下载源代码，提取并复制到您的计算机。所需的安装步骤如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Either add this to the environment variable path or go to the installation
    directory and run `./edb` to launch the debugger. This will give us the following
    interface:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要么将其添加到环境变量路径中，要么转到安装目录并运行`./edb`来启动调试器。这将给我们以下界面：
- en: '![](img/2f9d37c5-cd50-4c93-ab78-5890ac2a424c.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f9d37c5-cd50-4c93-ab78-5890ac2a424c.png)'
- en: 'Let''s open the `edb exe/linux` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`edb exe/linux`文件：
- en: '![](img/95d1fae1-ceb2-49cd-9d86-b87d6fd0d2b8.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95d1fae1-ceb2-49cd-9d86-b87d6fd0d2b8.png)'
- en: 'GDB/GNU debugger: This is a very old debugger and is commonly found by default
    in Ubuntu. It is a nice debugger but doesn''t have many features. To run it, simply
    type `gdb` and its prompt will open. It is, by default, a CLI tool:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB/GNU调试器：这是一个非常古老的调试器，通常在Ubuntu中默认找到。它是一个不错的调试器，但功能不多。要运行它，只需输入`gdb`，它的提示符就会打开。默认情况下，它是一个CLI工具。
- en: '![](img/6d8fb033-ae3f-40f8-9e03-484bf219ae27.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8fb033-ae3f-40f8-9e03-484bf219ae27.png)'
- en: Another good tool is idea-pro, but this is a commercial tool and is not free.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个好的工具是idea-pro，但这是一个商业工具，不是免费的。
- en: Fuzzing Linux applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊化Linux应用程序
- en: '**Fuzzing** is a technique used to discover bugs in an application that make
    the application crash when presented with input that was not anticipated by the
    application. Fuzzing typically involves the use of automated tools or scripts
    that send large strings to an application that would cause an application to break. The
    idea behind fuzzing is to discover vulnerabilities or bugs that, if found, could
    lead to catastrophic consequences. These vulnerabilities could belong to either
    the following categories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊化**是一种用于发现应用程序中的错误的技术，当应用程序收到未经应用程序预期的输入时，应用程序会崩溃。模糊化通常涉及使用自动化工具或脚本发送大型字符串到可能导致应用程序崩溃的应用程序。模糊化的想法是发现漏洞或错误，如果发现，可能会导致灾难性后果。这些漏洞可能属于以下类别之一：'
- en: Buffer overflow vulnerabilities
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出漏洞
- en: String format vulnerabilities
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式漏洞
- en: Fuzzing is the technique of sending randomly generated code to our test program
    with the intention of crashing it or seeing how it might behave on different inputs. Fuzzing
    is an automated way of sending payloads of different lengths to the program that
    is being tested, to see whether the program behaves strangely or unexpectedly
    at any point. If any exception conditions are observed during fuzzing, the payload
    length that caused the program to behave unexpectedly is marked. This helps the
    tester to further evaluate whether there is a possibility of exploitation. Put
    simply, fuzzing forms the first step of detecting whether there is a potential
    vulnerability of type overflow in the application being tested.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊化是将随机生成的代码发送到我们的测试程序的技术，目的是使其崩溃或查看它在不同输入下的行为。模糊化是以自动化方式向正在测试的程序发送不同长度的有效负载，以查看程序是否在任何时候表现出奇怪或意外的行为。如果在模糊化期间观察到任何异常情况，则标记导致程序出现意外行为的有效负载长度。这有助于测试人员进一步评估是否存在溢出类型的潜在漏洞。简而言之，模糊化是检测正在测试的应用程序中是否存在潜在溢出漏洞的第一步。
- en: 'An effective fuzzer generates semi-valid inputs that are **valid enough** in
    that they are not directly rejected by the parser, but that create unexpected
    behaviors deeper in the program and are **invalid enough** to expose corner cases
    that have not been properly dealt with. One tool that we can use for fuzzing is
    **Zzuf**. This is a very nice fuzzing tool that can be used with Linux-based systems.
    The installation steps are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的fuzzer生成半有效的输入，这些输入在解析器中不会被直接拒绝，但会在程序的更深层次上创建意外行为，并且足够无效，以暴露未正确处理的边缘情况。我们可以用于fuzzing的一个工具是**Zzuf**。这是一个非常好的fuzzing工具，可以在基于Linux的系统上使用。安装步骤如下：
- en: 'Download Zzuf from the GitHub source and install it manually using the following
    commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub源下载Zzuf并手动安装它，使用以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, however, we will focus on carrying out fuzzing with our native Python
    code. To understand how fuzzing can be done, let's take an example of a sample
    C code, which takes an input from the user, but does not perform the necessary
    checks on the input passed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里，我们将专注于使用我们的本机Python代码进行fuzzing。要了解如何进行fuzzing，让我们以一个示例C代码为例，该代码从用户那里获取输入，但没有对传递的输入执行必要的检查。
- en: Fuzzing in action
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fuzzing在行动
- en: 'Let''s take a basic code written in C, that takes a user input and displays
    it on the terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个用C编写的基本代码，它接受用户输入并在终端上显示它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following table explains the fields used in the preceding code block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了前面代码块中使用的字段：
- en: '| Field | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| `int fildes` | The file descriptor of where to read the input. You can either
    use a file descriptor obtained from the open ([http://codewiki.wikidot.com/c:system-calls:open](http://codewiki.wikidot.com/c:system-calls:open))
    system call, or you can use 0, 1, or 2, to refer to standard input, standard output,
    or standard error, respectively. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `int fildes` | 要读取输入的文件描述符。您可以使用从open ([http://codewiki.wikidot.com/c:system-calls:open](http://codewiki.wikidot.com/c:system-calls:open))系统调用获得的文件描述符，或者您可以使用0、1或2，分别表示标准输入、标准输出或标准错误。|'
- en: '| `const void *buf` | A character array where the read content is stored. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `const void *buf` | 读取内容存储的字符数组。|'
- en: '| `size_t nbytes` | The number of bytes to read before truncating the data.
    If the data to be read is smaller than *n* bytes, all data is saved in the buffer.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `size_t nbytes` | 截断数据之前要读取的字节数。如果要读取的数据小于*n*字节，则所有数据都保存在缓冲区中。|'
- en: '| `return value` | Returns the number of bytes that were read. If the value
    is negative, then the system call returns an error. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `return value` | 返回读取的字节数。如果值为负数，则系统调用返回错误。|'
- en: We can see that this simple program attempts to read from the console (specified
    by the 0 value of the file descriptor), and whatever it reads from the console
    window, it attempts to place in the locally created array variable called `arr`.
    Now `arr` acts as a buffer in this code with a maximum size of 400\. We know that
    a character datatype in C can hold 1 byte, which means that as long as our input
    is <=400 characters, the code should work fine, but if the input given is more
    than 400 characters, we may encounter an overflow or a segmentation fault, as
    we would be attempting to save more than the buffer `arr` can potentially hold.
    Looking at the preceding code, we can see straight away that more than 400 bytes
    of input will break the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个简单的程序试图从控制台读取（由文件描述符的值0指定），并且无论它从控制台窗口读取什么，它都试图放在本地创建的名为`arr`的数组变量中。现在`arr`在这段代码中充当缓冲区，最大大小为400。我们知道C中的字符数据类型可以保存1个字节，这意味着只要我们的输入<=400个字符，代码应该可以正常工作，但如果输入超过400个字符，我们可能会遇到溢出或分段错误，因为我们会尝试保存的内容超过了缓冲区`arr`的容量。从前面的代码中可以立即看到，超过400字节的输入将破坏代码。
- en: 'Imagine that we didn''t have access to the source code of the application. Then,
    for us to figure out the size of the buffer, we have the following three options:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们无法访问应用程序的源代码。那么，为了弄清楚缓冲区的大小，我们有以下三个选项：
- en: The first option is to reverse engineer it to see the mnemonics or assembly
    level code of the application. Who wants to do that!
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项是对其进行逆向工程，以查看应用程序的助记符或汇编级别代码。谁想这样做呢！
- en: Many modern day decompilers also give us a source code equivalent of the original
    application. For a small example like ours, this would be a good choice, but if
    the executable in question is thousands of lines of code, we might want to avoid
    this option as well.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多现代反编译器还为我们提供了原始应用程序的源代码等效物。对于我们这样的一个小例子，这将是一个不错的选择，但如果问题中的可执行文件有数千行代码，我们可能也要避免选择这个选项。
- en: The third and generally preferred approach is to take the application as a black
    box and identify the places where it expects the user to specify an input. These
    would be our injection points in which we would specify strings of varying lengths
    to see if the program crashes and, if it does, where this would happen.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种通常首选的方法是将应用程序视为黑盒，并确定它期望用户指定输入的位置。这些将是我们的注入点，在这些点上，我们将指定不同长度的字符串，以查看程序是否崩溃，如果崩溃，会发生在哪里。
- en: Let's compile our source code to generate the object file of C that we shall
    run and fuzz as a black box.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译我们的源代码以生成我们将作为黑盒运行和fuzz的C对象文件。
- en: 'By default, Linux systems are safe and they come with all sort of protection
    against buffer overflows. For this reason, while compiling the source code, we
    will disable the inbuilt protections as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Linux系统是安全的，并且它们配备了各种防止缓冲区溢出的保护措施。因此，在编译源代码时，我们将禁用内置的保护，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command would produce the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将产生以下截图：
- en: '![](img/9887237f-aa44-4959-956c-e0e9c9992f3c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9887237f-aa44-4959-956c-e0e9c9992f3c.png)'
- en: 'Let''s run our object file in a single line by piping the output of `echo`
    command to it. This will be automated using Python and fuzzing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的对象文件，通过将`echo`命令的输出传输到它来进行单行操作。这将使用Python和fuzzing自动化：
- en: '![](img/df6c9fe1-2555-487b-89bc-9d25ce8f7319.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df6c9fe1-2555-487b-89bc-9d25ce8f7319.png)'
- en: 'We know that `./buff` is our out-file that can be executed as an executable.
    Let''s assume that we know the actual source code of the file to see how we can
    use Python to fuzz the file. Let''s create a basic Python-fuzzing script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`./buff`是我们的输出文件，可以作为可执行文件执行。假设我们知道文件的实际源代码，我们可以使用Python来模糊文件。让我们创建一个基本的Python模糊脚本：
- en: '![](img/ea636bd1-bfa9-453c-8eae-f8bdae7babb6.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea636bd1-bfa9-453c-8eae-f8bdae7babb6.png)'
- en: 'Let''s run the preceding Python code to see how and what effects fuzzing has
    and how would it break the application to get us close to the crash point:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的Python代码，看看模糊测试的效果以及它如何使应用程序崩溃，使我们接近崩溃点：
- en: '![](img/8abd591b-7729-4753-8373-a1c64d3f3219.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8abd591b-7729-4753-8373-a1c64d3f3219.png)'
- en: 'As can be seen from the previous output, the point where the application crashes
    is somewhere between 400 and 500 bytes, which is where the actual crash lies.
    To be more precise, we can use a smaller step size for `i` and arrive at the following
    with a `step size=10`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，应用程序崩溃的地方在400到500字节之间，这就是实际的崩溃点。更准确地说，我们可以使用较小的步长`i`，并以`步长=10`到达以下结果：
- en: '![](img/df3931d1-4420-4f51-8cc8-709bfb63a3bd.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df3931d1-4420-4f51-8cc8-709bfb63a3bd.png)'
- en: The preceding screenshot gives us more granular information and tells us that
    the application crashes at an input length between `411` and `421`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图为我们提供了更详细的信息，并告诉我们应用程序在输入长度为`411`和`421`之间崩溃。
- en: Linux and assembly code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux和汇编代码
- en: 'In this section, we will read about the assembly language. The objective is
    to take a C code, translate it to an assembly, and see the proceedings. The sample
    C code that we will be loading and using is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习有关汇编语言的知识。目标是将C代码转换为汇编代码，并查看执行过程。我们将加载和使用的示例C代码如下：
- en: '![](img/6254c14b-e991-49da-a77d-7377d3038bfc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6254c14b-e991-49da-a77d-7377d3038bfc.png)'
- en: 'Let''s now run this program from the command line as `./buff` and try to attach
    this executable program to the Evans debugger as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从命令行运行这个程序，作为`./buff`，并尝试将这个可执行程序附加到Evans调试器：
- en: '![](img/54679166-b600-4abd-b641-2a132e7c9e66.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54679166-b600-4abd-b641-2a132e7c9e66.png)'
- en: 'We now attach our running code to the launched Evans debugger from the GUI
    by going to the **File** | **Attach** option. We attach the executable as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过GUI将我们运行的代码附加到启动的Evans调试器，方法是转到**文件** | **附加**选项。我们将可执行文件附加如下：
- en: '![](img/5a4876cf-56d3-4cfe-b014-f18903173f8d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a4876cf-56d3-4cfe-b014-f18903173f8d.png)'
- en: 'When we click on **OK**, the object file will be attached to the debugger and
    we will be able to see the associated assembly level code with it as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**OK**时，对象文件将被附加到调试器，并且我们将能够看到与之关联的汇编级别代码，如下所示：
- en: '![](img/90514aff-7754-4012-9722-f5048cc18342.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90514aff-7754-4012-9722-f5048cc18342.png)'
- en: 'The top-right section of the window displays the assembly code of the application
    under test. The top-left section represents the registers and their corresponding
    contents. The section just below the assembly code displays the method that will
    be invoked when the user inputs the data on the console, which is our read-system
    call. The section at the bottom of the screen represents the memory dump, wherein
    the contents of the memory is displayed both in Hexadecimal and ASCII format.
    Let''s see how the application cleanly exists when we specify a value that is
    less than 400 characters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的右上部分显示了被测试应用程序的汇编代码。左上部分表示寄存器及其相应的内容。汇编代码下方的部分显示了用户在控制台上输入数据时将调用的方法，即我们的读取系统调用。屏幕底部的部分表示内存转储，其中以十六进制和ASCII格式显示了内存的内容。让我们看看当我们指定一个小于400个字符的值时，应用程序是如何干净地退出的：
- en: '![](img/d2baf991-ee01-4e9a-acf0-7b30a77e9089.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2baf991-ee01-4e9a-acf0-7b30a77e9089.png)'
- en: 'Now, let''s input a value that is greater than 400 bytes and see what happens
    to our registers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们输入一个大于400字节的值，看看我们的寄存器会发生什么变化：
- en: '![](img/d2d73e0d-8a0e-4cb2-aae5-75e1680fe732.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d73e0d-8a0e-4cb2-aae5-75e1680fe732.png)'
- en: 'When we pass this input, we arrive at the following state:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递这个输入时，我们会得到以下状态：
- en: '![](img/6fdf4144-5758-4963-99e7-a355341bac30.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fdf4144-5758-4963-99e7-a355341bac30.png)'
- en: It can be seen in the preceding screenshot that the value we passed gets written
    in the register RSP. For a 64-bit architecture, the register RSP holds the address
    of the next instruction to be executed and, as the value overflowed from the `arr` buffer,
    some was written to the register RSP. The program fetched the contents of RSP
    to go to the next instruction that it was meant to execute and since it arrived
    to `aaaaaaaaaa`, it crashed, as this is an invalid address. It should be noted
    that `0X6161616161`, as shown in the previous screenshot, is the hexadecimal equivalent
    of `aaaaaaaaaa`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，我们传递的值被写入寄存器RSP。对于64位架构，寄存器RSP保存下一条要执行的指令的地址，由于值从`arr`缓冲区溢出，一些值被写入寄存器RSP。程序获取了RSP的内容以执行下一条指令，由于它到达了`aaaaaaaaaa`，程序崩溃了，因为这是一个无效的地址。应该注意的是，如前面的屏幕截图所示，`0X6161616161`是`aaaaaaaaaa`的十六进制等价物。
- en: Stack buffer overflow in Linux
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的堆栈缓冲区溢出
- en: Most vulnerabilities are flaws that arise due to conditions that the developer
    hasn't thought of. The most common vulnerability is a stack buffer overflow. This
    means that we define some sort of buffer that is not large enough for the storage
    we require. This is more of a problem when the input is controlled by the end-level
    user because this means it can be exploited.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数漏洞是由开发人员没有考虑到的条件导致的。最常见的漏洞是堆栈缓冲区溢出。这意味着我们定义了某种不足以存储所需数据的缓冲区。当输入由最终用户控制时，这就成为了一个问题，因为这意味着它可以被利用。
- en: In software, a stack buffer overflow or stack buffer overrun occurs when a program
    writes to a memory address on the program's call stack (as we know, every function
    has its own execution stack or is allocated a stack memory where it is executed)
    outside the intended data structure, which is usually a fixed-length buffer. A
    stack buffer overflow almost always results in the corruption of the adjacent
    data on the stack, and in cases where the overflow was triggered by mistake, this
    will often cause the program to crash or operate incorrectly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，堆栈缓冲区溢出或堆栈缓冲区溢出发生在程序写入程序调用堆栈上的内存地址（正如我们所知，每个函数都有自己的执行堆栈或分配一个堆栈内存来执行）超出预期数据结构的范围时。这通常是一个固定长度的缓冲区。堆栈缓冲区溢出几乎总是导致堆栈上相邻数据的损坏，在溢出是由错误触发时，这通常会导致程序崩溃或操作不正确。
- en: Let's assume that we have a memory cell `a` that can hold two bytes of data
    and that next to this memory cell `a` we have another memory cell `b` that can
    also hold two bytes of data. Let's also assume that both of these memory cells
    are placed on a stack adjacent to each other. If `a` is given more than two bytes
    of data, the data will actually spill over and it will be written to `b` instead,
    which was not expected by the programmer. Buffer overflow exploits capitalize
    on this process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个可以容纳两个字节数据的内存单元`a`，并且在这个内存单元`a`旁边有另一个内存单元`b`，它也可以容纳两个字节的数据。假设这两个内存单元都放置在相邻的堆栈上。如果`a`给出超过两个字节的数据，数据将实际上溢出并被写入`b`，这是程序员所不期望的。缓冲区溢出利用了这个过程。
- en: 'The instruction stack pointer is the pointer that points toward the address
    of the next instruction to be executed. Thus, whenever any instruction is executed,
    the contents of the IP gets updated. When a method is called and the activation
    record for that method is created, the following steps are performed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 指令堆栈指针是指向下一条要执行的指令的地址的指针。因此，每当执行任何指令时，IP的内容都会得到更新。当调用方法并创建该方法的激活记录时，执行以下步骤：
- en: An activation record or stack frame is created.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建激活记录或堆栈帧。
- en: The **Current Instruction Pointer** (**CIP**) and the **Current Environment
    Pointer** (**CEP**) (from the caller) are saved on the stack frame as a return
    point.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当前指令指针**（CIP）和**当前环境指针**（CEP）（来自调用者）被保存在堆栈帧上作为返回点。'
- en: The CEP is assigned the address of the stack frame.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CEP被分配为堆栈帧的地址。
- en: The CIP is assigned the address of the first instruction in the code segment.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CIP被分配为代码段中第一条指令的地址。
- en: The execution continues from the address in the CIP.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行从CIP中的地址继续。
- en: 'When a stack has finished its execution and there are no more instructions
    or commands left in the stack to get executed, the following steps are performed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆栈执行完毕并且没有更多的指令或命令可以执行时，执行以下步骤：
- en: The old values of the CIP and the CEP are retrieved from the return point location
    of the stack frame.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CEP和CIP的旧值从堆栈帧的返回点位置中检索出来。
- en: Using the value of CEP, we jump back to the caller function.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CEP的值，我们跳回到调用者函数。
- en: Using the value of CIP, we resume processing from the last instruction.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CIP的值，我们从最后一条指令中恢复处理。
- en: 'By default, the stack looks as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，堆栈如下所示：
- en: '![](img/f01fc8c9-2445-4fb3-b2d7-eb1e16643d52.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f01fc8c9-2445-4fb3-b2d7-eb1e16643d52.png)'
- en: It can now be seen that the return address lies at the bottom of the stack and
    that it actually contains the value of the old CEP. We call it a stack frame pointer.
    In technical terms, when the value of a buffer is overwritten and spilled, it
    completely fills up all the memory associated to a local variable space of the
    stack and then gets written to the return address portion of the stack and causes
    a buffer overflow. When all the memory space is occupied on the buffer, by convention,
    the contents of the return point is fetched to make the jump back to the caller.
    Since the address is overwritten by the data passed on from the user, however,
    this results in an invalid memory location, therefore causing a segmentation fault.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以看到返回地址位于堆栈底部，实际上包含了旧的CEP的值。我们称之为堆栈帧指针。在技术术语中，当缓冲区的值被覆盖并溢出时，它会完全填满与堆栈的本地变量空间相关的所有内存，然后被写入堆栈的返回地址部分，导致缓冲区溢出。当缓冲区上的所有内存空间被占用时，按照惯例，返回点的内容被提取以进行跳转回调用者。然而，由于地址被用户传递的数据覆盖，这导致了无效的内存位置，因此导致分段错误。
- en: This is where things get interesting. It should be noted that the data that
    the user passes and the local variables of the stack are actually implemented
    as registers, and thus the value we would pass would get stored in certain registers
    on the stack. Now, since whatever input the user is passing is getting written
    to certain registers and finally to the return point, what if we are able to inject
    shell code in a register `X` at a location `12345`? Since we are able to write
    to the return point of the stack, what if we write `12345` at the return point?
    This will result in the control being transferred to location `12345`, which would
    in turn result in the execution of our shell code. This is how buffer overflows
    can be exploited to grant us the shell of the victim's machine. Now that we have
    a better understanding of buffer overflow, let's see it in action in the following
    section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有趣的地方。应该注意的是，用户传递的数据和堆栈的本地变量实际上是作为寄存器实现的，因此我们传递的值将存储在堆栈上的某些寄存器中。现在，由于用户传递的任何输入都被写入某些寄存器，最终被写入返回点，如果我们能够在位置`12345`的寄存器`X`中注入shell代码会怎么样？由于我们能够写入堆栈的返回点，如果我们在返回点写入`12345`会怎样？这将导致控制转移到位置`12345`，这将导致执行我们的shell代码。这就是缓冲区溢出如何被利用来授予我们受害者机器的shell。现在我们对缓冲区溢出有了更好的理解，让我们在下一节中看看它的实际应用。
- en: Exploiting a buffer overflow
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用缓冲区溢出
- en: Take the following piece of code, which is vulnerable to buffer-overflow. Let's
    see how we can fuzz and exploit the vulnerability to get shell access to the system.
    We studied how to use Evans debugger in the earlier section. In this section,
    we will see how can we use `gdb` to exploit buffer overflows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个容易受到缓冲区溢出攻击的代码片段。让我们看看如何模糊测试和利用这个漏洞来获取对系统的shell访问权限。我们在之前的部分学习了如何使用Evans调试器。在本节中，我们将看到如何使用`gdb`来利用缓冲区溢出。
- en: 'The following is given a simple code snippet written in C that asks the user
    for their name. Based upon the supplied value from the Terminal, it greets the
    user with the greeting message `Hey <username>`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的C代码片段，询问用户的姓名。根据终端提供的值，它用问候消息“嘿<用户名>”来问候用户：
- en: '![](img/3c973b3c-d6bf-4ece-b71c-c83fa4fc9cd8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c973b3c-d6bf-4ece-b71c-c83fa4fc9cd8.png)'
- en: 'Let''s compile the application by disabling the stack protection using the
    following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令编译应用程序，禁用堆栈保护：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will create an object file called `bufferoverflow`, which can be run as
    follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`bufferoverflow`的目标文件，可以按以下方式运行：
- en: '![](img/4f051243-424d-40ca-929f-a277d0f85b06.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f051243-424d-40ca-929f-a277d0f85b06.png)'
- en: 'Now the next step for us is to generate a payload that will cause the application
    to break. We can use Python to do this as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的下一步是生成一个会导致应用程序崩溃的有效负载。我们可以使用Python来实现这一点：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command will create a text file with 500 *A*s in it. Let''s give
    this as an input to our code and see whether it breaks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个包含500个*A*的文本文件。让我们将其作为输入提供给我们的代码，看看是否会崩溃：
- en: '![](img/babc924e-32f8-42d2-b7fc-32a886226d94.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/babc924e-32f8-42d2-b7fc-32a886226d94.png)'
- en: As we learned earlier, the computer manages the stack through *registers*. Registers
    act as a dedicated place in memory, where data is stored while its worked on.
    Most registers temporarily store values for processing. In a 64-bit architecture,
    the **Register Stack Pointer** (**RSP**) and the **Register Base Pointer** (**RBP**) are
    especially important.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，计算机通过*寄存器*来管理栈。寄存器充当内存中的专用位置，用于在处理数据时存储数据。大多数寄存器临时存储处理的值。在64位架构中，**寄存器堆栈指针**（**RSP**）和**寄存器基址指针**（**RBP**）尤为重要。
- en: The program remembers its place in the stack with the RSP register. The RSP
    register will move up or down, depending on whether tasks are added or removed
    from the stack. The RBP register is used to remember where the end of the stack
    resides.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用RSP寄存器来记住栈中的位置。RSP寄存器将根据栈中添加或移除的任务而上下移动。RBP寄存器用于记住栈的末尾位置。
- en: Typically, the RSP register will instruct the program from where to continue
    the execution. This includes jumping into a function, out of a function, and so
    on. This is why an attacker's goal is to obtain control of where the RSP directs
    a program’s execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RSP寄存器将指示程序从哪里继续执行。这包括跳入函数、跳出函数等。这就是为什么攻击者的目标是控制RSP指向程序执行的位置。
- en: 'Now, let''s try to run the same code with `gdb` to find the value of the register
    RSP when the crash happens:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`gdb`运行相同的代码，找到崩溃发生时RSP寄存器的值：
- en: '![](img/b41f48fb-c6ac-4169-8461-b1e1925510c9.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b41f48fb-c6ac-4169-8461-b1e1925510c9.png)'
- en: 'As can be seen, we simply issue the `run` command and pass it in the created
    input file, which results in the program crashing. Let''s try to understand the
    status of all the registers at the time of the crash:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们只需发出`run`命令并将其传递给创建的输入文件，程序就会崩溃。让我们试着了解崩溃时所有寄存器的状态：
- en: '![](img/8c3414f4-c4ca-4a55-9655-41395fb3f479.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c3414f4-c4ca-4a55-9655-41395fb3f479.png)'
- en: 'The two columns displayed by the info registers tell us about the addresses
    of the registers in hex and decimal format. We know that the register of interest
    here is RSP as RSP will hold the address of the next instruction to be executred,and
    since it got corrupted and was over written by string of A''s it caused the crash.
    Let''s check the contents of the RSP at the time of the crash. Let''s also check
    the contents of other registers to see where all our input string of `aaaaa` is
    written. The reason we are checking the other registers is to determine the register
    in which we can place our payload:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: info registers显示的两列告诉我们寄存器的地址，以十六进制和十进制格式显示。我们知道这里感兴趣的寄存器是RSP，因为RSP将保存下一个要执行的指令的地址，由于它被损坏并被字符串A覆盖，导致了崩溃。让我们检查崩溃时RSP的内容。让我们还检查其他寄存器的内容，看看我们的输入字符串`aaaaa`写在了哪里。我们检查其他寄存器的原因是确定我们可以放置有效负载的寄存器：
- en: '![](img/f9f906cf-df0d-4eee-945b-21c20484d401.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f906cf-df0d-4eee-945b-21c20484d401.png)'
- en: 'From the preceding screenshot, we can validate that the input string aaaa,
    whose hexadecimal equivalent is `0x414141` is placed in the RSP, causing a crash.
    Interestingly, we also see that the string is placed inside registers `r9` and
    `r11`, making them potential candidates for our exploit code. But before getting
    there, we need to figure out at what point in our input of 500 characters was
    the buffer RSP overwritten. If we get the exact location of that offset, we will
    devise our payload to put a jump instruction at that offset, and we will try to
    make a jump to either register `r9` or `r11`, where we will place our shell code.
    For us to figure out the exact offset, we will generate a unique combination of
    characters with the help of a Metasploit Ruby module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中，我们可以验证输入字符串aaaa，其十六进制等价物为`0x414141`，被放置在RSP中，导致崩溃。有趣的是，我们还看到该字符串被放置在寄存器`r9`和`r11`中，使它们成为我们利用代码的潜在候选者。但在那之前，我们需要找出我们的500个字符输入中的缓冲区RSP何时被覆盖。如果我们得到该偏移量的确切位置，我们将设计我们的有效负载以在该偏移量处放置跳转指令，并尝试跳转到寄存器`r9`或`r11`，在那里我们将放置我们的shell代码。为了找出确切的偏移量，我们将使用Metasploit的Ruby模块生成一组唯一的字符组合：
- en: '![](img/a0d20d71-f944-4adb-a3a0-d7eb0a34181b.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0d20d71-f944-4adb-a3a0-d7eb0a34181b.png)'
- en: 'Now, since we placed this uniquely generated string in a file called `unique`,
    lets re-run the application, this time passing this `unique` file contents to
    the program:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们将这个唯一生成的字符串放在一个名为`unique`的文件中，让我们重新运行应用程序，这次将`unique`文件内容传递给程序：
- en: '![](img/be6e3c5f-0ba1-4c2e-b860-065a20121d5e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be6e3c5f-0ba1-4c2e-b860-065a20121d5e.png)'
- en: Now, at this point, the contents of the register RSP is`0x6f41316f`, which is
    in hex. The ASCII equivalent is `o1Ao`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这一点上，寄存器RSP的内容是`0x6f41316f`，这是十六进制。ASCII等价物是`o1Ao`。
- en: Since the contents of the register RSP is in little endian format, we actually
    need to convert `0x6f31416f` to its ASCII equivalent.It must be noted that IBM's
    370 mainframes, most [RISC](https://search400.techtarget.com/definition/RISC)-based
    computers, and Motorola microprocessors use the big-endian approach.On the other
    hand, Intel [processor](https://whatis.techtarget.com/definition/processor)s (CPUs)
    and DEC Alphas and at least some programs that run on them are little-endian
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于寄存器RSP的内容是小端格式，我们实际上需要将`0x6f31416f`转换为其ASCII等价物。必须注意的是，IBM的370大型机，大多数[RISC](https://search400.techtarget.com/definition/RISC)架构的计算机和Motorola微处理器使用大端方法。另一方面，英特尔[处理器](https://whatis.techtarget.com/definition/processor)（CPU）和DEC
    Alphas以及至少一些在它们上运行的程序是小端的。
- en: 'We will again use a Metasploit Ruby module to get the offset of this unique
    value to find the exact location of our payload. After this, we should have the
    jump instruction placed to make the RSP jump to the location of our choice:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Metasploit Ruby模块来获取这个唯一值的偏移量，以找到我们有效负载的确切位置。之后，我们应该放置跳转指令，使RSP跳转到我们选择的位置：
- en: '![](img/1a1b3edf-db63-4d94-a537-46e7e3849b43.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a1b3edf-db63-4d94-a537-46e7e3849b43.png)'
- en: 'Thus, we know that the next eight bytes of whatever we write after address
    `424` are going to be written to our rsp register. Let''s try to write `bbbb` and
    see if this is the case. The payload we generate will be as follows: `424*a +
    4*b + 72*c`. The exact command to use is this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道在地址`424`之后写入的下一个八个字节将被写入我们的`rsp`寄存器。让我们尝试写入`bbbb`，看看是否是这种情况。我们生成的有效负载将如下所示：`424*a
    + 4*b + 72*c`。要使用的确切命令是这个：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, given that we have verified that we can control the register RSP, let''s
    try to attack the r9 register, to hold our shell code. But before doing that,
    it''s important for us to know the location of the r9 register. In the following
    screenshot, we can see that the r9 register has a memory location of `0x7fffffffded0`,
    but this keeps changing every time the program reloads:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鉴于我们已经验证了我们可以控制寄存器RSP，让我们尝试攻击r9寄存器，以容纳我们的shell代码。但在这样做之前，重要的是我们知道r9寄存器的位置。在下面的屏幕截图中，我们可以看到r9寄存器的内存位置是`0x7fffffffded0`，但每次程序重新加载时都会发生变化：
- en: '![](img/858efe7d-0f3e-47f7-8aae-6487e4ed1e46.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/858efe7d-0f3e-47f7-8aae-6487e4ed1e46.png)'
- en: 'There are two ways to get around this. The first method is to avoid dynamic
    address change by disabling it at the OS level, which can be seen in the following
    screenshot. The other way is to find the address of any instruction that has the `jmp
    r9` command**. **We can search for `jmp r9` throughout the assembly code of our
    program and then place the address of the location inside our register RSP, thus
    avoiding dynamic address change. I will leave that as an exercise for you to figure
    out and do by yourself. For this section, let''s disable dynamic address loading
    by executing the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以解决这个问题。第一种方法是通过在操作系统级别禁用动态地址更改来避免它，可以在以下屏幕截图中看到。另一种方法是找到具有`jmp r9`命令的任何指令的地址**。**我们可以在程序的整个汇编代码中搜索`jmp
    r9`，然后将位置的地址放入我们的寄存器RSP，从而避免动态地址更改。我将把这留给你自己去想出并做。在本节中，让我们通过执行以下操作来禁用动态地址加载：
- en: '![](img/f236b2f1-2a66-4009-8a3b-4b4158a2a706.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f236b2f1-2a66-4009-8a3b-4b4158a2a706.png)'
- en: 'Now, since we are working on a Kali machine, let''s generate a reverse shell
    payload that will be placed in our final exploit code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们正在使用Kali机器，让我们生成一个将放置在我们最终的利用代码中的反向shell有效负载：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to figure out the common bad characters for the underlying software
    being tested, the most successful method is trial and error. What i usually do
    to figure out the common bad characters , is to send all unique characters to
    the application, and then using the debugger, we check what characters are changed
    at register level. The ones that get changed can be encoded and avoided.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出正在测试的底层软件的常见坏字符，最成功的方法是反复试验。我通常用来找出常见的坏字符的方法是将所有唯一字符发送到应用程序，然后使用调试器，检查寄存器级别发生了哪些字符变化。发生变化的字符可以被编码和避免。
- en: 'The preceding command would produce the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生以下屏幕截图：
- en: '![](img/7cb23632-599f-497d-8950-83e4e61d739f.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cb23632-599f-497d-8950-83e4e61d739f.png)'
- en: 'Let''s create a Python file called `exp_buf.py` and place the obtained shell
    code in that file. It must be noted that since we are encoding the payload, we
    will also need a few bytes in the beginning for it to get decoded, so we will
    specify a few `nop` characters in the beginning. We will also set up a netcat
    listener on port `4444` to see whether we get a reverse shell from the application.
    Remember the address of the r9 register; we will be using that as well:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`exp_buf.py`的Python文件，并将获取的shell代码放入该文件中。必须注意的是，由于我们正在对有效负载进行编码，我们还需要一些字节在开头进行解码，因此我们将在开头指定一些`nop`字符。我们还将在端口`4444`上设置一个netcat监听器，以查看我们是否从应用程序获得了反向shell。记住r9寄存器的地址；我们也将使用它：
- en: '![](img/7977e329-ec66-4112-a0ff-edd3d041a37b.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7977e329-ec66-4112-a0ff-edd3d041a37b.png)'
- en: 'The preceding Python code prints the payload that will be required to get us
    the reverse shell by penetrating through the vulnerable buffer overflow code we
    created. Let''s go and input this payload in a file called `buf_exp`, which we
    will be using with `edb` to exploit the code. Type in the following command to
    run the code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Python代码打印了我们需要的有效负载，以通过我们创建的易受攻击的缓冲区溢出代码获取反向shell。让我们将这个有效负载输入到一个名为`buf_exp`的文件中，我们将在`edb`中使用它来利用代码。输入以下命令来运行代码：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now set up a netcat listener on port 4444 that will listen to the reverse
    payload, which will in turn give us the shell:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在端口4444上设置一个netcat监听器，它将监听反向载荷，这将反过来给我们shell：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the application with `gdb` and try to exploit it as shown:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用`gdb`运行应用程序，并尝试利用它，如下所示：
- en: '![](img/3f4d655a-e0ea-4c19-975d-a0b0206014c8.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f4d655a-e0ea-4c19-975d-a0b0206014c8.png)'
- en: 'Bingo! The code has successfully spawned a new shell process. Let''s check
    what our netcat listener has obtained:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！代码成功地生成了一个新的shell进程。让我们检查一下我们的netcat监听器得到了什么：
- en: '![](img/d1832b93-bb79-428e-9643-6972f73c6c24.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1832b93-bb79-428e-9643-6972f73c6c24.png)'
- en: It can therefore be verified that we were able to successfully create a reverse
    shell using Python and `gdb`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此可以验证，我们成功地使用Python和`gdb`创建了一个反向shell。
- en: Heap buffer overflow in Linux
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的堆缓冲区溢出
- en: It should be noted that the scope of the variable, buffer, or storage that caused
    stack buffer overflow is confined to the function where it is declared (the local
    variable) and its scope is within the function. Since we know that functions are
    executed over a stack, this flaw causes the stack buffer to overflow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，导致堆栈缓冲区溢出的变量、缓冲区或存储的范围被限制在声明它的函数（局部变量）中，并且其范围在函数内。由于我们知道函数是在堆栈上执行的，这个缺陷导致了堆栈缓冲区溢出。
- en: 'In the case of a heap buffer overflow, the impact is a little greater, as the
    variable that we are trying to exploit does not live on a stack but instead on
    a heap. All the program variables that are declared within the same method are
    given memory within the stack. The variables that are dynamically allocated memory
    during run time, however, can''t be placed in the stack and are placed instead
    in a heap. Thus, when a program assigns memory to a variable at run time through
    `malloc` or `calloc` calls, it actually assigns them memory over the heap, and
    in a heap buffer overflow situation, this memory is caused to overflow or exploit.
    Let''s take a look at how this works:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆缓冲区溢出的情况下，影响会更大一些，因为我们试图利用的变量不是存储在堆栈上，而是存储在堆上。在同一方法中声明的所有程序变量都在堆栈中分配内存。然而，在运行时动态分配内存的变量不能放在堆栈中，而是放在堆中。因此，当程序通过`malloc`或`calloc`调用为变量分配内存时，实际上是在堆上分配内存，而在堆缓冲区溢出的情况下，这些内存就会溢出或被利用。让我们看看这是如何工作的：
- en: '![](img/1add16a5-8404-440a-8a38-665749741721.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1add16a5-8404-440a-8a38-665749741721.png)'
- en: Now go ahead and compile the code by disabling the inbuilt protection as shown.
    Note `-fno-stack-protector` and `-z execstack` are the commands that aid in disabling
    the stack protection an making it executable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续编译代码，禁用内置保护，如所示。请注意，`-fno-stack-protector`和`-z execstack`是用于禁用堆栈保护并使其可执行的命令。
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have compiled the application, let''s run it with input types that
    will break and execute the code as shown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了应用程序，让我们用会导致代码执行的输入类型来运行它，如下所示：
- en: '![](img/a0447202-627a-4a40-8dad-10a2f0204e34.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0447202-627a-4a40-8dad-10a2f0204e34.png)'
- en: The preceding screenshot gives a starting point of heap buffer overflows. We
    will leave it to the reader to discover how to exploit it further and get a reverse
    shell out of it. The methodology employed is very similar to that we used previously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图给出了堆缓冲区溢出的起点。我们将留给读者去发现如何进一步利用它并从中获得一个反向shell。所采用的方法与我们先前使用的方法非常相似。
- en: String format vulnerabilities
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式漏洞
- en: Uncontrolled format string exploits can be used to crash a program or to execute
    harmful code. The problem stems from the use of unchecked user input as a string
    parameter in certain C functions that perform formatting, such as `printf()`.
    A malicious user may use the `%s` and `%x` format tokens, among others, to print
    data from the call stack or possibly other locations in the memory. We could also
    write arbitrary data to arbitrary locations using the `%n` format token, which
    commands `printf()` and similar functions to write the number of bytes formatted
    to an address stored on the stack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无控制的格式字符串利用可以用于使程序崩溃或执行有害代码。问题源于在执行格式化的某些C函数中，如`printf()`中，使用未经检查的用户输入作为字符串参数。恶意用户可以使用`%s`和`%x`等格式标记，从调用堆栈或可能是内存中的其他位置打印数据。我们还可以使用`%n`格式标记，在堆栈上存储的地址上写入格式化的字节数，这会命令`printf()`和类似函数将任意数据写入任意位置。
- en: 'Let''s try to understand this further with the following piece of sample code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过以下一段示例代码进一步理解这一点：
- en: '![](img/bb027593-7b28-4072-b6e3-c994015f757d.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb027593-7b28-4072-b6e3-c994015f757d.png)'
- en: 'Now, go ahead and compile the code, disabling the inbuilt protection as shown:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续编译代码，禁用内置保护，如所示：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the print function takes the first parameter as the format string
    (`%s`, `%c`, `%d` and so on ). In the previous case, `argv[1]` can be used as
    a format string and print the content of any memory location. The preceding code
    is vulnerable. If it had been written as shown, however, the vulnerability would
    not exist:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，print函数将第一个参数作为格式字符串（`%s`、`%c`、`%d`等）。在前面的情况下，`argv[1]`可以用作格式字符串，并打印任何内存位置的内容。前面的代码是有漏洞的。然而，如果它是按照下面所示的方式编写的，那么漏洞就不会存在：
- en: '![](img/d910a09a-0984-4100-81eb-55f558ac0eec.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d910a09a-0984-4100-81eb-55f558ac0eec.png)'
- en: 'Now that we have compiled the application, let''s run it with input types that
    will break and execute the code shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了应用程序，让我们用会导致代码执行的输入类型来运行它，如下所示：
- en: '![](img/f30ddab8-5855-4219-acfc-bbffd7c57925.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f30ddab8-5855-4219-acfc-bbffd7c57925.png)'
- en: 'Let''s break the code with the format string vulnerability as shown:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用格式字符串漏洞来破坏代码，如下所示：
- en: '![](img/fc965f14-8d38-4216-83f7-fa7246204955.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc965f14-8d38-4216-83f7-fa7246204955.png)'
- en: The preceding screenshot gives a starting point; again, we will leave it to
    the reader to explore how to exploit this further. It is recommended that you
    try the same methodology that we discussed in detail previously.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图给出了一个起点；同样，我们将留给读者去探索如何进一步利用这一点。建议您尝试我们之前详细讨论过的相同方法。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed reverse engineering in Linux. We also studied
    fuzzing using Python. We looked at assembly language and mnemonics within the
    context of Linux debuggers (`edb` and `gdb`). We discussed stack buffer overflows
    in great detail, and we learned about the concepts of Heap buffer overflow and
    string format vulnerabilities. I would highly recommend spending a good amount
    of time on these ideas and exploring them on different operating system versions
    and vulnerable applications. By the end of this chapter, you should have a fair
    understanding of buffer overflow vulnerabilities and reversing in a Linux environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Linux中的逆向工程。我们还学习了使用Python进行模糊测试。我们在Linux调试器（`edb`和`gdb`）的上下文中查看了汇编语言和助记符。我们详细讨论了堆栈缓冲区溢出，并了解了堆缓冲区溢出和字符串格式漏洞的概念。我强烈建议花费大量时间来研究这些想法，并在不同的操作系统版本和易受攻击的应用程序上进行探索。到本章结束时，您应该对Linux环境中的缓冲区溢出漏洞和逆向工程有一个相当好的理解。
- en: In the next chapter, we will discuss reverse engineering and buffer overflow
    vulnerabilities in the Windows environment. We will demonstrate exploitation using
    a real-world application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Windows环境中的逆向工程和缓冲区溢出漏洞。我们将演示如何利用真实应用程序进行利用。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we automate the process of exploiting buffer overflow vulnerabilities?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动化利用缓冲区溢出漏洞的过程？
- en: What can we do to avoid advance protections being imposed by operating systems
    such as disabling code execution on a stack?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以采取什么措施来避免操作系统施加的高级保护，比如禁用堆栈上的代码执行？
- en: How can we deal with address randomization?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何处理地址随机化？
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Stack Buffer overflow crossfire: [https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit](https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈缓冲区溢出交火：[https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit](https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit)
- en: Stack Buffer overflow crossfire: [https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html](https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈缓冲区溢出交火：[https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html](https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html)
- en: 'Heap Buffer overflow: [https://www.win.tue.nl/~aeb/linux/hh/hh-11.html](https://www.win.tue.nl/~aeb/linux/hh/hh-11.html)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆缓冲区溢出：[https://www.win.tue.nl/~aeb/linux/hh/hh-11.html](https://www.win.tue.nl/~aeb/linux/hh/hh-11.html)
- en: 'String format vulnerabilities: [https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式漏洞：[https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)
