- en: Introduction to Exploit Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用开发简介
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: CPU registers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU寄存器
- en: Memory dump
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存转储
- en: CPU instructions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU指令
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python is helpful for creating simple prototype codes to test the exploits.
    In this chapter, we can learn the basics of exploit development, which may help
    you to correct broken exploits, or just build your own exploits from scratch.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python对于创建简单的原型代码来测试利用非常有帮助。在本章中，我们可以学习利用开发的基础知识，这可能有助于您修复损坏的利用，或者从头开始构建自己的利用。
- en: CPU registers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU寄存器
- en: CPU registers, or processor registers, are one of a small set of data holding
    places in the processor, which may hold an instruction, storage address, or any
    data. Registers should be capable of storing the instructions. Registers are the
    fastest computer memory, used to speed up the computer operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CPU寄存器，或处理器寄存器，是处理器中一小组数据存储位置之一，可以存储指令、存储地址或任何数据。寄存器应能够存储指令。寄存器是最快的计算机内存，用于加快计算机操作。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a basic idea about the registers before working with exploit
    development. For understanding, let's consider that registers are mainly in two
    forms, general purpose registers and special purpose registers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行利用开发之前，您需要对寄存器有一个基本的了解。为了理解，让我们考虑寄存器主要有两种形式，通用寄存器和特殊目的寄存器。
- en: General purpose registers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用寄存器
- en: 'General purpose registers are used to store intermediate results during program
    execution and to run mathematical operations. The four general purpose registers
    are EAX, EBX, ECX, and EDX:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器用于存储程序执行过程中的中间结果和运行数学运算。四个通用寄存器是EAX、EBX、ECX和EDX：
- en: '**EAX (The accumulator register)**: Used for basic mathematical operations
    and to return the value of a function.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAX（累加器寄存器）：用于基本数学运算和返回函数的值。
- en: '**EBX**: This is used for nominal storage as needed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'EBX: 这用于根据需要进行名义存储。'
- en: '**ECX (The counter register)**: Used for looping through functions and iterations.
    It can also be used for general storage.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECX（计数器寄存器）：用于循环遍历函数和迭代。它也可以用于一般存储。
- en: '**EDX (The data register)**: It is used for higher mathematical operations
    such as multiplication and division. It also stores function variables while running
    a program.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDX（数据寄存器）：用于高级数学运算，如乘法和除法。它还在运行程序时存储函数变量。
- en: Special purpose registers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊目的寄存器
- en: 'Special purpose registers are used to handle indexing and pointing. These are
    important in the case of writing exploits as we will try to manipulate and overwrite
    the data in these registers. The main special purpose registers are EBP, EDI,
    EIP, and ESP:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊目的寄存器用于处理索引和指向。这些在编写利用时非常重要，因为我们将尝试操纵和覆盖这些寄存器中的数据。主要的特殊目的寄存器是EBP、EDI、EIP和ESP：
- en: '**EBP**: This pointer register indicates where the bottom of the stack is at.
    So, this will point to the top of the stack or set to the old pointer value when
    we are starting a function as it''s the beginning.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'EBP: 这个指针寄存器指示堆栈底部的位置。因此，这将指向堆栈顶部，或者在我们启动函数时设置为旧的指针值，因为这是开始。'
- en: '**EDI**: This is the destination index register, used for pointers to function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'EDI: 这是目的地索引寄存器，用于指向函数的指针。'
- en: '**EIP**: Instruction pointer register is used to store the next instruction
    to be executed by the CPU. So, this is important for exploit writing as if we
    could edit this we can control the next instruction. Also, if we can overwrite
    this EIP it means that the program itself has failed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'EIP: 指令指针寄存器用于存储CPU要执行的下一条指令。因此，这对于利用编写非常重要，因为如果我们可以编辑这个，我们就可以控制下一条指令。此外，如果我们可以覆盖这个EIP，这意味着程序本身已经失败。'
- en: '**ESP**: Is when the stack pointer indicates the current top (lowest memory
    address) of the stack. This get updates while running the program as items are
    removed from the top of the stack. When new functions are loaded it goes back
    to the top position. If we need to access the stack memory we can use ESP.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ESP: 当堆栈指针指示堆栈的当前顶部（最低内存地址）时。随着程序运行，它会更新，因为项目从堆栈顶部移除。加载新函数时，它会返回到顶部位置。如果我们需要访问堆栈内存，我们可以使用ESP。'
- en: To view the registers while running a program we need debuggers, we have to
    install debuggers for this in your system. For debugging Windows programs we can
    use Immunity Debugger and for Linux and Mac we can use `pwngdb`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序时查看寄存器，我们需要调试器，在您的系统中安装调试器。对于调试Windows程序，我们可以使用Immunity Debugger，对于Linux和Mac，我们可以使用`pwngdb`。
- en: You can download and install Immunity Debugger from here: [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载并安装Immunity Debugger：[https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/)。
- en: 'To install `pwndbg`, get the code from the Git repository and run the setup
    script:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`pwndbg`，请从Git存储库获取代码并运行安装脚本：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: We can do some quick tasks for better understanding of these registers in the
    debugger tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调试器工具中执行一些快速任务，以更好地理解这些寄存器。
- en: To view the registers while running a program, we need to use debuggers. So
    open an executable in the Immunity Debugger. For that, open Immunity Debugger
    in a Windows machine.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行程序时查看寄存器，我们需要使用调试器。因此，在Windows机器上打开Immunity Debugger中的可执行文件。
- en: Then load the program to analyze it in Immunity Debugger. From the menu go to
    File | Open and select the application to monitor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后加载程序以在Immunity Debugger中进行分析。从菜单中转到文件|打开，并选择要监视的应用程序。
- en: It will open the application in debug mode and print out the current details.
    The top-right box will show the register details. The register pane in the Immunity
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将以调试模式打开应用程序并打印出当前的详细信息。右上角的框将显示寄存器的详细信息。Immunity中的寄存器窗格
- en: 'Debugger looks as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器如下所示：
- en: '![](img/00066.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.gif)'
- en: 'For Linux and macOS, after installing `pwndbg` we can open the application
    in `pwndbg` with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Linux和macOS，在安装`pwndbg`之后，我们可以使用以下命令在`pwndbg`中打开应用程序：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will open the application `app` in the debugger
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在调试器中打开应用程序`app`
- en: 'Now we can run the application in the debug mode with a break point set:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在调试模式下运行应用程序，并设置断点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will run the application and break at line `5`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行应用程序并在第`5`行处中断
- en: 'Now we can view the registers at the current state with the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令查看当前状态的寄存器：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00067.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: If the executable is 64-bit, the registers will start with `r`. Starting them
    with `e` is invalid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可执行文件是64位的，则寄存器将以`r`开头。以`e`开头是无效的。
- en: Memory dump
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存转储
- en: We can easily view the contents of a memory location with the memory dump. We
    can use Immunity Debugger or `pwndbg` for this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内存转储轻松查看内存位置的内容。我们可以使用Immunity Debugger或`pwndbg`来实现这一点。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the steps for better understanding of memory dump:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤更好地理解内存转储：
- en: Open an application in the Immunity Debugger.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Immunity Debugger中打开一个应用程序。
- en: 'If you want to view the memory dump in ESI register and right-click on the
    address and select the Follow in Dump option:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要查看ESI寄存器中的内存转储，并右键单击地址，选择转到转储选项：
- en: '![](img/00068.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: 'This will update the memory dump window in the bottom-left corner. The memory
    dump window in Immunity Debugger looks as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将更新左下角的内存转储窗口。Immunity Debugger中的内存转储窗口如下所示：
- en: '![](img/00069.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.gif)'
- en: 'With `pwndbg` we can get the memory dump with the `hexdump` command. For that,
    load the application in `gdb` and run it with a breaker:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pwndbg`，我们可以使用`hexdump`命令获取内存转储。为此，在`gdb`中加载应用程序并在断点处运行它：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now to view the memory dump in RSI register, run the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要查看RSI寄存器中的内存转储，请运行以下命令：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00070.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: CPU instructions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU指令
- en: When an application is written in high-level languages is compiled, the language
    instructions will be converted to assembly language corresponding to it. This
    is the code that machines can understand. With the debugger we can view each assembly
    instruction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序用高级语言编写并编译时，语言指令将被转换为相应的汇编语言。这是机器可以理解的代码。通过调试器，我们可以查看每个汇编指令。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the steps to understand the usage in debuggers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解调试器的用法：
- en: Open an application in the Immunity Debugger.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Immunity Debugger中打开一个应用程序。
- en: We can view the opcode in the top-left pane of the Immunity Debugger.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在Immunity Debugger的左上角窗格中查看操作码。
- en: 'We can step through the instructions one by one and see the results by pressing
    *F7*:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以逐步执行指令，并通过按下*F7*来查看结果：
- en: 'Here is how the instructions pane looks:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指令窗格的外观：
- en: '![](img/00071.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: This will update the corresponding registers in the top-right pane. Like this,
    we can follow the execution of each CPU instruction within Immunity Debugger.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新右上角窗格中相应的寄存器。通过这样，我们可以在Immunity Debugger中跟踪每个CPU指令的执行。
- en: 'In the case of `pwndbg`, we can use the `entry` command to execute at the entry
    point:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pwndbg`的情况下，我们可以使用`entry`命令在入口点执行：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will present with the context screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示上下文屏幕。
- en: 'We can use the `nearpc` command to view the opcode near the break pointers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`nearpc`命令查看断点附近的操作码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00072.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: 'We can step through the instructions with the `stepi` command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`stepi`命令逐步执行指令：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will execute one machine instruction, and then it will stop and return
    to the debugger.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行一条机器指令，然后停止并返回到调试器。
- en: Like this, we can go through the instructions to analyze it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以逐步分析指令。
