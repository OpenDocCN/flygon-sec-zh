- en: Vulnerability Scanner Python - Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞扫描器 Python - 第 2 部分
- en: When we talk of service scanning using open source scripts, the first thing
    that comes to mind is making use of various NSE scripts to get the service versions
    and associated vulnerabilities with the configured services. Now, in a typical
    manual network penetration test, we not only make use of NSE scripts to get the
    job done, we also use various Ruby, Perl, and Bash scripts, and Java class files.
    We also run Metasploit auxiliary modules for service scanning and exploit modules
    to exploit vulnerabilities and to create a POC. We may also run various Kali tools,
    such as Nikto for web scanning, or SQLmap, w3af, and Wireshark to capture clear-text
    usernames and passwords for improperly configured FTP or SSH services. All of
    these tools and scripts produce a huge information pool that a tester needs to
    enumerate manually and consolidate. False positives must also be eliminated to
    arrive to a conclusion as to which services possess which vulnerabilities. The
    other aspect of manual service scanning is that it lacks standardization and relies
    more on an individual's expertise and the choice of scripts used. It is important
    to bear in mind that the scripts to be used are mostly disintegrated from one
    another such that a person has to follow a sequential approach to run all the
    desired scripts and modules. We can achieve limited parallelism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论使用开源脚本进行服务扫描时，首先想到的是利用各种 NSE 脚本获取配置的服务的服务版本和相关漏洞。在典型的手动网络渗透测试中，我们不仅使用 NSE
    脚本来完成工作，还使用各种 Ruby、Perl 和 Bash 脚本，以及 Java 类文件。我们还运行 Metasploit 辅助模块进行服务扫描和利用模块来利用漏洞并创建
    POC。我们还可能运行各种 Kali 工具，比如用于 Web 扫描的 Nikto，或者用于捕获未正确配置的 FTP 或 SSH 服务的明文用户名和密码的 SQLmap、w3af
    和 Wireshark。所有这些工具和脚本产生了大量信息，测试人员需要手动枚举和整合。还必须消除误报，以得出哪些服务存在哪些漏洞的结论。手动服务扫描的另一个方面是缺乏标准化，更多地依赖于个人的专业知识和所使用的脚本的选择。重要的是要记住，要使用的脚本大多是相互分离的，以至于一个人必须按顺序运行所有所需的脚本和模块。我们可以实现有限的并行性。
- en: In this chapter, we will see how our vulnerability scanner can automate all
    of these activities and bring standardization to the whole ecosystem. We will
    also see how the automated scanner invokes and orchestrates all the amazing tools
    that Kali has to produce an integrated report for the penetration tester to walk
    through, giving them a consolidated view that can be used for quick analysis.
    We will also study the GUI version of the vulnerability scanner, which has more
    advanced features and complements existing vulnerability scanners such as Nessus.
    It must be noted that when I use the word *complements*, by no means am I comparing
    our scanner with Nessus or Qualys. They are both excellent commercial products
    that have evolved over years of R&D, and have some excellent engineers working
    on them. However, we will build something that works amazingly well; knowing the
    code gives you an opportunity to contribute to the scanner, which in turn helps
    to make it better and bigger over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到我们的漏洞扫描器如何自动化所有这些活动，并为整个生态系统带来标准化。我们还将看到自动化扫描器如何调用和编排所有 Kali 工具，以为渗透测试人员生成一个集成报告，供其快速分析使用。我们还将研究漏洞扫描器的图形用户界面版本，该版本具有更高级的功能，并补充了现有的漏洞扫描器，如
    Nessus。必须指出的是，当我使用 *补充* 这个词时，我绝不是在将我们的扫描器与 Nessus 或 Qualys 进行比较。它们都是经过多年研发的优秀商业产品，并有一些优秀的工程师在其中工作。然而，我们将构建出一个运行非常出色的东西；了解代码可以让您有机会为扫描器做出贡献，从而帮助它随着时间的推移变得更好更大。
- en: Architectural overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构概述
- en: 'We have already taken a look at the architecture of the scanner in Chapter
    5, *Vulnerability Scanner Python - Part 1*. Lets revisit the service-scanning
    part of the scanner and think about how the whole ecosystem works. The following
    diagram shows the service scanning architecture for us:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第 5 章 *漏洞扫描器 Python - 第 1 部分* 中看过了扫描器的架构。让我们重新审视扫描器的服务扫描部分，并思考整个生态系统是如何工作的。以下图表显示了我们的服务扫描架构：
- en: '![](img/a7c2cb8c-65e4-43cf-9b06-f7c6d48a5ff2.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c2cb8c-65e4-43cf-9b06-f7c6d48a5ff2.png)'
- en: A project ID would be associated with all scans that have been completed with
    Nmap port scanning. The user can select the project ID for which they want to
    carry out service scanning and can also see all the project IDs for which port
    scanning has successfully completed. It should be noted that only the project
    IDs for projects that have been completed will be displayed; projects for which
    the port scanning has been paused would not be displayed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 ID 将与使用 Nmap 端口扫描完成的所有扫描相关联。用户可以选择要进行服务扫描的项目 ID，并且还可以查看已成功完成端口扫描的所有项目 ID。应该注意，只有已完成的项目的项目
    ID 将被显示；暂停端口扫描的项目将不会被显示。
- en: Once the project ID has been selected, the code reads the database table `IPtable_history` to
    display open ports and the default configuration, which refers to the open ports
    and the associated scripts (depending on the service name). The user can reconfigure
    the scan results, including manually adding any open ports that have been missed
    or removing any entries for which ports displayed as open aren't actually accessible.
    Once the user has reconfigured the results, we are all set to run a service scan.
    It should be noted that the reconfiguration step can be skipped if the user finds
    the port-scanning results to be all right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了项目 ID，代码就会读取数据库表 `IPtable_history`，显示开放端口和默认配置，这指的是开放端口和相关脚本（取决于服务名称）。用户可以重新配置扫描结果，包括手动添加任何被忽略的开放端口或删除任何显示为开放但实际上不可访问的条目。一旦用户重新配置了结果，我们就可以运行服务扫描了。应该注意，如果用户发现端口扫描结果都正确，可以跳过重新配置步骤。
- en: When the scanning activity is over, we will save all the results in our MySQL
    database table. In case of service scanning, depending upon the service discovered,
    we will get a configured list of scripts that we need to execute if a specific
    service is found. We use a JSON file to map the service and corresponding scripts
    to execute.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描活动结束后，我们将把所有结果保存在我们的MySQL数据库表中。在服务扫描的情况下，根据发现的服务，我们将得到一个配置好的脚本列表，如果找到特定的服务，我们需要执行这些脚本。我们使用一个JSON文件来映射服务和相应的要执行的脚本。
- en: 'In case of port scanning, a user is prompted with the port-scanning results
    and is given an option to reconfigure the results if needed (to reduce false positives).
    Once the final configuration is set, service scanning is started. The logic is
    to pick one host at a time from the database and, based on the services discovered,
    read the appropriate scripts from the JSON file and execute them for that particular
    host. Finally, after the script is executed, the results should be saved in the
    database. This continues until all the hosts are scanned for their services. Finally,
    an HTML report is produced that contains the formatted results and also contains
    screenshots for the POC to be attached. The following screenshot depicts how the
    JSON file is configured to execute the scripts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口扫描的情况下，用户将收到端口扫描结果，并有选择重新配置结果（以减少误报）。最终配置设置后，将开始服务扫描。逻辑是从数据库中逐个选择一个主机，并根据发现的服务，从JSON文件中读取适当的脚本，并为该特定主机执行它们。最后，在执行脚本后，结果应保存在数据库中。这将持续到所有主机都扫描其服务为止。最后，将生成一个包含格式化结果和POC截图的HTML报告。以下截图显示了如何配置JSON文件以执行脚本：
- en: '![](img/14b16790-646d-4621-b88b-a1d1e4acc5b4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14b16790-646d-4621-b88b-a1d1e4acc5b4.png)'
- en: 'As can be seen from the preceding screenshot, there are various categories
    of commands that are placed in the JSON file. The Metasploit template contains
    the commands that are meant to execute the Metasploit modules. Single-line commands
    are used to execute NSE scripts and all modules and scripts that are not interactive
    and that can be fired with a single command. The other categories include `interactive_commands` and `single_line_sniffing`
    (where we need to sniff the traffic along with executing the scripts). The general
    template of the JSON file looks as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，JSON文件中包含各种类别的命令。Metasploit模板包含用于执行Metasploit模块的命令。单行命令用于执行NSE脚本以及所有非交互式的模块和脚本，可以用单个命令触发。其他类别包括“interactive_commands”和“single_line_sniffing”（需要在执行脚本的同时嗅探流量）。JSON文件的一般模板如下：
- en: '![](img/61f06b62-c5e6-4ed3-ad34-75242f926e11.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f06b62-c5e6-4ed3-ad34-75242f926e11.png)'
- en: The **key** is the name of the service. The title contains a description of
    the file. `method_id` is the actual Python method that should be invoked to call
    the external script to be executed. Note that for single-line commands, we also
    specify a `timeout` parameter in seconds as the first argument under the `args`
    parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**是服务的名称。标题包含文件的描述。`method_id`是应调用的实际Python方法，以调用要执行的外部脚本。请注意，对于单行命令，我们还在`args`参数下的第一个参数中指定了一个`timeout`参数，单位为秒。'
- en: A closer look at the code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的更详细查看
- en: It should be noted that the whole code base can be found at GitHub [https://github.com/FurqanKhan1/Dictator](https://github.com/FurqanKhan1/Dictator).
    We will be taking a look at all the essential code files that form the central
    piece of logic for our service scanner. Alternatively, I have created a plug-and-play
    Kali VM image that contains all the prerequisite installations and the codebase
    out of the box. This can be download and executed hassle-free from the following
    URL [https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing](https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing). The
    default username is `PTO_root` and the password is `PTO_root`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到整个代码库可以在GitHub上找到[https://github.com/FurqanKhan1/Dictator](https://github.com/FurqanKhan1/Dictator)。我们将查看所有构成服务扫描器核心逻辑的基本代码文件。或者，我创建了一个即插即用的Kali
    VM镜像，其中包含所有必需的安装和开箱即用的代码库。可以从以下URL[https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing](https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing)下载并无忧地执行。默认用户名是`PTO_root`，密码是`PTO_root`。
- en: Let's look at an overview of the essential files and methods that we will use
    to build our service- scanning engine, using Python.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概览一下我们将使用的基本文件和方法，来构建我们的服务扫描引擎，使用Python。
- en: Driver_scanner.py
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Driver_scanner.py
- en: 'After port scanning is over, the next step is to perform service scanning.
    This Python class invokes another class, `driver_meta.py`, which takes the project
    name/ID for which service scanning is to be performed, as shown in the following
    code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描结束后，下一步是执行服务扫描。这个Python类调用另一个类`driver_meta.py`，它接受要执行服务扫描的项目名称/ID，如下面的代码片段所示：
- en: '![](img/85fbab57-78e3-484a-8485-0046530ff0e1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85fbab57-78e3-484a-8485-0046530ff0e1.png)'
- en: driver_meta.py
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: driver_meta.py
- en: 'This class displays the default result of port scanning and gives user the
    option to reconfigure the results if needed. After reconfiguration, this class
    reads the hosts from the database table for the project for which service scanning
    is to be done. For each host, it then reads the JSON file to get the commands
    to be executed, and for each command to be executed, it passes on the control
    to another file `auto_comamnds.py`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类显示了端口扫描的默认结果，并给用户重新配置结果的选项。重新配置后，这个类从数据库表中读取要执行服务扫描的项目的主机。对于每个主机，它然后从JSON文件中读取要执行的命令，对于要执行的每个命令，它将控制传递给另一个文件`auto_comamnds.py`：
- en: '![](img/681da31c-9d55-4caf-8b07-493e0d90a3cf.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/681da31c-9d55-4caf-8b07-493e0d90a3cf.png)'
- en: The preceding class represents the main parent class for this Python module.
    As we can see, we have imported various other Python modules such as JSON, SYS,
    and psutil to be used with this class. We can also see that we have used other
    classes such as `auto_commands`, `Auto_logger`, `IPexploits`, and `IPtable` with
    this module. These are not in-built Python modules but our own classes that perform
    different functionalities for our service-scanning engine. We will discuss these
    in greater detail later on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类代表了这个Python模块的主要父类。正如我们所看到的，我们已经导入了其他各种Python模块，如JSON、SYS和psutil，以便与这个类一起使用。我们还可以看到，我们已经在这个模块中使用了其他类，如`auto_commands`、`Auto_logger`、`IPexploits`和`IPtable`。这些不是Python的内置模块，而是我们自己的类，用于执行我们服务扫描引擎的不同功能。我们将在稍后更详细地讨论这些。
- en: main()
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main()
- en: 'Take a look at the `main()` method of this class, from where the execution
    cycle actually starts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个类的`main()`方法，从这里实际上开始执行循环：
- en: The `main()` method is the same piece of code that is used with both the CLI
    version and the GUI version of the code, so there are many parameters that would
    only be relevant when invoked with the GUI mode. We will discuss those that are
    needed in CLI mode in this section. We can see that the `mode` variable is initialized
    to `c` inside the definition of the `main()` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`方法是用于CLI版本和GUI版本的相同代码片段，因此有许多参数只有在以GUI模式调用时才相关。我们将在本节讨论在CLI模式下需要的参数。我们可以看到`mode`变量在`main()`方法的定义中初始化为`c`。 '
- en: 'In the section highlighted as **(1)** in the following screenshot, we initialize
    an object for the `texttable()` Python module, which will be used to draw a table
    on the console window to display the project IDs for which service scanning can
    be performed. The second section collects all the completed projects from the
    database and section **(3)** adds the retrieved rows to the program variable to
    be displayed on the screen. The subsequent code is straightforward. At section **(4)**,
    the functionality actually removes the earlier details of a project for which
    service scanning would have been completed already, so that the user can overwrite
    the results with a new service-scanning operation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中标记为**(1)**的部分中，我们为`texttable()` Python模块初始化了一个对象，该模块将用于在控制台窗口上绘制一个表，以显示可以执行服务扫描的项目ID。第二部分从数据库中收集了所有已完成的项目，第三部分将检索到的行添加到程序变量中，以在屏幕上显示。随后的代码很简单。在第四部分，功能实际上删除了先前已完成服务扫描的项目的详细信息，以便用户可以用新的服务扫描操作覆盖结果：
- en: '![](img/ff8386f7-82c6-4c0e-84eb-68faf33667f5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff8386f7-82c6-4c0e-84eb-68faf33667f5.png)'
- en: Section **(5)** creates a directory called `<project_id>` under the `results` folder.
    For example, if the current project ID is `744`, the command `init_project_directory()`,
    will create a sub folder under `<parent_folder_code_base>/results/<744_data>`.
    All the log files, the scan configuration, and the final report will be placed
    in this folder. As we have already discussed, we have a preconfigured JSON file
    that contains a mapping between the service name and the test cases to be executed
    against that service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第五部分创建了一个名为`<project_id>`的目录，位于`results`文件夹下。例如，如果当前项目ID是`744`，则命令`init_project_directory()`将在`<parent_folder_code_base>/results/<744_data>`下创建一个子文件夹。所有日志文件、扫描配置和最终报告都将放在这个文件夹中。正如我们已经讨论过的，我们有一个预配置的JSON文件，其中包含服务名称和要针对该服务执行的测试用例之间的映射。
- en: 'The following sections shows how the JSON file is configured. Let''s take an
    example of an `http` service and see how the test cases are configured to be executed
    against the HTTP service:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分显示了JSON文件的配置方式。让我们以`http`服务为例，看看如何配置要针对HTTP服务执行的测试用例：
- en: '![](img/2cd0d5fc-1e43-4e3a-adb4-2979fd3bdd44.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cd0d5fc-1e43-4e3a-adb4-2979fd3bdd44.png)'
- en: '![](img/2dfa78c5-7d56-4f00-9816-a31c2b49b049.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dfa78c5-7d56-4f00-9816-a31c2b49b049.png)'
- en: '![](img/540f9725-5a06-4615-a521-68e986493403.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/540f9725-5a06-4615-a521-68e986493403.png)'
- en: '![](img/506435b2-4e03-4bd1-a5fe-807439c928fd.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/506435b2-4e03-4bd1-a5fe-807439c928fd.png)'
- en: '![](img/81302c92-bbc5-49eb-ade6-91118d91c197.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81302c92-bbc5-49eb-ade6-91118d91c197.png)'
- en: '![](img/21bb1a31-9f5b-4e24-880b-b84f899b0ce9.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21bb1a31-9f5b-4e24-880b-b84f899b0ce9.png)'
- en: 'As can be seen and classified from the preceding bifurcation, all the test
    cases for the service called `http` will be placed in a JSON list with the key
    as `Commands`. Each entry within the `Commands` list would be a JSON dictionary
    that has the following entries:`{"args":[],"id":"","method":"","include":"","title":""}`.
    Each dictionary formulates one test case to be executed. Let''s try to understand
    each of the entries:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的分叉中可以看出并分类，名为`http`的服务的所有测试用例将放在一个JSON列表中，其键为`Commands`。`Commands`列表中的每个条目都将是一个JSON字典，其中包含以下条目：`{"args":[],"id":"","method":"","include":"","title":""}`。每个字典构成一个要执行的测试用例。让我们试着理解每个条目：
- en: '`args`: The `args` parameter is actually a list that contains the actual commands
    and NSE scripts to be executed against a target. All the commands/scripts that
    are to be executed are classified into five different categories that we will
    see in the method section. For now, it is enough to understand that args contain
    the actual commands to be executed on the Kali console with Python.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：`args`参数实际上是一个包含要针对目标执行的实际命令和NSE脚本的列表。要执行的所有命令/脚本被分类为我们将在方法部分中看到的五个不同类别。现在，了解`args`包含要在Kali控制台上用Python执行的实际命令就足够了。'
- en: '`id`: Each command to be executed is given a unique ID, which makes the enumeration
    easy. For all HTTP-based commands, we can see the IDs are `http_1`, `http_2`,
    `http_3`, and so on.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：给定要执行的每个命令都有一个唯一的ID，这使得枚举变得容易。对于所有基于HTTP的命令，我们可以看到ID是`http_1`，`http_2`，`http_3`等等。'
- en: '`method`: This particular entry is very important, as it refers to an actual
    Python method that should be invoked to execute this testcase. The methods are
    placed inside a Python file/module `auto_commands.py` and this class has different
    methods mapped to the JSON file. Generally, all the scripts to be executed are
    broken into five classes/categories, and each category has a corresponding method
    associated with it. The categories of scripts and their corresponding methods
    are as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 这个特定的条目非常重要，因为它指的是应该调用的实际 Python 方法来执行这个测试用例。这些方法位于一个名为 `auto_commands.py`
    的 Python 文件/模块中，该类别有不同的方法与 JSON 文件进行了映射。通常，要执行的所有脚本被分成五类/类别，并且每个类别都有一个相应的方法与之关联。脚本的类别及其相应的方法如下：'
- en: '`Single_line_comamnds_timeout`: All the commands/scripts that require a one
    time invocation and that produce the output for you, without requiring any interaction
    in between, fall under this classification. For example, an NSE script can be
    executed as follows: `nmap -p80 --script <scriptname.nse> 10.0.2.15`; it would
    not require any other input and would just execute and give us the final output.
    Alternatively, a Perl script to perform directory enumeration can be invoked as
    follows: `perl http-dir-enum.pl http://10.0.2.15:8000`.Likewise, all the Python
    scripts, Bash commands, and Kali tools, such as Nikto or Hoppy, will fall under
    this category. All such scripts are handled by a Python method, `singleLineCommands_timeout()`,
    placed inside the `auto_comamnds.py` module. It should be noticed that all such
    scripts also need an additional `timeout` parameter. There are occasions when
    a single script hangs for some reasons (the host might be unresponsive, or it
    might encounter an unforeseen condition for which it was not tested), and the
    hanging of the script will cause the other scripts in the queue to be in the waiting
    state. To get around this condition, we specify a threshold parameter as the first
    argument in the `args[]` list, which is the maximum time in seconds for which
    we want the script to be executed. This is why, from the previous configuration,
    we can see that `500` seconds is specified as a timeout for the NSE script whose
    ID is `http_5`. If the script is not executed within `500` seconds, the operation
    is aborted and the next script in the queue is executed.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single_line_comamnds_timeout`: 所有需要一次性调用并为您生成输出的命令/脚本，而不需要在其间进行任何交互的命令/脚本都属于这一分类。例如，可以执行一个
    NSE 脚本，命令如下：`nmap -p80 --script <scriptname.nse> 10.0.2.15`；它不需要任何其他输入，只需执行并给出最终输出。或者，可以如下调用一个用于执行目录枚举的
    Perl 脚本：`perl http-dir-enum.pl http://10.0.2.15:8000`。同样，所有 Python 脚本、Bash 命令和
    Kali 工具，如 Nikto 或 Hoppy，都属于这一类别。所有这些脚本都由一个名为 `singleLineCommands_timeout()` 的
    Python 方法处理，该方法位于 `auto_comamnds.py` 模块中。需要注意的是，所有这些脚本还需要一个额外的 `timeout` 参数。有时单个脚本由于某些原因而挂起（主机可能无响应，或者可能遇到未经测试的意外情况），脚本的挂起将导致队列中的其他脚本处于等待状态。为了解决这种情况，我们在
    `args[]` 列表中指定一个阈值参数作为第一个参数，这是我们希望脚本执行的最长时间（以秒为单位）。因此，从先前的配置中，我们可以看到为 ID 为 `http_5`
    的 NSE 脚本指定了 `500` 秒的超时时间。如果脚本在 `500` 秒内未执行完毕，操作将被中止，并执行队列中的下一个脚本。'
- en: '`General_interactive`: Apart from scripts that require a single-line command
    to be fired and executed, we also have other Bash commands, Kali tools, and open
    source scrips that require some interaction after being fired. A typical example
    would be to SSH to a remote server, where we usually pass two sets of commands.
    This can be done in a single shot, but, just for the sake of understanding, let''s
    take the following example:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`General_interactive`: 除了需要执行单行命令并执行的脚本外，我们还有其他需要在执行后进行一些交互的 Bash 命令、Kali 工具和开源脚本。一个典型的例子是
    SSH 到远程服务器，通常我们需要传递两组命令。这可以一次完成，但为了更好地理解，让我们举个例子：'
- en: '`ssh root@192.168.250.143 [Command 1]`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh root@192.168.250.143 [Command 1]`'
- en: '`password:<my_password> [Command 2]`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password:<my_password> [Command 2]`'
- en: Another example could be tools such as SQLmap, or w3af_console, where some amount
    of user interaction is needed. Note that with this automation/scanning engine,
    we would have a workaround by which scripts would be automatically invoked and
    executed with Python. All scripts or testcases that require interaction are handled
    by a method called `general_interactive()`, which is placed under the Python module
    `auto_comamnds.py`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是工具，如 SQLmap 或 w3af_console，需要一定程度的用户交互。请注意，通过这种自动化/扫描引擎，我们可以通过自动调用 Python
    来解决脚本的问题。所有需要交互的脚本或测试用例都由一个名为 `general_interactive()` 的方法处理，该方法位于 Python 模块 `auto_comamnds.py`
    中。
- en: '`General_commands_timeout_sniff`: There are many occasions in which we need
    to execute a script or a bash command and at the same time we want Wireshark to
    sniff the traffic at the interface so that we can find out if the credentials
    are being passed in cleartext or not. During the execution of scripts in this
    category, the traffic must be sniffed as well. They can either be single-line
    scripts such NSE or interactive commands such as `ssh root@<target_ip>` as the
    first command and `password:<my_password>` as the second. All scripts that need
    this kind of invocation are handled by the Python method `generalCommands_Tout_Sniff()`, which
    is again present in the `auto_comamnds.py` module.'
  id: totrans-46
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`General_commands_timeout_sniff`: 有许多情况下，我们需要执行一个脚本或一个 Bash 命令，同时我们希望 Wireshark
    在接口上嗅探流量，以便我们可以找出凭据是否以明文传递。在执行此类别中的脚本时，流量必须被嗅探。它们可以是单行脚本，如 NSE，也可以是交互式命令，如 `ssh
    root@<target_ip>` 作为第一个命令，`password:<my_password>` 作为第二个命令。所有需要这种调用的脚本都由 Python
    方法 `generalCommands_Tout_Sniff()` 处理，该方法同样位于 `auto_comamnds.py` 模块中。'
- en: '`Metasploit_Modules`: This is the category that will execute and handle all
    the Metasploit modules. Whenever we are required to execute any Metasploit module,
    that module (be it auxiliary or exploit) will be placed inside this classification.
    The method to which the execution is delegated, which is called `custom_meta()`, is
    placed under `auto_commands.py`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit_Modules：这是执行和处理所有Metasploit模块的类别。每当我们需要执行任何Metasploit模块时，该模块（无论是辅助还是利用）都将放置在此分类中。执行委托的方法称为`custom_meta()`，放置在`auto_commands.py`下。
- en: '`HTTP_BASED`: The final category contains all test cases that require an HTTP
    GET/POST request to be posted on the target to be tested, and such cases are handled
    by a method called`http_based()`, which is again placed in the `auto_commands.py` module.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_BASED`：最终类别包含所有需要在目标上发布HTTP GET/POST请求进行测试的测试用例，并且这些情况由名为`http_based()`的方法处理，该方法再次放置在`auto_commands.py`模块中。'
- en: '`include`**: **The `include` parameter takes two values: `True` and `False`)
    If we don''t wish the test case/script to be included in the list of testcases
    to be executed, we can set `include=False`. This feature is very useful when choosing
    scan profiles. There are certain occasions where we don''t want to run time consuming
    testcases such as Nikto or Hoppy on our target and prefer to run only certain
    mandatory checks or scripts. To have that capability the include parameter is
    introduced. We will discuss this further when we look at scan profiles with the
    GUI version of our scanner.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`**: **`include`参数有两个值：`True`和`False`）如果我们不希望将测试用例/脚本包含在要执行的测试用例列表中，我们可以设置`include=False`。在选择扫描配置文件时，此功能非常有用。有时我们不希望在目标上运行耗时的测试用例，例如Nikto或Hoppy，并且更喜欢仅运行某些强制性检查或脚本。为了具有该功能，引入了包含参数。我们将在查看我们的扫描仪的GUI版本时进一步讨论这一点。'
- en: '`title`: This is an informative field, which gives information about the underlying
    script to be executed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个信息字段，提供有关要执行的基础脚本的信息。'
- en: Now that we have a good understanding of the JSON file that will be loaded into
    our `self.commandsJSON` `class variable`, let's move ahead with our code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对将加载到我们的`self.commandsJSON`类变量中的JSON文件有了很好的理解，让我们继续进行我们的代码。
- en: 'The section highlighted as **(6)** reads that JSON file in our `all_config_file`` program
    variable`, which eventually goes to the `self.commandsJSON` class variable. The
    sections of code highlighted as **(7), (8)** and **(9)** load the scan profile
    to be used with the scan:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分**(6)**读取我们的`all_config_file`程序变量中的JSON文件，最终进入`self.commandsJSON`类变量。突出显示的代码部分**(7)，(8)**和**(9)**加载要与扫描一起使用的扫描配置文件：
- en: '![](img/713e7e4b-8050-48d1-9fca-5c71b6923f2f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/713e7e4b-8050-48d1-9fca-5c71b6923f2f.png)'
- en: By default, the scan-profile with the command-line version of our code is **mandatory
    profile**. This profile by and large contains all the testcases that should be
    executed against the target; it just removes a few time-consuming ones. However,
    if we wish to change the definition of `mandatory_profile`, to add subtract test
    cases, we can edit the `mandatory.json` file, which lies at the same path as our
    code file, `driver_meta.py`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的代码的命令行版本的扫描配置文件是**强制性配置文件**。该配置文件基本上包含应针对目标执行的所有测试用例；它只删除了一些耗时的测试用例。但是，如果我们希望更改`mandatory_profile`的定义，以添加或减去测试用例，我们可以编辑`mandatory.json`文件，该文件位于与我们的代码文件`driver_meta.py`相同的路径上。
- en: 'The following are the entries present in the `mandatory.json` file for the
    `http` service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`mandatory.json`文件中为`http`服务存在的条目：
- en: '![](img/69c995fb-6104-47de-8833-c685ade1fb02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c995fb-6104-47de-8833-c685ade1fb02.png)'
- en: 'The section highlighted as (9) will load all the results obtained from the
    port scanning of the project ID `744` for our example. The results are saved inside
    the database table `IPtable_history` and the following screenshot gives us an
    idea of which records will be loaded:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分(9)将加载项目ID`744`的端口扫描获得的所有结果，结果将保存在数据库表`IPtable_history`中，以下屏幕截图给出了将加载的记录的想法：
- en: '![](img/8817ae65-958f-4a75-bfb8-2f7516511948.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8817ae65-958f-4a75-bfb8-2f7516511948.png)'
- en: We can see from the preceding screenshot that there are basically three records
    that correspond to our scan with the ID `744`. The schema of the table columns
    is `(record_id,IP,port_range,status,project_id,Services_detected[CSV_format])`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的屏幕截图中看到，基本上有三条记录对应于我们的ID`744`的扫描。表列的模式是`(record_id,IP,port_range,status,project_id,Services_detected[CSV_format])`。
- en: 'The actual query executed at the backend is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 后端执行的实际查询如下：
- en: '![](img/ab761712-4d83-40b8-99ca-4967034874ad.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab761712-4d83-40b8-99ca-4967034874ad.png)'
- en: The returned result would be a list of lists that can be iterated over. The
    0th index of the first inner list will contain the services detected loaded in
    CSV. The format would be `(host;protocol;port;name;state;product;extrainfo;reason;version;config;cpe)`,
    as can be verified from the preceding screenshot. All this information will be
    placed inside a `results_` list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果将是一个可以迭代的列表。第一个内部列表的第0个索引将包含以CSV格式加载的检测到的服务。格式将是`(主机;协议;端口;名称;状态;产品;额外信息;原因;版本;配置;cpe)`，可以从前面的屏幕截图中验证。所有这些信息将放在`results_`列表中。
- en: 'In section **(10)**, as shown in the folliwng snippet, we are iterating over
    the `results_` list and splitting the string data over the new line `\n`. We are
    further splitting the returned list over `;`, and finally placing all the results
    under a list, `lst1 []`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(10)**部分中，如下片段所示，我们正在遍历`results_`列表，并将字符串数据拆分为新行`\n`。我们进一步将返回的列表拆分为`；`，最后将所有结果放在一个列表`lst1
    []`中：
- en: '![](img/468fa19f-5549-44a3-b1f2-8cfbea3e15b6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/468fa19f-5549-44a3-b1f2-8cfbea3e15b6.png)'
- en: 'For the current example, after section (11), `lst1` will contain the following
    data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前示例，在第(11)部分之后，`lst1`将包含以下数据：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Thus, `lst1[0][0]` will give us `10.0.2.15`, `lst1[2][2]=111` and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`lst1[0][0]`将给我们`10.0.2.15`，`lst1[2][2]=111`等等。
- en: 'In section **(12)** of the code, we are sorting the data in `lst1` by the service
    type. We have declared a dictionary, `lst={}`, and we want to group all the hosts
    and ports according to their type of service, such that the output of section
    **(12)**, **(13)** would be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第**(12)**节中，我们正在按服务类型对`lst1`中的数据进行排序。我们声明了一个字典`lst={}`，并希望根据它们的服务类型对所有主机和端口进行分组，以便第**(12)**，**(13)**节的输出如下：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In section **(15)**, `ss = set(lst_temp).intersection(set(lst_pre))`, we are
    doing a set intersection between two structures that contain dictionary keys.
    One structure contains keys from the dictionary `lst`, which in turn contains
    all the services that our port scanner discovered. The other contains keys that
    are loaded from the preconfigured JSON file.The objective of this is for us to
    see all the discovered services for which test cases are mapped. All the discovered
    and mapped service keys/names go in the list **SS**, which stands for services
    to be scanned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**（15）**节中，`ss = set(lst_temp).intersection(set(lst_pre))`，我们对包含字典键的两个结构进行了交集运算。一个结构包含来自字典`lst`的键，该字典包含我们的端口扫描程序发现的所有服务。另一个包含从预配置的JSON文件中加载的键。这样做的目的是让我们看到所有已映射测试用例的发现服务。所有已发现和映射的服务键/名称都放在列表**SS**中，代表要扫描的服务。
- en: In section **(16)**, `ms=list(set(lst_temp) - set(lst_pre))`, we are comparing
    the services that are not configured in the JSON file against the services discovered.
    Our JSON file is quite exhaustive in terms of commonly found services, but there
    are still cases in which Nmap might find a service during port scanning that is
    not preconfigured in our JSON file. In this section, we are trying to identify
    the services that Nmap has discovered but that do not have testcases mapped against
    them in our JSON file. To do this, we are doing a set difference between the two
    structures. We will tag those services as `new`, and the user can either configure
    testcases against them or analyze them offline to execute custom testcases. All
    these services will be placed in a list called `ms`, where **ms** stands for **missed
    services**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**（16）**节中，`ms=list(set(lst_temp) - set(lst_pre))`，我们正在比较未在JSON文件中配置的服务与发现的服务。我们的JSON文件在常见服务方面非常详尽，但仍然有时Nmap可能会在端口扫描期间发现未在JSON文件中预先配置的服务。在本节中，我们试图识别Nmap发现但在我们的JSON文件中没有针对它们映射测试用例的服务。为此，我们对这两种结构进行了集合差异。我们将标记这些服务为`new`，用户可以对其进行配置测试用例，或者离线分析以执行自定义测试用例。所有这些服务将被放在一个名为`ms`的列表中，其中**ms**代表**未发现的服务**。
- en: 'In sections **(17) and (18)** as shown in the following code snippet, we are
    again restructuring the two missed and mapped services in two different dictionaries
    in the format mentioned earlier: `{"ssh":[[10.0.2.15,22,open,OpenSSH-7.2p2 Debian
    5;10]],...}`. The discovered services will be placed in the `dic` dictionary and
    then into the `self.processed_services` class variable. The missed ones will be
    placed into `ms_dic` and finally into `self.missed_services`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中显示的第**(17)**和**(18)**节中，我们再次将两个未发现和映射的服务重新构建为两个不同的字典，格式如前所述：`{"ssh":[[10.0.2.15,22,open,OpenSSH-7.2p2
    Debian 5;10]],...}`。发现的服务将放在`dic`字典中，然后放入`self.processed_services`类变量中。未发现的服务将放入`ms_dic`，最终放入`self.missed_services`中。
- en: '![](img/fb45071f-0a2e-464b-92e3-afcd94dc1f62.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb45071f-0a2e-464b-92e3-afcd94dc1f62.png)'
- en: Finally, under section **(19)**, we are invoking the `parse_and_process()` method, which
    will invoke the logic of displaying the discovered and missed services and will
    give the user the option to perform any reconfiguration if needed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第**（19）**节中，我们调用`parse_and_process()`方法，该方法将调用显示发现和未发现服务的逻辑，并为用户提供必要时执行任何重新配置的选项。
- en: After reconfiguration is done, `parse_and_process()` will invoke another method, `launchExploits()`,
    which will actually read the `method_name` from the JSON configuration file, replace
    the `<host>` and `<port>` with the appropriate host IP and port discovered, and
    pass the control to the relevant method (based upon the `method_name` read) of
    the `auto_command.py` module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重新配置完成后，`parse_and_process()`将调用另一个方法`launchExploits()`，该方法将实际从JSON配置文件中读取`method_name`，用发现的适当主机IP和端口替换`<host>`和`<port>`，并将控制传递给`auto_command.py`模块的相关方法（根据读取的`method_name`）。
- en: 'Once all the testcases are executed for all the discovered hosts and ports,
    it''s time to generate a report with screenshots and relevant data. This is the
    portion that is handled by sections **(20)** and **(21)**, as shown in the following
    snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对所有发现的主机和端口执行了所有测试用例，就该生成包含屏幕截图和相关数据的报告了。这部分由第**(20)**和**(21)**节处理，如下面的代码片段所示：
- en: '![](img/de832afc-89f4-4334-bb8a-f0b530f0e418.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de832afc-89f4-4334-bb8a-f0b530f0e418.png)'
- en: parse_and_process()
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析和处理()
- en: In the following section, we are going to understand how the `parse_and_process()`
    method works. It should be noted that for the CLI version, the mode variable has
    a value of `c`, and we are going to focus only on the code section that ladders
    to `mode=c`. The other branches of code will be for GUI mode, and you are free
    to read this if you want to know more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将了解`parse_and_process()`方法的工作原理。值得注意的是，对于CLI版本，mode变量的值为`c`，我们将只关注通向`mode=c`的代码部分。代码的其他分支将用于GUI模式，如果您想了解更多，可以自由阅读。
- en: 'The `parse_and_process()` method in sections, **(1), (2), (3),** and **(4)** starts
    its execution by iterating over `self.missed_services` and then over `self.processed_services`.
    The idea of iteration here is to place these discovered services, host, ports
    and `command_template` in a different database table, `IPexploits`. We will discuss
    the `command_template` in a little while. For our current example, the `self.processed_services` will
    contain the following data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(1)，(2)，(3)**和**(4)**节中的`parse_and_process()`方法开始执行，通过迭代`self.missed_services`和`self.processed_services`。这里的迭代思想是将这些发现的服务、主机、端口和`command_template`放入不同的数据库表`IPexploits`。我们将稍后讨论`command_template`。对于当前的示例，`self.processed_services`将包含以下数据：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is because all the discovered services except `rtsp` are mapped in the
    JSON file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为除了`rtsp`之外，所有发现的服务都在JSON文件中映射了。
- en: '![](img/7d65d025-09fe-4937-b2d5-69cb6a2c2701.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d65d025-09fe-4937-b2d5-69cb6a2c2701.png)'
- en: Section **(5)** of the code iterates over this dictionary and tries to fetch
    something such as `getTemplate(k)`, where `k` is the current service being iterated
    over. `getTemplate()` is a method that reads the JSON file and returns the command
    ID for the testcase to be executed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第**(5)**部分遍历此字典，并尝试获取诸如`getTemplate(k)`的内容，其中`k`是当前正在迭代的服务。`getTemplate()`是一个读取JSON文件并返回要执行的测试用例的命令ID的方法。
- en: '![](img/71b39b2a-5e6e-4b57-9c5b-133b20b04f55.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71b39b2a-5e6e-4b57-9c5b-133b20b04f55.png)'
- en: 'The following example will make this clear. Let''s say that `getTemplate` is
    invoked over `http`, such as `getTemplate(''http'')`. This would return the following
    structure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将说明这一点。假设`getTemplate`在`http`上被调用，如`getTemplate('http')`。这将返回以下结构：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The structure is as follows: `{ "http_5" : [''include_command,commands_executed,results_obtained]}`.
    If `http_5` is the key, the value is a list with three entries. The first says
    whether the command is to be included or executed (depending upon the scan profile
    chosen). The second entry holds the actual command that gets executed on the terminal.
    Initially it is set to 0, but once executed, the `0` for `http_5` will be replaced
    by `nmap -Pn --script=banner.nse -p 80 10.0.2.15`.The third, `0`, will actually
    be replaced by the results produced by the execution of the command mentioned.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结构如下：`{"http_5"：['include_command,commands_executed,results_obtained]}`。如果`http_5`是键，那么值是一个包含三个条目的列表。第一个条目表示命令是要包含还是执行（取决于所选择的扫描配置文件）。第二个条目保存在终端上执行的实际命令。最初它设置为0，但一旦执行，`http_5`的`0`将被替换为`nmap
    -Pn --script=banner.nse -p 80 10.0.2.15`。第三个`0`实际上将被执行命令产生的结果所替换。
- en: The code `entries=getTemplate(k)` will return entries such as the one mentioned
    for each service type. We prepare a list called `rows`, where we place the host,
    port, service, open/close status, and entries/`command_template`. The code snippet
    that performs that activity is `self.rows.append((self.project_id, str(h_p[0]),
    str(h_p[1]), str(k), 'init', entries, service_status, str(h_p[2]), str(h_p[3])))`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`entries=getTemplate(k)`将为每种服务类型返回一个类似上述的条目。我们准备一个名为`rows`的列表，其中放置主机、端口、服务、开/关状态和条目/`command_template`。执行该活动的代码片段是`self.rows.append((self.project_id,
    str(h_p[0]), str(h_p[1]), str(k), 'init', entries, service_status, str(h_p[2]),
    str(h_p[3])))`。
- en: 'The services where the `type=new` or that are not mapped will be handled by
    code section **(2)**. This will place the following in the entries for our example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`type=new`的服务或未映射的服务将由代码部分**(2)**处理。这将在我们的示例条目中放置以下内容：'
- en: '`entries={"Entries": {"new": true, "unknown": false}}`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries={"Entries": {"new": true, "unknown": false}}`'
- en: Code section **(6)** checks for something such as `if(is_custom==True)`. This
    means that, there are certain services that can be used multiple times with other
    services. For example, the testcases for `ssl` can be used with `https` such as `[http
    +ssl]`, `ftps` as `[ftp + ssl]`, `ssh` as `[ssh + ssl]`. For this reason, services
    such as `https`, `ftps`, and so on are marked as `custom`, and when `https` is
    discovered, we should load both templates for `http` and `ssl`. This is what is
    done in section **(6).**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分**(6)**检查诸如`if(is_custom==True)`之类的内容。这意味着有一些服务可以与其他服务多次使用。例如，`ssl`的测试用例可以与`https`一起使用，如`[http
    +ssl]`，`ftps`作为`[ftp + ssl]`，`ssh`作为`[ssh + ssl]`。因此，诸如`https`，`ftps`等服务被标记为`custom`，当发现`https`时，我们应该加载`http`和`ssl`的两个模板。这就是在第**(6)**部分中所做的。
- en: By the end of section(6), `self.rows` will have entries such as `[project_id,host,port,service,project_status,command_template,service_type,port_state,version]` for
    all hosts and ports. In our current example, it will hold six rows for all the
    service types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(6)部分结束时，`self.rows`将为所有主机和端口的所有服务类型保存类似`[project_id,host,port,service,project_status,command_template,service_type,port_state,version]`的条目。在我们当前的示例中，它将为所有服务类型保存六行。
- en: In section **(7)**, `self.IPexploit.insertIPexploits(self.rows)`, we push all
    the data of `self.rows` in the backend database table `IPexploits` in one shot.
    It must be remembered that the datatype of `command_template/entries` is marked
    as JSON in the backend database as well. For this reason, we require MySQL version
    5.7 or above, which supports the JSON datatype.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(7)**部分，`self.IPexploit.insertIPexploits(self.rows)`，我们一次性将`self.rows`的所有数据推送到后端数据库表`IPexploits`中。必须记住，后端数据库中`command_template/entries`的数据类型也标记为JSON。因此，我们需要MySQL版本5.7或更高版本，支持JSON数据类型。
- en: 'After this command is executed, our backend database for the current project `744` would
    look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们当前项目`744`的后端数据库将如下所示：
- en: '![](img/a7c5a600-cb6f-495c-a35f-04aa627ab35b.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c5a600-cb6f-495c-a35f-04aa627ab35b.png)'
- en: 'It must be noted that I am not loading the `command_template` (named `Exploits`
    at the back end ), because then the data becomes cluttered. Let''s try to load
    the template for two services, such as `rtsp` and `ssh`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，我没有加载`command_template`（在后端命名为`Exploits`），因为数据会变得混乱。让我们尝试加载两个服务的模板，如`rtsp`和`ssh`：
- en: '![](img/cb545040-2968-4d87-815a-460221e76c30.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb545040-2968-4d87-815a-460221e76c30.png)'
- en: Likewise, we will also have entries for `http`, `ssl`, and `rcpbind`. It should
    be noted that we were expecting six rows in the table, but there are in fact seven.
    This is because the `https` service is broken into two classes `http` and `ssl`,
    thus, at port `443`, instead of having `https`, we have two entries: `http-443` and `ssl-443`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还将有`http`，`ssl`和`rcpbind`的条目。应该注意的是，我们预计表中有六行，但实际上有七行。这是因为`https`服务被分为两类`http`和`ssl`，因此，在端口`443`上，我们不是有`https`，而是有两个条目：`http-443`和`ssl-443`。
- en: 'In the next section, the default configuration of the project (host, ports,
    testcases to be executed) is fetched from the same database table and is displayed
    to the user. Section eight calls the code using `launchConfiguration()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，项目的默认配置（主机、端口、要执行的测试用例）从同一数据库表中获取，并显示给用户。第八部分调用代码使用`launchConfiguration()`：
- en: '![](img/5b5026d0-b02a-484b-929c-fa6bfa035ca2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b5026d0-b02a-484b-929c-fa6bfa035ca2.png)'
- en: launchConfiguration()
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: launchConfiguration()
- en: In this section, let's take a look at the `launchConfiguration()` method, which
    loads default configurations, and also gives the user the ability to tweak or
    reconfigure it. Furthermore, it invokes the central logic of the file that would
    actually start script execution, which is `launchExploits()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，让我们来看一下`launchConfiguration()`方法，它加载默认配置，并且还允许用户进行微调或重新配置。此外，它调用了文件的中心逻辑，实际上会启动脚本执行，即`launchExploits()`。
- en: For the CLI version `launchExploits()` is invoked by `launchConfiguiration()`.
    However, in the GUI version, `launchExploits()` is invoked by the `parse_and_process()`
    method only. More information about this method can be seen from the preceding
    screenshot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CLI版本，`launchExploits()`是由`launchConfiguiration()`调用的。然而，在GUI版本中，`launchExploits()`只能由`parse_and_process()`方法调用。有关此方法的更多信息可以从前面的截图中看到。
- en: Section**(1)** of the following code snippet loads all details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits` list.
    Remember that in the backend table we only have the command IDs, such as `http_1` or `http_2` placed
    under the `Template`, but to display the selected configuration and commands to
    be executed, we pull out the actual script, which will map to `http-1` and so
    on. This is what section **(2)** is doing. It reads the JSON file to get the actual
    commands.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的第1节加载了放置在当前项目的`IPexploits`表中的所有细节。我们已经看到了将被拉出并放置在`IPexploits`列表下的七行。请记住，在后端表中，我们只有命令ID，例如`http_1`或`http_2`放在`Template`下，但是为了显示所选的配置和要执行的命令，我们拉出实际的脚本，它将映射到`http-1`等等。这就是第2节在做什么。它读取JSON文件以获取实际命令。
- en: 'In section **(3)**, we are placing the pulled details in a `tab_draw` variable, which
    will draw a table on the console window and represent the loaded configuration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3节中，我们将拉取的细节放在`tab_draw`变量中，它将在控制台窗口上绘制一个表，并表示加载的配置：
- en: '![](img/990785c3-c2da-44ba-a39b-8c30e0a52216.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/990785c3-c2da-44ba-a39b-8c30e0a52216.png)'
- en: 'Section **(4)** is self explanatory; we are placing all the pulled details
    in a dictionary called `config_entry`. This will be saved to a file, as the final
    chosen configuration with the scan will be launched:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第4节是不言自明的；我们将所有拉取的细节放在一个名为`config_entry`的字典中。这将被保存到一个文件中，因为最终选择的配置与扫描将被启动：
- en: '![](img/d6554158-8c15-420d-9e66-d22d7e042f83.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6554158-8c15-420d-9e66-d22d7e042f83.png)'
- en: 'Finally, under section **(6)**, we call `launchExploits()`. If there is a need
    to perform reconfiguration, section **(7)** calls the `self.reconfigure()` method,
    which is straightforward and can be referred from the code-base or from the following URL
    <https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/driver_meta.py>:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第6节下，我们调用`launchExploits()`。如果需要执行重新配置，第7节调用`self.reconfigure()`方法，该方法很简单，可以从代码库或以下URL
    <https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/driver_meta.py>
    中找到：
- en: '![](img/6433c485-b025-4b3f-9c44-0434e0202025.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6433c485-b025-4b3f-9c44-0434e0202025.png)'
- en: 'Section**(5)** will display the configuration on the screens as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第5节将如下显示屏幕上的配置：
- en: '![](img/c51bda78-c507-42b4-b873-91884245dc26.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c51bda78-c507-42b4-b873-91884245dc26.png)'
- en: '![](img/fb31c123-1961-459a-ad79-f98169b64cdc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb31c123-1961-459a-ad79-f98169b64cdc.png)'
- en: launchExploits()
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: launchExploits()
- en: The following section will talk about the `launchExploits()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将讨论`launchExploits()`方法。
- en: 'Section**(9)** of the following code loads all the details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits_data` list.
    We don''t need to focus on the `else` block of `if(concurrent=False)`, as that
    refers to code that is invoked in the GUI version. For now, let''s only take the
    `if` block into consideration, as `concurrent=False` for the CLI version. Next,
    we iterate over the `IPexploits_data: "for exploit in IPexploits_data:"` structure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码的第9节加载了放置在当前项目的`IPexploits`表中的所有细节。我们已经看到了将被拉出并放置在`IPexploits_data`列表下的七行。我们不需要关注`if(concurrent=False)`的`else`块，因为那是指在GUI版本中调用的代码。现在，让我们只考虑`if`块，因为对于CLI版本，`concurrent=False`。接下来，我们遍历`IPexploits_data:
    "for exploit in IPexploits_data:"`结构：'
- en: '![](img/d6763f0f-2643-46cd-aae9-d051b4138781.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6763f0f-2643-46cd-aae9-d051b4138781.png)'
- en: In section **(10)**, we loading the details from the JSON structure for the
    current service that is being iterated. Remember that `self.commandsJSON` holds
    the whole JSON file data where we mapped the services and testcases. We then load
    all the commands and testcases of that particular service and placing them under
    a list `meta`. For example, if `service = http`, then the meta will hold `[http_1,http_2,http_3,http_4,http_5
    ...]`. Now, remember that in the last section, for each record out of the seven
    records, the `project_status` was `init`. In the next line (section **(11)**),
    we update the status to `processing` for the current record's `(host,port,service,record_id)` combination.
    As we have already picked up this service to be executed, we want to change the
    database status.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10节中，我们从当前正在迭代的服务的JSON结构中加载细节。请记住，`self.commandsJSON`保存了整个JSON文件数据，我们在其中映射了服务和测试用例。然后，我们加载该特定服务的所有命令和测试用例，并将它们放在一个名为`meta`的列表下。例如，如果`service
    = http`，那么meta将包含`[http_1,http_2,http_3,http_4,http_5 ...]`。现在，请记住，在最后一节中，对于七条记录中的每条记录，`project_status`都是`init`。在下一行（第11节），我们将当前记录的`(host,port,service,record_id)`组合的状态更新为`processing`。因为我们已经选择了执行此服务，我们希望更改数据库状态。
- en: In section **(12)**, we load all the enabled service cases for the particular
    service to be executed, depending upon the scan profile chosen for the project.
    As discussed earlier, we have all the essential cases loaded.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12节中，我们加载了为项目选择的扫描配置所执行的特定服务用例的所有启用服务用例。
- en: 'There are certain projects/scans that may also need some user defined parameters,
    such as username, passwords to use, and so on. All such parameters are placed
    inside a `Project_params.json` file, and section **(13)** replaces the usernames
    and passwords of the command to be executed with the project specific usernames
    and passwords, wherever applicable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些项目/扫描可能需要一些用户定义的参数，例如要使用的用户名、密码等。所有这些参数都放在一个`Project_params.json`文件中，第**(13)**节将要执行的命令中的项目特定用户名和密码替换为适用的项目特定用户名和密码：
- en: '![](img/041520fe-43b0-49b0-8a05-bbf48c712f04.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/041520fe-43b0-49b0-8a05-bbf48c712f04.png)'
- en: '`Self.commandObj` holds the object of the `auto_commands.pl` class. Section **(14)** initializes
    the instance variables of the class that are relevant to the current record set
    to be executed (host, port, service, and so on). As we discussed earlier, the `args` parameter
    from the JSON file contains the actual command to be executed. We loaded the `args` value
    in the program variable args. As we know, this is a list that contains commands.
    We iterate over this list and replace entries such as `<host>` with the actual
    IP to be scanned and `<port>` with the actual port to be scanned. We will repeat
    this activity for all the testcases, one by one. For the current example, if we
    assume that `http` is the current service to be scanned, the code will iterate
    over all the commands, `[http_1,http_2..]`. Finally, the `final_args` list for `http_5` and
    port `80` will be specified as `[500, nmap -Pn --script=banner.nse -P80 10.0.2.5]`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Self.commandObj`保存了`auto_commands.pl`类的对象。第**(14)**节初始化了与要执行的当前记录集相关的类的实例变量（主机、端口、服务等）。正如我们之前讨论的，JSON文件中的`args`参数包含要执行的实际命令。我们将`args`的值加载到程序变量args中。我们知道，这是一个包含命令的列表。我们遍历这个列表，并将诸如`<host>`之类的条目替换为要扫描的实际IP，将`<port>`替换为要扫描的实际端口。我们将逐个为所有测试用例重复这个活动。对于当前示例，如果我们假设`http`是要扫描的当前服务，代码将遍历所有命令`[http_1,http_2..]`。最后，`http_5`和端口`80`的`final_args`列表将被指定为`[500,
    nmap -Pn --script=banner.nse -P80 10.0.2.5]`：'
- en: '![](img/e6ed344b-bd52-4367-a752-f63f7824bf31.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6ed344b-bd52-4367-a752-f63f7824bf31.png)'
- en: 'In section **(16)**, we are actually invoking the appropriate method from the `auto_comamnds.py` module. Let''s
    think about how this works. `getattr(object, name[, default])` returns the value
    of the named attribute of `object. name` and must be a string. If the string is
    the name of one of the object’s attributes, the result is the value of that attribute.
    For example, `getattr(x,''Method_name'')` is equivalent to `x. Method_name`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(16)**节中，我们实际上是从`auto_comamnds.py`模块中调用适当的方法。让我们思考一下这是如何工作的。`getattr(object,
    name[, default])`返回`object`的命名属性的值。如果字符串是对象属性之一的名称，则结果是该属性的值。例如，`getattr(x,'Method_name')`等同于`x.
    Method_name`：
- en: '![](img/b9c3517f-c4db-4c63-bc00-dfbb45d6796d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9c3517f-c4db-4c63-bc00-dfbb45d6796d.png)'
- en: 'As we have already discussed, the name of the method to execute the script/module
    is preconfigured in the JSON file, and in the preceding code it is read in the
    variable method. `func = getattr(self.commandObj,method_name)` will return the
    reference of that method, and can be invoked such as `func(args)`. This is what
    is done in section **(18)**: `func(final_args,grep_commands)`. When that method
    is executed, it will automatically save the results in the database. Once all
    the test cases for a service are executed, we want to update the status of that
    row from `processing` to `complete`, which is what is done at section **(20)**.
    The same operation is repeated until all the discovered services for all the hosts
    are scanned. Let''s take a look at what the database table looks like when a test
    case is executed. We will be taking examples from a different project ID:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，要执行脚本/模块的方法的名称在JSON文件中预先配置，并且在前面的代码中它被读入变量方法。`func = getattr(self.commandObj,method_name)`将返回该方法的引用，并且可以被调用，比如`func(args)`。这就是第**(18)**节中所做的：`func(final_args,grep_commands)`。当执行该方法时，它将自动将结果保存在数据库中。一旦一个服务的所有测试用例都执行完毕，我们希望将该行的状态从`processing`更新为`complete`，这就是第**(20)**节所做的。相同的操作会重复，直到所有主机的所有发现的服务都被扫描。让我们看一下当执行一个测试用例时数据库表是什么样子的。我们将从不同的项目ID中取一些例子：
- en: '![](img/36cb2886-81b8-4eb0-b265-0a256cb7a1c6.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36cb2886-81b8-4eb0-b265-0a256cb7a1c6.png)'
- en: 'As can be seen from the preceding screenshot, the data for this particular
    row for the project ID 736 before service scanning would have been as follows:
    `Pid=736,Service=''ssl'',Exploits={"Entries" :{"ssl_1":[true,0,0]} ... }`. Once
    the execution is over, however, the first 0 is replaced by a list that has the
    command(s) executed. In place of the second 0, we have the final results in the
    form of a string.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，项目ID 736的这一行在服务扫描之前的数据如下：`Pid=736,Service='ssl',Exploits={"Entries"
    :{"ssl_1":[true,0,0]} ... }`。然而，一旦执行结束，第一个0将被一个包含执行的命令的列表所替换。第二个0的位置，我们有最终结果的字符串形式。
- en: auto_commands.py
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动_commands.py
- en: 'In the next section, we will take a look at how stuff actually works, in terms
    of how the methods that get invoked automate the process of service scanning.
    We will be exploring the Python module or file `auto_commands.py`. It must be
    remembered that in this section, we will be covering the essential methods of
    this class. As well as these, there are a few others that are custom made for
    specific use cases. You can refer to the exact code file at the GitHub repository
    [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py%3E).
    Let''s start by looking at what the class looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下实际工作的方式，即调用的方法如何自动化服务扫描的过程。我们将探索Python模块或文件`auto_commands.py`。必须记住，在本节中，我们将涵盖该类的基本方法。除此之外，还有一些其他方法是为特定用例定制的。您可以在GitHub存储库的确切代码文件中查看[<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py%3E)。让我们首先看一下这个类是什么样子的：
- en: '![](img/0fce252f-5930-4159-a26d-36ccbe015f1e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fce252f-5930-4159-a26d-36ccbe015f1e.png)'
- en: One of the modules we imported was **pexpect**. In the following section, let's
    try to understand what this module does and why it is important.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的模块之一是**pexpect**。在接下来的部分中，让我们试着理解这个模块的作用以及它为什么重要。
- en: Pexpect
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pexpect
- en: Pexpect is a Python module that works like Unix's expect library. The primary
    purpose of this library is to automate interactive console commands and utilities.
    Pexpect is a pure Python module for spawning child applications, controlling them,
    and responding to expected patterns in their output. Pexpect allows your script
    to spawn a child application and control it as if a human were typing commands.
    Pexpect can be used for automating interactive applications such as SSH, FTP,
    passwd, telnet, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect是一个类似Unix的expect库的Python模块。这个库的主要目的是自动化交互式控制台命令和实用程序。Pexpect是一个纯Python模块，用于生成子应用程序、控制它们，并响应其输出中的预期模式。Pexpect允许您的脚本生成子应用程序并控制它，就像一个人在键入命令一样。Pexpect可用于自动化交互式应用程序，如SSH、FTP、passwd、telnet等。
- en: 'We will be using Pexpect to automate Metasploit with Python and also in to
    invoke various use-cases of terminal automation that require user interaction.
    It must be noted that there are two other methods for invoking Metasploit with
    Python code: `"msfrpc"`, which calls the service API built on top of Metasploit,
    and `".rc"` scripts. We have observed maximum success, however, using the Pexpect
    module.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Pexpect来使用Python自动化Metasploit，并且还将调用需要用户交互的终端自动化的各种用例。必须注意的是，还有另外两种用Python代码调用Metasploit的方法："msfrpc"，它调用了建立在Metasploit之上的服务API，以及".rc"脚本。然而，我们观察到使用Pexpect模块的成功率最高。
- en: The Pexpect module has a spawn class that is used to spawn any terminal command,
    process, or tool. The tools that are spawned should be spawned as a child process
    of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect模块有一个spawn类，用于生成任何终端命令、进程或工具。生成的工具应作为代码的子进程生成。
- en: 'The syntax for the spawn class constructor is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: spawn类构造函数的语法如下：
- en: '`pexpect.spawn(command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
    logfile=None, cwd=None, env=None, ignore_sighup=False, echo=True, preexec_fn=None,
    encoding=None, codec_errors=''strict'', dimensions=None, use_poll=False)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect.spawn(command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
    logfile=None, cwd=None, env=None, ignore_sighup=False, echo=True, preexec_fn=None,
    encoding=None, codec_errors=''strict'', dimensions=None, use_poll=False)`'
- en: 'The `spawn` class constructor takes many parameters, but the mandatory one
    is `command`. The `command` is the actual command that we wish to execute on a
    Unix terminal. If we wish to pass arguments to the command invoked, we can either
    specify the arguments with the command itself, separated with a space, or pass
    the arguments as a Python list specified under the second argument `args`. The
    third argument is `timeout`, which is 30 seconds by default. This implies that
    if a process is not spawned within 30 seconds, the whole operation will be terminated.
    If our server is under a high load, or we have performance issues, we can increase
    the `timeout` parameter. The following code represents how to invoke an SSH session
    with Pexpect:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`类构造函数有许多参数，但强制参数是`command`。`command`是我们希望在Unix终端上执行的实际命令。如果我们希望传递参数给调用的命令，我们可以在命令本身中指定参数，用空格分隔，或者将参数作为Python列表传递到第二个参数`args`下。第三个参数是`timeout`，默认为30秒。这意味着如果在30秒内未生成进程，整个操作将被终止。如果我们的服务器负载很高，或者我们有性能问题，我们可以增加`timeout`参数。以下代码表示如何使用Pexpect调用SSH会话：'
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also construct it with a list of arguments as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用参数列表构造它，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the command is executed on the terminal, a session is created and controlled
    via the process, which is returned and placed under the `child` variable, as shown
    in the preceding example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当在终端上执行命令时，会创建一个会话，并通过返回的进程进行控制，该进程被放置在`child`变量下，如前面的示例所示。
- en: Another important class for `pexpect` is `expect`. Expect, as the name suggests,
    lays down the expected output or outputs that might be produced if the `spawn`
    command is executed successfully. For example, if the `spawn` command is `pexpect.spawn('/usr/bin/ssh',['user@example.com'])`,
    we would usually expect the ssh server to ask us for a password. All the possible
    patterns or strings that might be expected from the previously specified command
    are passed as arguments to the `pexpect.expect` class, and if any of the patterns
    match, we can define the next command to be sent to the terminal according to
    the match. If there is no match, we may abort the operation and try to debug it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect`的另一个重要类是`expect`。如其名称所示，Expect规定了在成功执行`spawn`命令时可能产生的预期输出或输出。例如，如果`spawn`命令是`pexpect.spawn(''/usr/bin/ssh'',[''user@example.com''])`，我们通常期望ssh服务器要求我们输入密码。从先前指定的命令中可能期望的所有可能模式或字符串都作为参数传递给`pexpect.expect`类，如果任何模式匹配，我们可以根据匹配定义要发送到终端的下一个命令。如果没有匹配，我们可以中止操作并尝试调试。'
- en: 'The following syntax looks through the stream until a pattern is matched. The
    pattern is overloaded and may take several types. The pattern can be a String
    Type, EOF, a compiled regular expression, or a list of any of those types:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法查找流，直到匹配模式。模式是重载的，可能有多种类型。模式可以是字符串类型、EOF、编译的正则表达式，或者是任何这些类型的列表：
- en: '`pexpect.expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw)`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect.expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw)`'
- en: 'If you pass a list of patterns and more than one matches, the first match in
    the stream is chosen. If more than one pattern matches at this point, the leftmost
    pattern in the pattern list is chosen. For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了模式列表，并且有多个匹配项，则流中选择第一个匹配项。如果此时有多个模式匹配，则选择模式列表中最左边的模式。例如：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`child.sendLine(command)` is a method that takes the command that is to be
    sent to the terminal assuming everything is working as per the expected pattern:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`child.sendLine(command)`是一个方法，它接受要发送到终端的命令，假设一切都按预期模式工作：'
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a small example of SSH automation using Pexpect that will make
    things clearer:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Pexpect进行SSH自动化的小例子来更清楚地说明问题：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we are taking only the success scenario. It must be noted
    that if the terminal expects what lies at index 1 of the input list `'root@.*
    password:.'`, then we pass the password as root with the help of the `sendline`
    method. Note that `'root@.* password:.'` indicates any IP address after root,
    because it is a regex pattern*.* Based on the index of the string/regex pattern
    matched, we can formulate our logic to indicate what should be done next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只考虑成功的情况。必须注意，如果终端期望输入列表的第1个索引`'root@.* password:.'`，那么我们将使用`sendline`方法将密码作为root传递。注意`'root@.*
    password:.'`表示root后面的任何IP地址，因为它是一个正则表达式模式。根据匹配的字符串/正则表达式模式的索引，我们可以制定逻辑来指示接下来应该做什么。
- en: custom_meta()
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义_meta()
- en: Let's now take a look at the `custom_meta` method, which is responsible for
    handling all the Metasploit modules. It does this with the help of the Pexpect
    library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`custom_meta`方法，它负责处理所有的Metasploit模块。它借助Pexpect库完成这一工作。
- en: 'As can be seen in section **(1)** in the following snippet, we are using `pexpect.spawn`
    to invoke `"msfconsole -q"`, on our terminal. This will invoke a Metasploit process
    over a virtual terminal and would return the control of that process to the variable
    declared as a child:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在以下片段的第**(1)**部分中所示，我们使用`pexpect.spawn`在我们的终端上调用`"msfconsole -q"`。这将在虚拟终端上调用一个Metasploit进程，并将该进程的控制返回给声明为child的变量：
- en: '![](img/3fab3c20-acfd-4dad-a8cf-27e946740955.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fab3c20-acfd-4dad-a8cf-27e946740955.png)'
- en: 'Whenever we invoke msfconole, if there is no error, we would get a Metasploit
    prompt as `msf>`. This is what we are specifying in section **(2)**, [.*>, ..,
    ..] , as the 0th index. What is implied here is that we expect anything preceded
    by `>` to be successfully executed, and so we will pass the commands that are
    required to run the Metasploit module. If the index returned by child.expect is
    0, we will iterate over the command list of the JSON file and send each command
    to our Metasploit console. For our projectID `744` and the `http` service, we
    have configured a few Metasploit modules. One of these is shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用msfconole时，如果没有错误，我们将得到一个Metasploit提示符，如`msf>`。这就是我们在第**(2)**部分中指定的，[.*>,
    .., ..]，作为第0个索引。这里暗示的是，我们期望任何`>`之前的内容都能成功执行，因此我们将传递运行Metasploit模块所需的命令。如果child.expect返回的索引为0，我们将遍历JSON文件的命令列表，并将每个命令发送到我们的Metasploit控制台。对于我们的projectID
    `744`和`http`服务，我们配置了一些Metasploit模块。其中一个如下所示：
- en: '![](img/3641e7b9-2482-4cdc-b45f-a543895132bf.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3641e7b9-2482-4cdc-b45f-a543895132bf.png)'
- en: Whatever is within the `args` keyin the preceding screenshot of the JSON structure
    would be passed as a list to the `custom_meta` method and stored in the commands
    list. In section **(3)****,** we iterate over the commands list, and, as we studied
    earlier, the `<host>` and `<port>` would actually be replaced by an actual host
    and the port being scanned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的JSON结构的`args`键中的任何内容都将作为列表传递给`custom_meta`方法，并存储在commands列表中。在第**(3)**部分，我们遍历commands列表，并且，正如我们之前学过的那样，`<host>`和`<port>`实际上将被实际主机和正在扫描的端口替换。
- en: 'In this section, each command is sent to the msfconsole Terminal one by one
    with the `child.sendline(cmd)` command. After sending each command, we need to
    check whether the console is as we expect it to be, which means that it should
    contain the `msf>` prompt. We invoke `pexpect.expect` and specify `".*>"` as the
    0th index of our input list. Note that index 0 defines the success criteria for
    us to continue. As long as we get an output that matches with index 0, we continue,
    as specified by section **(4)**. If at anytime we observe anything other than
    index 0 (either a timeout or the end of a file – EOF), we realize that something
    did not happen as expected, and so we set the boolean variable as false:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，每个命令都会使用`child.sendline(cmd)`命令逐个发送到msfconsole终端。发送每个命令后，我们需要检查控制台是否符合我们的预期，也就是说它应该包含`msf>`提示符。我们调用`pexpect.expect`并将`".*>"`指定为我们输入列表的第0个索引。注意，索引0定义了我们继续的成功标准。只要我们得到与索引0匹配的输出，我们就继续，如第**(4)**部分所指定的那样。如果我们在任何时候观察到除索引0之外的任何内容（超时或文件结束-EOF），我们意识到某些事情并没有按预期发生，因此我们将布尔变量设置为false：
- en: '![](img/235e44b2-6881-4aef-adc9-3194a695d5bc.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/235e44b2-6881-4aef-adc9-3194a695d5bc.png)'
- en: When we get out of this iterative loop, we move to section **(9)**, where we
    are checking if run ==True. If it is true, we assume all the parameters are properly
    set to execute the Metasploit module. We issue the `'run'` command with the help
    of `sendline`, as highlighted by section **(10)**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出这个迭代循环时，我们转到第**(9)**部分，检查run == True。如果为真，我们假设所有参数都已正确设置以执行Metasploit模块。我们使用`sendline`发出`'run'`命令，如第**(10)**部分所示。
- en: 'Finally, if everything goes right and the module is executed successfully,
    it''s time for us to collect our results. In section **(11)**, if all goes as
    expected, we collect the results in an `exploits_results` variable and the commands
    in the `commands_launched` variable. If there is an error, we collect the error
    details in section **(12)**:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，模块成功执行，那么现在是收集结果的时候了。在第**(11)**部分，如果一切如预期那样进行，我们将在`exploits_results`变量中收集结果，并在`commands_launched`变量中收集命令。如果出现错误，我们将在第**(12)**部分中收集错误详情：
- en: '![](img/5fc5665f-f413-4ef1-88d2-aaa653010a87.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fc5665f-f413-4ef1-88d2-aaa653010a87.png)'
- en: 'Finally, in section **(14)**, we save the results in the database table by
    invoking the `saveDetails()`method**.** It must be noted that the results would
    be saved in the same JSON structure as discussed earlier against the `"http_headers_2"`
    key, which is the ID of the script. The definition of the `saveDetails` method is
    shown. Note it would be issued across all the different methods that we will discuss:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第**(14)**部分，我们通过调用`saveDetails()`方法将结果保存在数据库表中。必须注意，结果将以与之前讨论的相同的JSON结构保存在`"http_headers_2"`键下，这是脚本的ID。`saveDetails`方法的定义如下。请注意，它将被应用于我们将讨论的所有不同方法：
- en: '![](img/3eb32e5f-a63e-4e35-a349-d65ce07842ac.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eb32e5f-a63e-4e35-a349-d65ce07842ac.png)'
- en: The section highlighted as **(1)** invokes the method placed in the class file
    `IPexploits.py`, which would insert the details in the database. The whole code
    file can be found at the GitHub repository**.**
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1）**部分调用了放置在类文件`IPexploits.py`中的方法，该方法将在数据库中插入详细信息。整个代码文件可以在GitHub存储库中找到。'
- en: singleLineCommands_Timeout()
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: singleLineCommands_Timeout()
- en: In this section, we will see the definition of the `singleLineCommands_Timeout` method.
    This section of code explains the power of threading and multiprocessing. We studied
    all the concepts earlier, but in this section, we will see how can we apply the
    concepts of threads and processes to solve real-world problems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到`singleLineCommands_Timeout`方法的定义。这部分代码解释了线程和多进程的强大之处。我们之前学习了所有概念，但在本节中，我们将看到如何应用线程和进程的概念来解决现实世界的问题。
- en: The problem at hand is to execute all the categories of commands and scripts
    that can be executed by just firing a single line at the console. These produce
    the output. This might look straightforward, but there is a catch. Remember that
    we discussed occasions in which the execution of a script may take a long time
    for some unforeseen reason and we should design our solution in a manner such
    that we have a timeout associated with all the script categories where this might
    be the case. Here, we will be using threads to implement the timeout functionality.
    A combination of threads and processes will help us achieve our objective.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 手头的问题是执行所有可以通过在控制台上输入一行命令来执行的命令和脚本的所有类别。这些产生输出。这可能看起来很简单，但有一个问题。请记住，我们讨论过脚本的执行可能因为某些不可预见的原因而需要很长时间，我们应该设计我们的解决方案，以便所有可能出现这种情况的脚本类别都有一个关联的超时。在这里，我们将使用线程来实现超时功能。线程和进程的组合将帮助我们实现我们的目标。
- en: 'The central idea is to invoke a thread and bind it to a method "x". We call
    `join()` on the thread invoked and the duration of `join()` would be the timeout
    specified in the JSON file. As we studied earlier, the `join()` method, when invoked
    over a thread ''t'', from the main thread ''m'', will cause the main thread ''m''
    to wait until ''t'' finishes its execution. If we invoke join (20) over thread
    ''t'' from the main thread ''m'', this will cause the main thread ''m'' to wait
    for 20 seconds for ''t'' to finish. After 20 seconds, the main thread will continue
    its execution and exit. We can use the same analogy to achieve our task:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是调用一个线程并将其绑定到一个方法"x"。我们在调用的线程上调用`join()`，`join()`的持续时间将是JSON文件中指定的超时时间。正如我们之前学过的，当从主线程'm'上的线程't'上调用`join()`方法时，将导致主线程'm'等待，直到't'完成其执行。如果我们在主线程'm'上的线程't'上调用`join(20)`，这将导致主线程'm'等待20秒，直到't'完成。20秒后，主线程将继续执行并退出。我们可以使用相同的类比来实现我们的任务：
- en: '![](img/bf96f815-d45b-4934-b60f-b72e6c54bafb.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf96f815-d45b-4934-b60f-b72e6c54bafb.png)'
- en: In sections **(1)** and **(2)**, we are creating a `thread` object, and the
    method we are attaching to it is `"execute_singleLine"`. It should be noted that
    there are certain occasions where we want to grep out something from the final
    output, which is why we are checking whether the `grep` parameter is set. If it
    is set, we send the `grep` string as an argument to the thread method; otherwise,
    we only send the console script/command that the method is supposed to invoke.
    We don't need to worry about the grep condition for now.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在**（1）**和**（2）**部分，我们正在创建一个`thread`对象，并将其附加到`"execute_singleLine"`方法。应该注意的是，有时我们希望从最终输出中提取出一些内容，这就是为什么我们要检查`grep`参数是否设置。如果设置了，我们将`grep`字符串作为参数发送到线程方法；否则，我们只发送方法应该调用的控制台脚本/命令。现在我们不需要担心grep条件。
- en: 'In section **(3)**, we can see that we are collecting the timeout parameter,
    which is always at index 0 of the commands list or at the 0th index of the args
    from the JSON file. We invoke the start method on the thread, which will invoke
    the `"execute_singleLine"` method and pass the command to be executed as an argument.
    After that, we invoke `join(timeout)`, on the thread invoked, the code will be
    halted there until the duration of seconds specified under timeout. No line after
    section **(3)** will be executed until either the `"execute_singleLine"` method is
    finished or the time exceeds the timeout. Before moving on, let''s take a closer
    look at what is happening within the  `"``execute_singleLine``"` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在**（3）**部分，我们可以看到我们正在收集超时参数，该参数始终位于命令列表的索引0处，或者位于JSON文件的args的第0个索引处。我们在线程上调用start方法，该方法将调用`"execute_singleLine"`方法，并将要执行的命令作为参数传递。之后，我们在调用的线程上调用`join(timeout)`，代码将在那里暂停，直到超时指定的秒数为止。在**（3）**部分之后不会执行任何行，直到`"execute_singleLine"`方法完成或时间超过超时。在继续之前，让我们更仔细地看看`"execute_singleLine"`方法中发生了什么：
- en: '![](img/5ff0426b-08ff-46f1-bf48-998fd440d39e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff0426b-08ff-46f1-bf48-998fd440d39e.png)'
- en: As specified by section **(1)** of the `"execute_singleLine()"` method, we are
    making use of Python's subprocess module to spawn a child process. The process
    will be specified by the command present in the `"cmd"` variable. Therefore, if
    `cmd` holds "`nmap -Pn --script=banner.nse -p 80 192.168.250.143`", the same command
    will be executed at the terminal, which is nothing but a process at OS level. The
    instance of the process class will be returned and placed under the `self.process` class
    variable. The instance holds various properties such as `"id"`, `"is_alive()"`,
    and so on, which give us information about the state of the process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如`"execute_singleLine()"`方法的**（1）**部分所述，我们正在利用Python的subprocess模块来生成一个子进程。进程将由`cmd`变量中的命令指定。因此，如果`cmd`包含"`nmap
    -Pn --script=banner.nse -p 80 192.168.250.143`"，则相同的命令将在终端上执行，这只是操作系统级别的一个进程。进程类的实例将被返回并放置在`self.process`类变量下。该实例具有各种属性，如`"id"`，`"is_alive()"`等，这些属性给我们提供了有关进程状态的信息。
- en: Since we are sure of the parameters passed to the process (as they are not coming
    from user directly), we can proceed with it. However, it's a good practice to
    use `shell=False` and specify the arguments as a list `[]`, or, alternatively,
    use the **shelx** utility of Python to convert string arguments automatically
    to a list and use `shell=False`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们确定了传递给进程的参数（因为它们不是直接来自用户），我们可以继续进行。但是，最好使用`shell=False`并将参数指定为列表`[]`，或者使用Python的**shelx**实用程序自动将字符串参数转换为列表并使用`shell=False`。
- en: We want our parent process to wait until the child process executes and we also
    want the child process to give all the data it produces back to the parent process.
    We can achieve this by invoking `communicate()` on the invoked process. The `communicate()`
    method will return a tuple with a 0th index that contains the output from the
    process and a first index that will have the errors produced. Since we are specifying
    `output=subprocess.PIPE`, and `error=subprocess.PIPE`, both the output and the
    errors will be piped to the parent process via OS pipes, which is how we achieve
    inter-process communication. This is highlighted in section **(2).**
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望父进程等待子进程执行，我们也希望子进程将其产生的所有数据返回给父进程。我们可以通过在调用的进程上调用`communicate()`来实现这一点。`communicate()`方法将返回一个元组，其中包含来自进程的输出的第0个索引和产生的错误的第一个索引。由于我们指定了`output=subprocess.PIPE`和`error=subprocess.PIPE`，输出和错误都将通过OS管道传输到父进程，这就是我们实现进程间通信的方式。这在第(2)部分中有所强调。
- en: Our next challenge is to convert the console output to a standard ASCII format
    so that we can save the data cleanly in the database. It should be noted that
    different tools and scripts produce data in different formats and encoding that
    would be appropriate for the console to display. The console supports a wide range
    of encoding, but we need to save the output in our database tables, so before
    pushing the data, we need to convert it from console encoding to ASCII format.
    This is what we are doing in section **(3).**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个挑战是将控制台输出转换为标准的ASCII格式，以便我们可以将数据干净地保存在数据库中。需要注意的是，不同的工具和脚本以不同的格式和编码生成数据，这些格式和编码适合控制台显示。控制台支持各种编码，但我们需要将输出保存在数据库表中，因此在推送数据之前，我们需要将其从控制台编码转换为ASCII格式。这就是我们在第(3)部分所做的事情。
- en: In section **(4)**, we get control of the parent process by invoking `process
    = psutil.Process(self.process.pid).`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(4)部分中，我们通过调用`process = psutil.Process(self.process.pid).`来控制父进程。
- en: In section **(5)**, after we have cleaned the data, we push both of the commands
    that were executed and the data that was generated in the database table by invoking
    the `saveDetails()`method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(5)部分中，清理数据后，我们通过调用`saveDetails()`方法将执行的两个命令和生成的数据推送到数据库表中。
- en: After section **(3),** we check whether the thread is still alive by invoking
    `thread.is_alive()`. If it returns `false`, it means that the thread was successfully
    executed within the specified time via internally invoking the `subprocess.Process` command
    and also that the details are saved in the database table. However, if `thread.is_alive()`
    returns `true`, this means that the external script is still running and so we
    would need to forcibly kill it so that it doesn't hamper the execution of the
    other scripts that are lined up to be executed. Remember that the process invoked
    returns us the instance of the process that we saved under the `self.process`
    class variable. We are going to use that variable here in order to kill the process.
    Python has got a very powerful utility called `"psutil"`, which we can use to
    not only kill the process, but also all the child processes invoked by that process.
    We need to kill the child processes as well, because we don't want these to be
    running in the background and consuming our CPU. For example, tools such as Nikto
    invoke many child processes to expedite the whole operation and we would want
    to kill all of them to make sure the parent process is killed and all the system
    resources are released for other processes to use. Once we have fetched the parent
    process, we iterate over each of its child processes using a `for` loop, `for
    proc in process.children(recursive=True):`, and kill each of the child processes
    by issuing the command `proc.kill()`**. **This is highlighted in section **(5).**
    Finally, in section **(6)**, we ensure that we kill the parent process as well
    by invoking `self.process.kill()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(3)部分之后，我们通过调用`thread.is_alive()`来检查线程是否仍然活动。如果返回`false`，这意味着线程已经成功在指定的时间内执行，通过内部调用`subprocess.Process`命令，并且详细信息也保存在数据库表中。但是，如果`thread.is_alive()`返回`true`，这意味着外部脚本仍在运行，因此我们需要强制将其终止，以免影响其他要执行的脚本的执行。请记住，调用的进程会将我们保存在`self.process`类变量下的进程实例返回给我们。我们将在这里使用该变量来终止进程。Python有一个非常强大的实用程序叫做“psutil”，我们可以使用它来不仅终止进程，还可以终止该进程调用的所有子进程。我们还需要终止子进程，因为我们不希望它们在后台运行并消耗我们的CPU。例如，诸如Nikto之类的工具会调用许多子进程来加快整个操作，我们希望终止所有这些进程，以确保父进程被终止并且所有系统资源都被释放供其他进程使用。一旦我们获取了父进程，我们使用`for`循环迭代其每个子进程，`for
    proc in process.children(recursive=True):`，并通过发出命令`proc.kill()`来终止每个子进程。这在第(5)部分中有所强调。最后，在第(6)部分，我们通过调用`self.process.kill()`确保终止父进程。
- en: general_interactive()
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: general_interactive()
- en: In this section, we are going to understand how the `general_interactive()`
    method works. Although we could have Metasploit commands implemented with this
    method as well, to keep the separation of categories, we implemented Metasploit
    separately.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解`general_interactive()`方法的工作原理。虽然我们也可以使用这种方法实现Metasploit命令，但为了保持类别的分离，我们单独实现了Metasploit。
- en: 'The objective of `general_interactive` is to automate interactive tools and
    Bash commands. This means that the JSON file contains both success patterns and
    failure patterns, which define the workflow of execution. We will be using Pexpect
    to accommodate this as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`general_interactive`的目标是自动化交互式工具和Bash命令。这意味着JSON文件包含了定义执行工作流程的成功模式和失败模式。我们将使用Pexpect来实现这一点，如下所示：'
- en: '![](img/1fac8b47-a996-4614-84aa-b76504f92684.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fac8b47-a996-4614-84aa-b76504f92684.png)'
- en: 'Let''s take a closer look at this method by carrying out a dry run, as shown
    here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行干运行来更仔细地研究这个方法，如下所示：
- en: '![](img/6d93bb4e-20d8-43b1-a924-453ff53dd525.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d93bb4e-20d8-43b1-a924-453ff53dd525.png)'
- en: As we can see in the `args[]`, the first argument is the timeout. The second
    index holds the command that we wish to automate using the general interactive
    method. As always for this category, the first argument will be the `timeout`
    and the second will be the command to be fired. From here on, an alternate pattern
    is defined. The third index will hold the expected output list and the success
    criteria. If the success criteria is met, the fourth index will hold the next
    command to be send to the console. The fifth index will again hold the expected
    output list based upon the command sent in the fourth index, and it also holds
    the success criteria. The pattern is straightforward, and the same alternating
    sequence is carried on as required by the underlying command or tool that we plan
    to automate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`args[]`中看到的，第一个参数是超时时间。第二个索引保存我们希望使用一般交互方法自动化的命令。对于这个类别，第一个参数将始终是`超时时间`，第二个参数将是要执行的命令。从这里开始，定义了一个交替模式。第三个索引将保存预期输出列表和成功标准。如果满足成功标准，第四个索引将保存要发送到控制台的下一个命令。第五个索引将再次保存基于第四个索引发送的命令的预期输出列表，并且它还保存成功标准。模式很简单，根据我们计划自动化的底层命令或工具所需的，同样的交替序列将继续进行。
- en: 'The success criteria is defined at the first index of the expected output list.
    If there are multiple success outcomes or indices, they can be given as a comma
    separated input at the first index. Let''s take the above example of `rlogin`,
    where we are trying to do a remote login with root as the username and password,
    and try to understand what the expected output list holds and signifies. The list
    at index 3 holds `[''0,1'',''.* password: .*","[$,#]",".*No route.*"]`**. **Here,
    the 0th index "0,1" defines the success criteria. This means that if the terminal
    expects either `".* password: .*"` or `"[$,#]"`, we assume that the output is
    as expected and therefore we send the next command to the console, which is `"root"`
    in our case. If we get anything other than index 0 or 1, we assume that the tool
    or script is not behaving as expected, and thus abort the operation.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '成功标准在预期输出列表的第一个索引处定义。如果有多个成功结果或索引，它们可以作为逗号分隔的输入给出在第一个索引处。让我们以“rlogin”的上述示例为例，我们正在尝试使用root作为用户名和密码进行远程登录，并尝试理解预期输出列表的内容和意义。索引3处的列表包含`[''0,1'',''.*
    password: .*","[$,#]",".*No route.*"]`。在这里，第0个索引“0,1”定义了成功标准。这意味着如果终端期望`".* password:
    .*"`或`"[$,#]"`中的任何一个，我们就假设输出符合预期，因此我们将下一个命令发送到控制台，这在我们的情况下是“root”。如果我们得到的不是索引0或1，我们就假设工具或脚本的行为不符合预期，因此中止操作。'
- en: To configure commands and scripts that belong to this category, the tester needs
    to know how the script executes under both success and failure conditions, and
    formulate the configuration file once. The preceding code is straightforward and
    implements the same logic we discussed previously.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置属于此类别的命令和脚本，测试人员需要知道脚本在成功和失败条件下的执行方式，并制定配置文件。前面的代码很简单，实现了我们之前讨论的相同逻辑。
- en: generalCommands_Tout_Sniff()
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: generalCommands_Tout_Sniff()
- en: 'The idea here is similar to how we implemented the `singleLineComamnd()` method
    with the help of threads. Note that the category of the command to be executed
    would either be `interactive` or `"singleLineCommand_Timeout"`, along with a sniffing
    operation. We will create a thread and delegate the sniffing task to it by attaching
    it to the `start_sniffing` method. We will also reuse the methods we created earlier.
    Either we invoke `singleLineCommands_Timeout()` as specified by **(1)**, or `general_interactive()`
    as specified by **(2)**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法类似于我们如何使用线程实现`singleLineComamnd()`方法。请注意，要执行的命令的类别要么是`interactive`，要么是`"singleLineCommand_Timeout"`，还有一个嗅探操作。我们将创建一个线程，并将嗅探任务委托给它，通过将它附加到`start_sniffing`方法。我们还将重用我们之前创建的方法。我们要么按照**(1)**指定的方式调用`singleLineCommands_Timeout()`，要么按照**(2)**指定的方式调用`general_interactive()`：
- en: '![](img/b39b5a7b-b670-4897-92de-138e071f5b3a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b39b5a7b-b670-4897-92de-138e071f5b3a.png)'
- en: 'In section **(3)** and **(4)**, we check whether the sniffing process is still
    alive, and if it is, then we kill it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(3)**和**(4)**节中，我们检查嗅探进程是否仍然存活，如果是，则将其终止：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We usually use Wireshark to capture all traffic on our interface. Since Wireshark
    is a desktop application, however, in this case, we will use **Tshark**. Tshark
    stands for terminal shark and is the CLI version of Wireshark. The Tshark invocation
    command is specified in section **(2)**, where we specify the port at which we
    want Tshark to sniff traffic. We also specify the host for which traffic needs
    to be sniffed, or the destination host. The reason we specify both the host and
    the port is that we want to maintain result integrity; the GUI version of the
    tool can deployed on the server and multiple users can use it to conduct scanning.
    If we specify that it should sniff on the interface, data from other running sessions
    for other users would also be sniffed. To avoid this, we are very specific with
    host and port. We also specify the timeout duration for it to sniff. We save the
    output in a file specified as `"project_id_host_port_capture-output.pcap"`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用Wireshark来捕获接口上的所有流量。然而，由于Wireshark是一个桌面应用程序，在这种情况下，我们将使用**Tshark**。Tshark代表终端shark，是Wireshark的CLI版本。Tshark调用命令在第(2)部分中指定，我们指定要嗅探流量的端口。我们还指定需要嗅探流量的主机，或目标主机。我们指定主机和端口的原因是我们想要保持结果的完整性；工具的GUI版本可以部署在服务器上，并且多个用户可以使用它进行扫描。如果我们指定它应该在接口上嗅探，那么其他用户的其他运行会话的数据也会被嗅探。为了避免这种情况，我们对主机和端口非常具体。我们还指定了它嗅探的超时持续时间。我们将输出保存在指定的文件中`"project_id_host_port_capture-output.pcap"`。
- en: 'In section **(2)**, we invoke the `tshark` process with the help of the subprocess
    module, which we discussed earlier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(2)部分，我们使用子进程模块调用`tshark`进程，这是我们之前讨论过的：
- en: '![](img/43e571c8-2181-4798-8e4c-485f7364060e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43e571c8-2181-4798-8e4c-485f7364060e.png)'
- en: HTTP_based()
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP_based()
- en: 'The following `http_based` method is straightforward. We use Python''s request
    library to send a GET request to our target, capture the response, and save it
    in the database. For now, we are just sending a GET request, but you can tweak
    the code to handle both GET and POST in your own time. We will cover more about
    python requests and scraping in the next chapters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`http_based`方法很简单。我们使用Python的请求库向目标发送GET请求，捕获响应，并将其保存在数据库中。目前，我们只是发送GET请求，但您可以在自己的时间内调整代码以处理GET和POST。我们将在下一章节中更多地介绍Python请求和抓取：
- en: '![](img/f1f98ec6-8bd3-4733-8eba-a9dec6238b73.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1f98ec6-8bd3-4733-8eba-a9dec6238b73.png)'
- en: IPexploits.py
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPexploits.py
- en: Another important code file, which handles the database layer of the service
    scanning engine, is `IPexploits.py`. This file is straightforward; it contains
    various methods and the objective of each method is either to fetch data from
    a database table or to put data in a database table. We won't be discussing this
    module here, but I would recommend that you take a look at the code that can be
    found at the GitHub repository [https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py](https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 服务扫描引擎的数据库层处理另一个重要的代码文件是`IPexploits.py`。这个文件很简单；它包含各种方法，每个方法的目的要么是从数据库表中获取数据，要么是将数据放入数据库表中。我们不会在这里讨论这个模块，但我建议你看一下可以在GitHub存储库[https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py](https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py)找到的代码。
- en: Executing the code
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行代码
- en: Before executing the code, refer to the installation and setup instructions
    carefully from the GitHub repository [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    The installation guide also discusses how to set up the backend database and tables.
    Alternatively, you can download the plug and play VM that has everything installed
    and preconfigured.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码之前，请仔细参考GitHub存储库[https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki)中的安装和设置说明。安装指南还讨论了如何设置后端数据库和表。或者，您可以下载预先安装和预配置了所有内容的即插即用的虚拟机。
- en: 'To run the code, go to the following path: `/root/Django_project/Dictator/Dictator_Service`.
    Run the code file `driver_main_class.py` as `:python Driver_scanner.py` It must
    be noted that, the results are generated using a Python library that converts
    the console output into its HTML equivalent. Further details can be found at the
    following code file [https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python](https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python),
    under the `generate_results()` method.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请转到以下路径：`/root/Django_project/Dictator/Dictator_Service`。运行代码文件`driver_main_class.py`，如`:python
    Driver_scanner.py`。必须注意的是，结果是使用Python库生成的，该库将控制台输出转换为其HTML等效。更多细节可以在以下代码文件[https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python](https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python)的`generate_results()`方法中找到。
- en: Database schema for the service-scanning portion of the vulnerability scanner
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞扫描器的服务扫描部分的数据库模式
- en: 'For service scanning the scan results, go to the IPexploits table, the schema
    of which looks as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描服务扫描的扫描结果，请转到IPexploits表，其模式如下：
- en: '![](img/330d9b69-af86-4e96-86d5-d4d3c968b98b.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/330d9b69-af86-4e96-86d5-d4d3c968b98b.png)'
- en: GUI version of vulnerability scanner
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞扫描器的GUI版本
- en: The same code base discussed previously can be enhanced to develop a web-based
    version of the vulnerability scanner, with both port scanning and service scanning
    capabilities. The tool has many different features, including a four-tier architecture,
    which has a web layer presentation, a web layer server, an API layer, and a DB
    layer. Download and install the web version of the tool from the GitHub repository
    [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    Alternatively, you can use the plug-and-play vm and simply log in and open the
    browser at `https://127.0.0.1:8888` to access the tool.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 先前讨论的相同代码库可以进行增强，以开发一个基于Web的漏洞扫描仪版本，具有端口扫描和服务扫描功能。该工具具有许多不同的功能，包括四层架构，其中包括Web层呈现、Web层服务器、API层和DB层。从GitHub存储库[https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki)下载并安装工具的Web版本。或者，您可以使用即插即用的虚拟机，只需登录并在`https://127.0.0.1:8888`上打开浏览器即可访问该工具。
- en: 'The various features of GUI version of the scanner include the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描仪GUI版本的各种功能包括以下内容：
- en: Parallel port scanning
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行端口扫描
- en: Pausing and resuming port scanning
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和恢复端口扫描
- en: Service scanning
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务扫描
- en: All test case automation
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有测试用例自动化
- en: Pausing and resuming Service scanning **(not in CLI)**
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和恢复服务扫描 **（不在CLI中）**
- en: Parallel service scanning **(not in CLI)**
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行服务扫描 **（不在CLI中）**
- en: Nmap report uploading and parsing of Qualys and Nessus reports
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap报告上传和解析Qualys和Nessus报告
- en: Usage [PTO-GUI]
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用[PTO-GUI]
- en: The following section walks us through the usage of the GUI version of the scanner.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍扫描仪的GUI版本的用法。
- en: Scanning modules
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描模块
- en: Based upon the type and nature of scans being conducted on the underlying infrastructure,
    the pen tester has got multiple options available and may choose the one that
    may fit best with the given infrastructure to be tested. The various modes of
    usage available are covered in the following sections.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 基于正在进行的基础设施上的扫描类型和性质，渗透测试人员有多种可用选项，并且可以选择最适合被测试基础设施的选项。可用的各种使用模式在以下部分中进行了介绍。
- en: Sequential mode
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序模式
- en: In sequential mode, the tool would start with the discovery followed by reconfiguration
    and then it will start service scanning. Thus, it is a three step process. Note
    that in sequential mode
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序模式中，工具将从发现开始，然后重新配置，然后开始服务扫描。因此，这是一个三步过程。请注意，在顺序模式中
- en: The service scanning cannot be started until all hosts have been scanned
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有主机都被扫描之前，无法开始服务扫描
- en: Once service scanning is started, no reconfiguration can be done
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦服务扫描开始，就无法重新配置
- en: Service scanning once started, would be started for all services. User has no
    control over which service to scan first and which one to scan last
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦开始服务扫描，所有服务都将开始扫描。用户无法控制先扫描哪个服务，后扫描哪个服务
- en: '![](img/d1de7f0a-49fd-4838-bc8b-9988831c945b.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1de7f0a-49fd-4838-bc8b-9988831c945b.jpg)'
- en: Reconfiguration after discovery is finished
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现完成后重新配置
- en: In order to reduce false positives and false negatives, kindly analyze port
    scanning results and if required, reconfigure/change them. You may additionally
    add test cases if in case any service/port is left out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少误报和漏报，请分析端口扫描结果，如果需要，重新配置/更改它们。如果有任何服务/端口被遗漏，您还可以额外添加测试用例。
- en: '![](img/be48f0bc-0324-4267-9356-5722ec6de546.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be48f0bc-0324-4267-9356-5722ec6de546.jpg)'
- en: '![](img/b05d1ad9-b8a4-4aab-bc9b-0a19cf078f4e.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b05d1ad9-b8a4-4aab-bc9b-0a19cf078f4e.jpg)'
- en: 'In the preceding screenshot, we are changing service of type **status** to
    type `ftp`. Thus, the test cases would be run for `ftp`. Note: Do it only if you
    are sure that the service discovered is incorrect or of type `Unknown`. We shall
    understand service types shortly.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们将类型为**状态**的服务更改为`ftp`类型。因此，测试用例将为`ftp`运行。注意：只有在确定发现的服务不正确或类型为`Unknown`时才这样做。我们将很快了解服务类型。
- en: 'If nmap misses out host/port/service, it can be added manually as shown below:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果nmap错过了主机/端口/服务，可以手动添加，如下所示：
- en: '![](img/676cb125-e46d-41fa-9f82-2aed49201424.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/676cb125-e46d-41fa-9f82-2aed49201424.jpg)'
- en: 'After adding the test case, we can click upon **Start scanning** option to
    begin with service scanning. We can choose to enable threading option for speeding
    up the results, and we can also go and start service scanning without the threading
    option, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 添加测试用例后，我们可以点击“开始扫描”选项开始服务扫描。我们可以选择启用线程选项以加快结果的速度，也可以选择不使用线程选项开始服务扫描，如下图所示：
- en: '![](img/881bab84-8099-4e57-b6c7-89dc7dbf2044.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/881bab84-8099-4e57-b6c7-89dc7dbf2044.jpg)'
- en: 'Viewing intermediate results: The moment a person clicks upon **Start scanning**,
    he/she would be redirected to the scanning page. Every time a test case is executed,
    the UI would be updated and a blue color icon would appear on the screen in front
    of the service being scanned. A user may click upon that icon to view the test
    case results.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 查看中间结果：当用户点击“开始扫描”时，他/她将被重定向到扫描页面。每次执行一个测试用例，UI都会更新，并且一个蓝色的图标会出现在正在扫描的服务前面的屏幕上。用户可以点击该图标查看测试用例的结果。
- en: When all the `test_cases` for a service would be executed then the icon will
    turn green.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务的所有“测试用例”都被执行时，图标将变为绿色。
- en: 'The following diagram shows intermediate test case results:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了中间测试用例的结果：
- en: '![](img/4d10429a-985d-431a-b473-8368da06b74d.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d10429a-985d-431a-b473-8368da06b74d.jpg)'
- en: 'At any point,, a user can leave the UI without impacting the running scan.
    In case the user wishes to see the scans are that currently running, he may choose
    running scans from the **Scanning Status** tab at the top . The following screen
    would be displayed:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，用户都可以离开UI而不会影响正在运行的扫描。如果用户希望查看当前正在运行的扫描，可以从顶部的“扫描状态”选项卡中选择正在运行的扫描。将显示以下屏幕：
- en: '![](img/a388638e-aa90-4bf1-aed4-c3c759ecc6f8.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a388638e-aa90-4bf1-aed4-c3c759ecc6f8.jpg)'
- en: Depending upon the state of the scan, it will display an appropriate action.
    If the scan is under progress, the **Action** column will have action as **Ongoing**. 
    Users may click upon this button to get to the UI screen of the current state
    of his/her scan.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 根据扫描的状态，它将显示适当的操作。如果扫描正在进行中，**操作**列将显示**进行中**。用户可以点击此按钮以获取其扫描当前状态的UI屏幕。
- en: A user can click upon the name of the scan to see the configuration (hosts,
    ports, switch) with which the scan was initially launched.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以点击扫描名称以查看扫描最初启动时的配置（主机、端口、开关）。
- en: Concurrent mode
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模式
- en: In sequential mode, the service scanning cannot be started until port scanning
    results are available for all the ports and the hosts are scanned. Thus, a pen
    tester may have to wait to obtain these results. Also, in this mode, the pen tester
    does not have control over which services can be scanned first and which can be
    scanned later. All the services are scanned in one go, limiting the granularity
    of control over service scanning. These are the limitations of the sequential
    mode that is handled by the concurrent mode.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序模式中，直到所有端口的端口扫描结果可用并且主机已经扫描完毕，服务扫描才能开始。因此，渗透测试人员可能需要等待获取这些结果。此外，在此模式下，渗透测试人员无法控制哪些服务可以先扫描，哪些可以稍后扫描。所有服务将一次性扫描，限制了对服务扫描的控制粒度。这些是并发模式处理的顺序模式的限制。
- en: The concurrent mode offers the flexibility to launch service scanning the moment
    service discovery is finished and further gives an option to launch service scanning
    for selective services based upon the pen testers choice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式提供了在服务发现完成后立即启动服务扫描的灵活性，并进一步提供了根据渗透测试人员选择启动选择性服务扫描的选项。
- en: Click on **New Scan** tab under the **Scan** tab.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**扫描**选项卡下的**新扫描**选项卡。
- en: 'Fill in the scan parameters and choose the scan mode as **Concurrent**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写扫描参数，并选择**并发**扫描模式：
- en: '![](img/c7ceb7a8-e9ed-4348-9ac1-c1d080a592e9.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7ceb7a8-e9ed-4348-9ac1-c1d080a592e9.jpg)'
- en: 'The remaining steps will be the same, with the only exception being that in
    this mode of scan, a user will not have to wait for all hosts and ports to be
    scanned to begin with service scanning. Also, the user can choose what services
    he may wish to scan. This is illustrated in the following figure:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余步骤将相同，唯一的例外是在此扫描模式中，用户无需等待所有主机和端口都被扫描才能开始服务扫描。此外，用户可以选择希望扫描哪些服务。如下图所示：
- en: '![](img/a66c7363-483b-4e59-8cb4-2693bb49781e.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a66c7363-483b-4e59-8cb4-2693bb49781e.jpg)'
- en: As you can see in the preceding screenshot, a user can choose to scan `http`
    first and not scan ssh immediately. The user can decide when to scan what service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，用户可以选择先扫描`http`，而不立即扫描ssh。用户可以决定何时扫描哪项服务。
- en: All the capabilities (reconfiguration, viewing results and so on) are available
    with the concurrent mode as well.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式也具有重新配置、查看结果等所有功能。
- en: Sequential default mode
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序默认模式
- en: With this mode, the service scanning would start immediately after discovery
    is finished, thus skipping the reconfiguration phase. The utility of this mode
    is more relevant in case of scheduling scans where the pen tester may schedule
    scans to start at some other time and may not be available to do the reconfiguration
    while simultaneously wanting to proceed with default port scanning results for
    service scanning. Thus, this scan mode skips the reconfiguration phase and directly
    launches service scanning on obtaining default `nmap` port scanning results.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式，服务扫描将在发现完成后立即开始，从而跳过重新配置阶段。此模式的实用性在于调度扫描的情况下更为相关，渗透测试人员可以安排扫描在其他时间开始，并且可能无法进行重新配置，同时希望继续使用默认的端口扫描结果进行服务扫描。因此，此扫描模式跳过重新配置阶段，并在获取默认的`nmap`端口扫描结果后直接启动服务扫描。
- en: Click upon **New scan** tab under the **Scan** tab
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**扫描**选项卡下的**新扫描**选项卡
- en: Fill in the scan parameters and choose the scan mode as **Sequential Default**
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写扫描参数，并选择**顺序默认**扫描模式
- en: '![](img/2e095c26-7b94-439c-966d-6b2b8a12dc1f.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e095c26-7b94-439c-966d-6b2b8a12dc1f.jpg)'
- en: When port scanning results are done, it will start service scanning by itself,
    irrespective of whether the user is currently logged in.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当端口扫描结果完成后，它将自行开始服务扫描，无论用户当前是否已登录。
- en: Pausing and resuming scans
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和恢复扫描
- en: Irrespective of the scan mode, any scan weather in the discovery or service
    scanning state can be paused. The intermediate results would be saved, and the
    user can resume the scan anytime in the future.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 无论扫描模式如何，任何处于发现或服务扫描状态的扫描都可以暂停。中间结果将被保存，用户可以随时在将来恢复扫描。
- en: It must be noted that if the scan is paused while discovery (port scanning would
    have been going on), then the port scanning results for the ports that have already
    been scanned would be saved; the scan would start for unscanned ports once the
    user resumes. Likewise, if the scan is paused during service scanning, then whatever
    services would have been scanned, their results would be saved, and the user gets
    the flexibility to analyze the results of the services that would be scanned.
    When the scan resumes, the service scanning will start for unscanned services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，如果在发现过程中暂停扫描（端口扫描可能正在进行），则已经扫描的端口的端口扫描结果将被保存；用户恢复后，将对未扫描的端口进行扫描。同样，如果在服务扫描过程中暂停扫描，则已经扫描的服务的结果将被保存，用户可以灵活分析将要扫描的服务的结果。扫描恢复后，将对未扫描的服务进行服务扫描。
- en: 'The following screen shots show how to pause an ongoing scan:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何暂停正在进行的扫描：
- en: '![](img/b85ec9f7-aecf-4e07-b8eb-fd8ee0b2dc63.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b85ec9f7-aecf-4e07-b8eb-fd8ee0b2dc63.jpg)'
- en: 'In order to resume the scan, either go to the **Current scans** tab or go to
    the **Paused scans** tab. The action column by default would have two buttons
    :'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复扫描，可以转到**当前扫描**选项卡或**暂停的扫描**选项卡。默认情况下，操作列会有两个按钮：
- en: '**Resume**: This will resume the scan from whatever state it was paused.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复**：这将从暂停的状态恢复扫描。'
- en: '**Analyze**: If the scan is paused while scanning, then the penetration tester
    may analyze the results for the services that were already scanned. If you wish
    to resume the scan, then he/she may choose the option analyze. With this the user
    can get to see intermediate test case results for completed services.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：如果扫描在扫描时暂停，渗透测试人员可以分析已经扫描的服务的结果。如果您希望恢复扫描，那么他/她可以选择分析选项。通过这个选项，用户可以看到已完成服务的中间测试用例结果。'
- en: Analyze option may not appear if the scan would be paused during port scanning,
    as there would be no `test_cases` executed to analyze if port scanning would be
    going and mode would not be concurrent. **Analyze** option does not appear for
    concurrent scans, the **Resume** button will perform that joint functionality
    of resuming and analyzing the scans invoked in concurrent mode.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扫描在端口扫描期间暂停，分析选项可能不会出现，因为如果端口扫描正在进行并且模式不是并发的话，就不会执行`test_cases`来分析。**分析**选项不会出现在并发扫描中，**恢复**按钮将执行并发模式中的恢复和分析扫描的联合功能。
- en: '![](img/1746627a-0a38-4ff6-bd94-4d17adbd9538.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1746627a-0a38-4ff6-bd94-4d17adbd9538.jpg)'
- en: Downloading reports or analyzing when scan would be completed
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载报告或分析扫描何时完成
- en: 'When the scan would be finished, the user will get the option **Download All**
    on the UI. If the user would visit the **Current scans** tab, for all the scans
    with status as **Complete** for both discovery and service scanning, the **Action**
    column will by default have an option to download the results for offline analysis
    or to analyze the results online itself as shown in the following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当扫描完成时，用户将在UI上获得**全部下载**的选项。如果用户访问**当前扫描**选项卡，对于所有发现和服务扫描状态为**完成**的扫描，**操作**列将默认具有下载结果的选项，以进行离线分析或在线分析结果，如下图所示：
- en: '![](img/45cb5b5b-e634-4eb1-83df-a1c473c50050.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45cb5b5b-e634-4eb1-83df-a1c473c50050.jpg)'
- en: 'On clicking **Download All**, a zipped folder would be downloaded. It will
    have:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**全部下载**，将下载一个压缩文件夹。它将包括：
- en: The final HTML report containing all test case results.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有测试用例结果的最终HTML报告。
- en: 'Pcap files which would sniff certain services where sniffing is required. The
    Pcap files can be opened with Wireshark and analyzed weather the text/credentials
    are passed as plain text or in encrypted format. Note: The name of the Pcap file
    would be like `<project_id>_capture_output.pcap`. Thus if sniffing is done on
    `host1` for port `21` and project ID `100`, the Pcap file name would be `100_host1_21_capture_output.pcap`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pcap文件可以嗅探需要嗅探的某些服务。Pcap文件可以用Wireshark打开并分析文本/凭据是以明文还是加密格式传递的。注意：Pcap文件的名称将类似于`<project_id>_capture_output.pcap`。因此，如果在`host1`上对端口`21`和项目ID`100`进行嗅探，Pcap文件名称将是`100_host1_21_capture_output.pcap`。
- en: The downloaded folder will also have the final chosen configuration (Services
    -Test cases) with which the scan was launched. (JSON format)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载的文件夹还将包含最终选择的配置（服务-测试用例），用于启动扫描（JSON格式）
- en: On the other hand clicking upon **Analyze tests** will take us to UI where we
    can see the results of all `test_cases` on the user interface only.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，点击**分析测试**将带我们到用户界面，我们可以在那里看到所有`test_cases`的结果。
- en: Reporting
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告
- en: 'To upload Nmap report, go to **Upload Reports** and choose Nmap report. Its
    a result importer module, which can read the results from an existing `Nmap.xml`
    report file and can import the findings in our custom database, and further use
    these findings in order to launch test cases/service scan. Thus, this leaves the
    user with the flexibility to use our tool in both modes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传Nmap报告，请转到**上传报告**并选择Nmap报告。这是一个结果导入模块，可以读取现有的`Nmap.xml`报告文件中的结果，并将这些发现导入到我们的自定义数据库中，并进一步使用这些发现来启动测试用例/服务扫描。因此，这使用户可以在两种模式下使用我们的工具：
- en: Discovery and service scanning together
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现和服务扫描一起
- en: Service scanning mode alone
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅服务扫描模式
- en: '![](img/4c6d5b56-57cf-432b-b886-c535305a0e6f.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c6d5b56-57cf-432b-b886-c535305a0e6f.jpg)'
- en: '![](img/a18ad171-8f38-4d72-831a-51f19028cc01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a18ad171-8f38-4d72-831a-51f19028cc01.jpg)'
- en: On clicking on **Upload**, the report will be parsed and uploaded. A user may
    go to **Current scans** tab and would find the uploaded project `test_upload_nmap` listed
    over there, with its **Discovery status** as **Complete** and **Service scanning**
    status as **Incomplete**. A user may click upon **Action** tab **Ongoing** and
    can reconfigure the results and then start service scanning.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**上传**，报告将被解析和上传。用户可以转到**当前扫描**选项卡，会发现已上传的项目`test_upload_nmap`列在那里，其**发现状态**为**完成**，**服务扫描**状态为**未完成**。用户可以点击**操作**选项卡**进行中**，重新配置结果，然后开始服务扫描。
- en: Qualys and Nessus report parsers
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qualys和Nessus报告解析器
- en: 'To use this option, go to **Upload reports** tab and select either **Qualys**/**Nessus**
    report. We have a report merging module, which would merge the results obtained
    from Qualys, Nessus and manual test cases. In order to merge the reports, they
    have to be parsed first. We have Qualys, Nmap and Nessus report parsers. All of
    them will take a report in XML format and would parse the report and place it
    in local storage so that querying and integrating the results with other reports
    becomes easier:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此选项，请转到**上传报告**选项卡，并选择**Qualys**/**Nessus**报告。我们有一个报告合并模块，可以合并从Qualys、Nessus和手动测试用例获得的结果。为了合并报告，它们必须首先被解析。我们有Qualys、Nmap和Nessus报告解析器。它们都将以XML格式接收报告，并解析报告并将其放置在本地存储中，以便查询和将结果与其他报告集成变得更容易：
- en: '![](img/46df89e3-7ade-4543-bf82-9b8c604d177e.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46df89e3-7ade-4543-bf82-9b8c604d177e.jpg)'
- en: The purpose of uploading the report here is to merge it with some manual project.
    Thus select the project from drop-down list with which a user may wish to merge
    the Nessus/Qualys report.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里上传报告的目的是将其与某个手动项目合并。因此，从下拉列表中选择要将Nessus/Qualys报告合并的项目。
- en: 'Report merger:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告合并：
- en: To use this option go to **Merge reports** tab and select the **ID**/**Name**
    of the manual project with which you wish to integrate the Qualys and Nessus results.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此选项，请转到**合并报告**选项卡，并选择您希望将Qualys和Nessus结果集成的手动项目的**ID**/**名称**。
- en: It assumes that the Nessus and Qualys reports would have already been uploaded
    and linked to the project with which they are meant to be merged .
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 它假定Nessus和Qualys报告已经被上传并链接到它们应该合并的项目。
- en: This module merges the manual test cases, parsed Qualys report, parsed Nessus
    report and would also map the CVEs to exploits and finally, would provide the
    user an option to download the integrated reports in any of the format among (XML,
    HTML, CSV, JSON) thus providing one consolidated view for analysis.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块合并了手动测试用例、解析的Qualys报告、解析的Nessus报告，并将CVE映射到利用，最后，将为用户提供下载集成报告的选项，格式包括（XML、HTML、CSV、JSON），从而提供一个统一的分析视图。
- en: '![](img/34d668d7-9fa8-4f84-b7c1-01476bfd893a.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34d668d7-9fa8-4f84-b7c1-01476bfd893a.jpg)'
- en: '![](img/f393784d-9279-4b0a-ab86-b6ae5119e0bb.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f393784d-9279-4b0a-ab86-b6ae5119e0bb.jpg)'
- en: The final downloadable report is available in four formats (HTML, CSV, JSON,
    XML).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最终可下载的报告有四种格式（HTML、CSV、JSON、XML）。
- en: The merged report will do the merging based upon common results found in Nessus/Qualys
    and manual test_cases. It will cluster the common host and port into one group
    in such a way that analysis becomes easier.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 合并报告将根据Nessus/Qualys和手动测试用例中发现的共同结果进行合并。它将共同的主机和端口聚合到一组中，以便分析变得更容易。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed how to use various Python modules to achieve
    the task of service- scanning automation. We also studied how we can use a combination
    of threading and multiprocessing to solve real-world problems. All the concepts
    discussed in this chapter were mentioned by and large in the previous chapters.
    By the end of this chapter, the reader should have a good understanding of how
    powerful Python can be in the cyber security domain, and how can we use it to
    make a scanner of our own. We also looked at an overview of the vulnerability
    scanner in GUI mode.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用各种Python模块来实现服务扫描自动化的任务。我们还研究了如何使用线程和多进程的组合来解决现实世界的问题。本章讨论的所有概念在前几章中都有所提及。通过本章的学习，读者应该对Python在网络安全领域有多么强大以及我们如何使用它来创建自己的扫描器有了很好的理解。我们还在GUI模式下概述了漏洞扫描器。
- en: In the next chapter, we will see how we can use machine learning and Natural
    language processing to automate the manual report analysis phase of penetration
    testing phase.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用机器学习和自然语言处理来自动化渗透测试阶段的手动报告分析。
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we not use msfrpc to automate Metasploit ?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不使用msfrpc来自动化Metasploit？
- en: What can we possibly do to further optmize the throughput?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能还可以做些什么来进一步优化吞吐量？
- en: Is it mandatory to use the JSON file? Can we use a database instead?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JSON文件是强制性的吗？我们可以使用数据库吗？
- en: What other tools can we integrate with the scanner?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将哪些其他工具与扫描仪集成？
- en: Further reading
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Python-nmap 0.6.1: [https://pypi.org/project/python-nmap/](https://pypi.org/project/python-nmap/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python-nmap 0.6.1：[https://pypi.org/project/python-nmap/](https://pypi.org/project/python-nmap/)
- en: nmap from Python: [https://xael.org/pages/python-nmap-en.html](https://xael.org/pages/python-nmap-en.html)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python使用nmap：[https://xael.org/pages/python-nmap-en.html](https://xael.org/pages/python-nmap-en.html)
- en: 'JSON encoder and decoder: [https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON编码器和解码器：[https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)
