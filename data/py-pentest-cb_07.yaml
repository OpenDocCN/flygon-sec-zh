- en: Network Sniffing with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络嗅探
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Packet sniffer in Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的数据包嗅探器
- en: Parsing the packet
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析数据包
- en: PyShark
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyShark
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A sniffer is a program that can intercept network traffic and sniff packets
    to analyze them. As data streams flow across the network, the sniffer can capture
    each packet, decode the packet's raw data to get the values of various fields
    in the packet headers, and analyze its content according to the appropriate specifications.
    Network packet sniffers can be written in Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 嗅探器是一个可以拦截网络流量并嗅探数据包以进行分析的程序。随着数据流在网络上流动，嗅探器可以捕获每个数据包，解码数据包的原始数据以获取数据包头部中各个字段的值，并根据适当的规范分析其内容。网络数据包嗅探器可以用Python编写。
- en: Packet sniffer in Python
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的数据包嗅探器
- en: A simple packet sniffer in Python can be created with the help socket module.
    We can use the raw socket type to get the packets. A raw socket provides access
    to the underlying protocols, which support socket abstractions. Since raw sockets
    are part of the internet socket API, they can only be used to generate and receive
    IP packets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用socket模块创建一个简单的Python数据包嗅探器。我们可以使用原始套接字类型来获取数据包。原始套接字提供对支持套接字抽象的底层协议的访问。由于原始套接字是互联网套接字API的一部分，它们只能用于生成和接收IP数据包。
- en: '![](img/00025.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As some behaviors of the socket module depend on the operating system socket
    API and there is no uniform API for using a raw socket under a different operating
    system, we need to use a Linux OS to run this script. So, if you are using Windows
    or macOS, please make sure to run this script inside a virtual Linux environment.
    Also, most operating systems require root access to use raw socket APIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于socket模块的一些行为取决于操作系统套接字API，并且在不同操作系统下使用原始套接字没有统一的API，我们需要使用Linux操作系统来运行此脚本。因此，如果您使用的是Windows或macOS，请确保在虚拟Linux环境中运行此脚本。此外，大多数操作系统需要root访问权限才能使用原始套接字API。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Here are the steps  to create a basic packet sniffer with `socket` module:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`socket`模块创建基本数据包嗅探器的步骤：
- en: Create a new file called `basic-packet-sniffer-linux.py` and open it in your
    editor.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`basic-packet-sniffer-linux.py`的新文件，并在编辑器中打开它。
- en: 'Import the required modules:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can create an `INET` raw socket:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个`INET`原始套接字：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both reading and writing to a raw socket require creating a raw socket first.
    Here we use the `INET` family raw socket. The family parameter for a socket describes
    the address family of the socket. The following are the address family constants:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入原始套接字都需要先创建一个原始套接字。这里我们使用`INET`族的原始套接字。套接字的族参数描述了套接字的地址族。以下是地址族常量：
- en: '`AF_LOCAL`: Used for local communication'
  id: totrans-20
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_LOCAL`：用于本地通信'
- en: '`AF_UNIX`: Unix domain sockets'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_UNIX`：Unix域套接字'
- en: '`AF_INET`: IP version 4'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET`：IP版本4'
- en: '`AF_INET6`: IP version 6'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET6`：IP版本6'
- en: '`AF_IPX`: Novell IPX'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_IPX`：Novell IPX'
- en: '`AF_NETLINK`: Kernel user-interface device'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_NETLINK`：内核用户界面设备'
- en: '`AF_X25`: Reserved for X.25 project'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_X25`：保留给X.25项目'
- en: '`AF_AX25`: Amateur Radio AX.25'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_AX25`：业余无线电AX.25'
- en: '`AF_APPLETALK`: Appletalk DDP'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_APPLETALK`：Appletalk DDP'
- en: '`AF_PACKET`: Low-level packet interface'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_PACKET`：低级数据包接口'
- en: '`AF_ALG`: Interface to kernel crypto API'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_ALG`：与内核加密API的接口'
- en: 'The next parameter passed is the type of the socket. The following are the
    possible values for the socket type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的下一个参数是套接字的类型。以下是套接字类型的可能值：
- en: '`SOCK_STREAM`: Stream (connection) socket'
  id: totrans-32
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_STREAM`：流（连接）套接字'
- en: '`SOCK_DGRAM`: Datagram (connection-less) socket'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_DGRAM`：数据报（无连接）套接字'
- en: '`SOCK_RAW`: RAW socket'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_RAW`：原始套接字'
- en: '`SOCK_RDM`: Reliably delivered message'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_RDM`：可靠交付的消息'
- en: '`SOCK_SEQPACKET`: Sequential packet socket'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_SEQPACKET`：顺序数据包套接字'
- en: '`SOCK_PACKET`: Linux-specific method of getting packets at the development
    level'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_PACKET`：用于在开发级别获取数据包的Linux特定方法'
- en: The last parameter is the protocol of the packet. This protocol number is defined
    by the **Internet Assigned Numbers Authority** (**IANA**). We have to be aware
    of the family of the socket; then we can only choose a protocol. As we selected
    `AF_INET` (IPV4), we can only select IP-based protocols.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是数据包的协议。此协议号由**互联网数字分配机构**（**IANA**）定义。我们必须了解套接字的族；然后我们才能选择协议。由于我们选择了`AF_INET`（IPV4），我们只能选择基于IP的协议。
- en: 'Next, start an infinite loop to receive data from the socket:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开始一个无限循环，从套接字接收数据：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `recvfrom` method in the socket module helps us to receive all the data
    from the socket. The parameter passed is the buffer size; `65565` is the maximum
    buffer size.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字模块中的`recvfrom`方法帮助我们从套接字接收所有数据。传递的参数是缓冲区大小；`65565`是最大缓冲区大小。
- en: 'Now run the program with Python:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用Python运行程序：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/00026.jpeg)![](img/00027.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)![](img/00027.jpeg)'
- en: Parsing the packet
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析数据包
- en: Now we can try to parse the data that we sniffed, and unpack the headers. To
    parse a packet, we need to have an idea of the Ethernet frame and the packet headers
    of the IP.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试解析我们嗅探到的数据，并解包头部。要解析数据包，我们需要了解以太网帧和IP数据包头部。
- en: 'The Ethernet frame structure is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网帧结构如下：
- en: '![](img/00028.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'The first six bytes are for the **Destination MAC** address and the next six
    bytes are for the **Source MAC**. The last two bytes are for the **Ether Type**.
    The rest includes **DATA** and **CRC Checksum**. According to RFC 791, an IP header
    looks like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前六个字节是**目标MAC**地址，接下来的六个字节是**源MAC**。最后两个字节是**以太网类型**。其余部分包括**数据**和**CRC校验和**。根据RFC
    791，IP头部如下所示：
- en: '![](img/00029.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: 'The IP header includes the following sections:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IP头部包括以下部分：
- en: '**Protocol Version (four bits)**: The first four bits. This represents the
    current IP protocol.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议版本（四位）**：前四位。这代表了当前的IP协议。'
- en: '**Header Length (four bits)**: The length of the IP header is represented in
    32-bit words. Since this field is four bits, the maximum header length allowed
    is 60 bytes. Usually the value is `5`, which means five 32-bit words: *5 * 4 =
    20 bytes*.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部长度（四位）**：IP头部的长度以32位字为单位表示。由于这个字段是四位，允许的最大头部长度为60字节。通常值为`5`，表示五个32位字：*5
    * 4 = 20字节*。'
- en: '**Type of Service (eight bits)**: The first three bits are precedence bits,
    the next four bits represent the type of service, and the last bit is left unused.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务类型（八位）**：前三位是优先位，接下来的四位表示服务类型，最后一位未使用。'
- en: '**Total Length (16 bits)**: This represents the total IP datagram length in
    bytes. This a 16-bit field. The maximum size of the IP datagram is 65,535 bytes.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总长度（16位）**：这表示IP数据报的总长度（以字节为单位）。这是一个16位字段。IP数据报的最大大小为65,535字节。'
- en: '**Flags (three bits)**: The second bit represents the **Don''t Fragment** bit.
    When this bit is set, the IP datagram is never fragmented. The third bit represents
    the **More Fragment** bit. If this bit is set, then it represents a fragmented
    IP datagram that has more fragments after it.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志（三位）**：第二位表示**不分段**位。当设置了这一位时，IP数据报永远不会被分段。第三位表示**更多分段**位。如果设置了这一位，则表示一个被分段的IP数据报，在它之后还有更多分段。'
- en: '**Time To Live (eight bits)**: This value represents the number of hops that
    the IP datagram will go through before being discarded.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生存时间（八位）**：这个值表示IP数据报在被丢弃之前经过的跳数。'
- en: '**Protocol (eight bits)**: This represents the transport layer protocol that
    handed over data to the IP layer.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议（八位）**：这表示将数据传递给IP层的传输层协议。'
- en: '**Header Checksum (16 bits)**: This field helps to check the integrity of an
    IP datagram.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部校验和（16位）**：这个字段有助于检查IP数据报的完整性。'
- en: '**Source and destination IP (32 bits each)**: These fields store the source
    and destination address, respectively.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源IP和目标IP（每个32位）**：这些字段分别存储源地址和目标地址。'
- en: 'Refer to the RFC 791 document for more details on IP headers: [https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关IP头部的更多详细信息，请参考RFC 791文档：[https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Following are the steps to parse a packet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解析数据包的步骤：
- en: 'Create a new file called `basic-parse-packet-packet-linux.py` and import the
    modules required to parse the packets:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`basic-parse-packet-packet-linux.py`的新文件，并导入解析数据包所需的模块：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can create a function to parse the Ethernet header:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个函数来解析以太网头部：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we use the `unpack` method in the `struct` module to unpack the headers.
    From the Ethernet frame structure, the first six bytes are for the destination
    MAC, the second 6 bytes are for the source MAC, and the last unsigned short is
    for the Ether Type. Finally, the rest is data. So, this function returns the destination
    MAC, source MAC, protocol, and data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`struct`模块中的`unpack`方法来解包头部。从以太网帧结构中，前六个字节是目标MAC地址，接下来的6个字节是源MAC地址，最后的无符号短整型是以太网类型。最后，剩下的是数据。因此，这个函数返回目标MAC地址、源MAC地址、协议和数据。
- en: 'Now we can create a main function and, in the `ethernet_head()`, parse this
    function and get the details:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个主函数，在`ethernet_head()`中解析这个函数并获取详细信息：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can check the data section in the Ethernet frame and parse the IP headers.
    We can create another function to parse the `ipv4` headers:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查以太网帧中的数据部分并解析IP头部。我们可以创建另一个函数来解析`ipv4`头部：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As per the IP headers, we will unpack the headers using the `unpack` method
    in `struct`, and return the `version`, `header_lentgth`, `ttl`, protocol source,
    and destination IPs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IP头部，我们将使用`struct`中的`unpack`方法来解包头部，并返回`版本`、`头部长度`、`TTL`、协议源和目标IP。
- en: 'Now update `main()` to print the IP headers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新`main()`以打印IP头部：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Currently, the IP addresses printed are not in a readable format, so we can
    write a function to format them:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，打印出的IP地址不是可读格式，因此我们可以编写一个函数来格式化它们：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure to update the `ipv4_head` function to format the IP address by adding
    the following lines before returning the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新`ipv4_head`函数通过在返回输出之前添加以下行来格式化IP地址：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have the internet layer unpacked, the next layer we have to unpack
    is the transport layer. We can determine the protocol from the protocol ID in
    the IP header. The following are the protocol IDs for some of the protocols:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经解包了网络层，接下来要解包的是传输层。我们可以从IP头部的协议ID中确定协议。以下是一些协议的协议ID：
- en: '**TCP**: 6'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP**：6'
- en: '**ICMP**: 1'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ICMP**：1'
- en: '**UDP**: 17'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UDP**：17'
- en: '**RDP**: 27'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RDP**：27'
- en: 'Next, we can create a function to unpack the TCP packets:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个函数来解包TCP数据包：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The TCP packets are unpacked according to the TCP packet header''s structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: TCP数据包根据TCP数据包头的结构进行解包：
- en: '![](img/00030.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: 'Now we can update `main()` to print the TCP header details. Add the following
    lines inside the `ipv4` section:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更新`main()`以打印TCP头部的详细信息。在`ipv4`部分内添加以下行：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, update the functions to unpack the UDP and ICMP packets.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，更新函数以解包UDP和ICMP数据包。
- en: 'The packets are unpacked according to the packet header structure. Here is
    the packet header structure for ICMP:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包根据数据包头结构进行解包。以下是ICMP的数据包头结构：
- en: '![](img/00031.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'According to the diagram, we can unpack the packet using the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图表，我们可以使用以下代码解包数据包：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the packet header structure for UDP:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是UDP的数据包头结构：
- en: '![](img/00032.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'As we did for the ICMP, we can unpack the UDP packet headers as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对ICMP所做的那样，我们可以按照以下方式解包UDP数据包头：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now save and run the script with the required permission:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存并以所需权限运行脚本：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output will print all the packets that were sniffed. So, it will continue
    printing until we stop it with a keyboard interrupt. The output will be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将打印所有被嗅探到的数据包。因此，它会一直打印，直到我们用键盘中断停止。输出如下：
- en: '![](img/00033.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: PyShark
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyShark
- en: PyShark is a wrapper for the Wireshark CLI (TShark), so we can have all Wireshark
    decoders in the PyShark. We can use PyShark to sniff an interface or we can analyze
    the `pcap` files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PyShark是Wireshark CLI（TShark）的包装器，因此我们可以在PyShark中拥有所有Wireshark解码器。我们可以使用PyShark来嗅探接口，或者分析`pcap`文件。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'When using this module, make sure to install Wireshark on your system and install
    `pyshark` using the `pip` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此模块时，请确保在系统上安装Wireshark并使用`pip`命令安装`pyshark`：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also, make sure you have installed TShark on your machine. TShark is the terminal-based
    Wireshark, which is used by PyShark for packet capturing functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在计算机上安装了TShark。TShark是基于终端的Wireshark，PyShark用于数据包捕获功能。
- en: Learn more about TShark here: [https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于TShark的信息：[https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Lets try PyShark with some examples. Make sure to install TShark in your system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些PyShark的例子。确保在系统中安装了TShark。
- en: For a better understanding, we can use the Python interactive terminal and go
    through the functions of PyShark. Please note that these commands can also be
    included in the scripts. The only dependency is TShark.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们可以使用Python交互式终端并查看PyShark的功能。请注意，这些命令也可以包含在脚本中。唯一的依赖是TShark。
- en: 'Import the `pyshark` module:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pyshark`模块：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now load the `pcap` file to `pyshark`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`pcap`文件加载到`pyshark`中：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can sniff from a live interface with the following commands:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从实时接口进行嗅探：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will sniff the interface for the next 3 seconds
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将嗅探接口的下一个3秒
- en: Now you can get the packet details from the `cap` variable.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以从`cap`变量中获取数据包的详细信息。
- en: 'To print out the first packet details, we can use the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出第一个数据包的详细信息，我们可以使用以下命令：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output will be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/00034.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'You can view all the possible options with `dir()`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`dir()`查看所有可能的选项：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To view them in a pretty format, we can use the `pprint` module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以漂亮的格式查看它们，我们可以使用`pprint`模块：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will print all the possible options for a packet in PyShark. The output
    will be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印PyShark中数据包的所有可能选项。输出如下：
- en: '![](img/00035.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'You can iterate through each packet as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按如下方式迭代每个数据包：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/00036.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: 'We can get the stream of filtered packets to `pyshark` as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按如下方式获取经过筛选的数据包流到`pyshark`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will filter out the packets, except, TCP/IP to port `80`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将过滤数据包，除了TCP/IP到端口`80`
