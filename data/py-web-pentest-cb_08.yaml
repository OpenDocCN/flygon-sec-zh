- en: Chapter 8. Payloads and Shells
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。负载和Shell
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Extracting data through HTTP requests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP请求提取数据
- en: Creating an HTTP C2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTTP C2
- en: Creating an FTP C2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建FTP C2
- en: Creating an Twitter C2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Twitter C2
- en: Creating a simple Netcat shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的Netcat shell
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will be looking at the creation of reverse shells and payloads
    in Python. Once an upload vulnerability has been identified on a Linux or Mac
    system, Python payloads are in the sweet spot of next steps. They are easy to
    craft or customize to match a specific system, have clear functionality, and best
    of all, almost all Mac and Linux systems come with Python 2.7 by default.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在Python中创建反向shell和负载的过程。一旦在Linux或Mac系统上识别出上传漏洞，Python负载就处于下一步的甜蜜点。它们易于制作或定制以匹配特定系统，具有清晰的功能，最重要的是，几乎所有的Mac和Linux系统默认都安装了Python
    2.7。
- en: Extracting data through HTTP requests
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP请求提取数据
- en: 'The first script we''ll being creating will use a very simple technique to
    extract data from the target server. There are three basic steps: run the commands
    on the target, transfer the output through HTTP requests to the attacker, and
    view the results.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个脚本将使用非常简单的技术从目标服务器中提取数据。有三个基本步骤：在目标上运行命令，通过HTTP请求将输出传输给攻击者，并查看结果。
- en: Getting Ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe requires a web server that is accessible on the attacker''s side
    in order to receive the HTTP request from the target. Luckily, Python has a really
    simple way to start a web server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要一个Web服务器，该服务器可在攻击者一侧访问，以便接收来自目标的HTTP请求。幸运的是，Python有一种非常简单的方法来启动Web服务器：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will start a HTTP web server on port `8000`, serving up any files in the
    current directory. Any requests it receives are printed out directly to the console,
    making this a really quick way to grab the data and are therefore a nice addition
    to this script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`8000`上启动一个HTTP Web服务器，提供当前目录中的任何文件。它接收到的任何请求都将直接打印到控制台，这是一种非常快速获取数据的方法，因此是此脚本的一个很好的补充。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This is the script that will run various commands on the server and transfer
    the output through a web request:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将在服务器上运行各种命令并通过Web请求传输输出的脚本：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'After the imports, the first part of the script creates an array of commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 导入之后，脚本的第一部分创建了一个命令数组：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is an example of three standard Linux commands that could give useful information
    back to the attacker. Note that there's an assumption here that the target server
    is running Linux. Use scripts from the previous chapters for reconnaissance, in
    order to determine the target's operating system and replace the commands in this
    array with Windows equivalents, if necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是三个标准的Linux命令的示例，可以向攻击者提供有用的信息。请注意，这里假设目标服务器正在运行Linux。使用前几章的脚本进行侦察，以确定目标操作系统，并在必要时用Windows等效命令替换此数组中的命令。
- en: 'Next, we have the main `for` loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有主要的`for`循环：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This part of code executes the command and grabs the output from `subprocess`
    (piping both standard out and standard error into a single `subprocess.PIPE`).
    It then adds the result to the out dictionary. Notice that we use a `try` and
    `except` statement here, as any command that fails to run will cause an exception.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这部分执行命令并从`subprocess`中获取输出（将标准输出和标准错误都传输到单个`subprocess.PIPE`中）。然后将结果添加到输出字典中。请注意，我们在这里使用`try`和`except`语句，因为任何无法运行的命令都会引发异常。
- en: 'Finally, we have a single HTTP request:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个单一的HTTP请求：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This uses `urllib.encode` to transform the dictionary into URL encoded key/value
    pairs. This means that any characters that could affect the URL, for example,
    `&` or `=`, will be converted to their URL encoded equivalent, for example, `%26`
    and `%3D`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`urllib.encode`将字典转换为URL编码的键/值对。这意味着任何可能影响URL的字符，例如`&`或`=`，将被转换为它们的URL编码等效形式，例如`%26`和`%3D`。
- en: 'Note that there will be no output on the script side; everything is passed
    over in the HTTP request to the attacker''s web server (the example uses localhost
    on port `8000`). The `GET` request looks like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本端不会有任何输出；一切都通过HTTP请求传递到攻击者的Web服务器（示例使用本地主机的端口`8000`）。`GET`请求如下所示：
- en: '![How it works…](img/B04044_08_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04044_08_01.jpg)'
- en: Creating an HTTP C2
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个HTTP C2
- en: The issue with brazenly presenting your commands in URLs is that even a half-asleep
    log analyst will spot it. There are multiple methods of hiding requests, but when
    you don't know what the response text is going to look like, you need to provide
    a solid method of disguising the output and returning it to your server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL中公开您的命令的问题是，即使是半睡不醒的日志分析员也会注意到它。有多种方法可以隐藏请求，但是当您不知道响应文本将是什么样子时，您需要提供一种可靠的方法来伪装输出并将其返回到您的服务器。
- en: We will create a script that masks command and control activities as HTTP traffic,
    takes commands from comments on a web page, and returns the output into a guestbook.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，将命令和控制活动伪装成HTTP流量，从网页评论中获取命令，并将输出返回到留言簿中。
- en: Getting Started
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this, you will need a functioning web server with two pages, one to host
    your comments and one to host your retrieval page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您需要一个正常运行的Web服务器，其中包括两个页面，一个用于托管您的评论，另一个用于托管检索页面。
- en: 'Your comment page should just have standard content. For this, I''m using the
    Nginx default home page and adding comments to it at the end. A comment should
    be expressed as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论页面应该只包含标准内容。为此，我使用Nginx默认主页，并在末尾添加评论。评论应表达为：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The retrieval page can be as simple as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 检索页面可以非常简单：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Basically, what this PHP does is take an incoming value in the `POST` request
    named `comment` and places it in a database. It's very rudimentary and does not
    distinguish between multiple incoming commands if you have multiple shells going.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个PHP所做的是接收`POST`请求中名为`comment`的传入值，并将其放入数据库中。这非常基础，如果您有多个shell，它不会区分多个传入命令。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script we will be using is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows an example of the output produced when using this script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此脚本时产生的输出示例：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As ever, we import the necessary libraries and get the script going:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入必要的库并启动脚本：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As this script has a built-in self deletion method, we can set it up to run
    forever with the following loop:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此脚本具有内置的自删除方法，因此我们可以设置它以以下循环永远运行：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We make a request to check whether there are any comments on our preconfigured
    page. If there are, we put them in a list. We use very basic `regex` to perform
    this check:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出请求，检查我们预先配置的页面上是否有任何评论。如果有，我们将它们放在一个列表中。我们使用非常基本的`regex`来执行此检查：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing we do is check for an empty comment. This signifies to the
    script that it should delete itself, a very important mechanism for hands-off
    C2 scripts. If you wish the script to delete itself, just leave an empty comment
    on your page. The script deletes itself by looking for its own name and removing
    that name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是检查是否有空评论。这对脚本来说意味着它应该删除自己，这是一个非常重要的无人值守C2脚本机制。如果您希望脚本删除自己，只需在页面上留下一个空评论。脚本通过查找自己的名称并删除该名称来删除自己：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the comment isn''t blank, we attempt to pass it to the system with the `subprocess`
    command. It''s important that you use .`split()` on the command to account for
    how `subprocess` handles multi-part commands. We use `.check_output` to return
    whatever output the command gives directly to the variable that we assign:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果评论不为空，我们尝试使用`subprocess`命令将其传递给系统。重要的是你在命令上使用`.split()`来考虑`subprocess`如何处理多部分命令。我们使用`.check_output`将命令直接返回给我们分配的变量：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the command fails, we set the response value to be `command failed`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令失败，我们将响应值设置为`命令失败`：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We take the `response` variable and assign it to a key that matches our PHP
    script in a dictionary. In this circumstance, the field name is `comment` and
    thus we assign our output to a comment. We base64 the output in order to account
    for any random variables, such as spaces or code that may interfere with our script:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取`response`变量并将其分配给与字典中的PHP脚本匹配的键。在这种情况下，字段名为`comment`，因此我们将输出分配给评论。我们对输出进行base64编码，以便考虑到任何可能干扰我们脚本的随机变量，例如空格或代码：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the data has been assigned, we send it in a `POST` request to our preconfigured
    server and wait `30` seconds to again check for further instructions in the comments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经分配，我们将其发送到我们预先配置的服务器的`POST`请求中，并等待`30`秒再次检查评论中是否有进一步的指示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating an FTP C2
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建FTP C2
- en: This script is a quick and dirty file-theft tool. It runs in a straight line
    up the directories, nabbing everything it comes into contact with. It then exports
    these to an `FTP` directory that it's pointed at. In situations where you can
    drop a file and want to quickly get the contents of the server, this is ideal
    as a starting point.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个快速而肮脏的文件窃取工具。它沿着目录直线运行，抓取它接触到的一切。然后将这些导出到它指向的`FTP`目录。在您可以放置文件并希望快速获取服务器内容的情况下，这是一个理想的起点。
- en: We will create a script that connects to an FTP, grabs the files in the current
    directory, and exports them to the FTP. It then jumps up into the next directory
    and repeats. When it encounters two directory listings that are the same (that
    is, it has hit the root), it stops.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个连接到FTP的脚本，获取当前目录中的文件，并将它们导出到FTP。然后它跳到下一个目录并重复。当它遇到两个相同的目录列表（也就是说，它到达了根目录）时，它就会停止。
- en: Getting Started
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this, you will need a functioning FTP server. I'm using `vsftpd`, but you
    may use whatever you please. You'll need to either hard code the credentials into
    the script (not advisable) or send them with the credentials as flags.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您将需要一个正常运行的FTP服务器。我正在使用`vsftpd`，但您可以使用任何您喜欢的。您需要将凭据硬编码到脚本中（不建议）或者作为标志与凭据一起发送。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The script we will be using is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本如下：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As ever, we import our libraries and set up our variables. We have set the
    username and password as `sys.argv` to avoid having to hard code and therefore
    expose our systems:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入我们的库并设置我们的变量。我们已将用户名和密码设置为`sys.argv`，以避免硬编码，从而暴露我们的系统：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then connect to our FTP with an IP address and the credentials we set up
    through the flags. You can also pass the IP as `sys.argv` to avoid hard-coding:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用IP地址和通过标志设置的凭据连接到我们的FTP。您还可以将IP作为`sys.argv`传递，以避免硬编码：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I''ve set up a nonce value that won''t match the first directory for the directory
    checking method. We also set the loop as `0` and configure the "up directory"
    command as a variable, similar to the directory traversal script in [Chapter 3](ch03.html
    "Chapter 3. Vulnerability Identification"), *Vulnerability Identification*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个nonce值，它与目录检查方法的第一个目录不匹配。我们还将循环设置为`0`，并将"上一个目录"命令配置为一个变量，类似于[第3章](ch03.html
    "第3章.漏洞识别")中的目录遍历脚本，*漏洞识别*：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then create our main loop to repeat forever and create our chosen directory
    call. We list the files in the directory we call and assign it a variable. You
    can opt to print the file listing here if you wish, as I have for diagnostic purposes,
    but it makes no difference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建我们的主循环以永远重复并创建我们选择的目录调用。我们列出我们调用的目录中的文件并将其分配给一个变量。您可以选择在这里打印文件列表，如我所做的那样，以进行诊断目的，但这没有任何区别：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For each file detected in the directory, we attempt to open it. It''s important
    we open the file with `rb` as this allows it to be read as a binary, making it
    available to be transferred as a binary. If it''s openable, we transfer it to
    the FTP with the `storbinary` command. We then close the file to complete the
    transaction:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在目录中检测到的每个文件，我们尝试打开它。重要的是我们用`rb`打开文件，因为这允许它作为二进制文件读取，使其可以作为二进制文件传输。如果可以打开，我们使用`storbinary`命令将其传输到FTP。然后我们关闭文件以完成交易：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If, for whatever reason, we can''t open or transfer the file, we simply move
    on to the next one in the list:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因我们无法打开或传输文件，我们只需继续到列表中的下一个文件：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then check to see whether we have changed directories since the last command.
    If not, we break out of the main loop:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否自上次命令以来改变了目录。如果没有，我们就跳出主循环：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the directory listing doesn''t match, we set the `filecheck` variable to
    match the current directory, iterate the loop by `1`, and sleep for `10` seconds
    to avoid spamming the server:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录列表不匹配，我们将`filecheck`变量设置为匹配当前目录，通过`1`迭代循环，并休眠`10`秒以避免向服务器发送垃圾邮件：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, once everything else is complete, we close our connection to the FTP
    server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一切都完成后，我们关闭与FTP服务器的连接：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating an Twitter C2
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Twitter C2
- en: Up to a certain point, requesting random pages on the Internet is passable but
    once a **Security Operation Centre** (**SOC**) analyst takes a closer look at
    all the data that's vanishing up the tubes, it's going to be obvious that the
    requests are going to a dodgy site and therefore are likely associated with malicious
    traffic. Fortunately, social media helps out in this regard and allows us to hide
    data in plain sight.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，请求互联网上的随机页面是可以接受的，但一旦**安全运营中心**（**SOC**）分析员仔细查看所有消失在管道中的数据，很明显这些请求是发往一个可疑站点，因此很可能与恶意流量相关。幸运的是，社交媒体在这方面提供了帮助，并允许我们将数据隐藏在明处。
- en: We will create a script that connects to Twitter, reads tweets, performs commands
    based on those tweets, encrypts the response data, and posts it to Twitter. We'll
    also make a decode script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个连接到Twitter的脚本，读取推文，根据这些推文执行命令，加密响应数据，并将其发布到Twitter。我们还将创建一个解码脚本。
- en: Getting Started
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this, you will need a Twitter account with an API key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您需要一个带有API密钥的Twitter帐户。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script we will be using is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本如下：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The decoding script is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解码脚本如下：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An example of what the script in progress looks like is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本进行中的示例如下：
- en: '![How to do it…](img/B04044_08_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B04044_08_02.jpg)'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We import our libraries, as usual. There are numerous Twitter Python libraries;
    I''m just using the standard twitter API available at [https://code.google.com/p/python-twitter/](https://code.google.com/p/python-twitter/).
    The code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样导入我们的库。有很多Twitter的Python库；我只是使用了[https://code.google.com/p/python-twitter/](https://code.google.com/p/python-twitter/)上可用的标准twitter
    API。代码如下：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To meet the Twitter authentication requirements, we need to need to retrieve
    the **App token**, **App secret**, **User token**, and **User secret** from our
    **App page** at [developer.twitter.com](http://developer.twitter.com). We assign
    them to variables and set up our connection to the Twitter API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足Twitter的身份验证要求，我们需要从[developer.twitter.com](http://developer.twitter.com)的**App页面**中检索**App令牌**、**App密钥**、**用户令牌**和**用户密钥**。我们将它们分配给变量，并设置我们与Twitter
    API的连接：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We set up an infinite loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置一个无限循环：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We call the user timeline of the account that has been set up. It''s important
    that this App has both read and write privileges for the Twitter account. We then
    take the last text of the most recent tweet. We need to encode it as UTF-8 as
    there are often characters that the normal encoding won''t be able to handle:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用已设置的帐户的用户时间线。这个应用程序必须对Twitter帐户具有读写权限很重要。然后我们取最近推文的最后一条文本。我们需要将其编码为UTF-8，因为通常有一些字符，普通编码无法处理：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then take the oxt-last tweet to use as the key for our encryption. We encode
    it as `hex` to avoid there being things like spaces matching with spaces:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们取最后一条推文作为我们加密的密钥。我们将其编码为`hex`以避免出现空格匹配空格的情况：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We carry out the action by using the `subprocess` function. We encrypt the
    output with preset up XORing encryption and encode it as base64:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`subprocess`函数执行操作。我们使用预设的XOR加密加密输出，并将其编码为base64：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We split the encrypted and encoded response into 140 character chunks, to allow
    for the Twitter character cap. For each chunk, we create a Twitter status:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加密和编码的响应分成140个字符的块，以适应Twitter的字符限制。对于每个块，我们创建一个Twitter状态：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Because each step requires two tweets, I''ve left an hour gap between each
    command check, but it''s easy to change this for yourself:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个步骤都需要两条推文，我在每个命令检查之间留了一个小时的间隔，但您可以很容易地根据自己的需要进行更改：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For the decoding, import the `RC4` library, set your key tweet as the key,
    and put your reassembled base64 as the response:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解码，导入`RC4`库，将您的关键推文设置为密钥，并将重新组装的base64设置为响应：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Set up a new `RC4` code with the key, decode the data from base64, and decrypt
    it with the key:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字设置一个新的`RC4`代码，从base64解码数据，并使用关键字解密它：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Creating a simple Netcat shell
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的Netcat shell
- en: The following script we're going to create leverages the use of raw sockets
    to exfiltrate data from a network. The general idea of this shell is to create
    a connection between the compromised machine and your own machine through a Netcat
    (or other program) session and send commands to the machine this way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下脚本，利用原始套接字从网络中泄露数据。这个shell的一般思想是在受损的机器和您自己的机器之间创建一个连接，通过Netcat（或其他程序）会话发送命令到这台机器。
- en: The beauty of this Python script is the undetectable nature of it, as it appears
    as a completely legitimate script.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python脚本的美妙之处在于它的隐蔽性，因为它看起来就像一个完全合法的脚本。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This is the script that will establish a connection through Netcat and read
    the input:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将通过Netcat建立连接并读取输入的脚本：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To start the script as normal, we need to import our modules that will be used
    throughout the script:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要像往常一样启动脚本，我们需要导入将在整个脚本中使用的模块：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then need to define our variables: these values are the IP and port of the
    attacking machine to establish a connection with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义我们的变量：这些值是攻击机器的IP和端口，以建立连接：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We then move on to defining the original connection; we can then assign a value
    to our established value and refer to this later on to read the input and send
    the standard output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续定义原始连接；然后我们可以为我们建立的值分配一个值，并在以后引用它来读取输入并发送标准输出。
- en: 'We refer back to the host and port value that we previously set and create
    the connection. We assign the established connection the value of `go`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾一下之前设置的主机和端口值，并创建连接。我们将已建立的连接赋予`go`的值：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can then introduce the block of code that will do the waiting portion for
    us. This will be awaiting commands to be sent to it through the attacking machine's
    Netcat session. We ensure that data that gets sent through the session is piped
    into the shell and the standard output of this is then returned to us through
    the established Netcat session, thus giving us shell access through our reverse
    connection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以引入一段代码，用于等待部分。这将通过攻击机的Netcat会话等待发送给它的命令。我们确保通过会话发送的数据被导入到shell中，并且其标准输出通过已建立的Netcat会话返回给我们，从而通过反向连接为我们提供shell访问权限。
- en: 'We give the name data to the values that are passed to the compromised machine
    through the Netcat session. A value is added to the script to exit the session
    when the user is done; we''ve chosen `exit` for this, which means entering exit
    into our Netcat session will terminate the established connection. We then get
    down to the nitty gritty parts in which the data is opened (read) and piped into
    the shell for us. Once this has been done, we ensure the `stdout` value is read
    and given a value of `stdout` (this could be anything), which we then send back
    to ourselves via the `go` session that we established earlier. The code is as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给通过Netcat会话传递给受损机器的值命名为数据。脚本中添加了一个值，用于在用户完成操作时退出会话；我们选择了`exit`，这意味着在Netcat会话中输入exit将终止已建立的连接。然后，我们开始处理数据的细节部分，其中数据被打开（读取）并被导入到shell中。完成后，我们确保读取`stdout`值并赋予一个值`stdout`（这可以是任何值），然后通过之前建立的`go`会话将其发送回给我们自己。代码如下：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final portion of our script is our error-checking and running portion.
    Before the script runs, we make sure we let Python know that we have a mechanism
    in place to check whether the session is active by using our previous true statement.
    If the connection is lost, the Python script will attempt to re-establish a connection
    with the attacking machine, making it a persistent backdoor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的最后部分是错误检查和运行部分。在脚本运行之前，我们确保让Python知道我们有一个机制来检查会话是否处于活动状态，方法是使用我们之前的真实语句。如果连接丢失，Python脚本将尝试重新与攻击机建立连接，使其成为一个持久的后门：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
