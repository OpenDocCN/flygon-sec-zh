- en: Antivirus Evasion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防病毒规避
- en: The concept of having antivirus software is nothing new. It is a common security
    control that's used to protect users against malware and other types of malicious
    software. Historically, it has been focused purely on the prevention of virus
    infections. In your penetration testing engagements, finding a customer who doesn't
    have an antivirus is extremely rare to almost impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有防病毒软件的概念并不新鲜。这是一种常见的安全控制，用于保护用户免受恶意软件和其他类型的恶意软件的侵害。从历史上看，它一直专注于预防病毒感染。在您的渗透测试中，几乎不可能找到一个没有防病毒软件的客户。
- en: In this chapter, you will learn about the evolution of antivirus technologies
    and how they are becoming more sophisticated. You will learn about various techniques
    that you can leverage for antivirus evasion, and also learn about the tools that
    can help you utilize those techniques. You will learn how to encode payloads to
    avoid detection and, finally, explore the online tools that can be used to check
    the detection rate of your payload.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解防病毒技术的发展以及它们变得更加复杂的方式。您将学习各种可以用于防病毒规避的技术，并了解可以帮助您利用这些技术的工具。您将学习如何对有效载荷进行编码以避免检测，并最终探索可以用于检查有效载荷检测率的在线工具。
- en: 'As you progress through this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的进行，您将学习以下主题：
- en: The evolution of antivirus technologies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防病毒技术的发展
- en: Concepts of antivirus evasion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防病毒软件规避的概念
- en: Getting started with antivirus evasion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用防病毒规避
- en: Testing evasion techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试规避技术
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples and instructions in this chapter, please
    check that you have the following technical requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本章中的示例和说明进行操作，请检查您是否具备以下技术要求：
- en: Kali Linux 2019.1
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux 2019.1
- en: The evolution of antivirus technologies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防病毒技术的发展
- en: The threat landscape is evolving at a rapid pace. Over the past few years, there
    have been attack vectors such as automated attacks, fileless malware, firmware-based
    malware, **advanced persistent threat** (**APT**) malware, and, let's not forget,
    sophisticated ransomware. Attackers have a repertoire of attacks that can leverage
    artificial intelligence and machine learning at their disposal. Based on these
    advancements in attacks, antiviruses had to catch up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁形势正在迅速发展。在过去的几年里，出现了攻击向量，如自动化攻击、无文件恶意软件、固件恶意软件、高级持续性威胁（APT）恶意软件，还有，别忘了，复杂的勒索软件。攻击者拥有一系列攻击手段，可以利用人工智能和机器学习。基于这些攻击的进展，防病毒软件不得不跟上。
- en: Out with the old
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 淘汰旧技术
- en: The traditional antivirus, which served the purpose of simply stopping viruses
    based on signatures and looking for changes in filesystems or applications based
    on patterns, is no longer sufficient. Even though signatures and pattern-based
    matching is still used today, there are weaknesses that exist. For example, failure
    to update the signatures, or keeping up with the large amount of malware that
    is released daily poses a massive risk. Heuristic scanning is the ability of an
    antivirus to analyze code against a set of variables that will indicate whether
    a virus exists. This approach enables the detection of an additional set of viruses,
    but it can also be circumvented as the variables can be modified. The scanning
    and interception abilities of the antivirus has its benefits, but these too can
    be bypassed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的防病毒软件，其目的是仅仅基于签名停止病毒，并根据模式查找文件系统或应用程序的变化，已经不再足够。尽管签名和基于模式的匹配仍然在使用，但存在弱点。例如，无法更新签名，或者跟上每天发布的大量恶意软件都会带来巨大风险。启发式扫描是防病毒软件分析代码与一组变量的能力，这些变量将指示病毒是否存在。这种方法使得能够检测到一组额外的病毒，但也可以被规避，因为变量可以被修改。防病毒软件的扫描和拦截能力有其好处，但这些也可以被规避。
- en: Malware that exists now grows too rapidly for antivirus manufacturers to keep
    up with it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存在的恶意软件增长速度太快，使得防病毒制造商无法跟上。
- en: In with the new
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入新技术
- en: Today's antiviruses have evolved by having the ability to detect and prevent
    hidden exploits, leverage threat intelligence, have full visibility of the endpoints
    (including applications, processes, and memory), alert automation, forensic capabilities,
    and data collection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的防病毒软件已经发展，具有检测和防止隐藏漏洞利用的能力，利用威胁情报，对端点（包括应用程序、进程和内存）进行全面监控，自动警报，取证能力和数据收集。
- en: 'Antiviruses in this day and age can be called next-generation antiviruses,
    and use tactics such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的防病毒软件可以被称为下一代防病毒软件，并使用以下策略：
- en: Look at exploit techniques that block a process that is using a typical method
    to bypass a normal process operation. This method does not consider the file type
    but the process itself.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看阻止使用典型方法绕过正常进程操作的利用技术。这种方法不考虑文件类型，而是考虑进程本身。
- en: Machine learning techniques that can be used to learn hundreds of variants of
    a specific malicious file; a task which, in the older antivirus, would need some
    human interaction and a sandbox environment to test each variant.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于学习特定恶意文件的数百个变体的机器学习技术；而在旧的防病毒软件中，这需要一些人工干预和一个沙箱环境来测试每个变体。
- en: Detection capabilities that look further than the disk. Malware such as fileless
    malware doesn't drop anything on disk. Traditional antivirus software is unable
    to detect this, but the next generation of antiviruses can.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越磁盘的检测能力。例如，无文件恶意软件等恶意软件不会在磁盘上留下任何东西。传统的防病毒软件无法检测到这一点，但下一代防病毒软件可以。
- en: Artificial intelligence, whose role is to decrease human intervention further
    by enabling the antivirus to identify patterns, relate this to a threat, and update
    its own database with the new pattern.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能的作用是进一步减少人类干预，使防病毒软件能够识别模式，将其与威胁联系起来，并使用新模式更新自己的数据库。
- en: It may seem that these next-generation antiviruses make it impossible to evade,
    but it is still possible. As its defense capabilities get better, so do the offensive
    tools that we can make use of.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这些下一代反病毒软件使规避变得不可能，但仍然是可能的。随着其防御能力的提高，我们可以利用的进攻工具也在不断改进。
- en: Concepts of antivirus evasion
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反病毒规避的概念
- en: 'During the exploitation phase of your penetration test, you will need to get
    code to run on your target system. This can be done via phishing emails, an exploit,
    or social engineering. The blocker that you will have is antivirus software (be
    it the traditional variant or the next-generation variant). The most effective
    way to bypass an antivirus is to create your own customized payload. Before we
    dive into creating the payloads, let''s consider a few tips:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试的利用阶段，您需要在目标系统上运行代码。这可以通过钓鱼邮件、利用或社会工程来完成。您将遇到的阻碍是反病毒软件（无论是传统变体还是下一代变体）。绕过反病毒软件的最有效方法是创建自己的定制有效载荷。在我们深入创建有效载荷之前，让我们考虑一些技巧：
- en: Reconnaissance plays an important role in antivirus evasion. Knowing what your
    target has is key. If you feel that you want to have a customized payload that
    avoids all antivirus products, you are misleading yourself. The time spent to
    achieve this will be too long, and with every vendor actively making improvements
    to their products, your payload will be detectable in no time at all. Narrow down
    your payload to your target's antivirus.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侦察在反病毒规避中起着重要作用。了解您的目标拥有什么是关键。如果您觉得想要一个定制的有效载荷，可以避开所有反病毒产品，那么您是在误导自己。花费时间来实现这一点将会太长，而且随着每个供应商积极改进其产品，您的有效载荷将很快被检测到。将有效载荷缩小到目标的反病毒软件。
- en: Once you have a working shellcode, you might reuse it again in later penetration
    tests, and it may still work. To ensure that you reduce the detection capabilities
    of your exploit, never submit it to services such as VirusTotal (this will be
    covered later in this chapter) or any other online scanners. These online resources
    usually submit the samples to antivirus vendors, who, in turn, use it to amp up
    their detection capabilities.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您有一个可用的shellcode，您可能会在以后的渗透测试中再次重复使用它，而且它可能仍然有效。为了确保减少您的利用的检测能力，永远不要将其提交到VirusTotal等服务（本章后面将介绍），或任何其他在线扫描程序。这些在线资源通常会将样本提交给反病毒供应商，供应商又会用它来增强其检测能力。
- en: Simplicity is key. Don't go for glamorous payloads with loads of features. Remember,
    you are just trying to disable the antivirus and then use more powerful tools.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单是关键。不要选择带有大量功能的华丽有效载荷。记住，您只是试图禁用反病毒软件，然后使用更强大的工具。
- en: Use resources that are available to you. For example, Metasploit has modules
    that can be used for antivirus evasion. Online resources such as ExploitDB have
    shellcodes that can be downloaded, customized, and used.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用您可以使用的资源。例如，Metasploit具有可用于反病毒规避的模块。在线资源如ExploitDB有可以下载、定制和使用的shellcode。
- en: Keeping these tips in mind will help as you progress through your penetration
    testing career, as you have a good starting point in terms of what to consider
    when planning antivirus evasion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些技巧将有助于您在渗透测试职业中取得进展，因为您在规划反病毒规避时有一个很好的起点。
- en: Antivirus evasion techniques
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反病毒规避技术
- en: Now that we have established the need for antivirus evasion, let's look at the
    various techniques that exist. The following are the most common techniques that
    can be used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了需要进行反病毒规避，让我们来看看存在的各种技术。以下是可以使用的最常见的技术。
- en: Encoders
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码器
- en: Encoders allow you to avoid characters within an exploit that cause it to malfunction.
    By using MSFvenom, you have access to a number of encoders. Encoding works by
    tearing apart the payload and adding in additional code to mask the real payload.
    There are decoding instructions that get added into the payload so that before
    it is run, it can be decoded. MSFvenom has some built-in encoders, which we will
    look at later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器允许您避免在利用中导致其发生故障的字符。通过使用MSFvenom，您可以访问多个编码器。编码工作是通过拆分有效载荷并添加额外的代码来掩盖真实的有效载荷。在有效载荷中添加解码指令，以便在运行之前对其进行解码。MSFvenom具有一些内置的编码器，我们将在本章后面进行讨论。
- en: Custom compiling
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义编译
- en: Using the built-in encoders of MSFvenom is not as efficient as we would want
    it to be. Metasploit and its components are a constant highlight to antivirus
    manufacturers, and they keep a close watch on the improvements that are made to
    encoders within it. To get around this, you can leverage custom compiling to create
    an undetectable payload. Looking at the C programming language, there are some
    key components that you could leverage to add randomness to your code in an effort
    to trick antivirus programs into not detecting it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MSFvenom的内置编码器并不像我们希望的那样高效。Metasploit及其组件是反病毒制造商的一个不断关注的焦点，并且他们密切关注其中的编码器所做的改进。为了绕过这一点，您可以利用自定义编译来创建一个不可检测的有效载荷。查看C编程语言，有一些关键组件可以利用，以向您的代码添加随机性，以试图欺骗反病毒程序不要检测它。
- en: Obfuscation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆
- en: Obfuscation is the process of modifying the payload so that it's unclear to
    the antivirus, yet it is still usable for its intended purpose. One way of obfuscating
    your payload is using encryption. A tool such as Hyperion (which we will cover
    later) can be used to encrypt the payload using **Advanced Encryption Standard**
    (**AES**). Once the payload is run, decryption takes place and the payload is
    able to execute. This encryption helps reduce the detection rate by antiviruses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆是修改有效载荷的过程，使其对反病毒软件不清楚，但仍然可以用于其预期目的。混淆有效载荷的一种方法是使用加密。可以使用Hyperion等工具（我们将在后面介绍）使用**高级加密标准**（**AES**）对有效载荷进行加密。一旦运行有效载荷，解密就会发生，有效载荷就能够执行。这种加密有助于减少反病毒软件的检测率。
- en: Of course, since antiviruses are constantly getting better, it's simply not
    possible to use just one method of evasion. There is no **silver bullet** for
    antivirus evasion. You will need to combine a few techniques to help reduce the
    detection rate of your payload.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于杀毒软件不断变得更好，仅仅使用一种规避方法是不可能的。没有杀毒软件规避的**灵丹妙药**。您需要结合一些技术来帮助降低有效负载的检测率。
- en: Getting started with antivirus evasion
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用杀毒软件规避
- en: When conducting a penetration test, there is a level of trust that is defined
    between you and your client. When you drop any payloads into their environment,
    such as evading the antivirus to create a backdoor to your system, you need to
    ensure that the payload connects back to you only. There shouldn't be any bugs
    in the code that could lead to a real compromise of the client's environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，存在着您和客户之间定义的信任级别。当您将任何有效负载投放到他们的环境中时，例如规避杀毒软件以在您的系统中创建后门，您需要确保有效负载只连接回您。代码中不应该有任何可能导致客户环境真正妥协的错误。
- en: As you work through the various tools that are defined in this section, please
    ensure that you explicitly define your system's IP that the target would connect
    back to. Doing so will ensure that you enforce the concept of trust in the initial
    learning steps of your career.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在您学习本节中定义的各种工具时，请确保明确定义目标将连接回的系统IP。这样做将确保您在职业生涯的初步学习阶段强化信任的概念。
- en: MSFvenom
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSFvenom
- en: MSFvenom is a command-line tool and is part of the Metasploit Framework. It
    is used to generate various shellcodes that can be used to provide a backdoor
    into a system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom是Metasploit框架的命令行工具的一部分。它用于生成各种shellcode，可用于提供对系统的后门。
- en: 'Some of the common switches within MSFvenom are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom中的一些常见开关如下：
- en: '| `-l` | This is used to display a list of all modules within each category
    (encoders, payloads, formats, encrypters, and more). For example, using `msfvenom
    -l payloads` will display the current set of payloads available. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: -`-l` | 这用于显示每个类别（编码器、有效负载、格式、加密器等）中所有模块的列表。例如，使用`msfvenom -l payloads`将显示当前可用的有效负载集。
- en: '| `-p` | This defines the payload that will be used. For example, using the `msfvenom
    -p windows/x64/meterpreter_reverse_https` command will define the meterpreter
    reverse HTTPS payload. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: -`-p` | 这定义将使用的有效负载。例如，使用`msfvenom -p windows/x64/meterpreter_reverse_https`命令将定义meterpreter反向HTTPS有效负载。
- en: '| `-f` | This defines the output format. For example, you may want to create
    an `.exe` or `.c` file. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: -`-f` | 这定义了输出格式。例如，您可能想要创建一个`.exe`或`.c`文件。
- en: '| `-b` | This is used to eliminate bad characters. Antiviruses look for bad
    characters such as `\x00`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: -`-b` | 这用于消除坏字符。杀毒软件会寻找诸如`\x00`之类的坏字符。
- en: '| `-e` | This is used to define the encoder that will be used. For example,
    one of the commonly used encoders is `/x86/shikata_ga_nai`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: -`-e` | 这用于定义将使用的编码器。例如，常用的编码器之一是`/x86/shikata_ga_nai`。
- en: '| `-i` | This is used to define the maximum number of times to encode the shellcode.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: -`-i` | 这用于定义对shellcode进行编码的最大次数。
- en: '| `-a` | This is used to define the architecture. For example, `-a x64` will
    create a 64-bit shellcode. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: -`-a` | 这用于定义架构。例如，`-a x64`将创建一个64位的shellcode。
- en: '| `--platform` | This is used to define the platform that the shellcode will
    target. For example, `--platform Windows` for Windows operating systems. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '`--platform` | 这用于定义shellcode将针对的平台。例如，对于Windows操作系统，可以使用`--platform Windows`。'
- en: MSFvenom has a lot more options and switches; the preceding table describes
    what you would commonly use when creating a payload.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom有更多的选项和开关；前面的表格描述了在创建有效负载时通常使用的内容。
- en: MSFvenom allows you to chain multiple commands together. This is done using
    the `| \` sequence at the end of each command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom允许您将多个命令链接在一起。这是通过在每个命令的末尾使用`| \`序列来完成的。
- en: To create the payload using a chain of commands, follow these steps. Take note
    of the `| \` sequence at the end of each command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一系列命令创建有效负载，请按照以下步骤进行。注意每个命令末尾的`| \`序列。
- en: 'From a Terminal window, enter the following commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端窗口，输入以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you have completed entering the preceding commands, you should get the
    following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成输入上述命令后，您应该得到以下输出：
- en: '![](img/6371948d-f93c-4879-b68a-e4bbf90c0ffd.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6371948d-f93c-4879-b68a-e4bbf90c0ffd.png)'
- en: 'Figure 1: MSFvenom commands chained'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：MSFvenom命令链
- en: In the first line of the command, we are defining the `meterpreter/reverse_tcp`
    payload to be used. We then define our attacking host's IP (`LHOST`) and port
    (`LPORT`). We then use the raw format (`-f`), and use the `shikata_ga_nai` encoder
    (`-e`) with 15 iterations (`-i 15`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的第一行中，我们正在定义要使用的`meterpreter/reverse_tcp`有效负载。然后我们定义我们攻击主机的IP（`LHOST`）和端口（`LPORT`）。然后我们使用原始格式（`-f`），并使用`shikata_ga_nai`编码器（`-e`）进行15次迭代（`-i
    15`）。
- en: In the second line of the command, we further encode the raw file by now defining
    the architecture (`-a`), the platform, which is Windows (`--platform`) in this
    case, and the `x86/countdown` encoder with 9 iterations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的第二行中，我们通过现在定义架构（`-a`），平台，这种情况下是Windows（`--platform`），以及使用9次迭代的`x86/countdown`编码器进一步对原始文件进行编码。
- en: Lastly, we compile this by running the `shikata_ga_nai` encoder again and creating
    an `exe` file using the `-f exe -o` option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过再次运行`shikata_ga_nai`编码器并使用`-f exe -o`选项创建一个`exe`文件来编译这个。
- en: Once the command executes, it will create a backdoor file called `MSFV-payload.exe`,
    which is stored in the `/root/Downloads/` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行，它将创建一个名为`MSFV-payload.exe`的后门文件，存储在`/root/Downloads/`文件夹中。
- en: We will test this file's detection rate in the *Testing evasion techniques* section
    later in this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的*测试规避技术*部分测试此文件的检测率。
- en: Veil Evasion
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Veil Evasion
- en: The Veil Evasion set of tools can be used to create shellcode that would evade
    common antiviruses, and generate a reverse shell.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Veil Evasion工具套件可用于创建规避常见杀毒软件并生成反向shell的shellcode。
- en: 'Installing the Veil suite of tools can be done as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Veil工具套件可以按以下步骤完成：
- en: Open a Terminal window in Kali Linux.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kali Linux中打开一个终端窗口。
- en: Use the `apt install -y veil` command. This will download the Veil suite of
    tools, all dependencies, and prepare them for installation. The `-y` command is
    used to simply predefine the `yes` parameter when we are asked whether we want
    to install the software.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`apt install -y veil`命令。这将下载Veil工具套件，所有依赖项，并为安装做好准备。`-y`命令用于在询问是否要安装软件时简单地预定义`yes`参数。
- en: 'Once everything has been downloaded, you can kick off the installation by running
    the `veil`command (see the following screenshot). Use the `s`option for silent
    installation. This will still show you what components are being installed, but
    there will be no interaction required from your side:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切都下载完成后，可以通过运行`veil`命令（参见以下屏幕截图）来开始安装。使用`s`选项进行静默安装。这仍会显示正在安装的组件，但您无需进行任何交互：
- en: '![](img/08de093e-1133-458c-8311-059b417ff79f.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08de093e-1133-458c-8311-059b417ff79f.png)'
- en: 'Figure 2: Installing the components of Veil'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：安装Veil组件
- en: 'Once the installation of Veil has completed, you can run the tool by using
    the `veil` command from a Terminal window. On the first launch, you will be presented
    with the main window (see the following screenshot), which will show you the two
    tools that have been loaded. Using a specific tool is done using the `use [number]` command;
    for example, to use `Evasion`, you would use the `use 1` command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Veil安装完成后，您可以在终端窗口中使用`veil`命令运行该工具。首次启动时，将显示主窗口（参见以下屏幕截图），其中将显示已加载的两个工具。使用特定工具使用`use
    [number]`命令；例如，要使用`Evasion`，您将使用`use 1`命令：
- en: '![](img/70b7e294-9cf5-4dda-8881-ac36eb613fc9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70b7e294-9cf5-4dda-8881-ac36eb613fc9.png)'
- en: 'Figure 3: The Veil initial menu'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：Veil初始菜单
- en: 'The tools that we have available are `Evasion` and `Ordnance`. These two tools
    perform different functions, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的工具是`Evasion`和`Ordnance`。这两个工具执行不同的功能，如下所示：
- en: '`Evasion`: Thisis used to generate a payload that can be used to bypass the
    antivirus.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Evasion`：用于生成可用于绕过防病毒软件的有效载荷。'
- en: '`Ordnance`: This is used to generate shellcode that can be used with `Evasion`.
    `Ordnance` eliminates the need to use MSFvenom for shellcode generation. The reason
    for this is that as MSFvenom is updated, it would break the payloads created by
    `Evasion`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ordnance`：用于生成可与`Evasion`一起使用的shellcode。`Ordnance`消除了使用MSFvenom生成shellcode的需要。原因是随着MSFvenom的更新，它会破坏`Evasion`创建的有效载荷。'
- en: 'Let''s create a malicious payload using Veil:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Veil创建一个恶意有效载荷：
- en: Start `Veil` using the `veil` command.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`veil`命令启动`Veil`。
- en: Once `Veil` has started, we will use the `Evasion` tool. Type in `use 1`*:*
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Veil启动后，我们将使用`Evasion`工具。输入`use 1`*：*
- en: '![](img/727626f6-02a6-4656-b1d7-a9df8f0fd8d5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/727626f6-02a6-4656-b1d7-a9df8f0fd8d5.png)'
- en: 'Figure 4: Selecting the Evasion tool'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：选择Evasion工具
- en: To view the full list of payloads, enter the `list payloads` command. At the
    time of writing, there are 41 payloads available within Veil Evasion. We will
    create a payload using `python/shellcode_inject/aes_encrypt.py`*. *To select this
    payload, we will use the number associated with it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看有效载荷的完整列表，请输入`list payloads`命令。在撰写本文时，Veil Evasion中有41个有效载荷可用。我们将使用`python/shellcode_inject/aes_encrypt.py`创建有效载荷。要选择此有效载荷，我们将使用与之关联的数字。
- en: 'To use the payload, we will issue the `use 29` command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用有效载荷，我们将发出`use 29`命令：
- en: '![](img/23932785-5731-4520-9af1-986c3327a0ba.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23932785-5731-4520-9af1-986c3327a0ba.png)'
- en: 'Figure 5: Selecting the payload'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：选择有效载荷
- en: Within the payload, we have a number of options that can be configured. If you
    want to configure these, we can do so using the `set [option name] [value]` command.
    For example, to configure the `CLICKTRACK` option, you will use the `set CLICKTRACK
    1` command. We won't configure any options for now, so we will type `generate`
    to proceed to the next step.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有效载荷中，我们有许多可以配置的选项。如果要配置这些选项，可以使用`set [option name] [value]`命令。例如，要配置`CLICKTRACK`选项，将使用`set
    CLICKTRACK 1`命令。我们现在不会配置任何选项，因此我们将输入`generate`以进行下一步。
- en: 'Now we have options related to the shellcode (see the following screenshot).
    Here, you will notice that we can leverage `MSFVenom`, `Ordnance`, `Custom shellcode
    strings`, and more. We will use `Ordnance` to create the shellcode. Enter choice
    number `1`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有与shellcode相关的选项（参见以下屏幕截图）。在这里，您将注意到我们可以利用`MSFVenom`、`Ordnance`、`Custom
    shellcode strings`等。我们将使用`Ordnance`来创建shellcode。输入选项号`1`：
- en: '![](img/c9a4e95a-3fac-47d8-b85f-bc67d2ba15df.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9a4e95a-3fac-47d8-b85f-bc67d2ba15df.png)'
- en: 'Figure 6: The shellcode selection'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：shellcode选择
- en: 'When you enter option `1`, you are taken to the `Veil-Ordnance` menu (see the
    following screenshot). Here, you have a few options, such as viewing the `payloads`
    and `encoders`. To view the payloads, enter the `list payloads`command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您输入选项`1`时，将进入`Veil-Ordnance`菜单（参见以下屏幕截图）。在这里，您有一些选项，如查看`payloads`和`encoders`。要查看有效载荷，输入`list
    payloads`命令：
- en: '![](img/47dfbafd-4a98-49ee-830c-1a6d2f01b14a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47dfbafd-4a98-49ee-830c-1a6d2f01b14a.png)'
- en: 'Figure 7: Ordnance payloads'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Ordnance有效载荷
- en: We will use the `rev_https` payload by using the `use 3` command to select it.
    Now we are presented with options for the payload.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`rev_https`有效载荷，使用`use 3`命令选择它。现在我们将为有效载荷选择选项。
- en: 'We will need to define some options here. Define the `LHOST` and `LPORT` variables.
    Remember that this is the IP address and port that the target machine will connect
    back to. I have also defined the `Encoder` to use the built-in `xor` command.
    You can define these settings using the `set` command. Your output should look
    similar to the following, with the exception of the `LHOST` IP address:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在这里定义一些选项。定义`LHOST`和`LPORT`变量。记住这是目标机器将连接回来的IP地址和端口。我还定义了使用内置`xor`命令的`Encoder`。您可以使用`set`命令定义这些设置。您的输出应该与以下类似，除了`LHOST`
    IP地址：
- en: '![](img/3ff3e746-e355-4e35-9528-612f332652b7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ff3e746-e355-4e35-9528-612f332652b7.png)'
- en: 'Figure 8: Defining the payload options'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：定义有效载荷选项
- en: 'Type `generate` to generate the shellcode. You will now see the output of the
    shellcode, and Veil will ask you for a filename (see the following screenshot)*.*
    Give it a name and press *Enter*:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`generate`来生成shellcode。现在您将看到shellcode的输出，并且Veil会要求您输入一个文件名（见下图）*.*给它一个名字并按*Enter*：
- en: '![](img/0066bdbf-42cc-43f3-b926-6aad1191e2e4.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0066bdbf-42cc-43f3-b926-6aad1191e2e4.png)'
- en: 'Figure 9: The generated shellcode'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：生成的shellcode
- en: Once you have provided the base name for the output files, you will have a choice
    to select an option to create the payload executable. For this demo, we will use
    the default of `PyInstaller`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了输出文件的基本名称后，您可以选择一个选项来创建有效负载可执行文件。在这个演示中，我们将使用默认的`PyInstaller`。
- en: Once the process completes, you will have the locations of the malicious executable
    and source code displayed*:*
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦过程完成，您将看到恶意可执行文件和源代码的位置显示*:*：
- en: '![](img/19878fa6-b381-4360-8811-7dbdfb9f92ff.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19878fa6-b381-4360-8811-7dbdfb9f92ff.png)'
- en: 'Figure 10: The malicious executable created'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：创建的恶意可执行文件
- en: By running this executable on the target machine, it will create a backdoor
    reverse shell to the machine that you are using as the attacker. Of course, we
    still need to determine whether this executable will be detected by any antiviruses.
    We will perform the testing in the *Testing evasion techniques* section of this
    chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在目标机器上运行这个可执行文件，它将创建一个反向shell到您作为攻击者使用的机器。当然，我们仍然需要确定这个可执行文件是否会被任何防病毒软件检测到。我们将在本章的*测试规避技术*部分进行测试。
- en: TheFatRat
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TheFatRat
- en: 'TheFatRat is another tool that can be used to generate undetectable payloads.
    It supports payloads for Windows, Android, and macOS. It has a wealth of options,
    such as the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TheFatRat是另一个可以用来生成不可检测有效负载的工具。它支持Windows、Android和macOS的有效负载。它有丰富的选项，比如以下：
- en: Automating Metasploit functions (creating backdoors, antivirus evasion, starting
    meterpreter listens, and more)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化Metasploit功能（创建后门、防病毒规避、启动meterpreter监听等）
- en: Creating backdoors based on Android APKs
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Android APK创建后门
- en: File pumper (used to increase file size)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件泵（用于增加文件大小）
- en: Creating backdoors using office files
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用办公文件创建后门
- en: 'TheFatRat is not included by default with Kali Linux. It can be installed using
    the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: TheFatRat不是Kali Linux的默认组件。可以通过以下步骤安装：
- en: 'Open a Terminal window within Kali Linux and clone the repository for `TheFatRat`
    using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kali Linux中打开一个终端窗口，并使用以下命令克隆`TheFatRat`的存储库：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the repository is cloned, navigate to the directory using the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆存储库后，使用以下命令导航到目录：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change the file permissions and run the setup script using the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改文件权限并使用以下命令运行设置脚本：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this command, we are changing the permissions of the `setup.sh` file so that
    we can run it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们正在改变`setup.sh`文件的权限，以便我们可以运行它。
- en: During the setup process, all dependencies will be installed.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装过程中，将安装所有依赖项。
- en: Once the installation is completed, you can run TheFatRat using the `fatrat`
    command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用`fatrat`命令运行TheFatRat。
- en: During startup, TheFatRat provides a warning about not uploading your generated
    payloads to VirusTotal. We will discuss this later in this chapter, under the *Testing
    evasion techniques* section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，TheFatRat会提醒不要将生成的有效负载上传到VirusTotal。我们将在本章的*测试规避技术*部分讨论这个问题。
- en: 'Let''s create a payload using `TheFatRat`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`TheFatRat`创建一个有效负载：
- en: From a Terminal window, launch `TheFatRat` by using the `fatrat` command.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端窗口，使用`fatrat`命令启动`TheFatRat`。
- en: 'Once the menu has loaded, you will notice there are a few options that can
    be used:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单加载后，您会注意到有一些可以使用的选项：
- en: '![](img/afe68a7d-c555-4d9f-ad72-5cce6fa78fea.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afe68a7d-c555-4d9f-ad72-5cce6fa78fea.png)'
- en: 'Figure 11: TheFatRat main menu'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：TheFatRat主菜单
- en: Select option `2` to create a `Fud` with `Fudwin`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择选项`2`以使用`Fudwin`创建`Fud`。
- en: '`Fud` is an abbreviation of **Fully Undetectable Payload**.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fud`是**Fully Undetectable Payload**的缩写。'
- en: 'Once the `Fudwin` module has loaded, we have two options. We will select option
    `2` – `Slow but Powerfull`. This tool compiles a C program with a meterpreter
    reverse TCP payload:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`Fudwin`模块加载，我们有两个选项。我们将选择选项`2` - `慢但强大`。这个工具编译了一个带有meterpreter反向TCP有效负载的C程序：
- en: '![](img/136c4a48-c207-442e-a382-50b22740a19c.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/136c4a48-c207-442e-a382-50b22740a19c.png)'
- en: 'Figure 12: Tool selection using the Fudwin module'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：使用Fudwin模块进行工具选择
- en: Once you have selected option `2`, you will need to define the `LHOST` and `LPORT`
    options. Next, you will need to select the architecture of the target operating
    system. This can be `x86` or `x64`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择选项`2`后，您需要定义`LHOST`和`LPORT`选项。接下来，您需要选择目标操作系统的架构。可以是`x86`或`x64`。
- en: Once the options are defined, the tool will take care of the rest. It will compile
    the malicious payload into an executable, which will be stored within the `TheFatRat`
    root folder within the `output` directory.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选项被定义，工具将处理剩下的事情。它将把恶意有效负载编译成一个可执行文件，并存储在`TheFatRat`根文件夹中的`output`目录中。
- en: Once the file is run on the remote system, it will create a reverse `tcp` backdoor
    to the attacking machine. In the *Testing evasion techniques* section, we will
    compare this payload's detection rate to the others we have created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在远程系统上运行该文件，它将创建一个反向`tcp`后门到攻击机器。在*测试规避技术*部分，我们将比较这个有效负载的检测率和我们创建的其他有效负载。
- en: Custom compiling
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义编译
- en: Custom compiling can help reduce detection capabilities drastically. You can
    leverage custom shellcodes that are available on the internet and tweak them,
    if needed, to perform the function you are after.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义编译可以帮助大大减少检测能力。您可以利用互联网上可用的自定义shellcode，并根据需要进行调整，以执行您想要的功能。
- en: In this section, we will cover the creation of a custom shellcode at a basic
    level. The creation of shellcode can become complex and, as you progress in your
    penetration testing career, you will build up your skills to write complex shellcodes.
    We will be covering shellcode creation in the C programming language.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以基本水平介绍自定义shellcode的创建。Shellcode的创建可能变得复杂，随着您在渗透测试职业中的进步，您将建立起编写复杂shellcode的技能。我们将使用C编程语言来介绍shellcode的创建。
- en: Websites such as Exploit-DB host a number of shellcodes that are posted by the
    community. This can be accessed via the following URL: [https://www.exploit-db.com/shellcodes](https://www.exploit-db.com/shellcodes).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Exploit-DB之类的网站托管了社区发布的许多shellcode。可以通过以下URL访问：[https://www.exploit-db.com/shellcodes](https://www.exploit-db.com/shellcodes)。
- en: Let's create a custom shellcode using C.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用C创建一个自定义shellcode。
- en: 'To begin, we will create a shellcode file using MSFvenom. Let''s use the same
    shellcode we created earlier, but, this time, we will output it to a `.C` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用MSFvenom创建一个shellcode文件。让我们使用之前创建的相同shellcode，但是这次我们将其输出到一个`.C`文件中：
- en: From a Terminal window, create a new directory using the `mkdir msfv-shellcode`
    command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端窗口，使用`mkdir msfv-shellcode`命令创建一个新目录。
- en: Navigate to the directory using the `cd msfv-shellcode` command.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd msfv-shellcode`命令导航到目录。
- en: 'Now, create the payload using the following commands, which are chained:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令创建有效载荷：
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have executed the preceding commands, MSFvenom will create the shellcode
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了上述命令后，MSFvenom将创建shellcode文件。
- en: Now, we need to add in a few variables so that we can compile this using the
    C programming language. Edit the `MSFV-shellcode.c` file that was just created
    using a text editor or nano.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一些变量，以便使用C编程语言进行编译。使用文本编辑器或nano编辑刚刚创建的`MSFV-shellcode.c`文件。
- en: 'Add in the following lines, which are marked in bold:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下行，用**标记：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, I cut out the shellcode so that the required lines of
    code are visible. In your shellcode file, you will have a lot more characters
    underneath the `unsigned char buf [] =` line.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我剪切了shellcode，以便可见所需的代码行。在您的shellcode文件中，`unsigned char buf [] =`行下面将有更多字符。
- en: 'In the preceding code, we added the following components:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了以下组件：
- en: '| `#include<stdio.h>` | Here, we are calling a library that refers to input
    and output functions. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `#include<stdio.h>` | 在这里，我们调用一个库，该库涉及输入和输出函数。 |'
- en: '| `#include<string.h>` | Here, we are calling a library to manipulate strings,
    since we are using the `strlen` function for string length.  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `#include<string.h>` | 在这里，我们调用一个库来操作字符串，因为我们使用`strlen`函数来获取字符串长度。 |'
- en: '| `int main` | This string is used to declare a function. Within the C programming
    language, the function under `main` is what is run when the program loads. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `int main` | 此字符串用于声明一个函数。在C编程语言中，`main`下的函数是程序加载时运行的函数。 |'
- en: '| `printf("Shellcode Length: %d\n` | This line is used to send a printed output
    and mask the shellcode length. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `printf("Shellcode Length: %d\n` | 此行用于发送打印输出并掩盖shellcode长度。 |'
- en: '| `int (*ret)() = (int(*)())buf;`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '| `int (*ret)() = (int(*)())buf;`'
- en: '`ret ()` | `int (*ret)()` is used to declare a pointer, while `=(int(*)())buf;`
    is the pointer that will be used. `ret()` is calling that pointer, which then
    points to the shellcode that is run. |'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret ()` | `int (*ret)()`用于声明一个指针，而`=(int(*)())buf;`是将要使用的指针。`ret()`调用该指针，然后指向运行的shellcode。
    |'
- en: 'Once you have added in the additional code, we can now compile this into an
    executable file (see the following screenshot). This is done using the `mingw32`
    compiler, which would have been installed when you installed the Veil Framework.
    If this is not installed, you can install it using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了额外的代码后，我们现在可以将其编译为可执行文件（请参见以下屏幕截图）。这是使用`mingw32`编译器完成的，该编译器在安装Veil Framework时已安装。如果未安装，可以使用以下命令进行安装：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To compile the shellcode into an executable, use the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要将shellcode编译为可执行文件，请使用以下命令：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We get the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/75202425-ab4d-48e8-9d87-660c5000de56.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75202425-ab4d-48e8-9d87-660c5000de56.png)'
- en: 'Figure 13: Compiling the shellcode into an executable'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：将shellcode编译为可执行文件
- en: Now, you have an executable that will create a reverse shell. Using the process
    of custom compiling, you can dramatically reduce the detection rate of antiviruses.
    You can further obscure the detection rate by adding in additional random characters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个可执行文件，可以创建反向shell。通过自定义编译过程，可以大大降低防病毒软件的检测率。通过添加额外的随机字符，可以进一步模糊检测率。
- en: Testing evasion techniques
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试逃避技术
- en: Testing your payload can be done in two ways. One way is to test it in a lab
    environment with a replica of the target's system; however, this is not always
    possible as there might be licensing requirements for the antivirus program that
    your client is using.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的有效载荷有两种方法。一种方法是在实验室环境中使用目标系统的副本进行测试；然而，这并不总是可能的，因为您的客户使用的防病毒程序可能有许可要求。
- en: The other option you have is to submit the sample of the payload to online services
    such as VirusTotal.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您的另一个选择是将有效载荷的样本提交到VirusTotal等在线服务。
- en: VirusTotal
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VirusTotal
- en: VirusTotal is used by many in the security industry to submit files or URLs
    for malware analysis. VirusTotal works by cross-checking the submission with over
    70 antivirus vendors. There is one catch with VirusTotal, and that is that the
    submission is shared with antivirus vendors to help improve their detection capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal被许多安全行业人员用来提交文件或URL进行恶意软件分析。VirusTotal通过与70多个防病毒供应商交叉检查提交的文件来工作。VirusTotal有一个限制，就是提交将与防病毒供应商共享，以帮助提高其检测能力。
- en: When you build your own payload, you won't want this to be shared with the antivirus
    manufacturers. If it is shared, the chances of your payload working reduces dramatically,
    as the detection rate will increase once the antivirus manufacturers use the submission
    signals to update their detection capabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建自己的载荷时，您不希望与防病毒软件制造商共享。如果共享了，您的载荷的工作机会将大大减少，因为一旦防病毒软件制造商使用提交信号更新其检测能力，检测率将会增加。
- en: 'VirusTotal can be accessed via the following URL: [https://www.virustotal.com/](https://www.virustotal.com/).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal可以通过以下URL访问：[https://www.virustotal.com/](https://www.virustotal.com/)。
- en: Let's take a look at the payloads we created in the previous section, as well
    as their detection rates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在上一节中创建的载荷，以及它们的检测率。
- en: '**MSFvenom** had a detection rate of 50 out of 71, even though we used two
    encoders with multiple iterations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSFvenom**的检测率为71中的50，尽管我们使用了两个编码器和多次迭代：'
- en: '![](img/37d73c2e-6147-47ad-ad77-9edb03c4ddbc.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37d73c2e-6147-47ad-ad77-9edb03c4ddbc.png)'
- en: 'Figure 14: The detection rate of the MSFvenom-generated shellcode'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：MSFvenom生成的shellcode检测率
- en: 'Testing the custom shellcode that we have created using the same MSFvenom payload
    produced a significantly lower detection rate of 8 out of 70:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用相同MSFvenom载荷创建的自定义shellcode产生了明显较低的检测率，为70中的8：
- en: '![](img/6297be12-3fb6-4bac-b1d4-ad7b1c398010.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6297be12-3fb6-4bac-b1d4-ad7b1c398010.png)'
- en: 'Figure 15: Custom shell code detection rate.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：自定义shell代码检测率。
- en: '**Veil **had a detection rate of 35 out of 70*.* This is much lower than the
    one that was generated using MSFvenom:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Veil**的检测率为70中的35。这比使用MSFvenom生成的要低得多：'
- en: '![](img/eb16fe0b-1e86-4d8d-92a9-ee7bd40fff7f.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb16fe0b-1e86-4d8d-92a9-ee7bd40fff7f.png)'
- en: 'Figure 16: The detection rate of the Veil-generated shellcode'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：Veil生成的shell代码检测率
- en: 'TheFatRat had a detection rate of 6 out of 70*.* This is far lower than both
    MSFvenom and Veil. Notice that the filename is `Powerfull-fud.exe`; TheFatRat
    would have generated a normal `Powerfull.exe` file, which can also be used. That
    one received a detection rate of 8 out of 70:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TheFatRat的检测率为70中的6。这远低于MSFvenom和Veil。请注意文件名为`Powerfull-fud.exe`；TheFatRat可能已生成一个普通的`Powerfull.exe`文件，也可以使用。那个的检测率为70中的8：
- en: '![](img/70a5cb1e-eae7-4f00-9d99-ec37fbc038a9.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70a5cb1e-eae7-4f00-9d99-ec37fbc038a9.png)'
- en: 'Figure 17: The detection rate of the TheFatRat-generated shellcode'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：TheFatRat生成的shellcode检测率
- en: We can see here that different techniques produce different results. As antiviruses
    evolve, producing a fully undetectable payload gets more difficult. However, knowing
    how to use the tools that are available will help you build a payload that is
    tailored to your target and is undetectable by their antivirus software.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到不同的技术产生不同的结果。随着防病毒软件的发展，制作一个完全不可检测的载荷变得更加困难。然而，知道如何使用现有的工具将帮助您构建一个适合您的目标并且无法被其防病毒软件检测到的载荷。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about the evolution of antiviruses, and how
    they are now starting to make use of machine learning and artificial intelligence.
    You have learned about the various techniques that can be used for evading antiviruses,
    and the different tools that can be used to create undetectable payloads. We have
    created some payloads using shellcode and looked at their detection rate using
    online services such as VirusTotal.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了防病毒软件的发展，以及它们如何开始利用机器学习和人工智能。您已经了解了可以用于规避防病毒软件的各种技术，以及可以用于创建不可检测载荷的不同工具。我们已经使用shellcode创建了一些载荷，并查看了它们在VirusTotal等在线服务中的检测率。
- en: In the next chapter ([Chapter 12](e4dd2f7e-f929-4877-aef7-e97f1c359784.xhtml),
    *Maintaining Control within the Environment*), we will discuss persistence and
    how to maintain access in the compromised network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第12章](e4dd2f7e-f929-4877-aef7-e97f1c359784.xhtml)，*在环境中保持控制*）中，我们将讨论持久性以及如何在受损网络中保持访问。
- en: Questions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How have antiviruses evolved?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防病毒软件是如何发展的？
- en: Name two antivirus evasion techniques.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举两种防病毒软件规避技术。
- en: What tools can be leveraged to build undetectable payloads?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以利用哪些工具来构建不可检测的载荷？
- en: What are the benefits of using a custom-compiled shellcode?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义编译的shellcode有什么好处？
- en: What should you never do once you have built your payload?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建了您的载荷，您绝对不应该做什么？
