- en: Mobile Security Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动安全最佳实践
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Storing data securely
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全存储数据
- en: Implementing authentication controls
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施身份验证控件
- en: Securing data in transit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护传输中的数据
- en: Securely using Android and iOS platform components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全使用Android和iOS平台组件
- en: Securing third-party code and components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护第三方代码和组件
- en: Employing reverse engineering protections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用反向工程保护
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Mobile applications are often a crux for controlling consumer IoT. Be it smart
    home devices or connected vehicles, mobile applications are a desirable target
    to attack and be kept secure. In [Chapter 5](4f5f4da8-0adb-4596-925c-f90929b55915.xhtml), *Exploiting
    IoT Mobile Applications*, exploitation of mobile applications was covered from
    an offensive perspective. This chapter will provide mobile application security
    defensive controls used to protect from common attack vectors. It is important
    to note that this chapter is by no means exhaustive when it comes to mobile security
    best practices as full books are written on this subject alone. It is encouraged
    to reference supplemental reading for more in-depth understanding of certain controls
    and best practices described in this chapter. Where appropriate, examples for
    Android and iOS will be given throughout recipes. As per OWASP''s Mobile Security
    Project ([https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls](https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls)),
    the top 10 mobile controls consist of:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序通常是控制消费者物联网的关键。无论是智能家居设备还是连接的车辆，移动应用程序都是攻击和保持安全的理想目标。在[第5章](4f5f4da8-0adb-4596-925c-f90929b55915.xhtml)中，*利用物联网移动应用程序*，从攻击者的角度讨论了移动应用程序的利用。本章将提供用于保护常见攻击向量的移动应用程序安全防御控件。需要注意的是，本章在移动安全最佳实践方面并不是详尽无遗的，因为关于这个主题的完整书籍都是专门写的。鼓励参考补充阅读，以更深入地了解本章描述的某些控件和最佳实践。在适当的情况下，将在整个配方中提供Android和iOS的示例。根据OWASP的移动安全项目([https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls](https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls))，前10个移动控件包括：
- en: Identifying and protecting sensitive data.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别和保护敏感数据。
- en: Protecting authentication credentials.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护身份验证凭据。
- en: Protecting data in transit.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护传输中的数据。
- en: Implementing user authentication, authorization, and session management correctly.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确实施用户身份验证，授权和会话管理。
- en: Keeping the backend APIs (services) and the platform (server) secure.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持后端API（服务）和平台（服务器）的安全。
- en: Securing data integration with third-party services and applications.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保与第三方服务和应用程序的数据集成安全。
- en: Paying specific attention to the collection and storage of consent for the collection
    and use of the user's data.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别关注收集和存储用户数据收集和使用的同意。
- en: Implementing controls to prevent unauthorized access to paid-for resources.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施控件以防止未经授权访问付费资源。
- en: Ensuring secure distribution/provisioning of mobile applications.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保移动应用程序的安全分发/配置。
- en: Carefully checking any runtime interpretation of code for errors.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细检查任何代码的运行时解释是否存在错误。
- en: This chapter will address several of the earlier mentioned mobile security controls
    that are relative to common IoT application use cases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论与常见物联网应用程序用例相关的几个早期提到的移动安全控件。
- en: Storing data securely
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全存储数据
- en: Sensitive data in mobile applications varies on the nature of the IoT device.
    Many devices may store personal data, collect personal data, **patient health
    information** (**PHI**), credit card information, and store account credentials
    on a mobile device to authenticate to an IoT device. Leaked credentials or long-lived
    session tokens may have a critical impact for smart door locks and connected vehicles.
    This sensitive data must be secured with controls and verifications in place.
    Many times, sensitive data is unintentionally exposed to third-party applications
    running on a mobile device for operating system **interprocess communication**
    (**IPC**). Additionally, it is not uncommon to lose a mobile device, or have it
    stolen or seized when traveling. In these cases, applications must employ proper
    security controls to protect sensitive data and make obtaining the data more difficult.
    In this recipe, we will discuss methods for storing sensitive data securely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序中的敏感数据取决于物联网设备的性质。许多设备可能在移动设备上存储个人数据，收集个人数据，患者健康信息（PHI），信用卡信息，并存储用于对物联网设备进行身份验证的帐户凭据。泄露的凭据或长期的会话令牌可能对智能门锁和连接的车辆产生重大影响。这些敏感数据必须通过控件和验证来进行保护。许多时候，敏感数据会无意中暴露给在移动设备上运行的第三方应用程序，用于操作系统的进程间通信（IPC）。此外，丢失移动设备，或在旅行时被盗或被扣押也并非罕见。在这些情况下，应用程序必须采用适当的安全控件来保护敏感数据，并使获取数据变得更加困难。在本章中，我们将讨论安全存储敏感数据的方法。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, SQLCipher will be used to demonstrate a method of secure database
    storage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，将使用SQLCipher来演示安全数据库存储的方法。
- en: 'SQLCipher can be downloaded from the following web page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SQLCipher可以从以下网页下载：
- en: '[https://www.zetetic.net/sqlcipher/](https://www.zetetic.net/sqlcipher/)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.zetetic.net/sqlcipher/](https://www.zetetic.net/sqlcipher/)'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Both Android and iOS platforms have native methods to securely store sensitive
    data. For Android, sensitive data can be stored in the KeyStore. For iOS, sensitive
    data can be stored in the Keychain. It is important to note that, if a device
    is rooted or jailbroken, Android's KeyStore and iOS' Keychain contents can be
    dumped. Although, if an Android device has a **Trusted Execution Environment**
    (**TEE**) or a **Secure Element** (**SE**), the KeyStore is not directly accessible
    to the operating system and the data saved will not be accessible. In addition
    to the native platform APIs available to store data securely, third-party libraries
    are available to encrypt data on disk or an entire SQLite database such as SQLCipher.
    SQLCipher is available for Android and iOS and should be used to store data securely
    if SQLite databases are used for an IoT device.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Android和iOS平台都有本地方法来安全存储敏感数据。对于Android，敏感数据可以存储在KeyStore中。对于iOS，敏感数据可以存储在Keychain中。重要的是要注意，如果设备被root或越狱，Android的KeyStore和iOS的Keychain内容可以被转储。但是，如果Android设备具有**可信执行环境**（**TEE**）或**安全元素**（**SE**），则KeyStore对操作系统不可直接访问，保存的数据也将无法访问。除了本地平台API可用于安全存储数据外，还有第三方库可用于加密磁盘上的数据或整个SQLite数据库，如SQLCipher。SQLCipher适用于Android和iOS，如果SQLite数据库用于IoT设备，则应该用于安全存储数据。
- en: 'To use SQLCipher in an Android application, we need to create an activity,
    initialize the SQLCipher database, and save the data in the appropriate database
    table and column, as shown in the following example:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Android应用程序中使用SQLCipher，我们需要创建一个活动，初始化SQLCipher数据库，并将数据保存在适当的数据库表和列中，如下例所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An important step not included in the earlier example is the establishment of
    a PRAGMA key. This PRAGMA key is the encryption key for the SQLCipher database
    and should be generated at runtime during app initialization for each user and
    device. The PRAGMA key should have sufficient entropy and should not be hardcoded
    into the application or stored in storage locations that are not hardware backed
    (for example, secure element).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的示例中没有包括的一个重要步骤是建立PRAGMA密钥。这个PRAGMA密钥是SQLCipher数据库的加密密钥，应该在每个用户和设备的应用程序初始化期间动态生成。PRAGMA密钥应该具有足够的熵，并且不应该硬编码到应用程序中或存储在非硬件支持的存储位置（例如，安全元素）。
- en: A common Android insecure storage location for settings and configurations often
    used by developers is `SharedPreferences.xml`. Data saved in `SharedPreferences.xml`
    is clear text readable unless a third-party wrapper is used to encrypt the values
    of preferences.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android常见的不安全存储位置是`SharedPreferences.xml`，开发人员经常用来存储设置和配置。存储在`SharedPreferences.xml`中的数据是明文可读的，除非使用第三方包装器来加密偏好设置的值。
- en: For iOS, data should not be stored in files within the application container
    or within clear text plist files. The Keychain should be used for all credential
    and token data with the proper Keychain API attributes according to the context
    in which your app runs. For example, if the app does not run in the background,
    use the most restrictive attributes such as `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`,
    which prevents Keychain items from being backed up by iTunes or `kSecAttrAccessibleWhenUnlocked`.
    If the app needs to run in the foreground, use the `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`
    attribute.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS，数据不应存储在应用程序容器内的文件中，也不应存储在明文plist文件中。Keychain应该用于所有凭据和令牌数据，并根据应用程序运行的上下文使用适当的Keychain
    API属性。例如，如果应用程序不在后台运行，则使用最严格的属性，如`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`，这可以防止Keychain项目被iTunes备份，或者使用`kSecAttrAccessibleWhenUnlocked`。如果应用程序需要在前台运行，则使用`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`属性。
- en: 'There are several best practices to follow that apply to both Android and iOS
    when storing data. Common best practices include:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储数据时，有几个适用于Android和iOS的最佳实践需要遵循。常见的最佳实践包括：
- en: 1\. Do not store sensitive data where possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 尽量不要存储敏感数据。
- en: 2\. Only store data that is needed for application function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 只存储应用程序功能所需的数据。
- en: 3\. Avoid storing sensitive data in cache, external memory storage (SD cards),
    or temporary files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 避免将敏感数据存储在缓存、外部存储器（SD卡）或临时文件中。
- en: 4\. Do not log sensitive data to disk or to the console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 不要将敏感数据记录到磁盘或控制台。
- en: 5\. Disable keyboard caching for sensitive input fields.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 禁用对敏感输入字段的键盘缓存。
- en: 6\. Restrict backing up application data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 限制应用程序数据的备份。
- en: 7\. If sensitive data is stored on disk, encrypt its contents and store the
    data in a tamper-proof location such as a secure element.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 如果敏感数据存储在磁盘上，加密其内容并将数据存储在防篡改的位置，如安全元素。
- en: 8\. Ensure the app wipes sensitive data from memory after its use and when no
    longer necessary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 确保应用程序在使用后和不再需要时从内存中擦除敏感数据。
- en: 9\. Ensure that the clipboard is disabled for sensitive text fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 确保对敏感文本字段禁用剪贴板。
- en: At times, platform security APIs such as the KeyStore and Keychain may not be
    enough to ensure data confidentiality and integrity of sensitive data. In these
    cases, it is recommended to augment protections with application-level encryption
    and then store the encrypted data in the platform's secure storage location.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，平台安全API（如KeyStore和Keychain）可能不足以确保敏感数据的保密性和完整性。在这些情况下，建议使用应用级加密来增强保护，然后将加密数据存储在平台的安全存储位置中。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on the Keychain, refer to *Apple's Keychain Services Programming
    Guide* ([https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#/](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html%23/)).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Keychain的更多信息，请参阅*苹果的Keychain服务编程指南*（[https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#/](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html%23/)）。
- en: For more information on the Keychain, refer to *Android's Developer* documentation
    ([https://developer.android.com/training/articles/keystore.html](https://developer.android.com/training/articles/keystore.html)).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Keychain的更多信息，请参阅*Android的开发者*文档（[https://developer.android.com/training/articles/keystore.html](https://developer.android.com/training/articles/keystore.html)）。
- en: For more information on using SQLCipher, refer to *SQLCipher's API Developer*
    documentation ([https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用SQLCipher的更多信息，请参阅*SQLCipher的API开发者*文档（[https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)）。
- en: Implementing authentication controls
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施身份验证控制
- en: Authentication for mobile applications can occur from both server side and client
    side. IoT mobile applications can make use of both design patterns although each
    have their own risk considerations when implementing in production. This section
    will discuss some of these risks as well as best practice design implementations
    for server and client-side authentication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序的身份验证可以同时发生在服务器端和客户端。IoT移动应用程序可以利用这两种设计模式，尽管在生产中实施时每种都有自己的风险考虑。本节将讨论一些这些风险以及服务器端和客户端身份验证的最佳实践设计实施。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'General application principles for securely authenticating users apply to mobile
    applications as well. A great reference is OWASP''s *Authentication Cheat Sheet*
    ([https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet)).
    Common authentication controls and best practices consist of:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安全地验证用户的一般应用程序原则也适用于移动应用程序。一个很好的参考是OWASP的*身份验证备忘单*（[https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet)）。常见的身份验证控件和最佳实践包括：
- en: Proper password strength controls
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的密码强度控制
- en: Password length
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码长度
- en: 10 characters or more
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10个或更多字符
- en: Password complexity policies
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码复杂性策略
- en: 1 uppercase, 1 lowercase, 1 digit, 1 special character, and disallowing 2 consecutive
    characters such as 222
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个大写字母，1个小写字母，1个数字，1个特殊字符，并且不允许连续2个字符，如222
- en: Enforce password history
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制密码历史记录
- en: Disallow the last three used passwords (password reuse)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止使用过的最后三个密码（密码重用）
- en: Transmitting credentials only over encrypted communications (TLS)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅通过加密通信（TLS）传输凭据
- en: Send credentials over an `HTTP POST` body
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`HTTP POST`主体发送凭据
- en: Re-authenticate users for sensitive features
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新验证用户以使用敏感功能
- en: Changing passwords
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改密码
- en: Changing account pins
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改帐户PIN
- en: Changing security questions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改安全问题
- en: Sharing camera feeds
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享摄像头视频
- en: Unlocking vehicles
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁车辆
- en: Ensure authentication error messages do not disclose potential sensitive information
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保身份验证错误消息不会透露潜在的敏感信息
- en: A correct error response is as follows, invalid username and/or password
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的错误响应如下，无效的用户名和/或密码
- en: Ensuring logging of authentication functions to detect login failures
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保记录身份验证功能以检测登录失败
- en: Prevent automated brute-force attacks
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止自动暴力攻击
- en: Use a CAPTCHA or similar
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CAPTCHA或类似功能
- en: Rate limit suspicious login attempts
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制可疑登录尝试的速率
- en: Temporarily lock accounts after a given threshold and email the account address
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定阈值后暂时锁定帐户并发送电子邮件到帐户地址
- en: 'Ensure multifactor authentication exists and is enforced at login as well as
    when using step up authentication to access resources. Two-factor methods include:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保多因素身份验证存在并在登录时执行，以及在使用逐步身份验证访问资源时执行。双因素方法包括：
- en: A user known value in addition to a password
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除密码外，还有用户已知的值
- en: A **one-time password** (**OTP**) or code sent via email or SMS
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电子邮件或短信发送的一次性密码（OTP）或代码
- en: A physical token with an OTP in addition to a user's password
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除用户密码外，还有一个OTP的物理令牌
- en: 'The preceding items apply to both web applications, hybrid mobile applications,
    and even native mobile applications. The following items are mobile-specific authentication
    best practices to implement into an application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前述项目适用于Web应用程序、混合移动应用程序，甚至本机移动应用程序。以下项目是特定于移动设备的身份验证最佳实践，可实施到应用程序中：
- en: If biometrics are used, ensure to use the KeyStore and Keychain rather than
    the event based
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用生物识别技术，请确保使用KeyStore和Keychain而不是基于事件的方法
- en: Sessions are invalidated server-side
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话在服务器端被使无效
- en: Applications list the last login activities and allow users to block devices
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序列出最后的登录活动并允许用户阻止设备
- en: Refrain from using device UUIDs, IP addresses, MAC addresses, and IMEIs for
    authentication or authorization purposes
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用设备UUID、IP地址、MAC地址和IMEI进行身份验证或授权目的
- en: Use a third-party OTP application (for example, Google or Salesforce authenticator)
    outside of the mobile application
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动应用程序之外使用第三方OTP应用程序（例如Google或Salesforce认证器）
- en: 'Android-specific authentication practices are listed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Android特定的身份验证实践如下所示：
- en: When using Android's FingerprintManager class ([https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html)),
    use the `KeyGenerator` class with an asymmetric key pair. An example of using
    an asymmetric key pair is available at [https://github.com/googlesamples/android-AsymmetricFingerprintDialog](https://github.com/googlesamples/android-AsymmetricFingerprintDialog).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android的FingerprintManager类（[https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html)），使用`KeyGenerator`类与非对称密钥对。有关使用非对称密钥对的示例，请参见[https://github.com/googlesamples/android-AsymmetricFingerprintDialog](https://github.com/googlesamples/android-AsymmetricFingerprintDialog)。
- en: Introduced in Android Nougat API 24, use the `setInvalidatedByBiometricEnrollment`
    (`boolean invalidateKey`) method to invalidate new fingerprints from retrieving
    keys on the mobile device.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Nougat API 24中引入，使用`setInvalidatedByBiometricEnrollment`（`boolean invalidateKey`）方法来使新的指纹无法从移动设备上检索密钥。
- en: Apps should utilize the SafetyNet reCAPTCHA API to protect authentication from
    bot-based brute force attempts.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应利用SafetyNet reCAPTCHA API来保护免受基于机器人的暴力攻击的身份验证。
- en: 'To use the SafteyNet reCAPTCHA API, the following steps must be taken:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SafteyNet reCAPTCHA API，必须执行以下步骤：
- en: 'Register a reCAPCTHA key pair via [https://www.google.com/recaptcha/admin#androidsignup](https://www.google.com/recaptcha/admin%23androidsignup):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[https://www.google.com/recaptcha/admin#androidsignup](https://www.google.com/recaptcha/admin%23androidsignup)注册reCAPCTHA密钥对：
- en: '![](img/018e9535-f65e-46ef-946c-7ecc3e5aa292.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/018e9535-f65e-46ef-946c-7ecc3e5aa292.png)'
- en: 'Add the SafetyNet API dependency and Google Play Services if not already configured.
    For example, include the compile `com.google.android.gms:play-services-safetynet:11.4.2`
    in the project build gradle file, as shown here:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未配置，必须添加SafetyNet API依赖项和Google Play服务。例如，在项目构建gradle文件中包括`com.google.android.gms:play-services-safetynet:11.4.2`，如下所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A request to invoke a verify request has to be made via the `verifyWithRecaptcha()`
    ([https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String)](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String))).
    This request must contain the API site key as a parameter and must override the
    `onSuccess()` and `onFailure()` methods. The following snippet of code shows how
    to invoke this method provided Android''s Developer guide ([https://developer.android.com/training/safetynet/recaptcha.html#send-request](https://developer.android.com/training/safetynet/recaptcha.html%23send-request)):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须通过`verifyWithRecaptcha()`（[https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String)](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String))）发出调用验证请求的请求。此请求必须包含API站点密钥作为参数，并且必须覆盖`onSuccess()`和`onFailure()`方法。以下代码片段显示了如何调用此方法，提供了Android的开发人员指南（[https://developer.android.com/training/safetynet/recaptcha.html#send-request](https://developer.android.com/training/safetynet/recaptcha.html%23send-request)）：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Validate the response token via `SafetyNetApi.RecaptchaTokenResult.getTokenResult()`.
    An example `JSON HTTP` response looks like the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`SafetyNetApi.RecaptchaTokenResult.getTokenResult()`验证响应令牌。JSON HTTP响应的示例如下：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, logic must be added to handle failures and errors. There are seven status
    codes the SafetyNet reCAPTCHA API uses:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，必须添加逻辑来处理失败和错误。SafetyNet reCAPTCHA API使用七个状态代码：
- en: 1\. `RECAPTCHA_INVALID_SITEKEY`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. `RECAPTCHA_INVALID_SITEKEY`
- en: 2\. `RECAPTCHA_INVALID_KEYTYPE`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. `RECAPTCHA_INVALID_KEYTYPE`
- en: 3\. `RECAPTCHA_INVALID_PACKAGE_NAME`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. `RECAPTCHA_INVALID_PACKAGE_NAME`
- en: 4\. `UNSUPPORTED_SDK_VERSION`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. `UNSUPPORTED_SDK_VERSION`
- en: 5\. `TIMEOUT`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. `TIMEOUT`
- en: 6\. `NETWORK_ERROR`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. `NETWORK_ERROR`
- en: 7\. `ERROR`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. `ERROR`
- en: 'Details about each of the status codes are available at the following reference
    page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每个状态代码的详细信息，请参阅以下参考页面：
- en: '[https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes.](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes.](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes)'
- en: 'iOS-specific authentication practices are listed next:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来列出了特定于iOS的身份验证实践：
- en: Store an application's secret in an access-controlled Keychain lists to the
    specific application. An example code snippet for using the Keychain and Touch
    ID can be found using Apple's Developer documentation at [https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html](https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序的秘密存储在受访问控制的钥匙串列表中以供特定应用程序使用。可以在苹果的开发人员文档中找到使用钥匙串和Touch ID的示例代码片段，网址为[https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html](https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html)。
- en: Ensure applications read from `LAContext.evaluatedPolicyDomainState` to check
    if the `evaluatedPolicyDomainState` value has altered indicating the enrolled
    Touch ID fingerprint has changed.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序从`LAContext.evaluatedPolicyDomainState`中读取，以检查`evaluatedPolicyDomainState`值是否已更改，指示已注册的Touch
    ID指纹是否已更改。
- en: Disallow Keychain synchronizing to iCloud via `kSecAttrSynchronizable` unless
    required for app functioning.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非应用程序需要，否则禁止钥匙串通过`kSecAttrSynchronizable`与iCloud同步。
- en: Touch ID is a common method for authenticating users; however, there are several
    approaches and tools to bypass apps that only use the Local Authentication framework.
    Using Keychain ACLs as mentioned previously prevents attackers from overriding
    the `LAContextevaluatePolicy:localizedReason:reply` method during runtime or patching
    the application itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Touch ID是一种常见的用户身份验证方法；但是，有几种方法和工具可以绕过仅使用本地身份验证框架的应用程序。如前所述，使用钥匙串ACL可以防止攻击者在运行时覆盖`LAContextevaluatePolicy:localizedReason:reply`方法或对应用程序本身进行打补丁。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on iOS Keychain services refer to *Keychain Services Programming
    Guide* ([https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html))
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关iOS钥匙串服务的更多信息，请参阅*钥匙串服务编程指南*（[https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html)）
- en: For more information regarding authenticating to remote servers using the Fingerprint
    API, visit Android's developer blog ([https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html](https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html))
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用指纹API对远程服务器进行身份验证的更多信息，请访问Android的开发者博客（[https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html](https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html)）
- en: See the following Android developer page on the SafetyNet reCAPTCHA API ([https://developer.android.com/training/safetynet/recaptcha.html](https://developer.android.com/training/safetynet/recaptcha.html))
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看安卓开发者页面上关于SafetyNet reCAPTCHA API的信息（[https://developer.android.com/training/safetynet/recaptcha.html](https://developer.android.com/training/safetynet/recaptcha.html)）
- en: Securing data in transit
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护数据在传输中
- en: Securing end-to-end communication for IoT mobile applications has been known
    to be a difficult problem to solve. Often, data is leaked via clear text protocols
    such as HTTP or UDP (SIP) for audio transmission to a mobile application. On occasion,
    IoT manufacturers have been found to leak data to third parties that only communicate
    over HTTP or use less secure encryption configurations for analytic services such
    as content recognition or crash reporting analytic services. The goal of securing
    data in transit is to ensure the confidentiality and integrity of data exchanged
    between the mobile app, IoT device, and API endpoints. A mobile app must set up
    a secure encrypted channel for network communication using TLS and configuring
    the proper cipher suites. For devices such as smart locks or connected vehicles,
    this is a must. This recipe will cover best practices to follow to secure data
    in transit for IoT mobile applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 保护物联网移动应用的端到端通信一直是一个难题。通常，数据会通过明文协议泄露，比如HTTP或UDP（SIP）用于音频传输到移动应用。偶尔，物联网制造商被发现向第三方泄露数据，这些第三方只通过HTTP通信或者使用较不安全的加密配置进行内容识别或崩溃报告分析服务。保护数据在传输中的目标是确保移动应用、物联网设备和API端点之间交换的数据的机密性和完整性。移动应用必须使用TLS建立安全加密通道进行网络通信，并配置适当的密码套件。对于智能锁或连接车辆等设备，这是必须的。本文将介绍保护物联网移动应用中传输数据的最佳实践。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Securing data in transit for mobile applications has common requirements and
    best practices to follow. Best practices to secure data in transit include but
    are not limited to the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保护移动应用中传输数据有共同的要求和最佳实践。保护传输数据的最佳实践包括但不限于以下内容：
- en: Use the most updated TLS and cipher suite configurations the platform supports
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台支持的最新TLS和密码套件配置
- en: Verify the server X.509 certificate
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证服务器X.509证书
- en: Validate the certificate hostname
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证证书主机名
- en: Only accept certificates signed by a trusted certificate authority, which includes
    public CAs as well as internal trusted CAs
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只接受由受信任的证书颁发机构签名的证书，其中包括公共CA以及内部受信任的CA
- en: Disallow self-signed certificates
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止使用自签名证书
- en: Pin connections to only trusted certificates and/or public keys
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接固定到受信任的证书和/或公钥
- en: The implementation varies between Android and iOS. Native cryptographic APIs
    are available for both platforms; however, third-party wrapper libraries are also
    available but may not have abilities such as certificate pinning.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实现在安卓和iOS之间有所不同。两个平台都有本地的加密API；但是，也有第三方封装库可用，但可能没有证书固定等功能。
- en: Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓
- en: 'In the preceding example, an Android app creates a KeyStore with CAs (trusted
    certificates) that initializes the TrustManager whose job is to validate only
    the certificates that are within the KeyStore:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，一个安卓应用程序创建了一个包含CA（受信任证书）的KeyStore，初始化了TrustManager，其工作是仅验证KeyStore中的证书：
- en: 'Create the `KeyPinStore` class that is thread-safe (public static synchronized):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建线程安全的`KeyPinStore`类（public static synchronized）：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Load the CAs that are inside the application''s assets directory:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载应用程序资产目录中的CA：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a KeyStore with our specified trusted CAs:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含我们指定的受信任CA的KeyStore：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the TrustManager to validate the CAs in our KeyStore:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建TrustManager以验证我们KeyStore中的CA：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the SSLContent that uses our TrustManager:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建使用我们的TrustManager的SSLContent：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Tell the URLConnection to use a SocketFactory from our SSLContext when communicating
    to the application''s API endpoint:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉URLConnection在与应用程序的API端点通信时使用来自我们的SSLContext的SocketFactory：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A tool that can help with ensuring proper TLS/SSL configurations are in place
    is one released by Google called nogotofail. Not only does nogotofail check configurations,
    but it also ensures vulnerable TLS/SSL protocols are not in use as well as an
    insight as to what data is being sent from a client device via MITM techniques.
    To learn more about nogotofail, visit the project's GitHub page [https://github.com/google/nogotofail](https://github.com/google/nogotofail).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以帮助确保正确的TLS/SSL配置的工具是Google发布的nogotofail。nogotofail不仅检查配置，还确保不使用易受攻击的TLS/SSL协议，以及通过MITM技术查看从客户端设备发送的数据。要了解有关nogotofail的更多信息，请访问项目的GitHub页面[https://github.com/google/nogotofail](https://github.com/google/nogotofail)。
- en: iOS
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS
- en: 'Similar actions can be used to pin to certificates and/or public key fingerprints
    of certificates in iOS. Pinning is performed through the `NSURLConnectionDelegate`,
    where `connection:canAuthenticateAgainstProtectionSpace:` and `connection:didReceiveAuthenticationChallenge:.`
    must be implemented within `connection:didReceiveAuthenticationChallenge:`, and
    call `SecTrustEvaluate` to perform X509 validation checks. A sample iOS pinning
    application provided by OWASP can be used as a reference when deploying such checks
    in applications. The sample program can be downloaded via the following link:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的操作可以用于在iOS中将证书和/或证书的公钥指纹固定。固定是通过`NSURLConnectionDelegate`执行的，其中必须在`connection:didReceiveAuthenticationChallenge:`中实现`connection:canAuthenticateAgainstProtectionSpace:`和`connection:didReceiveAuthenticationChallenge:`，并调用`SecTrustEvaluate`执行X509验证检查。在部署此类检查时，可以使用OWASP提供的iOS固定应用程序示例作为参考。可以通过以下链接下载示例程序：
- en: '[https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip](https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip](https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip)'
- en: 'Aside from the general best practices that all applications should follow when
    employing TLS, iOS has a new feature that developers can take advantage of and
    will be required when submitting to Apple''s App Store in the future ([https://developer.apple.com/news/?id=12212016b](https://developer.apple.com/news/?id=12212016b)).
    This feature is known as **App Transport Security** (**ATS**), introduced in iOS
    9 and is enabled by default. ATS requires apps to communicate over HTTPS using
    TLSv1.2 with **Perfect Forward Secrecy** (**PFS**) as well as specific cipher
    suites. If an app does not meet the minimum requirements, connections will not
    be allowed to the iOS app. This is great for all IoT devices; however, there are
    ways to get around ATS. Specifically, developers can completely disable ATS by
    using the `NSAllowsArbitraryLoads` configuration in the `Info.plist` file, as
    illustrated in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有应用程序在使用TLS时应遵循的一般最佳实践外，iOS还有一个新功能，开发人员可以利用，并且在将来提交到苹果的App Store时将被要求（[https://developer.apple.com/news/?id=12212016b](https://developer.apple.com/news/?id=12212016b)）。这个功能被称为**应用传输安全**（**ATS**），在iOS
    9中引入，并默认启用。ATS要求应用程序使用TLSv1.2进行HTTPS通信，使用**完美前向保密**（**PFS**）以及特定的密码套件。如果应用程序不符合最低要求，将不允许连接到iOS应用程序。这对所有物联网设备都是很好的；然而，有方法可以绕过ATS。具体来说，开发人员可以通过在`Info.plist`文件中使用`NSAllowsArbitraryLoads`配置来完全禁用ATS，如下面的屏幕截图所示：
- en: '![](img/923236c5-0e58-41f1-89e5-0814cdd7ef0c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/923236c5-0e58-41f1-89e5-0814cdd7ef0c.png)'
- en: 'Unfortunately, this is very common in IoT applications due to the lack of knowledge
    in cryptography and/or PKI. ATS also gives the ability to provide exceptions per
    domain or globally rather than disabling ATS altogether. The following is a non-exhaustive
    list of exceptions that can be applied to the following configurations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于缺乏加密和/或PKI知识，这在物联网应用程序中非常普遍。ATS还可以提供针对每个域或全局的异常，而不是完全禁用ATS。以下是可以应用于以下配置的非详尽列表的异常：
- en: Disable PFS (`NSExceptionRequiresForwardSecrecy`)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用PFS（`NSExceptionRequiresForwardSecrecy`）
- en: Disable ATS for media (`NSAllowsArbitraryLoadsForMedia`)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为媒体禁用ATS（`NSAllowsArbitraryLoadsForMedia`）
- en: Allow insecure connections over HTTP (`NSExceptionAllowsInsecureHTTPLoads`)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许通过HTTP进行不安全连接（`NSExceptionAllowsInsecureHTTPLoads`）
- en: Lower the minimum TLS version (`NSExceptionMinimumTLSVersion`)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低最低TLS版本（`NSExceptionMinimumTLSVersion`）
- en: Allow connections to local domains (`NSAllowsLocalNetworking`)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许连接到本地域名（`NSAllowsLocalNetworking`）
- en: 'Apple has provided a tool that checks for App Transport Security issues called
    nscurl. Nscurl can be used by executing the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了一个检查应用传输安全问题的工具，名为nscurl。可以通过执行以下命令来使用nscurl：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Apple is making promising changes to influence developers to ensure data is
    being secured in transit. As noted, all apps submitted to the App Store will be
    required to support ATS at a time to be announced by Apple.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果正在做出有希望的改变，以影响开发人员确保数据在传输中得到安全保护。如前所述，所有提交到App Store的应用程序将被要求在未来支持ATS，具体时间由苹果宣布。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'A sample Android public key pinning application provided by OWASP can be downloaded
    via the following URL:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP提供的一个示例Android公钥固定应用程序可以通过以下URL下载：
- en: '[https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip](https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip](https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip)'
- en: 'Refer to the following Apple developer guide to learn more about ATS requirements:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅以下苹果开发人员指南，了解有关ATS要求的更多信息：
- en: '[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW57](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html%23/apple_ref/doc/uid/TP40009251-SW57)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW57](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html%23/apple_ref/doc/uid/TP40009251-SW57)'
- en: Securely using Android and iOS platform components
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地使用Android和iOS平台组件
- en: When IoT mobile applications execute or retrieve commands from third-party apps,
    internal platform APIs are used for **interprocess communication** (**IPC**).
    IPC can be used to integrate applications to make calls to expense tracking apps,
    third-party service apps such as IFTTT, or personal assistants such as Amazon's
    Alexa. Platforms such as Android offer a rich IPC capability while iOS only offers
    a couple of options. The majority of IoT applications use platform and hardware
    features to interact with the physical world, which in turn poses a higher impact
    in the event that adversaries successfully exploit a bug. In this recipe, we will
    discuss how to employ security controls around IPC and how to use platform APIs
    in a secure manner.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当物联网移动应用程序执行或检索来自第三方应用程序的命令时，内部平台API用于**进程间通信**（**IPC**）。IPC可用于集成应用程序，使其调用费用跟踪应用程序、IFTTT等第三方服务应用程序，或亚马逊的Alexa等个人助手。Android等平台提供了丰富的IPC功能，而iOS只提供了几个选项。大多数物联网应用程序使用平台和硬件功能与物理世界进行交互，这反过来会在对手成功利用漏洞时产生更大的影响。在本教程中，我们将讨论如何在IPC周围应用安全控制以及如何安全地使用平台API。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Interacting with commands originating from applications over to a mobile platform
    is a powerful capability. If not secured properly, unauthorized apps can hijack
    commands and access data that was not intended to be received by unintended parties.
    When using platform APIs, the following practices should be considered:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与源自应用程序的命令在移动平台上进行交互是一种强大的能力。如果没有得到适当的保护，未经授权的应用程序可能会劫持命令并访问本不应被未经意的第三方接收的数据。在使用平台API时，应考虑以下做法：
- en: Do not export sensitive functionality through IPC unless these mechanisms are
    properly protected.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非这些机制得到适当保护，否则不要通过IPC导出敏感功能。
- en: Inputs from external sources and users should be validated and sanitized, if
    necessary. This includes data received via the user interface, IPC mechanisms
    such as intents, custom URL handlers, and network sources.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自外部来源和用户的输入应该在必要时进行验证和清理。这包括通过用户界面、IPC机制（如意图、自定义URL处理程序）和网络来源接收的数据。
- en: WebViews should be configured to allow only the minimum set of protocol handlers
    required such as HTTPS and to disable other dangerous handlers, such as `file://`,
    `tel://`, `sms://`, and `app-id://`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebViews应该配置为仅允许加载所需的最小协议处理程序，如HTTPS，并禁用其他危险的处理程序，如`file://`、`tel://`、`sms://`和`app-id://`。
- en: Restrict IPC calls to a whitelist of trusted applications.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将IPC调用限制为受信任应用程序的白名单。
- en: Whitelist web pages and URL handlers to be loaded locally or remotely.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Web页面和URL处理程序列入白名单，以便本地或远程加载。
- en: Request only the minimum set of permissions necessary for app functionality.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅请求应用程序功能所需的最小权限集。
- en: Native methods exposed via WebViews should be verified that only JavaScript
    within the application sandbox is rendered.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebViews公开的本地方法应该验证，只有应用程序沙盒内的JavaScript才能被渲染。
- en: WebViews should disable JavaScript unless explicitly required.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非明确需要，否则WebViews应该禁用JavaScript。
- en: Serialization should only use safe serialization APIs and be cryptographically
    signed.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化应该只使用安全的序列化API，并进行加密签名。
- en: Most of the listed practices can be applied to Android and iOS platforms; however,
    specific considerations such as Android permissions, custom permissions, and protection
    levels should be reviewed according to an application's functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数列出的做法都可以应用于Android和iOS平台；但是，根据应用程序的功能，应该审查特定的考虑因素，如Android权限、自定义权限和保护级别。
- en: The following is an example of a custom permission called `IOT_COOKBOOK_ACTIVITY`
    that is required when launching the `MAIN_ACTIVITY``Activity`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`IOT_COOKBOOK_ACTIVITY`的自定义权限的示例，当启动`MAIN_ACTIVITY`“Activity”时需要该权限。
- en: 'The first code block defines the new permission with a label tag and description
    about the `Activity`. Next, the protection level is set based on the type of permission
    it is granting. Once the permission is defined, it can be enforced on the component
    by specifying the uses-permission in the application''s `AndroidManifest.xml`
    file. In the following example, the second block is the component that we will
    restrict with the permission we have defined. It can be enforced by adding the
    `android:permission` attributes:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个代码块使用标签定义了新的权限，并描述了“Activity”。接下来，根据权限类型设置了保护级别。一旦权限被定义，就可以通过在应用程序的`AndroidManifest.xml`文件中指定`uses-permission`来强制执行该组件上的权限。在下面的示例中，第二个块是我们将使用我们定义的权限来限制的组件。可以通过添加`android:permission`属性来强制执行：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the new permission `IOT_COOKBOOK_ACTIVTY` is created, apps can request
    it using the uses-permission tag in the `AndroidManifest.xml` file. In this case,
    it must be an app that is signed with the same certificate that can launch the
    `MAIN_ACTIVITY`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建了新的权限`IOT_COOKBOOK_ACTIVTY`，应用程序可以在`AndroidManifest.xml`文件中使用`uses-permission`标签请求该权限。在这种情况下，必须是使用相同证书签名的应用程序才能启动`MAIN_ACTIVITY`：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When introducing custom permissions and protection levels, it's always a good
    idea to reference Android's Developer documentation. All Android permissions can
    be found in the Android developer documentation at [https://developer.android.com/guide/topics/permissions/requesting.html](https://developer.android.com/guide/topics/permissions/requesting.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入自定义权限和保护级别时，始终参考Android的开发者文档是一个好主意。所有Android权限都可以在Android开发者文档中找到：[https://developer.android.com/guide/topics/permissions/requesting.html](https://developer.android.com/guide/topics/permissions/requesting.html)。
- en: In iOS applications, permissions are not applicable due to the closed ecosystem
    of iOS. However, iOS and Android share WebViews, which enable web pages to be
    loaded inside an app. Similar to web applications, malicious code can be executed
    inside web browsers, including the ones in WebViews. This is important to consider
    when reducing the attack surface of an IoT application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS应用程序中，由于iOS的封闭生态系统，权限不适用。但是，iOS和Android共享WebViews，这使得可以在应用程序内加载网页。与Web应用程序类似，恶意代码可以在WebViews中执行。在减少IoT应用程序的攻击面时，这一点很重要。
- en: 'The following code snippet illustrates how to disable JavaScript in WKWebViews
    in iOS applications:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何在iOS应用程序中禁用WKWebViews中的JavaScript：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For Android applications, disabling JavaScript is done by configuring a WebView''s
    `WebSettings`, as shown next. Additional settings should be configured such as
    disabling filesystem access, turning off plugins, and turning off geolocation,
    if not needed:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Android应用程序，禁用JavaScript是通过配置WebView的`WebSettings`来完成的，如下所示。还应该配置其他设置，如禁用文件系统访问、关闭插件和关闭地理位置信息（如果不需要）：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With least privilege and security in-depth principles in mind, apps should only
    utilize and expose platform components for required business functionality. As
    a rule of thumb, any data being sent and retrieved from third-party applications
    should be considered untrustworthy and validated appropriately.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑最小权限和深度安全原则的情况下，应用程序应该只利用和暴露平台组件以满足所需的业务功能。作为一个经验法则，从第三方应用程序发送和检索的任何数据都应该被视为不可信，并进行适当的验证。
- en: Securing third-party code and components
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护第三方代码和组件
- en: As with all software, mobile applications heavily use third-party libraries
    and wrappers to perform a function such as making HTTP requests or encrypting
    objects. These libraries can also introduce weaknesses into an application and
    expose confidential information or affect the integrity of the application itself.
    With this in mind, third-party code should be reviewed for vulnerabilities, updated,
    and tested where applicable. This is especially true for hybrid applications that
    depend on third-party hybrid frameworks and libraries to send, receive, and save
    data. This recipe will discuss methods to ensure third-party code does not introduce
    vulnerabilities into IoT applications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有软件一样，移动应用程序大量使用第三方库和包装器来执行诸如发出 HTTP 请求或加密对象之类的功能。这些库也可能会给应用程序引入弱点，暴露机密信息或影响应用程序本身的完整性。因此，应该审查第三方代码以发现漏洞，并在适用的情况下进行更新和测试。对于依赖第三方混合框架和库来发送、接收和保存数据的混合应用程序来说，这一点尤为重要。本文将讨论确保第三方代码不会给物联网应用程序引入漏洞的方法。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'In [Chapter 8](1a595cca-2dc4-4426-a3dc-ce5ac0b0a721.xhtml), *Firmware Security
    Best Practices*, methods to scan JavaScript libraries with NSP as well as Retire.js
    were discussed, these can still be applied to mobile applications. To ensure third-party
    code does not introduce security holes into mobile applications, the following
    recommendations should be considered:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](1a595cca-2dc4-4426-a3dc-ce5ac0b0a721.xhtml)中，*固件安全最佳实践*，讨论了使用 NSP 和 Retire.js
    扫描 JavaScript 库的方法，这些方法仍然适用于移动应用程序。为确保第三方代码不会给移动应用程序引入安全漏洞，应考虑以下建议：
- en: Continuously inventory the versions of libraries and frameworks and their dependencies
    using tools such as nsp, Retirejs, and dependency-check ([https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck))
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具如 nsp、Retirejs 和 dependency-check ([https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck))
    连续记录库和框架的版本及其依赖关系
- en: Create a bill of materials for all components and third-party software used
    in the mobile application
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动应用程序中使用的所有组件和第三方软件创建清单
- en: Continuously monitor vulnerabilities databases such as NVD for vulnerabilities
    in utilized components via analysis tools to automate the process
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分析工具连续监视 NVD 等漏洞数据库，以自动化流程
- en: Analyze third-party libraries to ensure they are invoked at runtime and remove
    functions not required for the application function
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析第三方库以确保它们在运行时被调用，并删除应用功能不需要的函数
- en: Ensure hybrid frameworks use the most up-to-date versions
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保混合框架使用最新版本。
- en: Monitor hybrid framework releases and blogs to ensure no known components with
    vulnerabilities are in use
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视混合框架的发布和博客，以确保没有已知的带有漏洞的组件在使用中
- en: Patch vulnerable libraries in the event framework developers do not merge upstream
    libraries
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架开发者没有合并上游库的情况下，修补易受攻击的库
- en: Monitor utilized open source code repositories for security issues and concerns
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视使用的开源代码库以发现安全问题和关注点
- en: Ensure hybrid framework plugins have been reviewed for security flaws prior
    to use
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保混合框架插件在使用前已经审查过安全漏洞
- en: Utilize newer Android version APIs to take advantage of newly introduced features
    (Apple forces iOS updates)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用更新的安卓版本 API 来利用新引入的功能（苹果强制 iOS 更新）
- en: Review Android and iOS security bulletins for platform vulnerabilities and new
    security capabilities
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查安卓和iOS的安全公告以发现平台漏洞和新的安全功能
- en: 'One of the most common mobile hybrid frameworks is Apache''s Cordova. Cordova
    can be updated for iOS and Android via the following commands:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的移动混合框架之一是 Apache 的 Cordova。Cordova 可以通过以下命令更新到 iOS 和安卓：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Cordova is known for being targeted by researchers and often has security updates
    included in new releases for both Android and iOS. The release notes for Cordova
    can be found via their blog located at [https://cordova.apache.org/blog/](https://cordova.apache.org/blog/).
    A good place to look for bugs that have not been released yet is the framework's
    bug tracking system such as Cordova's ([https://issues.apache.org/jira/projects/CB/summary](https://issues.apache.org/jira/projects/CB/summary)).
    You will be amazed to see the amount of bugs fixed, reported, and closed. For
    example, another popular hybrid framework used is Xamarin. Xamarin's credential
    manager used a hardcoded Android Keystore password leaving account credentials
    at risk of compromise from April 2014, until it was fixed in late 2016\. This
    can be found viewing the project's GitHub repository [https://github.com/xamarin/Xamarin.Auth/issues/55](https://github.com/xamarin/Xamarin.Auth/issues/55).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Cordova 以受到研究人员的关注而闻名，并且通常在新版本中包含了针对安卓和iOS的安全更新。Cordova 的发布说明可以在他们的博客中找到，位于
    [https://cordova.apache.org/blog/](https://cordova.apache.org/blog/)。一个寻找尚未发布的错误的好地方是框架的错误跟踪系统，比如
    Cordova 的 ([https://issues.apache.org/jira/projects/CB/summary](https://issues.apache.org/jira/projects/CB/summary))。你会惊讶地看到修复、报告和关闭的错误数量。例如，另一个常用的混合框架是
    Xamarin。Xamarin 的凭证管理器在2014年4月至2016年底之间使用了一个硬编码的安卓密钥库密码，使得账户凭证面临被妥协的风险，直到后来修复了这个问题。这可以在项目的
    GitHub 仓库中找到 [https://github.com/xamarin/Xamarin.Auth/issues/55](https://github.com/xamarin/Xamarin.Auth/issues/55)。
- en: See also
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Google takes a snapshot of devices being used in Google Play and publishes this
    data to a dashboard in an effort to help prioritization of supporting different
    devices ([https://developer.android.com/about/dashboards/index.html](https://developer.android.com/about/dashboards/index.html))
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌对在 Google Play 中使用的设备进行快照，并将这些数据发布到仪表板上，以帮助支持不同设备的优先级排序 ([https://developer.android.com/about/dashboards/index.html](https://developer.android.com/about/dashboards/index.html))
- en: Every month Google releases Android security bulletins that list announcements,
    vulnerabilities with CVEs, their severity, and mitigations. Android security bulletins
    can be found at [https://source.android.com/security/bulletin/](https://source.android.com/security/bulletin/).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个月，谷歌都会发布Android安全公告，列出公告、CVE漏洞、严重程度和缓解措施。Android安全公告可以在[https://source.android.com/security/bulletin/](https://source.android.com/security/bulletin/)找到。
- en: Apple releases an iOS security guide every year that details the platform security
    features and new security control capabilities with new iOS versions. The iOS
    security guide can be found at [https://www.apple.com/business/docs/iOS_Security_Guide.pdf](https://www.apple.com/business/docs/iOS_Security_Guide.pdf).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果每年都会发布一份iOS安全指南，详细介绍平台安全功能和新的iOS版本的安全控制能力。iOS安全指南可以在[https://www.apple.com/business/docs/iOS_Security_Guide.pdf](https://www.apple.com/business/docs/iOS_Security_Guide.pdf)找到。
- en: Employing reverse engineering protections
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用反向工程保护
- en: Writing secure code can be difficult when there are code bases with internal
    and outsourced teams for **user experience** (**UX**), specific feature sets such
    as finding devices during app startup, ensuring rule settings properly execute,
    and others such as ensuring app updates do not negatively affect IoT devices in
    the network. With such complexity for one application, bugs are bound to be discovered
    and security controls circumvented by attackers. Yes, this is inevitable for any
    software although techniques are available to make reverse engineering more difficult
    for attackers to compromise applications and steal a company's **intellectual
    property** (**IP**).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在内部和外包团队的代码库用于用户体验（UX）、特定功能集（例如在应用启动期间查找设备、确保规则设置正确执行等）时，编写安全代码可能会很困难，还有其他一些功能，例如确保应用更新不会对网络中的物联网设备产生负面影响。对于一个应用来说，存在这样的复杂性，错误很可能会被发现，并且安全控制可能会被攻击者绕过。是的，这对于任何软件来说都是不可避免的，尽管有技术可用于使反向工程对攻击者更加困难，以便攻击者不会妥协应用程序并窃取公司的知识产权（IP）。
- en: These techniques can be built into the application logic to protect against
    runtime modification, static analysis of applications binaries via obfuscation
    of application classes, and segmentation of data preparing for potential compromise.
    It is important to note, applications still need to build security controls into
    applications and not replace controls with third-party software protections. This
    recipe will introduce practices for making applications more resilient to attacks.
    These practices will not only make applications more resilient but also contribute
    to in-depth defenses as part of an application's anti-abuse system.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可以内置到应用程序逻辑中，以防止运行时修改，通过对应用程序类进行混淆来进行应用程序二进制文件的静态分析，并对数据进行分段以准备潜在的妥协。重要的是要注意，应用程序仍然需要在应用程序中构建安全控制，而不是用第三方软件保护替换控制。本文将介绍使应用程序更具抵抗力的做法。这些做法不仅会使应用程序更具抵抗力，还将作为应用程序反滥用系统的一部分，为应用程序提供深度防御。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'When implementing app reverse engineering controls and code modification techniques,
    the following practices should be followed:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施应用程序反向工程控制和代码修改技术时，应遵循以下做法：
- en: Applications should detect and respond to rooted or jailbroken devices either
    by alerting the user or terminating the app
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该检测并响应已越狱或越狱设备，可以通过警告用户或终止应用程序来实现
- en: Obfuscation of classes and methods is applied to builds for impeding on de-obfuscation
    via dynamic analysis
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过混淆类和方法来阻碍动态分析对构建的影响
- en: Hardware-backed process isolation is preferred over obfuscation whenever possible
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，首选硬件支持的进程隔离，而不是混淆
- en: Applications should prevent debugging and prevent debuggers from being attached
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该防止调试并阻止调试器的连接
- en: Applications should detect the presence of reverse engineering tools and frameworks
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该检测反向工程工具和框架的存在
- en: Applications should detect when running in an emulated environment and respond
    appropriately
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该检测是否在模拟环境中运行，并做出适当的响应
- en: Production builds should strip symbols
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产版本应该剥离符号
- en: Production builds should not contain debugging code or debuggable features such
    as `android:debuggable="false"`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产版本不应包含调试代码或可调试功能，例如`android:debuggable="false"`
- en: Android applications can use the SafetyNet Attestation API compatibility check
    to ensure applications have not been modified by an unknown source
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序可以使用SafetyNet Attestation API兼容性检查来确保应用程序未被未知来源修改
- en: The SafetyNet Verify Apps API should be used to check whether any potentially
    harmful apps are installed on a device ([https://developer.android.com/training/safetynet/verify-apps.html](https://developer.android.com/training/safetynet/verify-apps.html))
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用SafetyNet Verify Apps API来检查设备上是否安装了任何潜在有害的应用程序（[https://developer.android.com/training/safetynet/verify-apps.html](https://developer.android.com/training/safetynet/verify-apps.html)）
- en: 'iOS apps can look for common jailbreak file-based checks such as the following
    list ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md)):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: iOS应用程序可以寻找常见的越狱基于文件的检查，例如以下列表（[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md)）：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition, iOS apps can attempt to execute root-level system API calls or
    checking file permissions by writing data to a file that is outside of the application's
    sandbox to detect whether a device is jailbroken.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，iOS应用程序可以尝试执行根级系统API调用或通过向应用程序沙盒之外的文件写入数据来检测设备是否已越狱。
- en: 'Android apps can use similar methods to check commonly found rooted device
    files and also attempt to execute commands as root. A list of commonly rooted
    files and apps is listed as follows ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md)):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用程序可以使用类似的方法来检查常见的已root设备文件，并尝试以root身份执行命令。常见的已root文件和应用程序列表如下所示（[https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md)）：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Additionally, checking for custom Android ROM builds can indicate a rooted device
    although it is not a definitive method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查自定义的Android ROM版本可以指示已root设备，尽管这不是一个确定的方法。
- en: Multiple checks and defense methods should be used to ensure resilience. The
    overall goal is to ensure attackers cannot tamper, modify code, perform runtime
    modifications, and reverse engineering app packages to prevent abuse. Several
    of the preceding practices can be introduced into an application's logic upon
    startup and throughout the runtime of the application. Commercial solutions are
    available to perform some of the earlier-listed practices and more; however, they
    should be vetted prior to integrating into an application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用多种检查和防御方法来确保弹性。总体目标是确保攻击者无法篡改、修改代码、执行运行时修改和逆向工程应用程序包以防止滥用。前述实践中的一些可以在应用程序启动时和整个运行时引入到应用程序逻辑中。商业解决方案可用于执行一些早期列出的实践以及更多内容；但是，在集成到应用程序之前，应该经过审查。
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To understand the risks of mobile application reverse engineering and unauthorized
    code modification, reference OWASP's Reverse Engineering and Code Modification
    Prevention Project [https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project](https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project).
    This project does a great job of describing technical and business risk use cases
    with supplemental mitigation suggestions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解移动应用程序逆向工程和未经授权的代码修改的风险，请参考OWASP的逆向工程和代码修改预防项目[https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project](https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project)。该项目非常好地描述了技术和业务风险用例，并提供了补充的缓解建议。
- en: See also
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about requesting a compatibility check via the SafetyNet API
    can be found via the following Android Developer page ([https://developer.android.com/training/safetynet/attestation.html#cts-check](https://developer.android.com/training/safetynet/attestation.html#cts-check)).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关通过SafetyNet API请求兼容性检查的更多信息，请参阅以下Android开发者页面（[https://developer.android.com/training/safetynet/attestation.html#cts-check](https://developer.android.com/training/safetynet/attestation.html#cts-check)）。
