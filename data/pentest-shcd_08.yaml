- en: Exploit Development – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Exploit开发-第2部分
- en: In this chapter, we will continue our topic about exploit development. First,
    we will continue and complete our previous example by injecting a shellcode. Then,
    we will talk about a new technique, which is used to avoid the NX protection mechanism
    (NX will be explained in the last chapter).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论exploit开发的话题。首先，我们将通过注入shellcode继续并完成我们之前的例子。然后，我们将讨论一种新的技术，用于避免NX保护机制（NX将在最后一章中解释）。
- en: 'The following are the topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将涵盖的主题：
- en: Injecting shellcode
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入shellcode
- en: Return-oriented programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回导向编程
- en: Structured exception handler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化异常处理程序
- en: Injecting shellcode
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入shellcode
- en: Now, let's continue our example from the previous chapter. After we have control
    of the instruction pointer, what we need is to inject a shellcode and redirect
    the instruction pointer to point at it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续上一章的例子。在我们控制了指令指针之后，我们需要做的是注入shellcode并将指令指针重定向到它。
- en: 'For that to happen, we will need to find a home for the shellcode. It''s easy,
    actually; it just involves jumping to the stack. What we need now is to find that
    instruction:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要为shellcode找一个家。实际上很容易；它只涉及跳转到堆栈。现在我们需要做的是找到那个指令：
- en: 'Start vulnserver, then start the Immunity Debugger as an administrator, and
    from the File menu, attach with vulnserver:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动vulnserver，然后以管理员身份启动Immunity Debugger，并从“文件”菜单中，附加到vulnserver：
- en: '![](img/00311.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00311.jpeg)'
- en: 'Hit the run program icon and then right-click and select Search for; then,
    select All Commands in all modules to search for any instruction within the application
    itself or any related library:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行程序图标，然后右键单击并选择搜索；然后，在所有模块中选择所有命令来搜索应用程序本身或任何相关库中的任何指令：
- en: '![](img/00312.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00312.jpeg)'
- en: 'Then what we need to do is jump to the stack to execute our shellcode; so,
    let''s search for the `JMP ESP` instruction and hit Find:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要做的是跳转到堆栈来执行我们的shellcode；所以，让我们搜索`JMP ESP`指令并点击查找：
- en: '![](img/00313.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00313.jpeg)'
- en: Let's copy the address of `JMP ESP` from `kernel32.dll 7DD93132`, then re-run
    vulnserver inside the Immunity Debugger again, and hit the run program icon.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`kernel32.dll 7DD93132`复制`JMP ESP`的地址，然后再次在Immunity Debugger中重新运行vulnserver，并点击运行程序图标。
- en: You can use any library, not just `kernel32.dll`. However, if you use the system's
    libraries, such as `kernel32.dll`, then the address will change each time Windows
    boots up due to the ASLR mechanism (which will be explained in the last chapter);
    but if you use a library related to the application and not related to the system,
    then the address will not change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何库，不仅仅是`kernel32.dll`。但是，如果你使用系统的库，比如`kernel32.dll`，那么由于ASLR机制（将在最后一章中解释），每次Windows启动时地址都会改变；但如果你使用与应用程序相关而与系统无关的库，那么地址就不会改变。
- en: 'Then, from the attacking machine, edit our exploit to be like this:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从攻击机器上，编辑我们的exploit如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, run the exploit. The instruction pointer is not pointing at `43434343`,
    which are our `C` characters:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行exploit。指令指针现在指向`43434343`，这是我们的`C`字符：
- en: '![](img/00314.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00314.jpeg)'
- en: 'Now we are ready to insert our shellcode. Let''s create one using the Metasploit
    Framework:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备插入我们的shellcode。让我们使用Metasploit Framework创建一个：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command generates a reverse TCP shell to connect back to my attacking
    machine on port `4321`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个命令生成一个反向TCP shell，连接回我的攻击机器的端口`4321`：
- en: '![](img/00315.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00315.jpeg)'
- en: 'So, our final exploit should look like this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们的最终exploit应该是这样的：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s start vulnserver again. Then, set up a listener on our attacking
    machine:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次启动vulnserver。然后，在我们的攻击机器上设置一个监听器：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s time to try our exploit, and let''s keep our eyes on the listener:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候尝试我们的exploit了，让我们保持对监听器的关注：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, from our listener shell, we execute the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从我们的监听shell中，执行以下命令：
- en: '![](img/00316.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00316.jpeg)'
- en: 'Let''s confirm this using `ipconfig`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`ipconfig`来确认一下：
- en: '![](img/00317.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00317.jpeg)'
- en: Now we have control over our victim machine!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们控制了我们的受害机器！
- en: Return-oriented programming
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回导向编程
- en: What is **return-oriented programming** (**ROP**)?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**返回导向编程**（**ROP**）？
- en: Let's explain what ROP is in the simplest way. ROP is a technique used to exploit
    buffer overflow vulnerability even if NX is enabled. The ROP technique can pass
    NX protection techniques using ROP gadgets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用最简单的方式解释ROP是什么。ROP是一种技术，即使启用了NX，也可以利用缓冲区溢出漏洞。ROP技术可以使用ROP小工具绕过NX保护技术。
- en: ROP gadgets are sequences of addresses for machine instructions, which are stored
    already in the memory. So, if we could change the flow of execution to one of
    these instructions, then we could take control over the application, and we can
    do so without uploading a shellcode. Also, ROP gadgets end with the `ret` instruction.
    If you don't get it yet, it's okay; we will perform an example to fully understand
    what ROP is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ROP小工具是存储在内存中的机器指令地址序列。因此，如果我们能够改变执行流到这些指令中的一个，那么我们就可以控制应用程序，并且可以在不上传shellcode的情况下做到这一点。此外，ROP小工具以`ret`指令结尾。如果你还没有明白，没关系；我们将进行一个例子来完全理解ROP是什么。
- en: 'So, what we need is to install ropper, which is a tool to find ROP gadgets
    within a binary. You can download it via its official repository on GitHub ([https://github.com/sashs/Ropper](https://github.com/sashs/Ropper)), 
    [](https://github.com/sashs/Ropper) or you can follow the instructions given here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要安装ropper，这是一个在二进制文件中查找ROP小工具的工具。你可以通过它在GitHub上的官方存储库下载它（[https://github.com/sashs/Ropper](https://github.com/sashs/Ropper)），或者你可以按照这里给出的说明：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s take a look at the next vulnerable code, which will print out, `Starting
    /bin/ls`. Execute the `overflow` function, which will take input from the user
    and then print it out along with the size of the input:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个有漏洞的代码，它将打印出`Starting /bin/ls`。执行`overflow`函数，它将从用户那里获取输入，然后打印出来以及输入的大小：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s compile it, but without disabling NX:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译它，但不要禁用NX：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, start `gdb`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动`gdb`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s confirm that NX is enabled:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确认NX是否已启用：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00318.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00318.jpeg)'
- en: 'Let''s now perform fuzzing and controlling RIP using PEDA instead of the Metasploit
    Framework:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用PEDA执行模糊测试并控制RIP，而不是使用Metasploit框架：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will create a pattern of `500` characters and save a file named `pattern`.
    Now, let''s read this pattern as input:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含`500`个字符的模式，并将文件保存为`pattern`。现在，让我们将这个模式作为输入读取：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00319.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00319.jpeg)'
- en: 'The program crashed. The next step is to examine the last element in the stack
    to calculate the offset of EIP:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃了。下一步是检查栈中的最后一个元素，以计算EIP的偏移量：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We got the last element in the stack as `0x41413741` (if you are using the
    same OS, this address should be the same). Now, let''s see whether the offset
    of this pattern and the next offset will be the exact offset of RIP:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了栈中的最后一个元素为`0x41413741`（如果你使用相同的操作系统，这个地址应该是一样的）。现在，让我们看看这个模式的偏移量和下一个偏移量是否是RIP的确切偏移量：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00320.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00320.jpeg)'
- en: 'So the exact offset of RIP will start from `105`. Let''s confirm that too:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的确切偏移将从`105`开始。让我们也确认一下：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code should overflow RIP registers with six `B` characters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该用六个`B`字符溢出RIP寄存器：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, from inside GDB, run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从GDB内部运行以下命令：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00321.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00321.jpeg)'
- en: The preceding screenshot indicates that we are going in the right direction.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图表明我们正在朝着正确的方向前进。
- en: 'Since NX is enabled, we can''t upload and run a shellcode, so let''s use ROP
    with the return-to-libc technique, which enables us to use calls from libc itself,
    which could enable us to call the function. Here, we will use the `system` function
    to execute shell commands. Let''s take a look at the system `man` page:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NX已启用，我们无法上传和运行shellcode，所以让我们使用返回到libc的ROP技术，这使我们能够使用来自libc本身的调用，这可能使我们能够调用函数。在这里，我们将使用`system`函数来执行shell命令。让我们看一下`system`的man页面：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00322.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00322.jpeg)'
- en: What we need is the address of the `system` function and also the location of
    the string of a shell command—luckily, we have that inside our `/bin/ls` code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是`system`函数的地址，以及shell命令字符串的位置——幸运的是，我们在`/bin/ls`代码中有这个。
- en: The only thing we did was copy the location of the string into the stack. Now,
    we need to find a way to copy the location to the RDI register to enable the system
    function to execute the `ls` command. So, we need the ROP gadget, which can extract
    the address of the string and copy it to the RDI register because the first argument
    should be in the RDI register.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的唯一的事情就是将字符串的位置复制到栈中。现在，我们需要找到一种方法将位置复制到RDI寄存器，以启用系统函数执行`ls`命令。因此，我们需要ROP小工具，它可以提取字符串的地址并将其复制到RDI寄存器，因为第一个参数应该在RDI寄存器中。
- en: 'Okay, let''s start with the ROP gadget. Let''s search for any ROP gadget related
    to the RDI register. Then, navigate to the location where you installed ropper:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们从ROP小工具开始。让我们搜索与RDI寄存器相关的任何ROP小工具。然后，导航到你安装ropper的位置：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00323.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00323.jpeg)'
- en: 'This ROP gadget is perfect: `pop rdi; ret;`, with the address `0x0000000000400653`.
    Now, we need to find out where exactly the `system` function is in the memory,
    from inside GDB:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ROP小工具很完美：`pop rdi; ret;`，地址为`0x0000000000400653`。现在，我们需要从GDB内部找出`system`函数在内存中的确切位置：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00324.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00324.jpeg)'
- en: Now, we have also got the location of the `system` function with the address,
    `0x7ffff7a57590`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还得到了`system`函数的地址，为`0x7ffff7a57590`。
- en: This address may be different on your operating system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的操作系统上，这个地址可能会有所不同。
- en: 'Let''s get the location of the `/bin/ls` string, using GDB:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GDB获取`/bin/ls`字符串的位置：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00325.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00325.jpeg)'
- en: Now, we have got the location to the string with the address, `0x400697`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了带有地址`0x400697`的字符串的位置。
- en: 'The logical order of the stack should be:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的逻辑顺序应该是：
- en: The address of the `system` function
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`system`函数的地址'
- en: The string pointer, which will be popped to the RDI register
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将被弹出到RDI寄存器的字符串指针
- en: The ROP gadget to extract pop, which is the last element in the stack to the
    RDI register
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROP小工具用于提取pop，即栈中的最后一个元素到RDI寄存器
- en: 'Now, we need to push them into the stack in reverse order, using our exploit
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要以相反的顺序将它们推入栈中，使用我们的利用代码：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s run the script to update `input.txt`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行脚本来更新`input.txt`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, from GDB, run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从GDB中运行以下命令：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The logical order of the stack should be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的逻辑顺序应该是：
- en: '![](img/00326.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00326.jpeg)'
- en: It worked! And as you can see, the `ls` command executed successfully. We found
    a way to get around NX protection and exploit this code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！正如你所看到的，`ls`命令成功执行了。我们找到了绕过NX保护并利用这段代码的方法。
- en: Structured exception handling
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化异常处理
- en: '**Structured exception handling** (**SEH**) is simply an event that occurs
    during the execution of a code. We can see SEH in high-programming languages,
    such as C++ and Python. Take a look at the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化异常处理**（**SEH**）只是在代码执行过程中发生的事件。我们可以在高级编程语言中看到SEH，比如C++和Python。看一下下面的代码：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is an example of dividing by zero, which will raise an exception. The program
    should change the flow of execution to something else, which is doing whatever
    inside it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个除零的例子，会引发异常。程序应该改变执行流到其他地方，做里面的任何事情。
- en: 'SEH consists of two parts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SEH由两部分组成：
- en: Exception registration record (SEH)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常注册记录（SEH）
- en: Next exception registration record (nSEH)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个异常注册记录（nSEH）
- en: 'They are pushed into the stack in reverse order. So now how to exploit SEH?
    It''s as simple as a regular stack overflow:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它们以相反的顺序推入堆栈。那么现在如何利用SEH呢？就像普通的堆栈溢出一样简单：
- en: '![](img/00327.gif)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00327.gif)'
- en: 'This is what our exploit should look like. What we need exactly is to push
    an instruction, **pop pop ret**, into **SEH** to make a jump to **nSEH**. Then,
    push a jump instruction into **nSEH** to make a jump to the shellcode; so, our
    final shellcode should look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的利用程序应该看起来的样子。我们需要的是将一条指令**pop pop ret**推入**SEH**，以使跳转到**nSEH**。然后，将一条跳转指令推入**nSEH**，以使跳转到shellcode；因此，我们的最终shellcode应该是这样的：
- en: '![](img/00328.gif)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00328.gif)'
- en: We will cover a practical scenario in [Chapter 11](part0109.html#37UDA0-5bf3e26315164e77bbeecc4f75207114),
    *Real-World Scenarios – Part 3*, about exploiting SEH.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](part0109.html#37UDA0-5bf3e26315164e77bbeecc4f75207114)，*真实场景-第3部分*中涵盖一个实际场景，关于利用SEH。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here, we have briefly discussed exploit development, starting from fuzzing and
    how to gain control over the instruction pointer. Then, we saw how to find a home
    for a shellcode and change the flow of execution to that shellcode. Finally, we
    talked about a technique called ROP for bypassing the NX protection technique,
    and took a quick look at SEH exploiting techniques.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简要讨论了利用程序的开发，从fuzzing开始，以及如何控制指令指针。然后，我们看到了如何为shellcode找到一个家园，并改变执行流到该shellcode。最后，我们讨论了一种称为ROP的技术，用于绕过NX保护技术，并快速了解了SEH利用技术。
- en: In the next chapter, we will go through *real-world scenarios* and build an
    exploit for real applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过*真实场景*来构建一个真实应用的利用程序。
