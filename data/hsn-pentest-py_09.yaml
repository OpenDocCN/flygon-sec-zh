- en: Automated Web Application Scanning - Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动Web应用程序扫描-第2部分
- en: 'Continuing our discussion from the previous chapter, we are now going to study
    how to use Python to automatically detect **Cross-site scripting** (**XSS**),
    **Cross-site request forgery** (**CSRF**), clickjacking, and **secure sockets
    layer** (**SSL**) stripping. All the techniques that we are going to discuss in
    this chapter will help us to expedite the web application assessment process.
    I recommend that you should not be confined to the approaches that we are going
    to discuss in this chapter. The approaches discussed can be taken as a baseline,
    and the same ideas can be extended and improved to arrive at better solutions
    or to develop tools that aid the pen testing community. This chapter will discuss
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们在上一章的讨论，我们现在将学习如何使用Python自动检测**跨站脚本**（**XSS**）、**跨站请求伪造**（**CSRF**）、点击劫持和**安全套接字层**（**SSL**）剥离。本章讨论的所有技术将帮助我们加快Web应用程序评估过程。我建议您不要局限于本章讨论的方法。讨论的方法可以作为基线，相同的想法可以扩展和改进，以得到更好的解决方案或开发工具，以帮助渗透测试社区。本章将讨论以下主题：
- en: Cross-site scripting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: Cross-site request Forgery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: Clickjacking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击劫持
- en: SSL strip (missing HSTS header)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL剥离（缺少HSTS标头）
- en: XSS
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XSS
- en: '**XSS **attacks belong to the injection category of web application attacks.
    They are mainly caused by not sanitizing the user input that is passed to the
    web application from the end user. This does not lead to the server being compromised,
    but the implications are very serious in terms of the user''s data being compromised.
    Attacks happen when an attacker is able to inject some sort of Java script or
    HTML content into the web page that will be served to the user. This malicious
    content may attempt to steal sensitive information from the user visiting the
    website. In the following sections, we will take a look at different types of
    XSS attacks.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**XSS**攻击属于Web应用程序攻击的注入类别。它们主要是由于未对来自最终用户的Web应用程序传递的用户输入进行消毒而引起的。这不会导致服务器被攻破，但对用户数据的影响非常严重。攻击发生在攻击者能够将某种Java脚本或HTML内容注入到将提供给用户的网页中时。这种恶意内容可能会尝试从访问网站的用户那里窃取敏感信息。在接下来的章节中，我们将看看不同类型的XSS攻击。'
- en: Stored or Type 1 XSS attacks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储或Type 1 XSS攻击
- en: '**Stored XSS** are attacks in which the supplied malicious input from the attacker
    is persisted and stored in the back-end database or repository. Whenever that
    content is retrieved and rendered to be displayed on the web page, the browser
    is completely unaware of it and it either executes the malicious JavaScript that
    comes from the database or renders the malicious HTML markup, instead of displaying
    it as text. The stored XSS will remain permanently in the database and will impact
    all users visiting the affected web page.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储型XSS**是攻击，其中来自攻击者的恶意输入被持久化并存储在后端数据库或存储库中。每当检索并呈现该内容以在网页上显示时，浏览器完全不知道它，它要么执行来自数据库的恶意JavaScript，要么呈现恶意HTML标记，而不是将其显示为文本。存储型XSS将永久保留在数据库中，并影响访问受影响网页的所有用户。'
- en: Reflected or Type 2 XSS attacks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射型或Type 2 XSS攻击
- en: '**Reflected XSS** attacks are the second type of XSS attack vector, in which
    the malicious XSS payload is not stored in the database table for persistence,
    but is still injected in some parameter of the web page that gets rendered back
    to the user. The browser, unaware of this change, simply either renders the injected
    malicious HTML or executes the injected malicious Java script code, again resulting
    in the user''s data being compromised.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射型XSS**攻击是XSS攻击向量的第二种类型，其中恶意的XSS有效负载不会存储在数据库表中以进行持久化，但仍然被注入到返回给用户的网页的某些参数中。浏览器对此更改毫不知情，只是简单地呈现注入的恶意HTML或执行注入的恶意JavaScript代码，再次导致用户数据被泄露。'
- en: DOM-based or Type 0 XSS attacks
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于DOM或Type 0 XSS攻击
- en: A **document object model-**based XSS is the third category of XSS attacks.
    Here, the XSS payload is not sent to the server, but due to implementation flaws
    and changing the state/DOM of the web page with the help of client-side JavaScript,
    an attacker paces the payload that gets picked up with the JavaScript responsible
    for manipulating the state of the web page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于**文档对象模型**的XSS是XSS攻击的第三类。在这里，XSS有效负载不会发送到服务器，而是由于实现缺陷和使用客户端JavaScript改变网页状态/DOM，攻击者放置有效负载，该有效负载将由负责操纵网页状态的JavaScript拾取。
- en: Our focus here is to understand how can we automate the detection of XSS using
    Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点是了解如何使用Python自动检测XSS。
- en: Automatic detection of XSS with Python
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python自动检测XSS
- en: Here, we shall see an approach that we will use to automatically detect XSS
    in web applications using Python, Beautifulsoup, Selenium, and Phantomjs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一种方法，我们将使用Python、Beautifulsoup、Selenium和Phantomjs自动检测Web应用程序中的XSS。
- en: 'Let''s install the dependencies by running the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来安装依赖项：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s understand the objective of each:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个的目标：
- en: '**BeautifulSoup** is a brilliant Python library that is required for web scraping
    and parsing web pages.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BeautifulSoup**是一个出色的Python库，用于网页抓取和解析网页。'
- en: '**Selenium **is an automation framework used for automatically testing web
    applications. Its functionality is particularly important in the security domain
    and is used for browser simulation and automatically traversing the workflows
    of a web application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**是用于自动测试Web应用程序的自动化框架。其功能在安全领域尤为重要，用于浏览器模拟和自动遍历Web应用程序的工作流程。'
- en: '**Phantomjs** is a utility that is used for headless browsing. It performs
    all activities of a browser without actually loading it, but instead running it
    in the background, which makes it lightweight and very useful.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Phantomjs**是一种用于无头浏览的实用程序。它执行浏览器的所有活动，而不实际加载它，而是在后台运行，使其轻巧且非常有用。'
- en: 'After installing Phantomjs, we need to execute the following command on the
    console: `unset QT_QPA_PLATFORM`. This is used to handle the error thrown by the
    Phantomjs version on Ubuntu 16.04, which is as follows: `Message: Service phantomjs
    unexpectedly exited. Status code was: -6`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '安装Phantomjs后，我们需要在控制台上执行以下命令：`unset QT_QPA_PLATFORM`。这是用来处理Ubuntu 16.04上Phantomjs版本抛出的错误的，错误如下：`Message:
    Service phantomjs unexpectedly exited. Status code was: -6`。'
- en: It should be noted that the objective of this exercise is to simulate normal
    user behavior and find the injection points within the web application. What we
    mean by *injection points* are all the input fields in which the user can supply
    the input. To find the injection points, we shall make use of the `BeautifulSoup`
    library. From the web page, we extract all fields whose type is either text, password,
    or textarea. Once we find the injection points, we will use selenium to pass our
    payload values in the injection points. Once the payload is set in the injection
    points, we will then locate the submit button for the form, again with the help
    of `BeautifulSoup`. After this, we pass the ID of the submit button to silinium,
    to click it, in order to submit the form.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，这个练习的目的是模拟正常用户行为，并找到Web应用程序中的注入点。我们所说的*注入点*是指用户可以提供输入的所有输入字段。为了找到注入点，我们将使用`BeautifulSoup`库。从网页中，我们提取所有类型为文本、密码或文本区域的字段。一旦找到注入点，我们将使用selenium在注入点传递我们的有效负载值。一旦有效负载设置在注入点，我们将再次使用`BeautifulSoup`来定位表单的提交按钮。然后，我们将传递提交按钮的ID给selenium，点击它，以提交表单。
- en: The payload we will be using is `<a href=#> Malicious Link XSS </a>`. If this
    is created, we can deduce that the website is vulnerable to XSS. It must also
    be noted that, after submitting the payload, we also capture a screenshot of the
    webpage to see if the link was actually created, which will serve as a proof of
    concept.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的有效负载是`<a href=#> Malicious Link XSS </a>`。如果这个被创建了，我们可以推断网站存在XSS漏洞。还必须注意的是，在提交有效负载后，我们还捕获了网页的截图，以查看链接是否真的被创建，这将作为概念的证明。
- en: It should be noted that we will demonstrate the proof of concept of our script
    on the DVWA application that is running locally on our IP `http://192.168.250.1/dvwa`.
    As we know, the application requires the user to log in. We will first make our
    script log into the application automatically and then set the appropriate cookies
    and session. Then, after logging in, we will navigate to the pages where XSS is
    present and carry out the mentioned operation. We will also update the cookie
    value and set security=low, for XSS to be possible in the DVWA application. It
    should be noted that the same concept can be extended and applied to any web application,
    as we are using a very generic approach of identifying the injection points and
    submitting a payload in them. Modify the script and extend it further as appropriate.
    I will be working toward the development of a fully-featured XSS detection tool
    on top of this script, which will be located on my GitHub repository. Please feel
    free to contribute to it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，我们将在本地IP`http://192.168.250.1/dvwa`上运行的DVWA应用程序上演示我们脚本的概念验证。正如我们所知，该应用程序需要用户登录。我们将首先让我们的脚本自动登录应用程序，然后设置适当的cookie和会话。然后，在登录后，我们将导航到存在XSS的页面，并执行上述操作。我们还将更新cookie值，并设置security=low，以便在DVWA应用程序中可能发生XSS。应该注意，相同的概念可以扩展并应用于任何Web应用程序，因为我们使用了一种非常通用的方法来识别注入点并在其中提交有效负载。根据需要修改脚本并进一步扩展。我将致力于在这个脚本的基础上开发一个功能齐全的XSS检测工具，它将位于我的GitHub存储库中。请随时为其做出贡献。
- en: In the next section, we'll take a look at extreme automation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下极端自动化。
- en: Script in action
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本在执行
- en: 'Let''s name our script `Xss_automate.py` and add the content shown in the following 
    screenshots:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的脚本命名为`Xss_automate.py`，并添加以下截图中显示的内容：
- en: '![](img/484f429d-bd64-41a3-920c-38e3892b6249.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/484f429d-bd64-41a3-920c-38e3892b6249.png)'
- en: '![](img/08909770-f649-4193-b2e3-6416f920f08b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08909770-f649-4193-b2e3-6416f920f08b.png)'
- en: '![](img/a024dced-fd3e-4fe9-bd23-81486e046e6d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a024dced-fd3e-4fe9-bd23-81486e046e6d.png)'
- en: '![](img/c03fe143-c7a6-4041-b336-c4f73782c3fc.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c03fe143-c7a6-4041-b336-c4f73782c3fc.png)'
- en: 'The script can now be run as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以运行脚本如下：
- en: '![](img/a24eb513-17ea-4f53-b2e6-58201c03ddd3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a24eb513-17ea-4f53-b2e6-58201c03ddd3.png)'
- en: 'Let''s go and check the current path to see whether the screenshots were created:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去检查当前路径，看看截图是否已经创建：
- en: '![](img/c8657ffd-643f-4ed4-9469-31216243196c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8657ffd-643f-4ed4-9469-31216243196c.png)'
- en: 'As we indicated previously, three screenshots were created and captured. Let''s
    open each to validate the proof of concept. The following screenshot is what we
    see, after successfully logging in with our script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所指出的，已经创建并捕获了三个截图。让我们打开每一个来验证概念的证明。成功使用我们的脚本登录后，下面的截图就是我们看到的：
- en: '![](img/0d525220-1a2a-4f08-817a-06c5b9d13592.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d525220-1a2a-4f08-817a-06c5b9d13592.png)'
- en: 'The following screenshot shows the exploitation of the reflected XSS vulnerability
    with the creation of the link. Notice the value of security, which is set as low:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了反射XSS漏洞的利用，创建了链接。请注意，security的值被设置为low：
- en: '![](img/063194e2-c175-43e2-8fd9-21457c9a288e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/063194e2-c175-43e2-8fd9-21457c9a288e.png)'
- en: 'The following screenshot shows the Stored XSS vulnerability:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了存储的XSS漏洞：
- en: '![](img/cfa0cf01-a5eb-4a50-8110-625e472120eb.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa0cf01-a5eb-4a50-8110-625e472120eb.png)'
- en: 'It should be noted that we only applied the previous method to detect XSS in
    two pages, just to reduce the execution time and demonstrate the power of the
    concept. However, this can be extended for all the web pages of the application.
    We would be required to remove the condition of checking if the fetched URL from
    the `<a>` tag is present in the list: `self.target_links=["vulnerabilities/xss_r/","vulnerabilities/xss_s/"]`.
    Try this approach, removing this condition, and modify the script if needed to
    see what it covers.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只将先前的方法应用于检测两个页面中的XSS，只是为了减少执行时间并展示概念的威力。然而，这可以扩展到应用程序的所有网页。我们需要删除检查从`<a>`标签中获取的URL是否存在于列表中的条件：`self.target_links=["vulnerabilities/xss_r/","vulnerabilities/xss_s/"]`。尝试这种方法，删除这个条件，并根据需要修改脚本，看看它覆盖了什么。
- en: CSRF
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF
- en: '**CSRF** is an attack with the help of which an attacker exploits a valid user
    session in a manner that allows certain actions to be performed on the behalf
    of currently logged-in user. For example, let''s say an admin user is logged into
    the application and has a valid session cookie set at the browser. There is an
    option for the admin to delete all users from website by clicking the delete all
    button, which internally invokes the HTTP request `http://www.mysite.com/delete?users=all`.
    One of the properties of the web browser to send the session parameters/cookies
    to the server for every subsequent request after the user has logged in to the
    application. This can be exploited by the attacker by crafting a fake page that
    has an HTML image, such as `<img src"http://www.mysite.com/delete?users=all" style="display:hidden">`.
    The attacker can send the link of this fake page to the admin who would be currently
    logged in to his website `mysite.com`. Not aware of the malicious intent, if the
    admin user loads the web page, the HTTP request to delete all users will be triggered
    on their behalf, and the valid session cookies will be sent, causing the server
    to delete all users.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSRF**是一种攻击，攻击者利用有效的用户会话以允许在当前登录用户的名义下执行某些操作。例如，假设管理员用户已登录应用程序，并在浏览器中设置了有效的会话cookie。管理员可以通过单击删除所有按钮来删除网站上的所有用户，内部调用HTTP请求`http://www.mysite.com/delete?users=all`。Web浏览器的一个属性是在用户登录到应用程序后，为每个后续请求向服务器发送会话参数/cookie。攻击者可以利用这一点，通过制作一个包含HTML图像的伪造页面，例如`<img
    src"http://www.mysite.com/delete?users=all" style="display:hidden">`。攻击者可以将这个伪造页面的链接发送给当前已登录到他的网站`mysite.com`的管理员。如果管理员用户加载了这个网页，将会以他们的名义触发删除所有用户的HTTP请求，并发送有效的会话cookie，导致服务器删除所有用户。'
- en: Automatically detecting CSRF with Python
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python自动检测CSRF
- en: Here, we will look at an approach that we will use to automatically detect CSRF
    in web applications using Python, Beautifulsoup, Selenium, and Phantomjs. Before
    automating the detection, however, let's discuss the approach that we shall take.
    We know that CSRF attacks can be mitigated by implementing anti-CSRF tokens.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍一种使用Python、Beautifulsoup、Selenium和Phantomjs自动检测Web应用程序中CSRF的方法。然而，在自动化检测之前，让我们讨论一下我们将采取的方法。我们知道可以通过实现反CSRF令牌来减轻CSRF攻击。
- en: Any form that would be served from the server, which will potentially modify
    the state at the server, should have a hidden field that contains a random cryptic
    value called a CSRF token. The principle behind most CSRF tokens is that this
    form and a cookie must also be set with a cryptic value that translates to the
    same value of the token served in the hidden field. When the form is posted back
    to the server, the secret value of the cookie is extracted and compared with the
    hidden value posted back to the server within the hidden field. If both secrets
    match, the request is assumed to be genuine and is processed further.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器提供的任何可能修改服务器状态的表单都应该包含一个包含随机加密值的隐藏字段，称为CSRF令牌。大多数CSRF令牌背后的原则是，这个表单和一个cookie也必须设置为一个与在隐藏字段中提供的令牌的相同值的加密值。当表单被提交回服务器时，会提取cookie的秘密值并与在隐藏字段中提交回服务器的秘密值进行比较。如果两个秘密匹配，请求被认为是真实的，并进一步处理。
- en: We will use the same approach in our detection mechanism. For any form that
    would be posted back to the server, we will extract all the input fields and compare
    them with a list of commonly used hidden field parameter names for CSRF across
    various technologies such as Java, PHP, Python/Django, ASP.NET, and Ruby. Furthermore,
    we will also take a look at the cookies that are set before the form is submitted
    and compare the names of the cookies with the commonly used names for CSRF protection
    across all well known technology stacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的检测机制中使用相同的方法。对于任何要提交回服务器的表单，我们将提取所有输入字段并将它们与各种技术中常用的CSRF隐藏字段参数名称列表进行比较，如Java、PHP、Python/Django、ASP.NET和Ruby。此外，我们还将查看在提交表单之前设置的cookie的名称，并将这些cookie的名称与所有知名技术堆栈中常用的CSRF保护名称进行比较。
- en: 'Again, it should be noted that the script will simulate normal human behavior.
    It will log into the application and maintain a valid session and then try to
    look for CSRF flaws. The most commonly used CSRF hidden filed parameters along
    with technology stacks are shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要再次注意的是，脚本将模拟正常的人类行为。它将登录应用程序并保持有效会话，然后尝试查找CSRF漏洞。这里显示了最常用的CSRF隐藏字段参数以及技术堆栈：
- en: '`ASP.NET [Hiddenfiled : __RequestVerificationToken, Cookie : RequestVerificationToken]`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASP.NET [Hiddenfiled : __RequestVerificationToken, Cookie : RequestVerificationToken]`'
- en: '`PHP [Hiddenfiled : token, Cookie : token], [Hiddenfileld :_csrfToken, Cookie
    : csrfToken]`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PHP [Hiddenfiled : token, Cookie : token], [Hiddenfileld :_csrfToken, Cookie
    : csrfToken]`'
- en: '`PHP [Hiddenfiled : _csrftoken, Cookie : csrftoken]`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PHP [Hiddenfiled : _csrftoken, Cookie : csrftoken]`'
- en: The preceding list could be more exhaustive but it is fine for our purposes.
    We will be using the DVWA application to create our proof of concept script.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表可能更详尽，但对我们的目的来说已经足够了。我们将使用DVWA应用程序来创建我们的概念验证脚本。
- en: Script in action
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本在执行
- en: 'Let''s go ahead and create a script called `Csrf_detection.py` with the content
    shown in the following  screenshots:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个名为`Csrf_detection.py`的脚本，其中包含以下屏幕截图中显示的内容：
- en: '![](img/005e85f7-756e-4087-b759-4ccf0ddf62a1.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/005e85f7-756e-4087-b759-4ccf0ddf62a1.png)'
- en: '![](img/30d156ff-af96-4a4d-a911-1326a0eeed0c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30d156ff-af96-4a4d-a911-1326a0eeed0c.png)'
- en: '![](img/00ec8910-e107-4368-b0f9-4e654ef280d7.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00ec8910-e107-4368-b0f9-4e654ef280d7.png)'
- en: 'When we execute the script, we get the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行脚本时，我们得到以下输出：
- en: '![](img/b598296e-27e3-4d2f-ab9a-056a8874d1f6.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b598296e-27e3-4d2f-ab9a-056a8874d1f6.png)'
- en: 'The screenshot created is shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的屏幕截图显示在这里：
- en: '![](img/d9395078-a5a6-4dfc-8569-d01a54dd881a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9395078-a5a6-4dfc-8569-d01a54dd881a.png)'
- en: 'The captured screenshot for DVWA application is shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DVWA应用程序的捕获屏幕截图显示在这里：
- en: '![](img/6f7cec96-632d-491f-a3b8-f6340ce0f9ca.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f7cec96-632d-491f-a3b8-f6340ce0f9ca.png)'
- en: It should be noted that we applied the previous method to detect CSRF in only one
    page, just to reduce the execution time and demonstrate the power of the concept.
    However, this can be extended for all web pages of the application. We would be
    required to remove the condition of checking if the fetched URL from the `<a>`
    tag falls in the list: `self.target_links=["vulnerabilities/csrf"]`. Try the same
    approach, removing this condition, and modify the script if needed to see what
    it covers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们只在一个页面上应用了先前的方法来检测CSRF，只是为了减少执行时间并展示概念的威力。然而，这可以扩展到应用程序的所有网页。我们需要删除检查从`<a>`标签中获取的URL是否在列表中的条件：`self.target_links=["vulnerabilities/csrf"]`。尝试相同的方法，删除此条件，并根据需要修改脚本以查看它覆盖了什么。
- en: Clickjacking
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击劫持
- en: '**Clickjacking** is an attack in which the attacker overlays a custom-made
    attack page on a legitimate website or web page. Consider the same scenario as
    mentioned in the case of the CSRF attack. The web page that can delete all the
    users can be made transparent in such a way that the buttons on the page are not
    visible to the user. What is visible, therefore, is an attack page below the transparent
    layer of a legitimate web page. An attacker can craft a web page, for example,
    that displays iPhone offers and that might have a button that says **win iPhone
    now** placed under the transparent button **delete all users**. Thus, when a victim, **the
    admin user,** thinks they are clicking on a win iPhone button, they are actually
    clicking on the transparent button that deletes all users from the database.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击劫持**是一种攻击，攻击者在合法网站或网页上叠加自制的攻击页面。考虑与CSRF攻击案例中提到的相同情景。可以使能够删除所有用户的网页以透明的方式呈现，使用户看不到页面上的按钮。因此，用户看到的是一个透明层下的合法网页的攻击页面。例如，攻击者可以制作一个显示iPhone优惠的网页，可能有一个按钮写着**立即赢取iPhone**，放在透明按钮**删除所有用户**下面。因此，当受害者，**管理员用户**，认为他们点击的是赢取iPhone的按钮时，实际上他们点击的是透明按钮，从数据库中删除所有用户。'
- en: One of the ways for a website to prevent itself from Clickjacking is by implementing
    a special header called X-Frame-Options, which is defined in the following section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 网站防止点击劫持的一种方法是实施一个名为X-Frame-Options的特殊头部，该头部在以下部分中定义。
- en: X-Frame-Options
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X-Frame-Options
- en: 'There is a special HTTP response header called **X-Frame-Options** by which
    a website can state that it should not be rendered inside a frame or iframe. The
    client browser, on receiving this header, checks for the value that is set within
    the frame limit and, based on the value set, appropriate actions are taken. The
    various values are shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网站可以通过特殊的HTTP响应头部**X-Frame-Options**声明不应在框架或iframe中呈现。客户端浏览器在接收到此头部时，检查设置在框架限制内的值，并根据设置的值采取适当的操作。各种值显示在这里：
- en: '**DENY**: This value will prevent the web page from being loaded into a frame
    or iFrame. This is the recommended value to be used.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DENY**：此值将阻止网页加载到框架或iFrame中。这是建议使用的值。'
- en: '**SAMEORIGIN**: This value will only allow the page to be loaded in the frame
    or iframe if the page that is trying to load it into the iframe comes from the
    same origin as the page that is being loaded.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAMEORIGIN**：如果尝试将页面加载到iframe中的页面来自与被加载页面相同的源，则此值将允许页面仅在框架或iframe中加载。'
- en: '**ALLOW-FROM**: This value defines locations that are permitted to load the
    page into a frame or iframe.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALLOW-FROM**：此值定义了允许将页面加载到框架或iframe中的位置。'
- en: Automatically detecting clickjacking with Python
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python自动检测点击劫持
- en: 'Here, we will see an approach that we will use to see if a website is vulnerable
    to clickjacking. We will use a simple Python script that will check whether X-Frame-Options
    is present in the response header rendered by the application. We will call the
    script `CJ_detector.py` and add the following content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一种我们将用来查看网站是否容易受到点击劫持的方法。我们将使用一个简单的Python脚本，检查应用程序渲染的响应头中是否存在X-Frame-Options。我们将调用脚本`CJ_detector.py`并添加以下内容：
- en: '![](img/21e9f24e-ebae-4ab8-9cbb-e3472a0e0793.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21e9f24e-ebae-4ab8-9cbb-e3472a0e0793.png)'
- en: 'We will run the script and see if the DVWA application is protected against
    Clickjacking or not:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行脚本，看看DVWA应用程序是否受到点击劫持的保护：
- en: '![](img/4e8bfe5d-13f7-4f6f-aec8-b5edca533ad8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e8bfe5d-13f7-4f6f-aec8-b5edca533ad8.png)'
- en: SSL stripping (missing HSTS header)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL剥离（缺少HSTS头部）
- en: '**SSL stripping,** or **SSL downgrade,** is an attack vector that downgrades
    an HTTPS connection to HTTP. This attack is carried out by an attacker who is
    between the victim and the web server and acts as a transparent proxy. It further
    maintains a HTTP based downstream connection with the victim and a proper HTTPS
    upstream connection with the server.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL剥离**，或**SSL降级**，是一种将HTTPS连接降级为HTTP的攻击向量。这种攻击是由位于受害者和Web服务器之间的攻击者执行的，并充当透明代理。它进一步与受害者保持基于HTTP的下行连接，并与服务器保持适当的基于HTTPS的上行连接。'
- en: An attack is therefore carried out by the combination of ARP poisoning, SSL
    stripping, and setting up a transparent proxy between the attacker and the victim.
    Let's say that a victim wants to visit a site called `abc.com`. By default, `abc.com` is
    served by the server on HTTPS as `https://www.abc.com`, but when the user types
    the URL in the browser, `abc.com`, the browser sends the request as `http://www.abc.com` to
    the server, which responds with a 302 response and redirects the user to `https://www.abc.com`.
    What's important to note is that the first request from the user browser to the
    server went over plain HTTP, as the user typed `abc.com`. This is what is exploited
    by an attacker using an SSL strip.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，攻击是通过ARP欺骗、SSL剥离和在攻击者和受害者之间设置透明代理的组合来进行的。假设一个受害者想要访问一个名为`abc.com`的网站。默认情况下，`abc.com`由HTTPS服务器提供，如`https://www.abc.com`，但当用户在浏览器中输入URL`abc.com`时，浏览器将请求发送为`http://www.abc.com`到服务器，服务器响应302响应并将用户重定向到`https://www.abc.com`。重要的是要注意，用户浏览器到服务器的第一个请求是通过纯HTTP进行的，因为用户输入了`abc.com`。这就是攻击者使用SSL剥离所利用的。
- en: Consider an attacker who is placed on the same network and who is ARP poisoning
    the victim and router. In this case, the victim request to `abc.com` first comes
    to the attacker. The attacker has a transparent proxy set up from which they can
    forward the request to the actual server. The server responds with a 302 response.
    The attacker proxy sends a request to `https://abc.com` and receives the response,
    which is nothing but a web page. The attacker proxy has an additional capability
    of parsing the whole response, replacing all HTTPS links with plain HTTP, and
    then rendering back a plain page to victim. In the next request, the victim posts
    their credentials, not knowing that the traffic is passing via the attacker.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个放置在同一网络上并且正在ARP欺骗受害者和路由器的攻击者。在这种情况下，受害者对`abc.com`的请求首先到达攻击者。攻击者设置了一个透明代理，可以将请求转发到实际服务器。服务器响应302响应。攻击者代理发送一个请求到`https://abc.com`并接收响应，这只是一个网页。攻击者代理还有一个额外的功能，可以解析整个响应，用纯HTTP替换所有HTTPS链接，然后将一个纯页面呈现给受害者。在下一个请求中，受害者发布他们的凭据，却不知道流量是通过攻击者传递的。
- en: To prevent this kind of attack, the website must include a special header in
    the response they would be sending to the client. This header will be saved in
    the browser preferences and then whenever a connection is made to the website,
    the first request itself will be sent over HTTPS; therefore, making it impossible
    for the attacker to sniff the traffic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种攻击，网站必须在发送给客户端的响应中包含一个特殊的头。这个头将保存在浏览器首选项中，因此每当连接到网站时，第一个请求本身将通过HTTPS发送；因此，使得攻击者无法窃听流量。
- en: '**HTTP Strict Transport Security** (**HSTS**) is a security mechanism using
    which the browser remembers that this host is an HSTS host, and saves the details
    in the browser preferences. Thus, whenever this site is visited again, even if
    the user types `abc.com` in the browser, before releasing the request to the server,
    the browser will convert the request to HTTPS internally as it checks its HSTS
    list and finds the target host or server complaint. If the first request is HTTPS,
    the attacker no window to downgrade the request.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP严格传输安全**（**HSTS**）是一种安全机制，浏览器会记住这个主机是一个HSTS主机，并将详细信息保存在浏览器首选项中。因此，每当再次访问该站点时，即使用户在浏览器中输入`abc.com`，在向服务器释放请求之前，浏览器也会在内部将请求转换为HTTPS，因为它检查其HSTS列表并发现目标主机或服务器投诉。如果第一个请求是HTTPS，攻击者就没有机会降级请求。'
- en: Automatically detecting missing HSTS with Python
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python自动检测缺失的HSTS
- en: 'Here, we will see an approach that we will use in order to identify whether
    the website is vulnerable to clickjacking. We will use a simple Python script
    that will check whether Strict-Transport-Security is present in the response header
    rendered by the application. We will name the script `HSTS_detector.py` and put
    the following content in it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一种方法，我们将使用它来确定网站是否容易受到点击劫持的攻击。我们将使用一个简单的Python脚本来检查应用程序呈现的响应头中是否存在Strict-Transport-Security。我们将命名脚本为`HSTS_detector.py`，并将以下内容放入其中：
- en: '![](img/eca5a805-7183-4545-9e35-5574f75f05e4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eca5a805-7183-4545-9e35-5574f75f05e4.png)'
- en: 'Let''s run the script and see if the application DVWA is protected against
    Clickjacking or not:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行脚本，看看应用程序DVWA是否受到了点击劫持的保护：
- en: '![](img/abcd12ce-31c4-460a-b738-686c049c7c47.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abcd12ce-31c4-460a-b738-686c049c7c47.png)'
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the approaches that we can use to automate our
    web application scanning and assessment with Python. We saw how can we use Python
    to automate the detection of web application vulnerabilities such as XSS, CSRF,
    clickjacking and SSL stripping. All of these can come very handy during a real
    assessment and will help you as pen-testers to get a decent grasp of automating
    things with python.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了我们可以使用的方法来使用Python自动化我们的Web应用程序扫描和评估。我们看到了如何使用Python自动化检测Web应用程序的漏洞，如XSS、CSRF、点击劫持和SSL剥离。所有这些在实际评估中都非常有用，并将帮助您作为渗透测试人员对使用Python自动化事物有一个相当好的掌握。
- en: In the next chapter, we will explore various concepts related to reverse engineering,
    fuzzing, and buffer overflows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨与逆向工程、模糊测试和缓冲区溢出相关的各种概念。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What other application security use cases can be automated with Python?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有哪些应用程序安全用例可以使用Python自动化处理？
- en: How can we use Python to integrate network scanning and web application scanning?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Python集成网络扫描和Web应用程序扫描？
- en: Further reading
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Learning Python web penetration testing: [https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html](https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Python网络渗透测试：[https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html](https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html)
- en: Python for Pentesters: [https://www.pentesteracademy.com/course?id=1](https://www.pentesteracademy.com/course?id=1)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试人员的Python：[https://www.pentesteracademy.com/course?id=1](https://www.pentesteracademy.com/course?id=1)
- en: Penetration Testing Automation Using Python and Kali Linux: [https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux](https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python和Kali Linux进行渗透测试自动化：[https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux](https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux)
