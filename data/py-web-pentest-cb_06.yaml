- en: Chapter 6. Image Analysis and Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 图像分析和操作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Hiding a message by using LSB steganography
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LSB隐写术隐藏消息
- en: Extracting message hidden in LSB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取隐藏在LSB中的消息
- en: Hiding text in image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中隐藏文本
- en: Extracting text from images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像中提取文本
- en: Command and control by using steganography
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用隐写术进行命令和控制
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Steganography is the art of hiding data in plain sight. This can be useful if
    you want to mask your tracks. We can use steganography to evade detection by firewalls
    and IDS. In this chapter, we are going to look at some of the ways in which Python
    can help us to hide data within images. We will go through some basic image steganography
    using the **least significant bit** (**LSB**) to hide our data, and then we will
    create a custom steganography function. The culmination of this chapter will be
    creating a command and control system that uses our specially crafted images to
    communicate data between a server and client.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 隐写术是将数据隐藏在明文中的艺术。如果您想掩盖自己的踪迹，这可能会很有用。我们可以使用隐写术来规避防火墙和IDS的检测。在本章中，我们将看一些Python如何帮助我们在图像中隐藏数据的方法。我们将通过使用**最低有效位**（**LSB**）来隐藏我们的数据，然后我们将创建一个自定义的隐写术函数。本章的最终目标将是创建一个命令和控制系统，该系统使用我们特制的图像在服务器和客户端之间传输数据。
- en: 'The following image is an example of an image that has another hidden within
    it. You can see (or perhaps not see) that it''s impossible for the human eye to
    detect anything:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片是一个在其中隐藏了另一张图片的示例。您可以看到（或者也许看不到）人眼无法检测到任何东西：
- en: '![Introduction](img/B04044_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B04044_06_01.jpg)'
- en: Hiding a message using LSB steganography
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LSB隐写术隐藏消息
- en: In this recipe, we are going to create an image that hides another, using LSB
    steganography methods. This is one of the most common forms of steganography.
    As it's no good just having a means to hide the data, we will also be writing
    a script to extract the hidden data too.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用LSB隐写术方法创建一个隐藏另一个图像的图像。这是隐写术的最常见形式之一。由于仅仅有一种隐藏数据的方法是不够的，我们还将编写一个脚本来提取隐藏的数据。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'All of the image work we will encounter in the chapter will make use of the
    **Python Image Library** (**PIL**). To install the Python image libraries by using
    `PIP` on Linux, use the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中遇到的所有图像工作都将使用**Python图像库**（**PIL**）。要在Linux上使用`PIP`安装Python图像库，请使用以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are installing it on Windows, you may have to use the installers that
    is available at [http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在Windows上安装它，您可能需要使用[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)上可用的安装程序。
- en: Just make sure that you get the right installer for your Python version.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保为您的Python版本获取正确的安装程序。
- en: It is worth noting that PIL has been superseded with a newer version PILLOW.
    But for our needs, PIL will be fine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，PIL已被更新为更新版本的PILLOW。但对于我们的需求，PIL就足够了。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Images are created up by pixels, each of those pixels is made up of red, green,
    and blue (RGB) values (for color images anyway). These values range from 0 to
    255, and the reason for this is that each value is 8 bits long. A pure black pixel
    would be represented by a tuple of (R(0), G(0), B(0)), and a pure white pixel
    would be represented by (R(255), G(255), B(255)). We will be focusing on the binary
    representation of the `R` value for the first recipe. We will be taking the 8-bit
    values and altering the right-most bit. The reason we can get away with doing
    this is that a change to this bit will equate to a change of less than 0.4 percent
    of the red value of pixel. This is way below what the human eye can detect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由像素组成，每个像素由红色、绿色和蓝色（RGB）值组成（对于彩色图像）。这些值的范围是从0到255，之所以如此是因为每个值都是8位长。纯黑色像素将由元组（R（0），G（0），B（0））表示，纯白色像素将由（R（255），G（255），B（255））表示。我们将专注于第一个配方中`R`值的二进制表示。我们将获取8位值并改变最右边的位。我们之所以能够这样做是因为对这一位的更改将导致像素的红色值变化少于0.4％。这远低于人眼可以检测到的范围。
- en: 'Let''s look at the script now, then we will go through how it works later on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看一下脚本，然后我们稍后将介绍它是如何工作的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, we import the `Image` module from `PIL`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从PIL中导入`Image`模块：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we create our `Hide_message` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的`Hide_message`函数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function takes three parameters, which are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受三个参数，如下所示：
- en: '`carrier`: This is the filename of the image that we are using to hide our
    other image in'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`carrier`：这是我们用来隐藏另一张图片的图片的文件名'
- en: '`message`: This is the filename of the image that we are going to hide'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是我们要隐藏的图片的文件名'
- en: '`outfile`: This is the name of the new file that will be generated by our function'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outfile`：这是我们的函数生成的新文件的名称'
- en: 'Next, we open the carrier and message images:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开载体和消息图像：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then manipulate the image that we are going to hide so that it''s the same
    size (width and height) as our carrier image. We also convert the image that we
    are going to hide into pure black and white. This is done by setting the image''s
    mode to `1`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们操纵要隐藏的图像，使其与我们的载体图像具有相同的大小（宽度和高度）。我们还将要隐藏的图像转换为纯黑白。这是通过将图像的模式设置为`1`来完成的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we create a new image and we set the image mode to be RGB and the size
    to be that of the carrier image. We create two variables to hold the values of
    the carrier images width and height and we setup an array; this array will hold
    our new pixel values that we will eventually save into the new image, as shown
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新图像，并将图像模式设置为RGB，大小设置为载体图像的大小。我们创建两个变量来保存载体图像的宽度和高度的值，并设置一个数组；这个数组将保存我们最终保存到新图像中的新像素值，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next comes the main part of our function. We need to get the value of the pixel
    we want to hide. If it's a black pixel, then we will set the LSB of the carriers
    red pixel to `0`, if it's white then we need to set it to `1`. We can easily do
    this by using bitwise operations that uses a mask. If we want to set the LSB to
    `0` we can `AND` the value with `254`, or if we want to set the value to `1` we
    can `OR` the value with `1`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们函数的主要部分。我们需要获取我们想要隐藏的像素的值。如果它是黑色像素，那么我们将设置载体的红色像素的LSB为`0`，如果是白色，则需要设置为`1`。我们可以通过使用位操作来轻松实现这一点。如果我们想将LSB设置为`0`，我们可以使用`AND`值与`254`，或者如果我们想将值设置为`1`，我们可以使用`OR`值与`1`。
- en: 'We loop through all the pixels in the image, and once we have our `newred`
    values, we append these along with the original green and blue values into our
    `new_array`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历图像中的所有像素，一旦我们有了`newred`值，我们将这些值与原始绿色和蓝色值一起附加到我们的`new_array`中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the end of the function, we use the `putdata` method to add our array of
    new pixel values into the new image and then save the file using the filename
    specified by `outfile`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的最后，我们使用`putdata`方法将新像素值数组添加到新图像中，然后使用`outfile`指定的文件名保存文件。
- en: It should be noted that you must save the image as a PNG file. This is an important
    step as PNG is a lossless algorithm. If you were to save the image as a JPEG for
    instance, the LSB values won't be maintained as the compression algorithm that
    JPEG uses will change the values we specified.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，您必须将图像保存为PNG文件。这是一个重要的步骤，因为PNG是一种无损算法。例如，如果您将图像保存为JPEG，LSB值将不会保持不变，因为JPEG使用的压缩算法会改变我们指定的值。
- en: There's more…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We have used the Red values LSB for hiding our image in this recipe; however,
    you could have used any of the RGB values, or even all three. Some methods of
    steganography will split 8 bits across multiple pixels so that each bit will be
    split across RGBRGBRG, and so on. Naturally, if you want to use this method, your
    carrier image will need to be considerably larger than the message you want to
    hide.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用了红色值的LSB来隐藏我们的图像；然而，您可以使用RGB值中的任何一个，甚至全部三个。一些隐写术的方法会将8位分割到多个像素中，以便每个位都会分割到RGBRGBRG等中。自然地，如果您想使用这种方法，您的载体图像将需要比您想要隐藏的消息大得多。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: So, we now have a way of hiding our image. In the following recipe, we will
    look at extracting that message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了一种隐藏我们的图像的方法。在下一个方法中，我们将看看如何提取该消息。
- en: Extracting messages hidden in LSB
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取隐藏在LSB中的消息
- en: This recipe will allow us to extract messages hidden in images by using the
    LSB technique from the preceding recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将允许我们通过使用前面方法中的LSB技术从图像中提取隐藏的消息。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As seen in the previous recipe, we used the LSB of the `Red` value of an RGB
    pixel to hide a black or white pixel from an image that we wanted to hide. This
    recipe will reverse that process to pull the hidden black and white image out
    of the carrier image. Let''s take a look at the function that will do this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的方法所示，我们使用RGB像素的`Red`值的LSB来隐藏我们想要隐藏的图像中的黑色或白色像素。这个方法将颠倒这个过程，从载体图像中提取隐藏的黑白图像。让我们来看看将执行此操作的函数：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'First, we import the `Image` module from the Python image library:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从Python图像库中导入`Image`模块：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we set up the function that we will use to extract the messages. The
    function takes in two parameters: the `carrier` image file name and the filename
    that we want to create with the extracted image:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置将用于提取消息的函数。该函数接受两个参数：`carrier`图像文件名和我们想要用提取的图像创建的文件名：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we create an `Image` object from the `carrier` image. We also create
    a new image for the extracted data; the mode for this image is set to `L` because
    we are creating a grayscale image. We create two variables that will hold the
    width and height of the carrier image. Finally, we set up an array that will hold
    our extracted data values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从`carrier`图像创建一个`Image`对象。我们还为提取的数据创建一个新图像；该图像的模式设置为`L`，因为我们正在创建一个灰度图像。我们创建两个变量来保存载体图像的宽度和高度。最后，我们设置一个数组来保存我们提取的数据值：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, onto the main part of the function: the extraction. We create our `for`
    loops to iterate over the pixels of the carrier. We use the `Image` objects and
    `getpixel` function to return the RGB values of the pixels. To extract the LSB
    from the Red value of a pixel, we use a bitwise mask. If we use a bitwise `AND`
    with the Red value using a mask of `1,` we will get a `0` returned if the LSB
    was `0,` and `1` returned if it was `1`. So, we can put that into an `if` statement
    to create the values for our new array. As we are creating a grayscale image,
    the pixel values range from `0` to `255`, so, if we know the LSB is a `1,` we
    convert it to `255`. That''s pretty much all there is to it. All that''s left
    to do is to use our new images `putdata` method to create the image from the array
    and then save.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入函数的主要部分：提取。我们创建`for`循环来迭代载体的像素。我们使用`Image`对象和`getpixel`函数来返回像素的RGB值。为了从像素的红色值中提取LSB，我们使用位掩码。如果我们使用一个位`AND`与红色值，使用一个掩码`1`，如果LSB是`0`，我们将得到一个`0`，如果是`1`，我们将得到一个`1`。因此，我们可以将其放入一个`if`语句中来创建我们新数组的值。由于我们正在创建一个灰度图像，像素值的范围是`0`到`255`，所以，如果我们知道LSB是`1`，我们将其转换为`255`。基本上就是这样。剩下的就是使用我们新图像的`putdata`方法来从数组创建图像，然后保存。
- en: There's more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: So far, we've looked at hiding one image within another, but there are many
    other ways of hiding different data within other carriers. With this extraction
    function and the previous recipe to hide an image, we are getting closer to having
    something we can use to send and receive commands through messages, but we are
    going to have to find a better way of sending actual commands. The next recipe
    will focus on hiding actual text within an image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了在另一张图像中隐藏一张图像的方法，但还有许多其他隐藏不同数据在其他载体中的方法。有了这个提取函数和之前用于隐藏图像的方法，我们离能够通过消息发送和接收命令的东西更近了，但我们需要找到一个更好的方法来发送实际的命令。下一个方法将专注于在图像中隐藏实际文本。
- en: Hiding text in images
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中隐藏文本
- en: In the previous recipes, we've looked at hiding images within another. This
    is all well and good, but our main aim of this chapter is to pass text that we
    can use in a command and control style format. The aim of this recipe is to hide
    some text within an image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们已经研究了如何在另一个图像中隐藏图像。这都很好，但是我们本章的主要目标是传递我们可以在命令和控制样式格式中使用的文本。这个配方的目的是在图像中隐藏一些文本。
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: So far, we've looked at focusing on the RGB values of a pixel. In PNGs, we can
    access another value, the `A` value. The `A` value of `RGBA` is the transparency
    level of that pixel. In this recipe, we are going to work with this mode, as it
    will allow us to store 8 bits in the LSBs of each value across two pixels. This
    means that we can hide a single `char` value across two pixels, so we will need
    an image that has a pixel count of at least twice the number of characters we
    are trying to hide.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于像素的RGB值。在PNG中，我们可以访问另一个值，即`A`值。`RGBA`的`A`值是该像素的透明度级别。在这个配方中，我们将使用这种模式，因为它将允许我们在每个值的LSB中存储8位。这意味着我们可以在两个像素中隐藏一个单个`char`值，因此我们需要一个像素计数至少是我们要隐藏的字符数量的两倍的图像。
- en: 'Let''s look at the script:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下脚本：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we import the `Image` module from `PIL`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`PIL`中导入`Image`模块：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we set up a helper function that will assist in setting the LSB of the
    value we pass in based on the binary to be hidden:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个辅助函数，它将帮助根据要隐藏的二进制设置传入值的LSB：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are using a bitmask to set the LSB-based on whether the binary value we pass
    in is either a `1` or `0`. If it's a `0,` we use the bitwise `AND` with a mask
    of `254` (11111110), and if it's a `1,` we bitwise `OR` with a mask of `1` (00000001).
    The resulting value is returned from our function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个位掩码来设置LSB，根据我们传入的二进制值是`1`还是`0`。如果是`0`，我们使用掩码`254`（11111110）进行按位`AND`，如果是`1`，我们使用掩码`1`（00000001）进行按位`OR`。函数返回结果值。
- en: 'Next up, we create our main `Hide_message` method that takes three parameters:
    the filename for our carrier image, a string for the message we want to hide,
    and finally, the filename of the image we will create for the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的主要`Hide_message`方法，它接受三个参数：我们的载体图像的文件名，我们想要隐藏的消息的字符串，最后是我们将创建的输出图像的文件名：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next line of code adds the value of `0x00` to the end of our string. This
    will be important in the extraction function as it will let us know that we''ve
    reached the end of the hidden text. We use the `chr()` function to convert `0x00`
    to a string-friendly representation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码将值`0x00`添加到字符串的末尾。这在提取函数中将很重要，因为它将告诉我们已经到达了隐藏文本的末尾。我们使用`chr()`函数将`0x00`转换为友好的字符串表示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following section of the code creates two image objects: one of our carrier
    and one for the output image. For our carrier image, we change the mode to `RGBA`
    to make sure we have the four values per pixel. We then create a few arrays: `pixel_list`
    is all the pixel data from our carrier image and `new_array` will hold all the
    new pixel values for our combined `carrier` and `message` image:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分创建了两个图像对象：一个是我们的载体，另一个是输出图像。对于我们的载体图像，我们将模式更改为`RGBA`，以确保每个像素有四个值。然后我们创建了一些数组：`pixel_list`是来自我们载体图像的所有像素数据，`new_array`将保存我们合并的`carrier`和`message`图像的所有新像素值：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we loop over each character in our message in a `for` loop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`for`循环中循环遍历消息中的每个字符：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We start by converting the character to an `int`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将字符转换为`int`：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then convert that `int` to a binary string, we `zfill` the string to ensure
    that it''s `8` character long. This will make it easier later on. When you use
    `bin(),` it will prefix the string with 0 bits, so the `[2:]` just strips that
    out:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将该`int`转换为二进制字符串，我们使用`zfill`函数确保它有8个字符长。这将使以后更容易。当你使用`bin()`时，它会在字符串前面加上0位，所以`[2:]`只是去掉了它：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we create two pixel variables and populate them. We use the current messages
    character index `*2` for the first of the pixels and the (current messages character
    index `*2`) and `1` for the second. This is because we are using two pixels per
    character:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个像素变量并填充它们。我们使用当前消息字符索引的`*2`作为第一个像素，使用（当前消息字符索引的`*2`）和`1`作为第二个像素。这是因为我们每个字符使用两个像素：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we create two arrays that will hold the values of the hidden data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个将保存隐藏数据值的数组：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that everything is set up, we can start to change the values of the pixel
    data we iterate `4` times (for the `RGBA` values) and call our helper method to
    set the LSB. The `newpix1` function will contain the first 4 bits of our 8-bit
    character; `newpix2` will have the last `4`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了，我们可以开始改变像素数据的值，我们迭代4次（对于RGBA值），并调用我们的辅助方法来设置LSB。`newpix1`函数将包含我们8位字符的前4位；`newpix2`将包含最后4位：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once we have our new values, we will convert them to tuples and append them
    to the `new_array:`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了新的值，我们将把它们转换为元组并附加到`new_array`中：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is an image that describes what we will achieve:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述我们将实现的图像：
- en: '![How it works…](img/B04044_06_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_06_02.jpg)'
- en: 'All that''s left to do is extend the `new_array` method with the remaining
    pixels from our carrier image and then save it using the `filename` parameter
    that was passed in to our `Hide_message` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是用载体图像中剩余的像素扩展`new_array`方法，然后使用传递给我们的`Hide_message`函数的`filename`参数保存它：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As stated at the start of this recipe, we need to make sure that the carrier
    images pixel count is twice the size of our message that we want to hide. We could
    add in a check for this, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本配方开始时所述，我们需要确保载体图像的像素计数是我们要隐藏的消息的两倍大小。我们可以添加一个检查，如下所示：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's pretty much it for this recipe; we can now hide text in an image, and
    also with the previous recipes, we can hide images too. In the next recipe, we
    will extract the text data out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方来说，基本上就是这样；我们现在可以在图像中隐藏文本，而且还可以使用之前的配方隐藏图像。在下一个配方中，我们将提取文本数据。
- en: Extracting text from images
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像中提取文本
- en: In the previous recipe, we saw how to hide text in the `RGBA` values of an image.
    This recipe will let us extract that data out.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们看到了如何隐藏文本在图像的“RGBA”值中。这个配方将让我们提取这些数据。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We saw in the previous recipe that we split up a characters byte into 8 bits
    and spread them over the LSBs of two pixels. Here''s that diagram again as a refresher:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个配方中看到，我们将字符的字节分成8位，并将它们分布在两个像素的LSB上。这里是那个图表，作为提醒：
- en: '![How to do it…](img/B04044_06_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B04044_06_03.jpg)'
- en: 'The following is the script that will do the extraction:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将执行提取的脚本：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, we import the `Image` module from `PIL`; we also import the `izip` module
    from `itertools`. The `izip` module will be used to return pairs of pixels:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`PIL`导入`Image`模块；我们还从`itertools`导入`izip`模块。`izip`模块将用于返回像素对：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create two helper functions. The `get_pixel_pairs` function takes
    in our pixel list and returns the pairs back; as each message character was split
    over two pixels, this makes extraction easier. The other helper function `get_LSB`
    will take in an `R`, `G`, `B`, or `A` value and use a bit mask to get the LSB
    value and return it in a string format:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个辅助函数。`get_pixel_pairs`函数接受我们的像素列表并返回对；由于每个消息字符分布在两个像素上，这使得提取更容易。另一个辅助函数`get_LSB`将接受`R`、`G`、`B`或`A`值，并使用位掩码获取LSB值，并以字符串格式返回它：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have our main `extract_message` function. This takes in the filename
    of our carrier image:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的主要`extract_message`函数。这需要我们载体图像的文件名：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then create an image object from the filename passed in and then create
    an array of pixels from the image data. We also create an empty string called
    `message`; this will hold our extracted text:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从传入的文件名创建一个图像对象，然后从图像数据创建一个像素数组。我们还创建一个名为“message”的空字符串；这将保存我们提取的文本：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we create a `for` loop that will iterate over all of the pixel pairs returned
    using our helper function `get_pixel_pairs;` we set the returned pairs to `pix1`
    and `pix2:`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个“for”循环，它将迭代使用我们的辅助函数“get_pixel_pairs”返回的所有像素对；我们将返回的对设置为“pix1”和“pix2”：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next part of code that we will create is a string variable that will hold
    our binary string. Python knows that it''ll be the binary representation of a
    string by the `0b` prefix. We then iterate over the `RGBA` values in each pixel
    (`pix1` and `pix2`) and pass that value to our helper function, `get_LSB`, the
    value that''s returned is appended onto our binary string:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的代码的下一部分是一个字符串变量，它将保存我们的二进制字符串。Python通过`0b`前缀知道它将是字符串的二进制表示。然后，我们迭代每个像素（`pix1`和`pix2`）中的`RGBA`值，并将该值传递给我们的辅助函数`get_LSB`，返回的值将附加到我们的二进制字符串上：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the preceding code runs, we will get a string representation of the binary
    for the character that was hidden. The string will look like this `0b01100111`,
    we placed a stop character at the end of the message that was hidden that will
    be `0x00`, when this is outputted by the extraction part we need to break out
    of the `for` loop as we know we have hit the end of the hidden text. The next
    part does that check for us:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码运行时，我们将得到一个字符的二进制表示的字符串。字符串看起来像这样`0b01100111`，我们在隐藏的消息末尾放置了一个停止字符，将是`0x00`，当提取部分输出时，我们需要跳出`for`循环，因为我们知道已经到达了隐藏文本的末尾。下一部分为我们进行了检查：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If it''s not our stop byte, then we can convert the byte to its original character
    and append it onto the end of our message string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是我们的停止字节，那么我们可以将字节转换为其原始字符，并将其附加到我们的消息字符串的末尾：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All that's left to do is return the complete message string back from the function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是从函数中返回完整的消息字符串。
- en: There's more…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now that we have our hide and extract functions, we can put them together into
    a class that we will use for the next recipe. We will add a check to test if the
    class has been used by another or if it is being run on its own. The whole script
    looks like the following. The `hide` and `extract` functions have been modified
    slightly to accept an image URL; this script will be used in the C2 example in
    [Chapter 8](ch08.html "Chapter 8. Payloads and Shells"), *Payloads and Shells*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了隐藏和提取函数，我们可以将它们放在一起成为一个类，我们将在下一个配方中使用。我们将添加一个检查，以测试该类是否已被其他类使用，或者是否正在独立运行。整个脚本如下。`hide`和`extract`函数已经稍作修改，以接受图像URL；此脚本将在[第8章](ch08.html
    "第8章. 负载和外壳")的C2示例中使用，*负载和外壳*：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Enabling command and control using steganography
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐写术启用命令和控制
- en: This recipe will show how steganography can be used to control another machine.
    This can be handy if you are trying to evade **Intrusion Detection System** (**IDS**)/firewalls.
    The only traffic that would be seen in this scenario is HTTPS traffic to and from
    the client machine. This recipe will show a basic server and client setup.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示隐写术如何被用来控制另一台机器。如果您试图规避入侵检测系统（IDS）/防火墙，这可能会很方便。在这种情况下，唯一可见的流量是来自客户机的HTTPS流量。这个配方将展示一个基本的服务器和客户端设置。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the image sharing website Imgur to host our images.
    The reason for this is simply that the Python API for Imgur is easy to install
    and simple to use. You could choose to work with another, though. However, you
    will need to create an account with Imgur if you wish to use this script and also
    register an application to get the API Key and Secret. Once this is done, you
    can install the `imgur` Python libraries by using `pip:`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用图像分享网站Imgur来托管我们的图像。这样做的原因很简单，即Imgur的Python API易于安装且易于使用。您也可以选择使用其他网站。但是，如果您希望使用此脚本，您需要在Imgur上创建一个帐户，并注册一个应用程序以获取API密钥和密钥。完成后，您可以使用`pip`安装`imgur`
    Python库：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can register for an account at [http://www.imgur.com](http://www.imgur.com).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.imgur.com](http://www.imgur.com)注册一个帐户。
- en: Once signed up for an account, you can register an app to obtain an API Key
    and Secret from [https://api.imgur.com/oauth2/addclient](https://api.imgur.com/oauth2/addclient).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注册账户后，您可以注册一个应用程序，以从[https://api.imgur.com/oauth2/addclient](https://api.imgur.com/oauth2/addclient)获取API密钥和密钥。
- en: Once you have your imgur account, you'll need to create an album and upload
    an image to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有imgur账户，您需要创建一个相册并将图像上传到其中。
- en: This recipe will also import the full stego text script from the previous recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将从上一个步骤中导入完整的隐写文本脚本。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'The way this recipe works is split into two parts. We will have one script
    that will run and act as a server, and another script that will run and act as
    the client. The basic steps that our scripts will follow is detailed in the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤的工作方式分为两部分。我们将有一个脚本作为服务器运行和操作，另一个脚本作为客户端运行和操作。我们的脚本将遵循的基本步骤如下所述：
- en: The server script is run.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器脚本。
- en: The server waits for the client to announce it's ready.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器等待客户端宣布它已准备就绪。
- en: The client script is run.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行客户端脚本。
- en: The client informs the server that it's ready.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通知服务器它已准备就绪。
- en: The server shows that the client is waiting and prompts user for command to
    send over to client.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器显示客户端正在等待，并提示用户发送到客户端的命令。
- en: The server sends a command.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送一个命令。
- en: The server waits for a response.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器等待响应。
- en: The client receives command and runs it.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端接收命令并运行它。
- en: The client sends output from command back to the server.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送命令的输出回到服务器。
- en: The server receives output from the client and displays it to the user.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收来自客户端的输出并显示给用户。
- en: The steps 5 to 10 are repeated until a `quit` command is sent.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤5到10将重复执行，直到发送`quit`命令。
- en: 'With these steps in mind, let''s take a look first at the server script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些步骤，让我们首先看一下服务器脚本：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the script for our client:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的客户端脚本：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Firstly, we create an `imgur` client object; the authenticate function handles
    getting the `imgur` client authenticated with our account and app. When you run
    the script, it will output a URL to visit to get a pin code to enter. It then
    gets a list of albums for our imgur username. If you haven't created an album
    yet, the script will fail, so make sure you've got an album ready. We will take
    the first album in the list and get a further list of all images contained in
    that album.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`imgur`客户端对象；authenticate函数处理将`imgur`客户端与我们的账户和应用程序进行身份验证。当您运行脚本时，它将输出一个URL，让您访问以获取PIN码输入。然后，它会获取我们的imgur用户名的相册列表。如果您还没有创建相册，脚本将失败，所以请确保您已经准备好相册。我们将获取列表中的第一个相册，并获取该相册中包含的所有图像的进一步列表。
- en: 'The image list is ordered by putting the earliest uploaded image first; for
    our script to work, we need to know the timestamp of the latest uploaded image,
    so we use the `[-1]` index to get it and store it in a variable. When this is
    done, the server will wait for the client to connect:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图像列表按照最早上传的图像排列；为了使我们的脚本工作，我们需要知道最新上传图像的时间戳，所以我们使用`[-1]`索引来获取它并将其存储在一个变量中。完成这些步骤后，服务器将等待客户端连接：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once the server is awaiting a client connection, we can run the client script.
    The initial start of the client script creates an `imgur` client object, just
    like the server, instead of waiting; however, it generates a message and hides
    it in a random image. This message contains the `os` type the client is running
    on (this will make it easier for the server user to know what commands to run),
    a `ready` status, and also an identifier for the client (if you wanted to expand
    on the script to allow multiple clients to connect to the server).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器等待客户端连接，我们就可以运行客户端脚本。客户端脚本的初始启动创建了一个`imgur`客户端对象，就像服务器一样，但不是等待；相反，它生成一条消息并将其隐藏在一个随机图像中。这条消息包含客户端正在运行的`os`类型（这将使服务器用户更容易知道要运行什么命令），一个`ready`状态，以及客户端的标识符（如果您想扩展脚本以允许多个客户端连接到服务器）。
- en: 'Once the image has been uploaded, the `last_message_datetime` function is set
    to the new timestamp:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像上传完成，`last_message_datetime`函数就会设置为新的时间戳：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The server will wait until it sees the message; it does this by using a `while`
    loop and checks for an image datetime later than the one it saved when we fired
    it up. Once it sees there is a new image, it will download it and extract the
    message. It then checks the message to see if it''s the client ready message;
    if it is, then it displays the `uuid` client and `os` type, and it then prompts
    the user for input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将等待直到看到消息；它通过使用`while`循环来做到这一点，并检查比启动时保存的图像日期时间晚的图像。一旦看到有新的图像，它将下载并提取消息。然后检查消息是否是客户端准备好的消息；如果是，它会显示`uuid`客户端和`os`类型，然后提示用户输入：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After the user inputs a command, it''s encoded up by using base32 in order
    to avoid breaking our message string. It''s then hidden in a random image and
    uploaded to imgur. The client is sat in a while loop awaiting this message. The
    start of this loop checks the datetime in the same way our server did; if it sees
    a new image, it checks to see if it''s addressed to this machine using `uuid`,
    and if it is, it will extract the message, convert it into a friendly format that
    `Popen` will accept using `shlex,` and then run the command using `Popen`. It
    then waits for the output from the command before hiding it in a random image
    and uploading it to imgur:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入命令后，它会使用base32对其进行编码，以避免破坏我们的消息字符串。然后将其隐藏在一个随机图像中，并上传到imgur。客户端坐在一个循环中等待这条消息。这个循环的开始方式与我们的服务器相同；如果它看到一个新的图像，它会检查是否使用`uuid`寻址到这台机器，如果是，它将提取消息，将其转换为`Popen`将接受的友好格式，然后使用`Popen`运行命令。然后等待命令的输出，然后将其隐藏在一个随机图像中并上传到imgur：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All that's left for the server to do is get the new image, extract the hidden
    output, and display it to the user. It then gives a new prompt and awaits the
    next command. That's it; it is a very simple way of passing command and control
    data over steganography.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器所需做的就是获取新图像，提取隐藏的输出，并将其显示给用户。然后它会给出一个新的提示，等待下一个命令。就是这样；这是一种非常简单的通过隐写术传递命令和控制数据的方法。
