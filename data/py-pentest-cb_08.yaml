- en: Scapy Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy基础知识
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating a packet with Scapy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy创建数据包
- en: Sending and receiving packets with Scapy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy发送和接收数据包
- en: Layering a packet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层数据包
- en: Reading and writing to a PCAP file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入PCAP文件
- en: Sniffing packets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嗅探数据包
- en: ARP man-in-the-middle tool with Scapy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy创建ARP中间人工具
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Scapy is a powerful Python module for packet manipulation. It can decode and
    create packets for a wide variety of protocols. Scapy can be used for scanning,
    probing, and network discovery tasks inside Python programs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy是一个强大的Python模块，用于数据包操作。它可以解码和创建各种协议的数据包。Scapy可用于扫描、探测和网络发现任务。
- en: Creating a packet with Scapy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy创建数据包
- en: As we know, the basic unit of network communication is a packet. So we can start
    by creating a packet with Scapy. Scapy creates packets in layers; each layer is
    nested inside its parent layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，网络通信的基本单元是数据包。因此，我们可以通过使用Scapy创建数据包来开始。Scapy以层的形式创建数据包；每个层都嵌套在其父层内。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we require a Scapy module to be installed in the environment, make sure
    to install it with the `pip` command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在环境中安装Scapy模块，请确保使用`pip`命令安装它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installation, make sure it''s working by issuing the `scapy` command
    in your Terminal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，请确保通过在终端中发出`scapy`命令来检查它是否正常工作：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will open up an interactive Terminal for Scapy. You can also use this
    for basic debugging of Scapy scripts. A list of all the protocols supported by
    Scapy is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个交互式的Scapy终端。您还可以使用它来对Scapy脚本进行基本调试。Scapy支持的所有协议的列表如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00037.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'Similarly, we can get the details and parameters in each protocol, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以按以下方式获取每个协议中的详细信息和参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/00038.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Following are the steps to create packets with the `scapy` module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scapy`模块创建数据包的步骤：
- en: Create a new file called `scapy-packet.py` and open it in your editor.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scapy-packet.py`的新文件，并在编辑器中打开它。
- en: 'As usual, import the `scapy` module and `pprint` for better readable printing:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，导入`scapy`模块和`pprint`以获得更好的可读性打印：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Packets are crafted by defining the packet headers for each protocol layer
    of TCP/IP and stacking them in the correct order. So, we can create the first
    layer of a TCP packet with the following:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义TCP/IP每个协议层的数据包头并按正确顺序堆叠它们来制作数据包。因此，我们可以通过以下方式创建TCP数据包的第一层：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we can create the IP layer of the packet, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以创建数据包的IP层，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As it''s the network layer, we have to pass the destination IP as the parameter.
    Scapy accepts different IP notations, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是网络层，我们必须将目的地IP作为参数传递。Scapy接受不同的IP表示法，如下所示：
- en: 'Plain dotted-quad notation:'
  id: totrans-33
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通的点分十进制表示法：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'CIDR notation:'
  id: totrans-35
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIDR表示法：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Hostnames:'
  id: totrans-37
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, we can set multiple destinations by passing the destinations as a list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过将目的地作为列表传递来设置多个目的地：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, we can create the transport layer. In our case, it is a TCP layer.
    We can create it as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以创建传输层。在我们的情况下，它是一个TCP层。我们可以按以下方式创建它：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here we pass the destination port and the flag is set to `S` for a SYN packet.
    We can also pass the destination ports as a list for creating multiple packets:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递目的地端口，并将标志设置为`S`以进行SYN数据包。我们还可以将目的地端口作为列表传递以创建多个数据包：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next we can stack these layers with the `/` operator:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`/`运算符堆叠这些层：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can check the packets generated by printing them with `pprint`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用`pprint`打印它们来检查生成的数据包：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also use `ls()` to inspect a packet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ls()`来检查数据包：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another option to get the packet details is the `show()` method in the packet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据包详细信息的另一个选项是数据包中的`show()`方法：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can create a single packet with a script. The script will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用脚本创建一个单个数据包。脚本如下：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create a TCP/IP packet with the SYN flag set, the destination address [https://rejahrehim.com/](https://rejahrehim.com/),
    and the destination port `80`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有SYN标志的TCP/IP数据包，目的地地址为[https://rejahrehim.com/](https://rejahrehim.com/)，目的地端口为`80`。
- en: 'Now run the script with the `sudo` permission:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以`sudo`权限运行脚本：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00039.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Here we can see that `scapy` has identified the source IP as the local IP, and
    automatically added those details to the packet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`scapy`将源IP识别为本地IP，并自动将这些详细信息添加到数据包中。
- en: 'As you will have noticed, the first line of the response is a warning message
    saying `No route found for IPV6 destination`. We can avoid these less important
    messages by using the `logger` module. To do this, import and set the logging
    level to `ERROR` (which will only print the error messages) before importing Scapy.
    This can be achieved by adding the following lines at the top of the script. This
    step is applicable to all recipes that use the `scapy` module:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，响应的第一行是一个警告消息，说`未找到IPV6目标的路由`。我们可以通过使用`logger`模块来避免这些不太重要的消息。为此，在导入Scapy之前，导入并将日志级别设置为`ERROR`（仅打印错误消息）。可以通过在脚本顶部添加以下行来实现这一步骤。这一步骤适用于所有使用`scapy`模块的配方：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sending and receiving packets with Scapy
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy发送和接收数据包
- en: We have already created some packets in the previous recipe. Now we can send
    and receive those packets with Scapy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一篇文章中创建了一些数据包。现在我们可以使用Scapy发送和接收这些数据包。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Following are the methods to send and receive packets with `scapy` module:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scapy`模块发送和接收数据包的方法：
- en: 'Make sure to import the required modules:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保导入所需的模块：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use the `send()` function to send packets at layer 3\. In this case,
    Scapy will handle the routing and layer 2 within it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`send()`函数在第3层发送数据包。在这种情况下，Scapy将处理其内部的路由和第2层：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will send an ICMP packet
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送一个ICMP数据包
- en: 'To send a packet with custom layer 2, we have to use the `sendp()` method.
    Here we have to pass the interface to be used for sending the packet. We can provide
    it with the `iface` parameter. If this is not provided, it will use the default
    value from `conf.iface`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送带有自定义第2层的数据包，我们必须使用`sendp()`方法。在这里，我们必须传递要用于发送数据包的接口。我们可以使用`iface`参数提供它。如果未提供此参数，它将使用`conf.iface`的默认值：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To send a packet and receive a response, we have to use the `sr()` method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送一个数据包并接收响应，我们必须使用`sr()`方法：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use the `sr1()` method to send a packet or group of packets, and to
    record only the first response:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`sr1()`方法发送一个数据包或一组数据包，并且只记录第一个响应：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similarly, we can use `srloop()` to loop the process of sending stimulus packets,
    receive the response, and print them.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`srloop()`来循环发送刺激数据包的过程，接收响应并打印它们。
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Layering packets
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层数据包
- en: In Scapy, each packet is a collection of nested dictionaries, as Scapy uses
    Python dictionaries as the data structure for packets. Starting from the lowest
    layer, each layer will be a child dictionary of the parent layer. Also, each and
    every field inside the layer of a packet is a key value pair inside the dictionary
    for that layer. So, we can make changes in this field using the assignment operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scapy中，每个数据包都是嵌套字典的集合，因为Scapy使用Python字典作为数据包的数据结构。从最底层开始，每个层都将是父层的子字典。此外，数据包中每个层的每个字段都是该层字典中的键值对。因此，我们可以使用赋值操作更改此字段。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the layering in Scapy, we can go through the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Scapy中的分层，可以按照以下步骤进行：
- en: 'We can get the details of a packet and its layered structure using the `show()`
    method. We can use the interactive Terminal for inspecting and determining more
    about each packet''s structure. Open up the Terminal and type the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`show()`方法获取数据包及其分层结构的详细信息。我们可以使用交互式终端检查和确定有关每个数据包结构的更多信息。打开终端并输入以下内容：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, create a packet and show its details, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个数据包并显示其详细信息，如下所示：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then it will print out the structure of the packet we created:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将打印出我们创建的数据包的结构：
- en: '![](img/00040.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: Even if we don't provide the source addresses, Scapy automatically assigns the
    source address.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不提供源地址，Scapy也会自动分配源地址。
- en: 'We can get the summary of a packet using the `summary()` method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`summary()`方法获取数据包的摘要：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/00041.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: 'We can get each layer of a packet through its list index or its name:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过列表索引或名称获取数据包的每个层：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Both will print the details of the TCP layer, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都将打印TCP层的详细信息，如下所示：
- en: '![](img/00042.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: 'Similarly, we can get each field inside the layers. We can get the destination
    IP address of a packet, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以获取每个层内的每个字段。我们可以获取数据包的目标IP地址，如下所示：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/00043.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: 'We can test the existence of a specific layer with the `haslayer()`method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`haslayer()`方法测试特定层是否存在：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similarly, can get a specific layer with the `getlayer()` method
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以使用`getlayer()`方法获取特定层
- en: 'We can use the Scapy `sniff()` function to sniff the network and the filter
    argument to get a specific type of packet from the sniffed packets:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Scapy的`sniff()`函数嗅探网络，并使用过滤参数从嗅探到的数据包中获取特定类型的数据包：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reading and writing to pcap files
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入pcap文件
- en: The pcap files are used to save the captured packets for later use. We can read
    packets from a pcap file and write them to a pcap file using Scapy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: pcap文件用于保存捕获的数据包以供以后使用。我们可以使用Scapy从pcap文件中读取数据包并将其写入pcap文件。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can write a script to read and write pcap files with Scapy as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个脚本来使用Scapy读取和写入pcap文件，如下所示：
- en: 'We can import the pcap file to Scapy, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤将pcap文件导入到Scapy中：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can iterate and work with the packets as we did for the created packets:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像处理创建的数据包一样迭代和处理数据包：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also manipulate the packets during the import itself. If we want to
    change the destination and source MAC address of the packets in the captured pcap
    file, we can do it while importing, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在导入过程中操纵数据包。如果我们想要更改捕获的pcap文件中数据包的目标和源MAC地址，我们可以在导入时进行，如下所示：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we define a new function, `changePacketParameters(),` to iterate through
    each packet, and update its source and destination MAC addresses inside the Ethernet
    layer. Also, we will call that function inside the `sniff()` section as `prn`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个新函数`changePacketParameters()`，用于迭代每个数据包，并在以太网层内更新其源和目标MAC地址。此外，我们将在`sniff()`部分内调用该函数作为`prn`。
- en: 'We can export packets to a pcap file with the `wrpcap()` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`wrpcap()`函数将数据包导出到pcap文件：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also filter the packets that we will write into a pcap file with Scapy:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用Scapy过滤要写入pcap文件的数据包：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can replay the packets captured in the pcap file with the `sendp()` method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`sendp()`方法重放pcap文件中捕获的数据包：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can read and replay the packets with one line of code in Scapy:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一行代码在Scapy中读取和重放数据包：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sniffing packets
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗅探数据包
- en: Scapy has a `sniff()` function that we can use for getting packets from the
    network. But Scapy's built-in `sniff()` function is a bit slow and may skip some
    packets. It is better to use `tcpdump` when the sniffing speed is important.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy有一个`sniff()`函数，我们可以用它来从网络中获取数据包。但是Scapy内置的`sniff()`函数速度有点慢，可能会跳过一些数据包。当嗅探速度很重要时，最好使用`tcpdump`。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to write a sniffer with `scapy` module:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scapy`模块编写嗅探器的步骤：
- en: Create a file called `scapy-sniffer.py` and open it with your editor.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scapy-sniffer.py`的文件并用编辑器打开它。
- en: 'As usual, import the required modules for the script:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，为脚本导入所需的模块：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, define the variables required. Here we need to define the `interface`
    to sniff:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义所需的变量。这里我们需要定义要嗅探的`interface`：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can get the `interface` to be used with the help of the `ifconfig` command
    in Linux and macOS:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Linux和macOS中的`ifconfig`命令获取要使用的`interface`：
- en: '![](img/00044.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'Now we can write a function to handle the sniffed packets, which will be provided
    as the callback function for the sniffer:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个函数来处理嗅探到的数据包，这将作为嗅探器的回调函数提供：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we get the source and destination IP of all the DNS packets, and extract
    the domain for those DNS packet
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取所有DNS数据包的源和目的地IP，并提取这些DNS数据包的域
- en: 'Now we can use the `sniff()` method to start sniffing and passing the packet
    to the callback function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`sniff()`方法开始嗅探并将数据包传递给回调函数：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will start sniffing for the packets from the interface specified in the
    variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始嗅探来自变量中指定的接口的数据包。
- en: 'Now we can start the script with the `sudo` permission:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`sudo`权限启动脚本：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00045.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: 'We can print the `payload` in the sniffed packet as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按如下方式打印嗅探到的数据包中的`payload`：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ARP man-in-the-middle tool with Scapy
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy进行ARP中间人工具
- en: A man-in-the-middle attack means that the attacker sits between the source and
    destination to pass all the data through the attacking system. This will allow
    the attacker to view the victim's activities. We can write a small script in Python
    with the help of Scapy to run a man-in-the-middle attack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 中间人攻击意味着攻击者坐在源和目的地之间，通过攻击系统传递所有数据。这将允许攻击者查看受害者的活动。我们可以借助Scapy编写一个小型的Python脚本来运行中间人攻击。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For better understanding we can write a script, following the steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们可以编写一个脚本，按照以下步骤：
- en: Create a new file named `mitm-scapy.py` and open it in your editor.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mitm-scapy.py`的新文件，并在编辑器中打开它。
- en: 'As usual, import the required module:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，导入所需的模块：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we import Scapy along with the `os`, `time`, and `sys` modules, which are
    required in the script.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入Scapy以及所需的`os`、`time`和`sys`模块，这些模块在脚本中是必需的。
- en: 'Now we have to define the variables for the script. We can get the variable
    details with the `raw_input` method in Python 2.x or `input()` in Python 3.x,
    rather than defining it in the script:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须为脚本定义变量。我们可以使用Python 2.x中的`raw_input`方法或Python 3.x中的`input()`来获取变量的详细信息，而不是在脚本中定义它：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we have to get the MAC addresses of the source and destination to craft
    an ARP response, we will request both with an ARP request and parse the response
    to get the MAC addresses. Now we have to create a function to get the MAC addresses:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们必须获取源和目的地的MAC地址以构建ARP响应，我们将使用ARP请求请求两者，并解析响应以获取MAC地址。现在我们必须创建一个函数来获取MAC地址：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will return the MAC address of the IP provided while calling this function
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回调用此函数时提供的IP的MAC地址
- en: 'Now we will create a function to toggle the IP forwarding. This is different
    for Linux and macOS:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个函数来切换IP转发。这在Linux和macOS上是不同的：
- en: 'For macOS:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于macOS：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For Linux:'
  id: totrans-164
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Linux：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we have to write another function to re-establish the connection between
    the victim and the source. This is to make sure that the interception is not identified
    by the victim:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须编写另一个函数来重新建立受害者和源之间的连接。这是为了确保受害者不会发现拦截：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this function, we first get the MAC addresses of both the source and the
    destination using the function we wrote: `getMAC()`. Then, we will send requests
    to the source as if was from the destination. Also, we will send requests to the
    destination as if it was from the source. Finally, we reset the IP forwarding
    with the function we wrote: `setIPForwarding()`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先使用我们编写的`getMAC()`函数获取源和目的地的MAC地址。然后，我们将发送请求到源，就好像是来自目的地。此外，我们将发送请求到目的地，就好像是来自源。最后，我们将使用我们编写的`setIPForwarding()`函数重置IP转发
- en: 'Now we will do the actual attack. For that we will write a function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将进行实际攻击。为此，我们将编写一个函数：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will send the packet to both the source and destination, indicating that
    our interface is the destination of the source and the source for the destination
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把数据包发送到源和目的地，指示我们的接口是源的目的地和目的地的源
- en: 'Next, we have to set a callback function to parse the sniffed packets from
    the interface:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置一个回调函数来解析从接口嗅探到的数据包：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we will define the `main()` function to call the attack:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义`main()`函数来调用攻击：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will create an infinite loop to set the attack and sniff the packets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个无限循环来设置攻击并嗅探数据包。
