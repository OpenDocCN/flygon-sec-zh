- en: Password Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码测试
- en: In [Chapter 4](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80), *Resources
    Discovery*, we learned how to write a basic web application, BruteForcer, to help
    us with resources discovery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80)，*资源发现*中，我们学习了如何编写一个基本的Web应用程序BruteForcer来帮助我们进行资源发现。
- en: 'In this chapter, we''re going to learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: How password attacks work
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码攻击的工作原理
- en: Our first password BruteForcer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个密码破解器
- en: Adding support for digest authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持摘要身份验证
- en: Form-based authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表单的身份验证
- en: How password attacks work
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码攻击的工作原理
- en: In this section, we're going to take a look at what password cracking is; it
    is also known as password testing. We will cover the different approaches we can
    take when doing password cracking and finally, we're going to learn about password
    policies and account locking, which is important when planning a password attack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看密码破解是什么；它也被称为密码测试。我们将介绍进行密码破解时可以采取的不同方法，最后，我们将学习密码策略和帐户锁定，这在计划密码攻击时很重要。
- en: Password cracking
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码破解
- en: Password cracking is the most common type of brute force attack against web
    applications. It is an attack against the login credentials, and it exploits the
    fact that passwords are usually weak, due to the fact that users need to remember
    them and they need a difficult-to-guess word.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 密码破解是针对Web应用程序的最常见的暴力攻击类型。这是对登录凭据的攻击，它利用了密码通常较弱的事实，因为用户需要记住它们并且需要一个难以猜测的单词。
- en: Password cracking is usually done with a dictionary of known words, or more
    exactly, with a list of well-known and widely used passwords. These lists are
    created by taking the most used passwords from the list of passwords leaked from
    different online services. Password lists may also include variations of words,
    such as those generated by replacing letters with numbers such as O with zero,
    and I with one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 密码破解通常使用已知单词的字典，或者更确切地说，使用广泛使用的密码列表。这些列表是通过从不同在线服务的密码泄露列表中获取最常用的密码而创建的。密码列表还可能包括单词的变体，例如通过用数字替换字母生成的变体，比如用零替换O，用一替换I。
- en: 'When we plan a password attack, we have different options as to how to do it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计划进行密码攻击时，我们有不同的选择：
- en: '**Vertical scanning**: The most common and most used is vertical scanning,
    which takes one username and tries all passwords in the dictionary.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直扫描**：最常见且最常用的是垂直扫描，它使用一个用户名并尝试字典中的所有密码。'
- en: '**Horizontal scanning**: This is basically the opposite of vertical scanning.
    It takes a password and tests it against all usernames. This is usually done in
    order to prevent account locking after many invalid login attempts.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扫描**：这基本上是垂直扫描的相反。它使用一个密码并对所有用户名进行测试。通常这样做是为了防止在多次无效登录尝试后锁定帐户。'
- en: '**Diagonal scanning**: This mixes a different username and password each time,
    reducing the possibility of the user being detected or blocked.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对角线扫描**：每次混合不同的用户名和密码，减少用户被检测或阻止的可能性。'
- en: '**Three-dimensional scanning**: Sometimes, diagonal scanning is not enough,
    and we need to go further in order to prevent detection. This is when three-dimensional
    scanning comes into play. This is a combination of horizontal, vertical, or diagonal,
    but in this case, we have multiple machines that we can launch our request on
    or HTTP proxies that will allow us to use different source IPs for each request.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维扫描**：有时，对角线扫描不够，我们需要进一步防止被检测。这就是三维扫描发挥作用的时候。这是水平、垂直或对角线的组合，但在这种情况下，我们有多台机器可以在上面启动我们的请求，或者HTTP代理可以允许我们为每个请求使用不同的源IP。'
- en: '**Four-dimensional scanning**: This adds a time delay per request on top of
    source IP rotation or distribution.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四维扫描**：这在源IP旋转或分发的基础上增加了每个请求的时间延迟。'
- en: Password policies and account locking
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码策略和帐户锁定
- en: A password policy is a set of rules designed to enhance computer security by
    encouraging users to employ strong passwords and use them properly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略是一组旨在通过鼓励用户使用强密码并正确使用它们来增强计算机安全性的规则。
- en: The password policy may either be advisory or mandated, such as via technical
    means, like forcing it at the time of account creation or when the password needs
    to be changed. The password policy can dictate the length of passwords, case sensitivity,
    mix of lower and upper case, characters allowed, characters, numbers and symbols,
    reuse of past passwords, how many previous passwords you can't use, blacklisted
    passwords, and very easy-to-guess words and combinations such as **password** and
    **123456**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略可以是建议性的，也可以是强制性的，例如通过技术手段，比如在帐户创建时强制执行，或者在需要更改密码时强制执行。密码策略可以规定密码的长度、大小写敏感性、小写和大写字母的混合、允许的字符、数字和符号、过去密码的重复使用、不能使用的先前密码数量、黑名单密码，以及非常容易猜测的单词和组合，如**password**和**123456**。
- en: Also, the password policy can define things such as how frequently you need
    to change your password and whether to lock the account after X number of wrong
    attempts. So, now we understand how a password policy works. We have to be careful
    when we launch a password cracking test, because we can end up blocking thousands
    of accounts, and that could mean the end of the penetration test and some problems
    for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，密码策略还可以定义诸如需要多频繁更改密码以及在X次错误尝试后锁定帐户等事项。因此，现在我们了解了密码策略的工作原理。当我们启动密码破解测试时，我们必须小心，因为我们可能会封锁数千个帐户，这可能意味着渗透测试的结束和一些问题。
- en: This is illegal to perform without authorization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 未经授权进行此操作是非法的。
- en: Our first password BruteForcer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个密码破解器
- en: In this section, we're going to look at what basic authentication is, how it
    works, and then we're going to create our first password BruteForcer for this
    method. Finally, we're going to test the script against our victim web application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看基本身份验证是什么，它是如何工作的，然后我们将为这种方法创建我们的第一个密码破解器。最后，我们将对我们的受害者Web应用程序测试脚本。
- en: Basic authentication
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: 'Basic authentication is one of the simplest techniques for enforcing access
    control to web application resources. It is implemented by adding special HTTP
    headers which is insecure by design, as the credentials are being sent encoded
    with the Base64 method. Encoded means that it can be reversed easily. For example,
    we can see what a basic authentication header looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证是强制访问控制到Web应用程序资源的最简单的技术之一。它通过添加特殊的HTTP头来实现，这是不安全的，因为凭据被使用Base64方法编码后发送。编码意味着它可以很容易地被反转。例如，我们可以看到基本身份验证头是什么样子的：
- en: '![](img/00050.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: The encoded string can be decoded and we found that the password being sent
    is equal to `admin123`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编码字符串可以被解码，我们发现发送的密码等于`admin123`。
- en: Usually, when you see a string that ends in equals, it could be a base64 encoding
    string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你看到以等号结尾的字符串时，它可能是一个base64编码的字符串。
- en: Creating the password cracker
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建密码破解器
- en: 'Let''s create our password cracker:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的密码破解器：
- en: Let's go back to the Atom editor and open the `back2basics.py` file. In `Section-5`,
    we can see that in the `import` area, we don't have anything new, and the structure
    of the script is pretty similar to the previous one.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到Atom编辑器，打开`back2basics.py`文件。在`Section-5`中，我们可以看到在`import`区域，我们没有任何新的内容，脚本的结构与之前的相似。
- en: 'We have the `start` function that will show the `banner`, and it will pass
    the command line and read the parameters—the same parameters, except we have the
    `user` parameter now. Then, it will invoke the function `launcher_thread` with
    the variables `passwords`, `threads`, `user`, and `url`, which correspond to the
    dictionary of passwords, the number of threads, the username to be used, and the
    target URL:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个`start`函数，它将显示`banner`，并传递命令行并读取参数——相同的参数，除了现在有`user`参数。然后，它将使用变量`passwords`、`threads`、`user`和`url`调用函数`launcher_thread`，这些变量对应于密码字典、线程数、要使用的用户名和目标URL：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in `launcher_thread`, we have a `while` loop that will continue until
    we don''t have any words left in the array passwords:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`launcher_thread`中，我们有一个`while`循环，直到密码数组中没有任何单词为止：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, for every word in the array, we do a `pop`, then we instantiate the `request_performer`
    class with the `n`, the `username`, and the `url`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于数组中的每个单词，我们都执行`pop`，然后用`n`、`username`和`url`实例化`request_performer`类。
- en: 'In `request_performer`, we define some attributes to the object, and then we
    execute the GET request:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`request_performer`中，我们为对象定义了一些属性，然后执行GET请求：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The important bit here is the `auth` parameter, which tells requests to use
    basic authentication with the provided username and password.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的部分是`auth`参数，它告诉请求使用提供的用户名和密码进行基本身份验证。
- en: Then, if the status is `200`, we print that the password was found and used.
    We use the variable `hit` in order to determine if we found a valid password and
    to stop sending requests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果状态是`200`，我们打印出找到并使用的密码。我们使用变量`hit`来确定是否找到了有效密码，并停止发送请求。
- en: That's it; now, we have our first basic authentication BruteForcer. Let's try
    it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；现在，我们有了我们的第一个基本身份验证暴力破解器。让我们试试看。
- en: Before running it, remember the previous section, when we discovered different
    directories, and there was one that returned the status code of 401? This means
    that it is requesting authentication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，记住上一节，当我们发现不同的目录时，有一个返回状态码401的目录？这意味着它正在请求身份验证。
- en: 'The directory was `/Admin`, and when we try to access it, we can see the authentication
    popup:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目录是`/Admin`，当我们尝试访问它时，我们可以看到身份验证弹出窗口：
- en: '![](img/00051.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'Let''s go to the Terminal. We''re going to run it with the following command
    line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去终端。我们将使用以下命令行运行它：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is very simple, but this is only for demonstration purposes. We can see
    that the password for the user `admin` is `administrator` in this case:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但这只是为了演示目的。我们可以看到在这种情况下用户`admin`的密码是`administrator`：
- en: '![](img/00052.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'Let''s try it on the website. You will be able to see that it works:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在网站上试试看。你会看到它是有效的：
- en: '![](img/00053.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: Now, you know how to perform a basic authentication password test in web applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何在Web应用程序中执行基本身份验证密码测试了。
- en: Adding support for digest authentication
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对摘要身份验证的支持
- en: In this section, we're going to start learning about what digest authentication
    is. Then, we're going to modify our password BruteForcer to support this method,
    and finally, we're going to test the new script against our test web application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将开始学习摘要身份验证是什么。然后，我们将修改我们的密码破解器以支持这种方法，最后，我们将测试新脚本对我们的测试Web应用程序的效果。
- en: What is digest authentication?
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是摘要身份验证？
- en: 'Digest authentication is a more secure option to basic authentication. It uses
    MD5 to do the hashing of the username and password plus a nonce. The **nonce**
    is used to prevent replay attacks, and it is sent by the server after the user
    requests a protected resource. The browser creates the response with the following
    code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要身份验证是基本身份验证的更安全选项。它使用MD5对用户名和密码加上一个随机数进行哈希处理。**随机数**用于防止重放攻击，并在用户请求受保护的资源后由服务器发送。浏览器使用以下代码创建响应：
- en: '![](img/00054.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Finally, the response is an **MD5** hash of **HA1** nonce **HA2**. The realm
    value defines a protection space. If the credentials work for a page in one realm,
    they will also work for other pages in that same realm. Now, let's add support
    for digest to our script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应是**HA1**随机数**HA2**的**MD5**哈希。领域值定义了一个保护空间。如果凭据适用于一个领域中的页面，它们也将适用于该领域中的其他页面。现在，让我们为我们的脚本添加对摘要的支持。
- en: Adding digest authentication to our script
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将摘要身份验证添加到我们的脚本中
- en: 'Let''s go back to our editor and open the `back2digest.py` file. We added a
    few lines to include support for digest authentication. First, we added this import:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的编辑器，打开`back2digest.py`文件。我们添加了几行以支持摘要身份验证。首先，我们添加了这个导入：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code allows us to select the authentication. In a `request_performer`,
    we need to add a condition to check if the user chose to run a `digest` authentication
    attack or `basic`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许我们选择身份验证。在`request_performer`中，我们需要添加一个条件来检查用户是否选择运行`digest`身份验证攻击还是`basic`：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We specify the different methods in the request instantiation. In the case of
    `digest`, it is slightly different as we need to specify `HTTPDigestAuth` in the
    `auth` parameter. Also, we need to add in the `start` function the handler of
    the new parameter, we add the `-m` in the `getopt` function, the new parameter
    that will manage the type of authentication method. And we'll add it to every
    function as a variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在请求实例化中指定不同的方法。在`digest`的情况下，稍有不同，因为我们需要在`auth`参数中指定`HTTPDigestAuth`。此外，我们需要在`start`函数中添加新参数的处理程序，在`getopt`函数中添加`-m`，新参数将管理身份验证方法的类型。然后我们将它添加到每个函数作为变量。
- en: That's it. We should be able to test against the digest-protected resource.
    Let's do it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们应该能够针对受摘要保护的资源进行测试。让我们试试看。
- en: 'Let''s go back to the Terminal but first, let''s check the resource `backoffice`
    that we found in the `robot.txt`. We can see that it needs authentication, and
    to the user it is exactly the same as basic authentication:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到终端，但首先，让我们检查`robot.txt`中找到的资源`backoffice`。我们可以看到它需要身份验证，并且对用户来说与基本身份验证完全相同：
- en: '![](img/00055.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: 'Let''s look at the headers of the response that the server sent us. Click on
    the Open menu option on the right-hand side of the Mozilla browser, select Developer |
    Network, and then click on the Reload button. Cancel the Authentication Required
    window and select the row as shown in the following screenshot. We can see that
    there is a WWW- Authenticate header with a `Digest realm` parameter, the `nonce`,
    and the `algorithm= MD5`. So let''s go to the console to run our script:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看服务器发送给我们的响应的标头。单击Mozilla浏览器右侧的打开菜单选项，选择Developer | Network，然后单击Reload按钮。取消所需的身份验证窗口，然后选择如下屏幕截图所示的行。我们可以看到有一个带有`Digest
    realm`参数的WWW- Authenticate标头，`nonce`和`algorithm= MD5`。所以让我们去控制台运行我们的脚本：
- en: '![](img/00056.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: 'Let''s run it against the directory back office. We run the `back2digest.py`
    with the same parameters as before, but we change the resource to `/backoffice`
    instead of `/admin`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对后台目录运行它。我们使用与之前相同的参数运行`back2digest.py`，但是我们将资源更改为`/backoffice`而不是`/admin`：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We change the user to `administrator`, we keep `5` threads and the same dictionary, `pass.text`,
    and finally, a new parameter method indicating `digest`, and we run it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户更改为`administrator`，保持`5`个线程和相同的字典`pass.text`，最后，指示`digest`的新参数方法，然后运行它：
- en: '![](img/00057.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: No luck this time. None of the combinations were valid; maybe the user doesn't
    exist. Let's try another user, `admin` for example. Let's run it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有运气。没有一个组合是有效的；也许用户不存在。让我们尝试另一个用户，例如`admin`。让我们运行它。
- en: 'Great, we found the password for the user `admin`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们找到了用户`admin`的密码：
- en: '![](img/00058.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: 'Let''s try this in the browser now. Set the User Name as `admin`, and Password
    as `admin123`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在浏览器中尝试一下。将用户名设置为`admin`，密码设置为`admin123`：
- en: '![](img/00059.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: Perfect, we're in. Not much to see in here. Now you have your password BruteForcer
    that can do basic and digest authentication. Congratulations! Let's continue adding
    more functionalities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，我们成功了。这里没有太多可看的。现在你有了可以进行基本和摘要身份验证的密码破解器。恭喜！让我们继续添加更多功能。
- en: Form-based authentication
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于表单的身份验证
- en: In this section, we're going to learn how to brute force form-based authentication
    in web applications. We're going to start learning what form-based authentication
    is, and then we're going to modify one of our previous tools to enable this attack.
    Finally, we're going to test our script against the victim web application and
    fine tune it to improve the results.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何在Web应用程序中暴力破解基于表单的身份验证。我们将开始学习什么是基于表单的身份验证，然后我们将修改我们之前的工具之一，以启用此攻击。最后，我们将测试我们的脚本针对受害者Web应用程序，并对其进行微调以改进结果。
- en: Form-based authentication overview
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于表单的身份验证概述
- en: Let's start with a quick overview of form-based authentication. Form-based authentication
    is the most common and widely used method of authentication in web applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对基于表单的身份验证的快速概述开始。基于表单的身份验证是Web应用程序中最常见和广泛使用的身份验证方法。
- en: This method is not standardized as the previous two methods we learned were,
    which means that the implementation of this method will vary. Basically, the web
    application will present a form that will prompt the user for the username and
    password. Then, that data will go to the server where it will be evaluated, and
    if the credentials are valid, it will provide a valid session cookie to the user,
    and it will let the user access the protected resource.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们之前学到的两种方法不同，这意味着此方法的实现将有所不同。基本上，Web应用程序将呈现一个表单，提示用户输入用户名和密码。然后，这些数据将发送到服务器进行评估，如果凭据有效，它将为用户提供有效的会话cookie，并允许用户访问受保护的资源。
- en: Let's add this to our previous script. So, you're probably waiting for me to
    say let's go back to the editor and open the previous scripts, but no. Let's just
    stop for a minute and evaluate what our best option is here. We're going to deal
    with forms, and there is no standard as to how to handle authentication on forms,
    so we'll need to have good filtering in order to weed out the incorrect attempts
    and to be able to identify the good ones.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这添加到我们之前的脚本中。所以，你可能在等我说让我们回到编辑器并打开之前的脚本，但不是。让我们停下来一分钟，评估我们在这里的最佳选择是什么。我们将处理表单，并且没有关于如何处理表单上的身份验证的标准，因此我们需要有很好的过滤来筛选出不正确的尝试，并能够识别出好的尝试。
- en: For this reason, instead of adding all the filtering code to the previous script,
    we add the post handling and payload handling to the `forzaBruta-forms.py` script
    from `Section 5`. So now, go back to the editor and open the file. Let's start
    adding the code to enable it to brute force login forms.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是将所有过滤代码添加到先前的脚本中，而是将`post`处理和`payload`处理添加到`第5节`的`forzaBruta-forms.py`脚本中。因此，现在，返回编辑器并打开文件。让我们开始添加代码，使其能够暴力破解登录表单。
- en: 'We don''t add a new `import`. We can go to the `start` function and add the
    `getopt` function for handling the post `payload`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不添加新的`import`。我们可以转到`start`函数，并添加`getopt`函数来处理`post` `payload`：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, it will be the `-p`. If `-p` is present, we assign its value to
    the `payload` variable. We pass `payload` to `launcher_thread`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将是`-p`。如果存在`-p`，我们将其值分配给`payload`变量。我们将`payload`传递给`launcher_thread`。
- en: 'Then, inside the `launcher_thread`, we pass it again to `request_performer`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`launcher_thread`中，我们再次将其传递给`request_performer`：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We add the `payload` to the `init` function of `request_performer`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`payload`添加到`request_performer`的`init`函数中。
- en: 'And then we check if the payload is empty or not. If it''s not empty, we replace
    the keyword `FUZZ` with the dictionary word, otherwise we don''t touch it and
    leave it as it is:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查payload是否为空。如果不为空，我们用字典词替换关键字`FUZZ`，否则我们不会触及它，保持原样：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we go to the `run` method, and we need a conditional to tell us when
    to use `post` and when to use `get`. We can do this by checking if `self.payload`
    is empty, in which case we use `get`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转到`run`方法，我们需要一个条件来告诉我们何时使用`post`和何时使用`get`。我们可以通过检查`self.payload`是否为空来做到这一点，如果为空，我们使用`get`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If it is not empty, we'll be using the `post` request.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不为空，我们将使用`post`请求。
- en: 'For the `post` request, we need the payload in the form of a dictionary:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`post`请求，我们需要以字典形式的payload：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we have it as a string with `&` and `=` signs, so we're going to replace
    the symbols with one space, then we're going to split the string using spaces,
    creating a list of elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将其作为一个带有`&`和`=`符号的字符串，所以我们将用一个空格替换符号，然后我们将使用空格拆分字符串，创建一个元素列表。
- en: Then, we create a `post` request using that payload, and those are all the changes
    necessary to be able to perform password brute forcing on login forms. Now, it
    will be good to test it against our victim web application. Let's do it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用该payload创建一个`post`请求，这些都是执行登录表单密码暴力破解所需的所有更改。现在，测试它对我们的受害者Web应用程序将是很好的。让我们来做吧。
- en: How do we set up a brute force attack against forms? Let's open a page that
    has the login form, in our case, `www.scruffybank.com/login.php`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设置对表单的暴力攻击？让我们打开一个具有登录表单的页面，在我们的情况下是`www.scruffybank.com/login.php`。
- en: 'We right-click on the page and we select View Page Source:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们右键单击页面，然后选择查看页面源代码：
- en: '![](img/00060.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: 'Now, we need to find the form action, that is, where the credentials are going
    to be sent to be verified. In this case, it is `check_login.php`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要找到表单操作，也就是凭证将被发送以进行验证的地方。在这种情况下，它是`check_login.php`：
- en: '![](img/00061.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: We also need the names of the variables, in this case, `username` and `password`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要变量的名称，在这种情况下是`username`和`password`。
- en: That's the data we need to set up our attack.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们设置攻击所需的数据。
- en: 'Let''s go back to the Terminal and run the script with the following command
    line, `forzaBruta-forms.py`, followed by the same URL. This time, we change the
    login to `check_login.php`. We leave the threads as `5`. In this case, we have
    the `username` and `password` parameters in the payload of the `post`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们返回终端，并使用以下命令行运行脚本，`forzaBruta-forms.py`，后跟相同的URL。这次，我们将登录更改为`check_login.php`。我们将线程保留为`5`。在这种情况下，我们在`post`的`payload`中有`username`和`password`参数：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to concatenate the parameters with an `&`. `weaksource.txt` is a list
    of the weakest passwords used by people in different services. Now, let''s fire
    this up. We can see that all of the results are `302`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用`&`连接参数。`weaksource.txt`是人们在不同服务中使用的最弱密码的列表。现在，让我们启动它。我们可以看到所有结果都是`302`：
- en: '![](img/00062.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: So, filtering by code won't help us. We can filter out the `chars` equal to
    `2373` which we know are our failed attempts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按代码进行过滤对我们没有帮助。我们可以过滤掉等于`2373`的`chars`，这是我们知道的失败尝试。
- en: 'Let''s modify the code to filter the `chars` instead of the code with the command-line
    parameter `-c`. We change the code to filter by `chars`. Doing so, we can filter
    by `chars` without modifying much of the code. Go back to the editor and modify
    the line `self.hidecode !=code` to `self.hidecode != chars:`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改代码，以过滤`chars`而不是使用命令行参数`-c`过滤代码。我们将代码更改为按`chars`进行过滤。这样做，我们可以在不修改太多代码的情况下按`chars`进行过滤。返回编辑器，修改行`self.hidecode
    !=code`为`self.hidecode != chars:`：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s save this. Now, we change the command line to add `-c 2373` to filter
    all results out, and we run it again:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这个。现在，我们更改命令行以添加`-c 2373`来过滤所有结果，并再次运行它：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sweet. We have our username and password:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们有我们的用户名和密码：
- en: '![](img/00063.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: Congratulations, you now know how to test password security against the three
    most common web application authentication methods! In this section, we also leveraged
    previous work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，现在您知道如何测试密码安全性，针对三种最常见的Web应用程序身份验证方法！在本节中，我们还利用了以前的工作。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the different authentication methods commonly
    used in web applications, and we created one tool to test basic and digest authentication.
    Finally, we created a login form authentication BruteForcer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Web应用程序中常用的不同身份验证方法，并创建了一个用于测试基本和摘要身份验证的工具。最后，我们创建了一个登录表单身份验证BruteForcer。
- en: In [Chapter 6](part0070.html#22O7C0-5a228e2885234f4ba832bb786a6d0c80), *Detecting
    and Exploiting SQL Injection Vulnerabilities*, we're going to learn about detecting
    and exploiting SQL injection vulnerabilities.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0070.html#22O7C0-5a228e2885234f4ba832bb786a6d0c80)中，*检测和利用SQL注入漏洞*，我们将学习如何检测和利用SQL注入漏洞。
