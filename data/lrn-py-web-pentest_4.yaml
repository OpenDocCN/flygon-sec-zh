- en: Resources Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源发现
- en: 'In [Chapter 3](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80), *Web
    Crawling with Scrapy – Mapping the Application*, we saw how to write our own crawler
    using Python and the Scrapy library. In this chapter, we are going to learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80)中，*使用Scrapy进行Web爬虫-映射应用程序*，我们看到了如何使用Python和Scrapy库编写我们自己的爬虫。在本章中，我们将学习：
- en: What is resource discovery?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是资源发现？
- en: Building our first BruteForcer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的第一个BruteForcer
- en: Analyzing the results
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析结果
- en: Adding more information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多信息
- en: Taking screenshots of the findings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对发现结果进行截图
- en: What is resource discovery?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是资源发现？
- en: In this section, we're going to learn what resource discovery is and why it
    is important when testing web applications. Also, we're going to introduce FUZZDB,
    which is going to be used in the next section as our dictionary database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习什么是资源发现，以及在测试Web应用程序时为什么资源发现很重要。此外，我们将介绍FUZZDB，它将在下一节作为我们的字典数据库使用。
- en: You will remember that, in [Chapter 1](part0019.html#I3QM0-5a228e2885234f4ba832bb786a6d0c80),
    *Introduction to Web Application Penetration Testing*, we learned about the penetration
    testing process. The second phase in the process was mapping. In the mapping phase,
    we need to build a map or catalog of the application pages and functionalities.
    In earlier sections, we learned how to perform application mapping using a crawler.
    We also learned that crawlers have some limitations. For example, links generated
    by JS are not identified by crawlers. This can be overcome by using HTTP proxies
    or by using a headless browser such as PhantomJS. If we do that, we should be
    able to identify all the resources that are linked somewhere in the web application,
    but my personal experience has shown me that we can find many resources that are
    not linked.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，在[第1章](part0019.html#I3QM0-5a228e2885234f4ba832bb786a6d0c80)中，*Web应用程序渗透测试简介*，我们学习了渗透测试过程。过程中的第二阶段是映射。在映射阶段，我们需要构建应用程序页面和功能的地图或目录。在较早的部分中，我们学习了如何使用爬虫执行应用程序映射。我们还了解到爬虫有一些局限性。例如，爬虫无法识别由JS生成的链接。这可以通过使用HTTP代理或使用PhantomJS等无头浏览器来克服。如果我们这样做，我们应该能够识别与Web应用程序中的某个地方链接的所有资源，但我的个人经验告诉我，我们可以找到许多未链接的资源。
- en: 'In order to discover these, we need to perform resource discovery via dictionaries
    of known words. These kinds of tools are known as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现这些资源，我们需要通过已知单词的字典执行资源发现。这些工具被称为：
- en: '**Dictionary attacks**: Here, we use a list of known words in order to identify
    resources'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典攻击：在这里，我们使用已知单词的列表来识别资源
- en: '**Brute forcing**: This is using brute force in order to identify resources
    when using a list of permutations or combinations of strings'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴力破解：这是使用暴力破解来识别资源，当使用字符串的排列或组合列表时
- en: '**Fuzzing**: This is not really correct but is often used to refer to resource
    discovery'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试：这不是真正正确的，但经常用来指代资源发现
- en: What can we find using these techniques?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术，我们能找到什么？
- en: '**Files**: Such as backup files, test files, notes, scripts, documentations,
    and examples'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：例如备份文件、测试文件、笔记、脚本、文档和示例
- en: '**Directories**: Such as admin interfaces, backups, internal areas, and upload
    directories'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录：例如管理界面、备份、内部区域和上传目录
- en: '**Actions**: Whenever there are verb names in options or parameters, we can
    use a dictionary of similar words to identify other functionalities'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作：每当选项或参数中有动词名称时，我们可以使用类似单词的字典来识别其他功能
- en: '**Servlets**: Are similar to actions but with a file'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlets：类似于带有文件的操作
- en: '**Parameters**: We can enumerate ranges or combinations of potential valid
    strings used in parameters'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：我们可以枚举参数中使用的潜在有效字符串的范围或组合
- en: In order to be successful when doing resource recovery, you need to have good
    quality lists. There are many dictionary databases where you can find a variety
    of word lists appropriate for different environments or scenarios. FUZZDB ([https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb))
    is one of the most popular and complete databases available on the internet. We
    are going to use it in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在进行资源恢复时取得成功，您需要具有高质量的列表。有许多字典数据库，您可以在其中找到适用于不同环境或场景的各种单词列表。FUZZDB（[https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)）是互联网上最受欢迎和最完整的数据库之一。我们将在下一节中使用它。
- en: For resource discovery, we are going to focus on the predictable resource locations
    dictionary. I recommend that you take a look at it in our virtual machine, under
    the code samples for this section, and get familiar with the different dictionaries
    or string lists that are available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于资源发现，我们将专注于可预测的资源位置字典。我建议您在我们的虚拟机中查看它，在本节的代码示例下，熟悉可用的不同字典或字符串列表。
- en: Building our first BruteForcer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个BruteForcer
- en: In this section, we're going to build a script that will help us to discover
    resources using a dictionary. We're going to create a basic BruteForcer. We'll
    start by defining the objective of the tool and then go over the code for the
    basic structure of the BruteForcer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建一个脚本，帮助我们使用字典发现资源。我们将创建一个基本的BruteForcer。我们将从定义工具的目标开始，然后查看BruteForcer的基本结构的代码。
- en: 'Finally, we''ll run it against our test web application using the following
    steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下步骤针对我们的测试Web应用程序运行它：
- en: Go back to our editor and open the project folder for section 4 by selecting
    File | Add Project Folder... | Desktop | Examples | Section-4 | OK.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的编辑器，并通过选择文件|添加项目文件夹...|桌面|示例|第4节|确定，打开第4节的项目文件夹。
- en: Then, open the file for `forzabruta.py`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`forzabruta.py`文件。
- en: In this script, we have the basic structure for our BruteForcer. We have our
    typical `import`, and then we have the `banner` function, which will print the
    name of the script. The `usage` function opens to provide help on how to use the
    script.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们有了我们暴力破解器的基本结构。我们有我们典型的`import`，然后我们有`banner`函数，它将打印脚本的名称。`usage`函数提供了如何使用脚本的帮助。
- en: 'Now, let''s jump to the `start` function, which is invoked when we run our
    program:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们跳到`start`函数，当我们运行程序时会调用它：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Print the `banner` and then check the parameters used to invoke our program.
    Then, pass the parameters and assign the URL dictionary and number of threads.
    Open the dictionary and read all the lines, and finally, call the `launcher_thread`
    with the `words`, `threads`, and `url`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`banner`，然后检查用来调用我们程序的参数。然后，传递参数并分配URL字典和线程数。打开字典并读取所有行，最后，使用`words`、`threads`和`url`调用`launcher_thread`。
- en: As we want our application to perform several tasks at once, we can use threads.
    Otherwise, our BruteForcer will be sequential, and for big dictionaries, it will
    be slow. By using threads, we can speed up this attack. We can reuse this script's
    skeleton whenever we want to implement threading in other tools, as threading
    is usually tricky to implement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的应用程序能够同时执行多个任务，我们可以使用线程。否则，我们的暴力破解器将是顺序的，对于大字典来说，速度会很慢。通过使用线程，我们可以加快这次攻击的速度。我们可以在其他工具中实现线程时重用这个脚本的框架，因为通常实现线程是棘手的。
- en: 'The `launcher_thread` function will basically manage the threads and will instantiate
    the class request performer for each thread with one word from the dictionary
    and the target URL, and then it will start the thread. This will be done for each
    word that is loaded in the dictionary:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`launcher_thread`函数基本上会管理线程，并为字典中的每个单词和目标URL实例化请求执行者类，并启动线程。这将对加载在字典中的每个单词执行：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The thread instantiates the class `request_performer`. This class has the `init`
    method which is used to set up the object after it is created, which is basically
    the constructor. In this case, we basically create the attributes `self.word`
    and `self.urly`, which will replace the `FUZZ` tag with a dictionary word.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程实例化了`request_performer`类。这个类有一个`init`方法，用于在创建对象后设置对象，基本上是构造函数。在这种情况下，我们基本上创建了属性`self.word`和`self.urly`，它们将用字典中的单词替换`FUZZ`标记。
- en: 'Then, we have the method `run`, which will perform the request and print the
    requested URL and the status code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`run`方法，它将执行请求并打印请求的URL和状态码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, update the thread counter. When the words from the dictionary are consumed,
    the program will be completed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新线程计数器。当字典中的单词被消耗完时，程序将完成。
- en: The preceding steps show the basic structure for a BruteForcer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤展示了暴力破解器的基本结构。
- en: 'Let''s look at an example with our vulnerable test application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用我们易受攻击的测试应用程序的例子：
- en: Go to the Terminal and type `python forzabruta.py`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到终端，输入`python forzabruta.py`。
- en: We now have the first option that is the target URL with the word `FUZZ`, which
    is the token that will be replaced by every word in the dictionary. It is the
    position that we want to test, which in this case is dictionaries and files in
    the root directory in the test application. Then, we have the option `-t 5`, which
    is the number of threads we want to use, and finally `-f comment.text`, which
    is the dictionary file created for this exercise. It is pretty simple, but remember
    that in a real test you need to use FUZZDB dictionaries.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了第一个选项，即目标URL和单词`FUZZ`，它是将被字典中的每个单词替换的标记。这是我们想要测试的位置，在这种情况下是测试应用程序中的字典和文件的根目录。然后，我们有选项`-t
    5`，这是我们想要使用的线程数，最后`-f comment.text`，这是为这个练习创建的字典文件。这很简单，但请记住，在真实测试中，您需要使用FUZZDB字典。
- en: 'Once we run this, we should see the results shown in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行后，我们应该看到以下截图中显示的结果：
- en: '![](img/00039.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: We have one result per word in the dictionary. We have some valid `200` status
    codes, and a `401`, which means authentication is needed, and many `404` not found
    codes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在字典中每个单词有一个结果。我们有一些有效的`200`状态码，还有一个`401`，表示需要身份验证，以及许多`404`未找到的代码。
- en: 'Let''s see some examples in the browser. We are particularly interested in
    the `/Admin` directory. When we request `/Admin`, an authentication form pops
    up needing User Name and Password; we''ll come back to this later:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中看一些例子。我们特别感兴趣的是`/Admin`目录。当我们请求`/Admin`时，会弹出一个需要用户名和密码的身份验证表单；我们稍后会回到这个问题：
- en: '![](img/00040.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: 'Now, let''s see if `robots.txt` has anything interesting. There are three entries
    in the `robots.txt`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`robots.txt`是否有什么有趣的东西。`robots.txt`中有三个条目：
- en: '![](img/00041.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: One is `/admin` and the other is the `/includes/` directory. We knew about admin
    already, but `/backoffice` looks interesting. `robot.txt` often produces some
    interesting findings for our testing purposes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是`/admin`，另一个是`/includes/`目录。我们已经知道了`admin`，但`/backoffice`看起来很有趣。`robot.txt`经常为我们的测试目的提供一些有趣的发现。
- en: Wow, congratulations. You wrote a basic HTTP BruteForcer. The coined script
    is pretty basic and the results are not that great, but we're going to improve
    them in the upcoming sections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，恭喜。你写了一个基本的HTTP暴力破解器。这个脚本很基础，结果也不是很好，但我们将在接下来的部分中改进它们。
- en: Analysing the results
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析结果
- en: In this section, we will improve the BruteForcer we created in the previous
    section in order to facilitate an analysis of the results. We're going to see
    how we can improve the results, then we'll add the improvements to our code, and
    finally test the code without testing the web app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将改进我们在上一节中创建的暴力破解器，以便更容易分析结果。我们将看到如何改进结果，然后将改进内容添加到我们的代码中，并最终测试代码而不测试Web应用程序。
- en: In the previous section, we created a basic BruteForcer, but we saw that the
    results were a little basic and that, when we have a lot of them, it isn't easy
    to identify the interesting findings. So, we can add colors depending on the status
    code. A good start would be to print in green all the results that have a status
    code greater or equal to 200 and lower than 300; in red, the results with a status
    code greater or equal to 400 and lower than 500; and finally, in blue, the results
    with a status code greater or equal to 300 and lower than 400\. This will help
    us to quickly identify the results. Our interest will be mainly in the green and
    blue results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个基本的BruteForcer，但是我们发现结果有点基本，并且当我们有很多结果时，很难识别出有趣的发现。因此，我们可以根据状态码添加颜色。一个好的开始是以绿色打印所有状态码大于或等于200且小于300的结果；以红色打印状态码大于或等于400且小于500的结果；最后，以蓝色打印状态码大于或等于300且小于400的结果。这将帮助我们快速识别结果。我们主要感兴趣的是绿色和蓝色的结果。
- en: We can also enrich our results with more information about the responses, such
    as the number of characters, the number of words, and the number of lines. This
    will help us to tell apart pages that return the same content for multiple resources,
    as we'll be able to identify them by looking at the characters, words, or lines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以丰富我们的结果，提供有关响应的更多信息，例如字符数、单词数和行数。这将帮助我们区分返回多个资源相同内容的页面，因为我们可以通过查看字符、单词或行来识别它们。
- en: 'Finally, we''ll add the option to filter or hide results based on the status
    code. This will be useful to remove any unfound responses that are usually 404;
    although, often, developers customize their apps or servers to return 200, 301,
    or 302:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加根据状态码过滤或隐藏结果的选项。这将有助于删除通常为404的任何未找到的响应；尽管通常开发人员会自定义他们的应用程序或服务器返回200、301或302：
- en: Let's go back to our editor, and open the file `forzabruta-2.py`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的编辑器，打开文件`forzabruta-2.py`。
- en: 'Add some more imports such as `termcolor`, which will allow us to print colors
    in the Terminal, and `re` for regular expressions:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些更多的导入，比如`termcolor`，它将允许我们在终端中打印颜色，以及`re`用于正则表达式：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `request_performer`, we obtain all the information from the response, for
    example:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`request_performer`中，我们从响应中获取所有信息，例如：
- en: '`lines`: Counts the number of new lines'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lines`: 计算新行的数量'
- en: '`chars`: Calculates the number of characters'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chars`: 计算字符的数量'
- en: '`words`: Calculates the number of words'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`words`: 计算单词的数量'
- en: '`code`: Calculates the `status_code`:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`: 计算`status_code`：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we''ll add them all to the result output. This chain of conditions will
    allow us to filter on non-interesting responses with the code equal to a specific
    hide code, and to visualize other kinds of requests with three different colors:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把它们全部添加到结果输出中。这一系列条件将允许我们根据特定隐藏代码的相等代码来过滤非感兴趣的响应，并以三种不同的颜色可视化其他类型的请求：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are going to use `green` for status codes greater than or equal to `200`
    and less than `300`, `red` for codes greater than or equal to `400` and less than
    `500`, and `blue`, when the result is greater than or equal to `300` and less
    than `400`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`green`表示大于或等于`200`且小于`300`的状态码，使用`red`表示大于或等于`400`且小于`500`的状态码，以及当结果大于或等于`300`且小于`400`时使用`blue`。
- en: 'Now, we need to add a new parameter to our program. We add `c` in the `getopt`
    parameters, and then we assign the value of `-c` to the variable `hidecode`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要向我们的程序添加一个新参数。我们在`getopt`参数中添加`c`，然后将`-c`的值赋给变量`hidecode`：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We pass `hidecode` to the `launcher_thread`, and then to `request_performer`.
    In `request_performer`, we add a condition before printing. In order to filter
    out the codes we are not interested in, this is usually 404.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`hidecode`传递给`launcher_thread`，然后传递给`request_performer`。在`request_performer`中，在打印之前添加一个条件。为了过滤我们不感兴趣的代码，这通常是404。
- en: Let's go back to the Terminal and run the program.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到终端并运行程序。
- en: 'Change the command to `forzabruta-2.py` and run:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令更改为`forzabruta-2.py`并运行：
- en: '![](img/00042.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: 'You can see the results are much easier to read as the different codes can
    be identified quickly. Let''s try it again adding the parameter `-c` and hide
    response `404` to the command line:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到结果更容易阅读，因为不同的代码可以很快被识别出来。让我们再试一次，添加参数`-c`并在命令行中隐藏响应`404`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is much better.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了。
- en: 'This will help us to quickly identify where the interesting stuff is:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们快速识别有趣的内容所在的位置：
- en: '![](img/00043.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: But it seems that `test1.txt` and `test2.txt` are the same files, right? They
    have the same number of `lines`, `chars`, and `words`, as highlighted in the preceding
    screenshot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`test1.txt`和`test2.txt`看起来是相同的文件，对吧？它们有相同数量的`lines`、`chars`和`words`，就像前面的截图中所突出显示的那样。
- en: 'Let''s open them in the browser by typing `www.scruffybank.com/test1.txt`.
    You can see `test1.txt` only has `aaa`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`www.scruffybank.com/test1.txt`在浏览器中打开它们。你只能看到`test1.txt`只有`aaa`：
- en: '![](img/00044.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'Now, let''s open `test2.txt` by typing `www.scruffybank.com/test2.txt`. The
    content is `bbb`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入`www.scruffybank.com/test2.txt`来打开`test2.txt`。内容是`bbb`：
- en: '![](img/00045.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: They are not the same, but with our current tool, we weren't able to tell these
    files apart. Let's see how we can solve this in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它们并不相同，但是使用我们当前的工具，我们无法区分这些文件。让我们看看在下一节中我们如何解决这个问题。
- en: Adding more information
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多信息
- en: In this section, we'll continue adding features to our BruteForcer in order
    to improve detection and to facilitate filtering.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续为我们的BruteForcer添加功能，以改进检测并简化过滤。
- en: First, we're going to add the code that will detect whether there was a redirection,
    then we're going to add the time it took for the request response transaction
    and the MD5 hash of the response. Finally, we're going to test the improved script.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加代码来检测是否有重定向，然后我们将添加请求响应事务所花费的时间和响应的MD5哈希。最后，我们将测试改进后的脚本。
- en: 'Currently, the `requests` library returns a `200` status code for resources
    that follow the redirection as it is returning the status code from the last resource
    in the redirection chain. If we want to know whether there was a redirection,
    we need to check the history of requests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`requests`库对遵循重定向的资源返回`200`状态码，因为它返回重定向链中最后一个资源的状态码。如果我们想知道是否有重定向，我们需要检查请求的历史记录：
- en: Let's go back to the Atom editor and open the file `forzaBruta-3.py`. We need
    to add this code in order to improve the redirection detection.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到Atom编辑器，打开文件`forzaBruta-3.py`。我们需要添加这段代码以改进重定向检测。
- en: 'After line 48, we get the request response. This code will check whether there
    was a redirection and it will update the code with the first redirection code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第48行之后，我们得到了请求的响应。这段代码将检查是否有重定向，并将代码更新为第一个重定向代码：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the request time, we can do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于请求时间，我们可以这样做：
- en: Take the time before the request and the time after the request, and then subtract
    the start time from the elapsed time.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录请求前和请求后的时间，然后从经过的时间中减去开始时间。
- en: 'In order to do this, we''re going to use the `time` library. We''ll add the
    `import` library at the beginning, as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用`time`库。我们将在开头添加`import`库，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we add the following line before the request in order to capture the
    time at that moment and we do the same after the request is performed:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在请求之前添加以下行以捕获那一刻的时间，请求执行后也是一样：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we subtract the start time from the elapsed time, and we get the time
    it took for the response to arrive:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从经过的时间中减去开始时间，得到响应到达所花费的时间：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Entering the hash of the response content
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入响应内容的哈希
- en: Remember in the previous example that the files `test1.txt` and `test2.txt` had
    similar results? That was because the number of `lines`, `chars`, and `words`
    were the same. But there will be times when you need to know whether there is
    an actual difference in the content, and in order to do this, we can calculate
    the MD5 hash of the content to get the resources' unique fingerprints.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前的例子中`test1.txt`和`test2.txt`的文件结果相似吗？那是因为`lines`、`chars`和`words`的数量相同。但是有时候你需要知道内容是否实际上有差异，为了做到这一点，我们可以计算内容的MD5哈希值，以获取资源的唯一指纹。
- en: We need to import MD5 and add `forzabruta-3.py` code. That hash will be unique,
    and it will be useful for filtering resources with similar `chars`, `words`, `lines`,
    and `code`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入MD5并添加`forzabruta-3.py`的代码。该哈希将是唯一的，并且对于过滤具有相似`chars`、`words`、`lines`和`code`的资源非常有用。
- en: Let's try it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。
- en: 'Let''s go back to the Terminal and run `forzabruta-3.py` with the same parameters
    as before. Now, this is looking way better:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到终端，并使用与之前相同的参数运行`forzabruta-3.py`。现在，情况好多了：
- en: '![](img/00046.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: The results are very rich now. Check out the difference in the `MD5` hash of
    `test1.txt` and `test2.txt`. Cool, right?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果非常丰富。看看`test1.txt`和`test2.txt`的`MD5`哈希的差异。很酷，对吧？
- en: We now have a value with which to tell them apart. Also, we can see the redirection
    in blue instead of a `200` result. What if we just want to look for `.php` files?
    We just need to add `.php` after the `FUZZ` string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个值可以用来区分它们。此外，我们可以看到重定向是蓝色的，而不是`200`的结果。如果我们只想寻找`.php`文件怎么办？我们只需要在`FUZZ`字符串后添加`.php`。
- en: 'Also, we change to `commons` as it is a bigger dictionary for this scenario. Let''s
    run it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们改为使用`commons`，因为它是这种情况下更大的字典。让我们运行它：
- en: '![](img/00047.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: You can see that we have many new results to investigate. Great stuff. Well
    done! You now have a functional web application—BruteForcer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们有许多新的结果需要调查。做得好！现在你有一个功能齐全的网络应用程序—BruteForcer。
- en: What if we want to make the BruteForcer take a screenshot of the resource, then
    return a 200 status code? Let's look at that in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让BruteForcer对资源进行截图，然后返回200状态码怎么办？让我们在下一节中看看。
- en: Taking screenshots of the findings
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对发现的资源进行截图
- en: In this short section, we're going to learn how to automatically take a screenshot
    from our BruteForcer. We're going to see why taking pictures can be useful, and
    which libraries we need to add this capability to our script. Finally, we're going
    to run a new BruteForcer and take some pictures.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的部分中，我们将学习如何从我们的BruteForcer自动截图。我们将看到为什么拍照可能有用，以及我们需要添加哪些库来使我们的脚本具备这种功能。最后，我们将运行一个新的BruteForcer并拍一些照片。
- en: What do we want to achieve in this section? Basically, we want to take a screenshot
    of every resource that returns a 200 code. This will help us to speed up the analysis
    of big apps, or test multiple apps in a shorter period of time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想要实现什么？基本上，我们想对返回200状态码的每个资源进行截图。这将帮助我们加快大型应用程序的分析速度，或者在较短的时间内测试多个应用程序。
- en: For this, I chose the selenium web driver for Python ([http://docs.seleniumhq.org](http://docs.seleniumhq.org))
    and PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)). Selenium WebDriver
    is a tool used to automate web browsers pragmatically, mainly for software testing
    purposes. Selenium WebDriver will drive PhantomJS, which is a headless browser,
    and has access to PhantomJS capabilities in Python, in this case, the screenshot
    function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我选择了Python的selenium web driver（[http://docs.seleniumhq.org](http://docs.seleniumhq.org)）和PhantomJS（[http://phantomjs.org/](http://phantomjs.org/)）。Selenium
    WebDriver是一个用于自动化Web浏览器的工具，主要用于软件测试。Selenium WebDriver将驱动PhantomJS，它是一个无头浏览器，并且在Python中具有对PhantomJS功能的访问权限，本例中是截图功能。
- en: 'But we can also access the DOM, which will be very useful for testing DOM injections.
    I have installed Selenium and PhantomJS in the virtual machine to facilitate training.
    Let''s see how to add this to our BruteForcer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们也可以访问DOM，这对于测试DOM注入非常有用。我已经在虚拟机中安装了Selenium和PhantomJS以方便培训。让我们看看如何将其添加到我们的BruteForcer中：
- en: 'Go back to our editor and open `forzabruta-4.py`. We''re going to add the following
    selenium libraries in the `import` area:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的编辑器，打开`forzabruta-4.py`。我们将在`import`区域添加以下selenium库：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define the capabilities where we specify, we want to use PhantomJS:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们要使用PhantomJS的能力：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we instantiate the WebDriver with the capabilities, and wait `2` seconds
    just to make sure the page is loaded:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用这些能力实例化WebDriver，并等待`2`秒，只是为了确保页面加载：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We define the size of the screenshot, then we load the page, and finally, we
    save the screenshot to `word.png`, with the name of the results found:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了屏幕截图的大小，然后加载页面，最后将屏幕截图保存为`word.png`，并附上找到的结果的名称：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Short and easy, right? Let's run it now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简短而简单，对吧？现在让我们运行它。
- en: 'Let''s go back to the Terminal and run `forzabruta-4.py` with the same parameters
    as before. We will see that there are some delays, but they were caused by us
    waiting a couple of seconds to make sure the page loaded. Now, if we look in the
    directory where we ran the script, we should see a few `.png` images:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到终端，并使用与之前相同的参数运行`forzabruta-4.py`。我们会看到一些延迟，但这是因为我们等待了几秒钟，以确保页面加载。现在，如果我们查看运行脚本的目录，我们应该会看到一些`.png`图像：
- en: '![](img/00048.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: 'Let''s open `index.php.png` by selecting the Examples folder on the desktop
    and by clicking on Section-4 | index.php.png. This is a screenshot of the content
    of `index.php`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在桌面上选择Examples文件夹，然后点击Section-4 | index.php.png来打开`index.php.png`。这是`index.php`内容的屏幕截图：
- en: '![](img/00049.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: Screenshot of the index.php
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: index.php的屏幕截图
- en: 'Then, we can open `robots.text.png`, and finally, `test1.txt.png`. We can now
    see the content of the files. This is very interesting considering we are using
    two tools in order to automate the screenshots: Selenium, which lets us drive
    PhantomJS, which in turn lets us take a screenshot.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开`robots.text.png`，最后是`test1.txt.png`。现在我们可以看到文件的内容。考虑到我们使用了两个工具来自动截取屏幕截图，这是非常有趣的：Selenium让我们驱动PhantomJS，而PhantomJS又让我们截取屏幕截图。
- en: Congratulations! Now you have the knowledge to expand the BruteForcer and add
    anything that you may need in the future. Some suggestions for further development
    are filtering by `lines`, `words`, `chars`, and `MD5`, adding recursion when detecting
    a directory, and generating an HTML report of the results.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你有了扩展BruteForcer并在将来可能需要的任何内容的知识。一些建议进一步发展的内容包括按`行`、`单词`、`字符`和`MD5`进行过滤，当检测到目录时添加递归，并生成结果的HTML报告。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we learned how to write a BruteForcer tool that will help us
    to discover and enumerate resources such as files, directories, and parameters.
    We saw how to add filtering capabilities, and we saw how this can be extended
    in order to add more information and capabilities to help us filter responses
    and identify interesting ones. Finally, we saw how we can take screenshots automatically
    using Selenium and PhantomJS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何编写一个BruteForcer工具，它将帮助我们发现和枚举文件、目录和参数等资源。我们看到了如何添加过滤功能，以及如何扩展这一功能，以帮助我们过滤响应并识别感兴趣的内容。最后，我们看到了如何使用Selenium和PhantomJS自动截取屏幕截图。
- en: In [Chapter 5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password
    Testing*, we're going to learn about password quality testing, also known as password
    cracking.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80)，*密码测试*中，我们将学习有关密码质量测试，也称为密码破解。
