- en: Python with Penetration Testing and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python与渗透测试和网络
- en: '**Penetration** (**pen**) tester and hacker are similar terms. The difference
    is that penetration testers work for an organization to prevent hacking attempts,
    while hackers hack for any purpose such as fame, selling vulnerability for money,
    or to exploit the vulnerability of personal enmity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试员和黑客是类似的术语。不同之处在于渗透测试员为组织工作以防止黑客攻击，而黑客则出于名誉、出售漏洞以获取金钱，或者利用个人仇恨的目的进行攻击。
- en: Lots of well-trained hackers have got jobs in the information security field
    by hacking into a system and then informing the victim of their security bug(s)
    so that they might be fixed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多训练有素的黑客通过侵入系统然后通知受害者他们的安全漏洞，从而在信息安全领域找到了工作。
- en: 'A hacker is called a penetration tester when they work for an organization
    or company to secure its system. A pentester performs hacking attempts to break
    into the network after getting legal approval from the client and then presents
    a report of their findings. To become an expert in pentesting, a person should
    have a deep knowledge of the concepts of their technology. In this chapter, we
    will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当黑客为组织或公司保护其系统时，他被称为渗透测试员。渗透测试员在获得客户的合法批准后，对网络进行黑客攻击，并提交他们的发现报告。要成为渗透测试的专家，一个人应该对技术的概念有深入的了解。在本章中，我们将涵盖以下主题：
- en: The scope of pentesting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试的范围
- en: The need for pentesting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试的必要性
- en: Components to be tested
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要测试的组件
- en: Qualities of a good pentester
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀渗透测试员的素质
- en: Approaches to pentesting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试的方法
- en: Understanding the tests and tools you'll need
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解你需要的测试和工具
- en: Network sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络套接字
- en: Server socket methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器套接字方法
- en: Client socket methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端套接字方法
- en: General socket methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般的套接字方法
- en: Practical examples of sockets
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字的实际例子
- en: Socket exceptions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字异常
- en: Useful socket methods
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的套接字方法
- en: Introducing the scope of pentesting
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍渗透测试的范围
- en: In simple words, penetration testing is used to test the information security
    measures of a company. Information security measures entail a company's network,
    database, website, public-facing servers, security policies, and everything else
    specified by the client. At the end of the day, a pentester must present a detailed
    report of their findings such as weaknesses, vulnerabilities in the company's
    infrastructure, and the risk level of particular vulnerabilities, and provide
    solutions if possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，渗透测试用于测试公司的信息安全措施。信息安全措施包括公司的网络、数据库、网站、面向公众的服务器、安全策略以及客户指定的其他一切。在一天结束时，渗透测试员必须提交一份详细的报告，报告中包括公司基础设施的弱点、漏洞以及特定漏洞的风险水平，并在可能的情况下提供解决方案。
- en: The need for pentesting
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渗透测试的必要性
- en: 'There are several points that describe the significance of pentesting:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点描述了渗透测试的重要性：
- en: Pentesting identifies the threats that might expose the confidentiality of an
    organization
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试识别可能暴露组织机密性的威胁
- en: Expert pentesting provides assurance to the organization with a complete and
    detailed assessment of organizational security
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专家级的渗透测试为组织提供了对组织安全的全面和详细的评估
- en: Pentesting assesses the network's efficiency by producing a huge amount of traffic
    and scrutinizes the security of devices such as firewalls, routers, and switches
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试通过产生大量的流量来评估网络的效率，并审查防火墙、路由器和交换机等设备的安全性
- en: Changing or upgrading the existing infrastructure of software, hardware, or
    network design might lead to vulnerabilities that can be detected by pentesting
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改或升级现有的软件、硬件或网络设计基础设施可能导致渗透测试发现的漏洞
- en: In today's world, potential threats are increasing significantly; pentesting
    is a proactive exercise to minimize the chances of being exploited
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当今世界，潜在威胁显著增加；渗透测试是一种积极的行为，以最小化被利用的机会
- en: Pentesting ensures whether suitable security policies are being followed or
    not
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渗透测试确保是否遵循适当的安全策略
- en: Consider the example of a well-reputed e-commerce company that makes money from
    an online business. A hacker or a group of black hat hackers find a vulnerability
    in the company's website and hack it. The amount of loss the company will have
    to bear will be tremendous.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个声誉良好的电子商务公司的例子，他们通过在线业务赚钱。黑客或一群黑客在公司的网站上发现了一个漏洞并进行了攻击。公司将不得不承受巨大的损失。
- en: Components to be tested
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要测试的组件
- en: 'An organization should conduct a risk assessment operation before pentesting;
    this will help identify the main threats such as misconfiguration or vulnerability
    in:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组织在进行渗透测试之前应进行风险评估操作；这将有助于识别主要威胁，如错误配置或漏洞：
- en: Routers, switches, or gateways
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器、交换机或网关
- en: Public-facing systems; websites, DMZ, email servers, and remote systems
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向公众的系统；网站、DMZ、电子邮件服务器和远程系统
- en: DNS, firewalls, proxy servers, FTP, and web servers
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS、防火墙、代理服务器、FTP和Web服务器
- en: Testing should be performed on all hardware and software components of a network
    security system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应对网络安全系统的所有硬件和软件组件进行测试。
- en: Qualities of a good pentester
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀渗透测试员的素质
- en: 'The following points describe the qualities of a good pentester. They should:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点描述了一个优秀的渗透测试员的素质。他们应该：
- en: Choose a suitable set of tests and tools that balance cost and benefits
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一套平衡成本和效益的测试和工具
- en: Follow suitable procedures with proper planning and documentation
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循适当的程序，进行适当的规划和文档记录
- en: Establish the scope for each penetration test, such as objectives, limitations,
    and the justification of procedures
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每次渗透测试建立范围，如目标、限制和程序的合理性
- en: Be ready to show how to exploit the vulnerabilities that they find
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备好展示如何利用他们发现的漏洞
- en: State the potential risks and findings clearly in the final report and provide
    methods to mitigate the risk(s) if possible
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终报告中清楚地说明潜在风险和发现，并在可能的情况下提供减轻风险的方法
- en: Keep themselves updated at all times because technology is advancing rapidly
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终保持更新，因为技术在迅速发展
- en: A pentester tests the network using manual techniques or the relevant tools.
    There are lots of tools available on the market. Some of them are open source
    and some of them are highly expensive. With the help of programming, a programmer
    can make his/her own tools. By creating your own tools, you can clear your concepts
    and also perform more R&D. If you are interested in pentesting and want to make
    your own tools, then the Python programming language is the best, since extensive
    and freely available pentesting packages are available in Python, in addition
    to its ease of programming. This simplicity, along with the third-party libraries
    such as scapy and mechanize, reduces the code size. In Python, to make a program,
    you don't need to define big classes such as Java. It's more productive to write
    code in Python than in C, and high-level libraries are easily available for virtually
    any imaginable task.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试员使用手动技术或相关工具测试网络。市面上有很多工具可用。其中一些是开源的，一些则非常昂贵。通过编程，程序员可以制作自己的工具。通过创建自己的工具，你可以澄清自己的概念，也可以进行更多的研究和开发。如果你对渗透测试感兴趣并想制作自己的工具，那么Python编程语言是最好的选择，因为Python中有大量免费的渗透测试包，除了编程的简易性。这种简易性，再加上第三方库如scapy和mechanize，可以减少代码量。在Python中，要编写程序，你不需要像Java那样定义大的类。用Python编写代码比用C更高效，而且高级库几乎可以满足任何想象得到的任务。
- en: If you know some programming in Python and are interested in pentesting, this
    book is perfect for you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你懂一些Python编程并对渗透测试感兴趣，这本书非常适合你。
- en: Defining the scope of pentesting
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义渗透测试的范围
- en: 'Before we get into pentesting, the scope of pentesting should be defined. The
    following points should be taken into account while defining the scope:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始渗透测试之前，应该定义渗透测试的范围。在定义范围时应考虑以下几点：
- en: You should develop the scope of the project by consulting with the client. For
    example, if Bob (the client) wants to test the entire network infrastructure of
    the organization, then pentester Alice would define the scope of pentesting by
    taking this network into account. Alice will consult Bob on whether any sensitive
    or restricted areas should be included or not.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该通过与客户协商来制定项目的范围。例如，如果Bob（客户）想要测试组织的整个网络基础设施，那么渗透测试员Alice将考虑这个网络来定义渗透测试的范围。Alice将与Bob商议是否应该包括任何敏感或受限制的区域。
- en: You should take into account time, people, and money.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该考虑时间、人员和金钱。
- en: You should profile the test boundaries on the basis of an agreement signed by
    the pentester and the client.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该根据渗透测试员和客户签署的协议来界定测试边界。
- en: Changes in business practice might affect the scope. For example, the addition
    of a subnet, new system component installations, the addition or modification
    of a web server, and so on, might change the scope of pentesting.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务实践的变化可能会影响范围。例如，子网的添加，新系统组件的安装，添加或修改Web服务器等，可能会改变渗透测试的范围。
- en: 'The scope of pentesting is defined in two types of tests:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试的范围分为两种测试类型：
- en: '**A non-destructive test**: This test is limited to finding and carrying out
    the tests without any potential risks. It performs the following actions:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非破坏性测试**：这种测试仅限于发现和执行测试，没有潜在风险。它执行以下操作：'
- en: Scans and identifies the remote system for potential vulnerabilities
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描和识别远程系统的潜在漏洞
- en: Investigates and verifies the findings
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查和验证发现
- en: Maps the vulnerabilities with proper exploits
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将漏洞与适当的利用进行映射
- en: Exploits the remote system with proper care to avoid disruption
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以适当的注意力利用远程系统，以避免中断
- en: Provides a proof of concept
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供概念的证明
- en: Does not attempt a **Denial-of-Service** (**DoS**) attack
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试**拒绝服务**（**DoS**）攻击
- en: '**A destructive test**: This test can produce risks. It performs the following
    actions:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性测试**：这种测试可能会产生风险。它执行以下操作：'
- en: Attempts a DoS attack and a buffer overflow attack, which have the potential
    to bring down the system
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试DoS攻击和缓冲区溢出攻击，这可能会导致系统崩溃
- en: Approaches to pentesting
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渗透测试的方法
- en: 'There are three types of approaches to pentesting:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种渗透测试的方法：
- en: 'Black-box pentesting follows a non-deterministic approach of testing:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒渗透测试遵循非确定性测试的方法：
- en: You will be given just a company name
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将只会得到一个公司名字
- en: It is like hacking with the knowledge of an outside attacker
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就像是具有外部攻击者知识的黑客
- en: You do not need any prior knowledge of the system
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要对系统有任何先验知识
- en: It is time-consuming
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要时间
- en: 'White-box pentesting follows a deterministic approach to testing:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒渗透测试遵循确定性测试的方法：
- en: You will be given complete knowledge of the infrastructure that needs to be
    tested
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将获得需要测试的基础设施的完整知识
- en: This is like working as a malicious employee who has ample knowledge of the
    company's infrastructure
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就像是作为对公司基础设施有充分了解的恶意员工在工作
- en: You will be provided information on the company's infrastructure, network type,
    company's policies, do's and don'ts, the IP address, and the IPS/IDS firewall
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将获得有关公司基础设施、网络类型、公司政策、行为准则、IP地址和IPS/IDS防火墙的信息
- en: 'Gray-box pentesting follows a hybrid approach of black-box and white-box testing:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰盒渗透测试遵循黑盒和白盒测试的混合方法：
- en: The tester usually has limited information on the target network/system that
    is provided by the client to lower the costs and decrease trial and error on the
    part of the pentester
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试人员通常只能获得客户提供的目标网络/系统的有限信息，以降低成本并减少渗透测试人员的试错。
- en: It performs the security assessment and testing internally
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在内部执行安全评估和测试
- en: Introducing Python scripting
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python脚本
- en: Before you start reading this book, you should know the basics of Python programming,
    such as the basic syntax, variable type, data type tuple, list dictionary, functions,
    strings, and methods. Two versions, 3.4 and 2.7.8, are available at [python.org/downloads/](http://python.org/downloads/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始阅读这本书之前，你应该了解Python编程的基础知识，比如基本语法、变量类型、数据类型元组、列表字典、函数、字符串和方法。在[python.org/downloads/](http://python.org/downloads/)上有两个版本，3.4和2.7.8。
- en: In this book, all experiments and demonstrations have been done in Python version
    2.7.8\. If you use Linux OSes such as Kali or BackTrack, then there will be no
    issue, because many programs, such as wireless sniffing, do not work on the Windows
    platform. Kali Linux also uses the 2.7 version. If you love to work on Red Hat
    or CentOS, then this version is suitable for you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，所有的实验和演示都是在Python 2.7.8版本中完成的。如果你使用Kali或BackTrack等Linux操作系统，那就没有问题，因为许多程序，比如无线嗅探，在Windows平台上无法工作。Kali
    Linux也使用2.7版本。如果你喜欢在Red Hat或CentOS上工作，那么这个版本适合你。
- en: Most hackers choose this profession because they don't want to do programming.
    They want to use tools. However, without programming, a hacker cannot enhance
    his/her skills. Each and every time, they have to search for the tools over the
    internet. Believe me, after seeing its simplicity, you will love this language.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数黑客选择这个职业是因为他们不想做编程。他们想使用工具。然而，没有编程，黑客无法提高自己的技能。每一次，他们都不得不在互联网上搜索工具。相信我，看到它的简单性之后，你会喜欢这种语言的。
- en: Understanding the tests and tools you'll need
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解你需要的测试和工具
- en: As you have seen, this book is divided into nine chapters. To conduct scanning
    and sniffing pentesting, you will need a small network of attached devices. If
    you don't have a lab, you can make virtual machines on your computer. For wireless
    traffic analysis, you should have a wireless network. To conduct a web attack,
    you will need an Apache server running on the Linux platform. It is a good idea
    to use CentOS or Red Hat Version 5 or 6 for the web server because this contains
    the RPM of Apache and PHP. For the Python script, we will use the Wireshark tool,
    which is open source and can be run on Windows as well as Linux platforms.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这本书分为九章。要进行扫描和嗅探渗透测试，你将需要一个连接设备的小型网络。如果你没有实验室，你可以在你的计算机上创建虚拟机。对于无线流量分析，你应该有一个无线网络。进行网络攻击，你将需要在Linux平台上运行的Apache服务器。最好使用CentOS或Red
    Hat版本5或6作为Web服务器，因为这包含了Apache和PHP的RPM。对于Python脚本，我们将使用Wireshark工具，这是开源的，可以在Windows和Linux平台上运行。
- en: Learning the common testing platforms with Python
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用Python的常见测试平台
- en: You will now perform some pentesting; I hope you are well acquainted with networking
    fundamentals such as IP addresses, classful subnetting, classless subnetting,
    the meaning of ports, network addresses, and broadcast addresses. A pentester
    must be knowledgeable in networking fundamentals as well as in at least one operating
    system; if you are thinking of using Linux, then you are on the right track. In
    this book, we will execute our programs on Windows as well as Linux. In this book,
    Windows, CentOS, and Kali Linux will be used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将进行一些渗透测试；我希望你对网络基础知识非常熟悉，比如IP地址、类别子网划分、无类别子网划分、端口的含义、网络地址和广播地址。渗透测试人员必须对网络基础知识以及至少一种操作系统有所了解；如果你打算使用Linux，那么你走对了路。在这本书中，我们将在Windows和Linux上执行我们的程序。在这本书中，将使用Windows、CentOS和Kali
    Linux。
- en: A hacker always loves to work on a Linux system. Since it is a free and open
    source, Kali Linux marks the rebirth of BackTrack and is like an arsenal of hacking
    tools. Kali Linux NetHunter is the first open-source Android penetration testing
    platform for Nexus devices. However, some tools work on both Linux and Windows,
    but on Windows, you have to install those tools. I expect you to have knowledge
    of Linux. Now, it's time to work with networking on Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客总是喜欢在Linux系统上工作。因为它是免费和开源的，Kali Linux标志着BackTrack的重生，就像一个黑客工具的武库。Kali Linux
    NetHunter是第一个为Nexus设备提供的开源Android渗透测试平台。然而，一些工具在Linux和Windows上都可以工作，但在Windows上，你必须安装这些工具。我希望你对Linux有所了解。现在，是时候在Python上进行网络工作了。
- en: Network sockets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络套接字
- en: A network socket address contains an IP address and port number. In a very simple
    way, a socket is a way to talk to other computers. By means of a socket, a process
    can communicate with another process over the network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字地址包含IP地址和端口号。简单地说，套接字是与其他计算机通信的一种方式。通过套接字，一个进程可以通过网络与另一个进程通信。
- en: 'In order to create a socket, use the `socket.socket()`  that is available in
    the socket module. The general syntax of a socket function is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个套接字，使用套接字模块中可用的`socket.socket()`。套接字函数的一般语法如下：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the description of the parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参数的描述：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`AF_INET` is the address family for IPv4\. `PF_PACKET` operates at the device
    driver layer. The pcap library for Linux uses `PF_PACKET`. You will see more details
    on `PF_PACKET` in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml), *Sniffing
    and Penetration Testing*. These arguments represent the address families and the
    protocol of the transport layer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`AF_INET`是IPv4的地址族。`PF_PACKET`在设备驱动程序层操作。Linux的pcap库使用`PF_PACKET`。你将在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)中看到更多关于`PF_PACKET`的细节，*嗅探和渗透测试*。这些参数代表传输层的地址族和协议：'
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `socket.SOCK_DGRAM` argument depicts that UDP is unreliable and connectionless,
    and `socket.SOCK_STREAM` depicts that TCP is reliable and a two-way, connection-based
    service. We will discuss `socket.SOCK_RAW` in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.SOCK_DGRAM`参数表示UDP是不可靠和无连接的，`socket.SOCK_STREAM`表示TCP是可靠的和双向的，基于连接的服务。我们将在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)中讨论`socket.SOCK_RAW`，*嗅探和渗透测试*：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Generally, we leave this argument; it takes 0 if it's not specified. We will
    see the use of this argument in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会留下这个参数；如果未指定，它将为0。我们将在[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)中看到这个参数的用法，*嗅探和渗透测试*。
- en: Server socket methods
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器套接字方法
- en: 'In a client-server architecture, there is one centralized server that provides
    service, and many clients request and receive service from the centralized server.
    Here are some methods you need to know:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器架构中，有一个提供服务的集中服务器，许多客户端从集中服务器请求和接收服务。以下是您需要了解的一些方法：
- en: '`socket.bind(address)`: This method is used to connect the address (IP address,
    port number) to the socket. The socket must be open before connecting to the address.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.bind(address)`: 该方法用于将地址（IP地址，端口号）连接到套接字。在连接到地址之前，套接字必须是打开的。'
- en: '`socket.listen(q)`: This method starts the TCP listener. The `q` argument defines
    the maximum number of lined-up connections.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.listen(q)`: 该方法启动TCP监听器。`q`参数定义了最大排队连接数。'
- en: '`socket.accept()`: The use of this method is to accept the connection from
    the client. Before using this method, the `socket.bind(address)` and `socket.listen(q)`
    methods must be used. The `socket.accept()` method returns two values, `client_socket`
    and `address`, where `client_socket` is a new socket object used to send and receive
    data over the connection, and `address` is the address of the client. You will
    see examples of this later.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.accept()`: 使用此方法是为了接受来自客户端的连接。在使用此方法之前，必须使用`socket.bind(address)`和`socket.listen(q)`方法。`socket.accept()`方法返回两个值，`client_socket`和`address`，其中`client_socket`是一个新的套接字对象，用于在连接上发送和接收数据，`address`是客户端的地址。稍后将看到这个的例子。'
- en: Client socket methods
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端套接字方法
- en: 'The only method dedicated to the client is the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于客户端的方法只有以下一个：
- en: '`socket.connect(address)`: This method connects the client to the server. The
    `address` argument is the address of the server.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.connect(address)`: 该方法将客户端连接到服务器。`address`参数是服务器的地址。'
- en: General socket methods
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的套接字方法
- en: 'The general socket methods are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的套接字方法如下：
- en: '`socket.recv(bufsize)`: This method receives a TCP message from the socket.
    The `bufsize` argument defines the maximum data it can receive at any one time.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recv(bufsize)`: 该方法从套接字接收TCP消息。`bufsize`参数定义了它可以一次接收的最大数据量。'
- en: '`socket.recvfrom(bufsize)`: This method receives data from the socket. The
    method returns a pair of values, the first value gives the received data, and
    the second value gives the address of the socket sending the data.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recvfrom(bufsize)`: 该方法从套接字接收数据。该方法返回一对值，第一个值给出接收到的数据，第二个值给出发送数据的套接字的地址。'
- en: '`socket.recv_into(buffer)`: This method receives data less than or equal to
    `buffer`. The `buffer` parameter is created by the `bytearray()` method. We will
    discuss this in an example later.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recv_into(buffer)`: 该方法接收小于或等于`buffer`的数据。`buffer`参数由`bytearray()`方法创建。稍后我们将在示例中讨论这一点。'
- en: '`socket.recvfrom_into(buffer)`: This method obtains data from the socket and
    writes it into the buffer. The return value is a pair (nbytes, address), where
    nbytes is the number of bytes received, and the address is the address of the
    socket sending the data.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recvfrom_into(buffer)`: 该方法从套接字获取数据并将其写入缓冲区。返回值是一对（nbytes，address），其中nbytes是接收到的字节数，address是发送数据的套接字的地址。'
- en: Be careful while using the `socket.recv from_into(buffer)` method in older versions
    of Python. Buffer overflow vulnerability has been found in this method. The name
    of this vulnerability is CVE-2014-1912, and its vulnerability was published on
    February 27, 2014\. Buffer overflow in the `socket.recvfrom_into` function in
    `Modules/socketmodule.c` in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x
    before 3.4rc1, allows remote attackers to execute arbitrary code via a crafted
    string.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Python中使用`socket.recvfrom_into(buffer)`方法时要小心。在该方法中发现了缓冲区溢出漏洞。该漏洞的名称是CVE-2014-1912，其漏洞于2014年2月27日发布。在Python
    2.5之前的2.7.7，3.x之前的3.3.4和3.4.x之前的3.4rc1中的`Modules/socketmodule.c`中的`socket.recvfrom_into`函数中存在缓冲区溢出，允许远程攻击者通过精心制作的字符串执行任意代码。
- en: '`socket.send(bytes)`: This method is used to send data to the socket. Before
    sending the data, ensure that the socket is connected to a remote machine. It
    returns the number of bytes sent.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.send(bytes)`: 该方法用于向套接字发送数据。在发送数据之前，请确保套接字已连接到远程机器。它返回发送的字节数。'
- en: '`socket.sendto(data, address)`: This method is used to send data to the socket.
    Generally, we use this method in UDP. UDP is a connectionless protocol; therefore,
    the socket should not be connected to a remote machine, and the address argument
    specifies the address of the remote machine. The returned value tells us the number
    of bytes sent.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendto(data, address)`: 该方法用于向套接字发送数据。通常，我们在UDP中使用此方法。UDP是一种无连接的协议；因此，套接字不应连接到远程机器，地址参数指定远程机器的地址。返回值告诉我们发送的字节数。'
- en: '`socket.sendall(data)`: As the name implies, this method sends all data to
    the socket. Before sending the data, ensure that the socket is connected to a
    remote machine. This method ceaselessly transfers data until an error is seen.
    If an error is seen, an exception will rise, and `socket.close()` will close the
    socket.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendall(data)`: 正如其名称所示，该方法将所有数据发送到套接字。在发送数据之前，请确保套接字已连接到远程机器。此方法不断传输数据，直到出现错误。如果出现错误，将引发异常，并且`socket.close()`将关闭套接字。'
- en: Now, it is time for the practical; no more mundane theory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是实践的时候了；不再是平凡的理论。
- en: Moving on to the practical
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续实践
- en: 'First, we will make a server-side program that offers a connection to the client
    and sends a message to the client. Run `server1.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将制作一个服务器端程序，为客户端提供连接并向客户端发送消息。运行`server1.py`：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is very simple; it is minimal code on the server side.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单；这是服务器端的最小代码。
- en: 'First, import the socket module and define the host and port number, `192.168.0.1`
    is the server''s IP address. `Socket.AF_INET` defines the IPv4 protocol''s family.
    `Socket.SOCK_STREAM` defines the TCP connection. The `s.bind((host,port))` statement
    takes only one argument. It binds the socket to the host and port number. The
    `s.listen(2)` statement listens to the connection and waits for the client. The
    `conn, addr = s.accept()` statement returns two values: `conn` and `addr`. The
    `conn` socket is the client socket, as we discussed earlier. The `conn.send()`
    function sends the message to the client. Finally, `conn.close()` closes the socket.
    From the following examples and screenshot, you will understand `conn` better.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入socket模块并定义主机和端口号，`192.168.0.1`是服务器的IP地址。`Socket.AF_INET`定义了IPv4协议的族。`Socket.SOCK_STREAM`定义了TCP连接。`s.bind((host,port))`语句只接受一个参数。它将套接字绑定到主机和端口号。`s.listen(2)`语句监听连接并等待客户端。`conn,
    addr = s.accept()`语句返回两个值：`conn`和`addr`。`conn`套接字是客户端套接字，正如我们之前讨论的那样。`conn.send()`函数将消息发送给客户端。最后，`conn.close()`关闭套接字。通过以下示例和截图，您将更好地理解`conn`。
- en: 'This is the output of the `server1.py` program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`server1.py`程序的输出：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, the server is in the listening mode and is waiting for the client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器处于监听模式，并且正在等待客户端。
- en: 'Let''s see the client-side code. Run `client1.py`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户端代码。运行`client1.py`：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, there are two new methods, `s.connect((host,port))`,
    which connects the client to the server, and `s.recv(1024)`, which receives the
    strings sent by the server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有两个新方法，`s.connect((host,port))`，它将客户端连接到服务器，以及`s.recv(1024)`，它接收服务器发送的字符串。
- en: 'The output of `client.py` and the response of the server is shown in the following
    screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.py`的输出和服务器的响应如下截图所示：'
- en: '![](img/14f05721-e8ce-4b8f-bb26-5894fa0c874e.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14f05721-e8ce-4b8f-bb26-5894fa0c874e.png)'
- en: The preceding screenshot of the output shows that the server accepted the connection
    from `192.168.0.11`. Don't get confused by seeing port `1789`; it is the random
    port of the client. When the server sends a message to the client, it uses the
    `conn` socket, as mentioned earlier, and this `conn` socket contains the client
    IP address and port number.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上面输出的截图显示服务器接受了来自`192.168.0.11`的连接。不要被看到端口`1789`所困惑；这是客户端的随机端口。当服务器向客户端发送消息时，它使用前面提到的`conn`套接字，这个`conn`套接字包含客户端的IP地址和端口号。
- en: 'The following diagram shows how the client accepts a connection from the server.
    The server is in listening mode, and the client connects to the server. When you
    run the server and client program again, the random port gets changed. For the
    client, the server port, **12345**, is the destination port, and for the server,
    the client random port, **1789**, is the destination port:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了客户端如何接受来自服务器的连接。服务器处于监听模式，客户端连接到服务器。当再次运行服务器和客户端程序时，随机端口会发生变化。对于客户端，服务器端口**12345**是目标端口，对于服务器，客户端随机端口**1789**是目标端口：
- en: '![](img/fd35ccc8-43e5-4dd8-9331-43fd588bcc09.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd35ccc8-43e5-4dd8-9331-43fd588bcc09.png)'
- en: TCP communication
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: TCP通信
- en: 'You can extend the functionality of the server using the `while` loop, as shown
    in the following program. Run the `server2.py` program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`while`循环扩展服务器的功能，如下面的程序所示。运行`server2.py`程序：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is the same as the previous one, except the infinite `while`
    loop has been added.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码与前一个代码相同，只是添加了无限的`while`循环。
- en: Run the `server2.py` program, and from the client, run `client1.py`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`server2.py`程序，并从客户端运行`client1.py`。
- en: 'The output of `server2.py` is shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`server2.py`的输出如下所示：'
- en: '![](img/6b8299e5-1db4-489c-8c82-f858eb2cbc01.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b8299e5-1db4-489c-8c82-f858eb2cbc01.png)'
- en: One server can give service to many clients. The `while` loop keeps the server
    program alive and does not allow the code to end. You can set a connection limit
    to the `while` loop; for example, set `while i>10` and increment `i` with each
    connection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务器可以为多个客户端提供服务。`while`循环使服务器程序保持运行，并且不允许代码结束。您可以为`while`循环设置连接限制；例如，设置`while
    i>10`并且每次连接增加`i`。
- en: Before proceeding to the next example, the concept of `bytearray` should be
    understood. The `bytearray` array is a mutable sequence of unsigned integers in
    the range of 0 to 255\. You can delete, insert, or replace arbitrary values or
    slices. The `bytearray` array's objects can be created by calling the built-in
    `bytearray` array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个例子之前，应该理解`bytearray`的概念。`bytearray`数组是一个可变的无符号整数序列，范围在0到255之间。您可以删除、插入或替换任意值或切片。可以通过调用内置的`bytearray`数组来创建`bytearray`数组的对象。
- en: 'The general syntax of `bytearray` is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytearray`的一般语法如下：'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s illustrate this with an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is an example of slicing the `bytearray`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`bytearray`的切片的一个例子。
- en: 'Now, let''s look at the `split` operation on `bytearray()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`bytearray()`上的`split`操作：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the `append` operation on `bytearray()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`bytearray()`上的`append`操作：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next example is of `s.recv_into(buff)`. In this example, we will use `bytearray()`
    to create a buffer to store data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是`s.recv_into(buff)`。在这个例子中，我们将使用`bytearray()`来创建一个缓冲区来存储数据。
- en: 'First, run the server-side code. Run `server3.py`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行服务器端代码。运行`server3.py`：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding program is the same as the previous one. In this program, the
    server sends `Thanks`; six characters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序与前一个程序相同。在这个程序中，服务器发送`Thanks`；六个字符。
- en: 'Let''s run the client-side program. Run `client3.py`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行客户端程序。运行`client3.py`：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding program, a `buf` parameter is created using `bytearray()`.
    The `s.recv_into(buf)` statement gives us the number of bytes received. The `buf`
    parameter gives us the string received.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的程序中，使用`bytearray()`创建了一个`buf`参数。`s.recv_into(buf)`语句给出了接收到的字节数。`buf`参数给出了接收到的字符串。
- en: 'The output of `client3.py` and `server3.py` is shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`client3.py`和`server3.py`的输出如下所示：'
- en: '![](img/3632eaee-6f83-42d3-8263-8ba308f07af7.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3632eaee-6f83-42d3-8263-8ba308f07af7.png)'
- en: Our client program successfully received 6 bytes of the string, `Thanks`. You
    must have an idea of `bytearray()` by now. I hope you will remember it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端程序成功接收了字符串`Thanks`的6个字节。到目前为止，您应该对`bytearray()`有所了解。我希望您会记得它。
- en: This time, I will create a UDP socket.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我将创建一个UDP套接字。
- en: 'Run `udp1.py`, and we will discuss the code line by line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`udp1.py`，我们将逐行讨论代码：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`socket.SOCK_DGRAM` creates a UDP socket, and `data, addr = s.recvfrom(1024)`
    returns two things, the first is the data and the second is the address of the
    source.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.SOCK_DGRAM`创建了一个UDP套接字，而`data, addr = s.recvfrom(1024)`返回了两个东西，第一个是数据，第二个是源地址。'
- en: 'Now, see the client-side preparations. Run `udp2.py`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看客户端的准备工作。运行`udp2.py`：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, I used the UDP socket and the `s.sendto()` method, as you can see in the
    definition of `socket.sendto()`. You will know that UDP is a connectionless protocol,
    so there is no need to establish a connection here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了UDP套接字和`s.sendto()`方法，如您在`socket.sendto()`的定义中所看到的。您将知道UDP是一种无连接协议，因此这里不需要建立连接。
- en: 'The following screenshot shows the output of `udp1.py` (the UDP server) and
    `udp2.py` (the UDP client):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`udp1.py`（UDP服务器）和`udp2.py`（UDP客户端）的输出：
- en: '![](img/77906a5b-5ba5-43ef-ad49-5b516fde9a16.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77906a5b-5ba5-43ef-ad49-5b516fde9a16.png)'
- en: The server program successfully received data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器程序成功接收了数据。
- en: Let's assume that a server is running and that there is no client start connection,
    and that the server will have been listening. So, to avoid this situation, use
    `socket.settimeout(value)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设服务器正在运行，并且没有客户端开始连接，并且服务器将一直在监听。因此，为了避免这种情况，使用`socket.settimeout(value)`。
- en: Generally, we give a value as an integer; if I give `5` as the value, this would
    mean wait for five seconds. If the operation doesn't complete within five seconds,
    then a timeout exception would be raised. You can also provide a non-negative
    float value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们给一个整数值；如果我给`5`作为值，这意味着等待五秒钟。如果操作在五秒钟内没有完成，那么将引发超时异常。您也可以提供非负浮点值。
- en: 'For example, let''s look at the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下代码：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I added one extra line, that is, `s.settimeout(5)`. The program waits for five
    seconds; only after that will it give us an error message. Run `udptime1.py`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一行额外的代码，即`s.settimeout(5)`。程序等待五秒钟；只有在那之后才会给我们一个错误消息。运行`udptime1.py`。
- en: 'The output is shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示：
- en: '![](img/ff7e8798-e580-437c-bdc4-e4666fb5b71a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff7e8798-e580-437c-bdc4-e4666fb5b71a.png)'
- en: The program shows an error; however, it does not look good if it gives an error
    message. The program should handle the exceptions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示了一个错误；但是，如果它给出一个错误消息，那就不好看了。程序应该处理异常。
- en: Socket exceptions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字异常
- en: 'In order to handle exceptions, we''ll use the try and except blocks. The following
    example will tell you how to handle the exceptions. Run `udptime2.py`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理异常，我们将使用try和except块。以下示例将告诉您如何处理异常。运行`udptime2.py`：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示：
- en: '![](img/2ea24b23-fc29-47b0-b990-9c728967aec7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ea24b23-fc29-47b0-b990-9c728967aec7.png)'
- en: In the try block, I put my code, and from the except block, a customized message
    is printed if any exception occurs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在try块中，我放置了我的代码，从except块中，如果发生任何异常，将打印一个自定义消息。
- en: 'Different types of exceptions are defined in Python''s socket library for different
    errors. These exceptions are described here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python的套接字库定义了不同类型的异常，用于不同的错误。这些异常在这里描述：
- en: '`exception socket.herror`: This block catches the address-related error.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.herror`：此块捕获与地址相关的错误。'
- en: '`exception socket.timeout`: This block catches the exception when a timeout
    on a socket occurs, which has been enabled by `settimeout()`. In the previous
    example, you can see that we used `socket.timeout`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.timeout`：此块捕获套接字启用`settimeout()`的超时发生时的异常。在前面的例子中，您可以看到我们使用了`socket.timeout`。'
- en: '`exception socket.gaierror`: This block catches any exception that is raised
    due to `getaddrinfo()` and `getnameinfo()`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.gaierror`：此块捕获由`getaddrinfo()`和`getnameinfo()`引发的任何异常。'
- en: '`exception socket.error`: This block catches any socket-related errors. If
    you are not sure about any exception, you could use this. In other words, you
    can say that it is a generic block and can catch any type of exception.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.error`：此块捕获任何与套接字相关的错误。如果您对任何异常不确定，可以使用此功能。换句话说，您可以说它是一个通用块，可以捕获任何类型的异常。'
- en: Downloading the example code
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all of the Packt Publishing books you have purchased. If you purchased this
    book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，以获取您购买的所有Packt
    Publishing图书。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: Useful socket methods
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的套接字方法
- en: 'So far, you have gained knowledge of socket and client-server architecture.
    At this level, you can make a small program of networks. However, the aim of this
    book is to test the network and gather information. Python offers very beautiful
    as well as useful methods to gather information. First, import the socket and
    then use these methods:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了套接字和客户端-服务器架构。在这个级别上，您可以制作一个小型的网络程序。但是，本书的目的是测试网络并收集信息。Python提供了非常美丽和有用的方法来收集信息。首先，导入套接字，然后使用这些方法：
- en: '`socket.gethostbyname(hostname)`: This method converts a hostname to the IPv4
    address format. The IPv4 address is returned in the form of a string. Here is
    an example:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyname(hostname)`：此方法将主机名转换为IPv4地址格式。IPv4地址以字符串形式返回。这是一个例子：'
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I know you are thinking about the `nslookup` command. Later, you will see more
    magic.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道您正在考虑`nslookup`命令。稍后，您将看到更多的魔法。
- en: '`socket.gethostbyname_ex(name)`: This method converts a hostname to the IPv4
    address pattern. However, the advantage over the previous method is that it gives
    all the IP addresses of the domain name. It returns a tuple (hostname, canonical
    name, and IP_addrlist) where the hostname is given by us, the canonical name is
    a (possibly empty) list of canonical hostnames of the server for the same address,
    and IP_addrlist is a list of all of the available IP addresses of the same hostname.
    Often, one domain name is hosted on many IP addresses to balance the load of the
    server. Unfortunately, this method does not work for IPv6\. I hope you are well-acquainted
    with tuples, lists, and dictionaries. Let''s look at an example:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyname_ex(name)`：此方法将主机名转换为IPv4地址模式。然而，与前一种方法相比的优势在于它给出了域名的所有IP地址。它返回一个元组（主机名，规范名称和IP_addrlist），其中主机名由我们给出，规范名称是服务器的规范主机名（可能为空）的列表，IP_addrlist是同一主机名的所有可用IP地址的列表。通常，一个域名托管在许多IP地址上，以平衡服务器的负载。不幸的是，这种方法不适用于IPv6。我希望你对元组、列表和字典很熟悉。让我们看一个例子：'
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It returns many IP addresses for a single domain name. This means that one domain
    such as `thapar.edu` or `google.com` runs on multiple IPs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它为一个域名返回许多IP地址。这意味着一个域名如`thapar.edu`或`google.com`在多个IP上运行。
- en: '`socket.gethostname()`: This returns the hostname of the system where the Python
    interpreter is currently running:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostname()`：返回Python解释器当前运行的系统的主机名：'
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To glean the current machine''s IP address by using the socket module, you
    can use the following trick using `gethostbyname(gethostname())`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字模块来获取当前机器的IP地址，可以使用以下技巧：`gethostbyname(gethostname())`：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You know that our computer has many interfaces. If you want to know the IP address
    of all of the interfaces, use the extended interface:.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道我们的计算机有许多接口。如果您想知道所有接口的IP地址，可以使用扩展接口：。
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It returns one tuple containing three elements, the first is the machine name,
    the second is a list of aliases for the hostname (empty, in this case,) and the
    third is the list of the IP addresses of interfaces.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含三个元素的元组，第一个是机器名，第二个是主机名的别名列表（在这种情况下为空），第三个是接口的IP地址列表。
- en: '`socket.getfqdn([name])`: This is used to find the fully qualified domain name
    if it''s available. The fully qualified domain name consists of a host and domain
    name; for example, `beta` might be the hostname, and `example.com` might be the
    domain name. The **fully qualified domain name** (**FQDN**) becomes `beta.example.com`:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getfqdn([name])`：如果可用，用于查找完全合格的域名。完全合格的域名由主机名和域名组成；例如，`beta`可能是主机名，`example.com`可能是域名。**完全合格的域名**（**FQDN**）变成了`beta.example.com`：'
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, `edge-star-shv-12-frc3` is the hostname, and `facebook.com`
    is the domain name. In the following example, FQDN is not available for `thapar.edu`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`edge-star-shv-12-frc3`是主机名，`facebook.com`是域名。在下面的例子中，`thapar.edu`的FQDN不可用：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the name argument is blank, it returns the current machine name:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称参数为空，它将返回当前机器的名称：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`socket.gethostbyaddr(ip_address)`: This is like a *reverse* lookup for the
    name. It returns a tuple (hostname, canonical name, and IP_addrlist) where hostname
    is the hostname that responds to the given `ip_address`, the canonical name is
    a (possibly empty) list of canonical names of the same address, and IP_addrlist
    is a list of IP addresses for the same network interface on the same host:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyaddr(ip_address)`：这就像是对名称的*反向*查找。它返回一个元组（主机名，规范名称和IP_addrlist），其中主机名是响应给定`ip_address`的主机名，规范名称是同一地址的规范名称（可能为空）的列表，IP_addrlist是同一主机上同一网络接口的IP地址列表：'
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It shows an error in the last query because reverse DNS lookup is not present.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了最后一个查询中的错误，因为没有反向DNS查找。
- en: '`socket.getservbyname(servicename[, protocol_name])`: This converts any protocol
    name to the corresponding port number. The Protocol name is optional, either TCP
    or UDP. For example, the DNS service uses TCP as well as UDP connections. If the
    protocol name is not given, any protocol could match:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getservbyname(servicename[, protocol_name])`：这将任何协议名称转换为相应的端口号。协议名称是可选的，可以是TCP或UDP。例如，DNS服务使用TCP和UDP连接。如果没有给出协议名称，任何协议都可以匹配：'
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`socket.getservbyport(port[, protocol_name])`: This converts an internet port
    number to the corresponding service name. The protocol name is optional, either
    TCP or UDP:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getservbyport(port[, protocol_name])`：这将互联网端口号转换为相应的服务名称。协议名称是可选的，可以是TCP或UDP：'
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`socket.connect_ex(address)`: This method returns an error indicator. If successful,
    it returns `0`; otherwise, it returns the `errno` variable. You can take advantage
    of this function to scan the ports. Run the `connect_ex.py` program:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.connect_ex(address)`：此方法返回一个错误指示器。如果成功，它返回`0`；否则，它返回`errno`变量。您可以利用这个函数来扫描端口。运行`connect_ex.py`程序：'
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示：
- en: '![](img/3dbc81c8-458a-4fb5-bed1-9981140d834d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dbc81c8-458a-4fb5-bed1-9981140d834d.png)'
- en: 'The preceding program output shows that ports `80` ,`912` ,`135 `, and `445`
    are open. This is a rudimentary port scanner. The program is using the IP address
    `127.0.0.1`; this is a loopback address, so it is impossible to have any connectivity
    issues. However, when you have issues, perform this on another device with a large
    port list. This time, you will have to use `socket.settimeout(value)`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序输出显示端口`80`，`912`，`135`和`445`是开放的。这是一个基本的端口扫描程序。程序正在使用IP地址`127.0.0.1`；这是一个环回地址，所以不可能有任何连接问题。然而，当您遇到问题时，在另一台设备上执行此操作，并使用一个大的端口列表。这时，您将需要使用`socket.settimeout(value)`：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This socket method converts the host and port arguments into a sequence of five
    tuples.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个套接字方法将主机和端口参数转换为五元组的序列。
- en: 'Let''s take a look at the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Output `2` represents the family, `1` represents the socket type, `0` represents
    the protocol, `''` represents the canonical name, and `('220.227.15.47', 80)`
    represents the `2` socket address. However, this number is difficult to comprehend.
    Open the directory of the socket.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`2`表示家族，`1`表示套接字类型，`0`表示协议，`''`表示规范名称，`('220.227.15.47', 80)`表示`2`套接字地址。然而，这个数字很难理解。打开套接字的目录。
- en: 'Use the following code to find the result in a readable form:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码以可读的形式找到结果：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the code is shown in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出显示在以下截图中：
- en: '![](img/b23fe0ab-be34-4f13-ba4e-06051b364ca5.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b23fe0ab-be34-4f13-ba4e-06051b364ca5.png)'
- en: The upper part makes a dictionary using the `AF_`, `SOCK_`, and `IPPROTO_` prefixes
    that map the protocol number to their names. This dictionary is formed by the
    list comprehension technique.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上部分使用`AF_`、`SOCK_`和`IPPROTO_`前缀创建了一个字典，将协议号映射到它们的名称。这个字典是通过列表推导技术形成的。
- en: 'The upper part of the code might be confusing sometimes, but we can execute
    the code separately as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的上部分有时可能会令人困惑，但我们可以分别执行代码如下：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, this is easy to understand. This code is usually used to get the protocol
    number:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很容易理解。这段代码通常用于获取协议号：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding line of code returns the five values, as discussed in the definition.
    These values are then matched with their corresponding dictionary.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前一行返回了五个值，如定义中所讨论的。然后将这些值与其相应的字典进行匹配。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: From reading this chapter, you have got an understanding of networking in Python.
    The aim of this chapter was to complete the prerequisites of the upcoming chapters.
    From the start, you have learned the need for pentesting. Pentesting is conducted
    to identify threats and vulnerabilities in an organization. What should be tested?
    This is specified in the agreement; don't try to test anything that is not mentioned
    in the agreement. The agreement is your get out of jail free card. A pentester
    should have knowledge of the latest technology, and you should have some knowledge
    of Python before you start reading this book. In order to run Python scripts,
    you should have a lab setup, a network of computers to test a live system, and
    dummy websites running on the Apache server.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，您已经了解了Python中的网络。本章的目的是完成即将到来的章节的先决条件。从一开始，您就学会了渗透测试的必要性。渗透测试是为了识别组织中的威胁和漏洞。应该测试什么？这在协议中有规定；不要尝试测试协议中未提及的任何内容。协议是您的免责条款。渗透测试人员应该了解最新的技术，并且在阅读本书之前应该对Python有一些了解。为了运行Python脚本，您应该有一个实验室设置，一个用于测试实时系统的计算机网络，以及在Apache服务器上运行的虚拟网站。
- en: This chapter also discussed the socket and its methods. The server socket method
    defines how to make a simple server. The server binds its own address and port
    to listen to the connections. A client that knows the server address and port
    number connects to the server to get a service. Some socket methods such as `socket.recv(bufsize)`,
    `socket.recvfrom(bufsize)`, `socket.recv_into(buffer)`, `socket.send(bytes)`,
    and so on are useful for the server as well as the client. You learned how to
    handle different types of exceptions. In the *Useful socket methods* section,
    you got an idea of how to get the IP address and hostname of a machine, how to
    glean the IP address from the domain name, and vice versa.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了套接字及其方法。服务器套接字方法定义了如何创建一个简单的服务器。服务器将自己的地址和端口绑定到监听连接。知道服务器地址和端口号的客户端连接到服务器以获取服务。一些套接字方法，如`socket.recv(bufsize)`、`socket.recvfrom(bufsize)`、`socket.recv_into(buffer)`、`socket.send(bytes)`等对服务器和客户端都很有用。您学会了如何处理不同类型的异常。在*有用的套接字方法*部分，您了解了如何获取机器的IP地址和主机名，如何从域名中获取IP地址，反之亦然。
- en: In the next chapter, we will be looking at scanning pentesting, which includes
    IP address scanning to detect live hosts. To carry out IP scanning, ping sweep
    and TCP scanning are used. You will learn how to detect services running on a
    remote host using a port scanner.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究扫描渗透测试，其中包括IP地址扫描以检测活动主机。进行IP扫描时，使用ping扫描和TCP扫描。您将学习如何使用端口扫描器检测远程主机上运行的服务。
