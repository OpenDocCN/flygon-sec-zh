- en: Chapter 4. SQL Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。SQL注入
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Checking jitter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查抖动
- en: Identifying URL-based SQLi
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别基于URL的SQLi
- en: Exploiting Boolean SQLi
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用布尔SQLi
- en: Exploiting Blind SQLi
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用盲目SQLi
- en: Encoding payloads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码有效载荷
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: SQL Injection is the loud and noisy attack that beats you over the head in every
    tech-related media provider you see. It is one of the most common and most devastating
    attacks of recent history and continues to thrive in new installations. This chapter
    focuses on both performing and supporting SQL Injection attacks. We will create
    scripts that encode attack strings, perform attacks, and time normal actions to
    normalize attack times.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是一种吵闹的攻击，在你看到的每个与技术相关的媒体提供商中都会被强调。这是最常见和最具破坏性的攻击之一，继续在新的安装中蓬勃发展。本章重点介绍执行和支持SQL注入攻击。我们将创建编码攻击字符串的脚本，执行攻击，并计时正常操作以规范化攻击时间。
- en: Checking jitter
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查抖动
- en: The only difficult thing about performing time-based SQL Injections is that
    plague of gamers everywhere, lag. A human can easily sit down and account for
    lag mentally, taking a string of returned values, and sensibly going over the
    output and working out that *cgris* is *chris*. For a machine, this is much harder;
    therefore, we should attempt to reduce delay.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 执行基于时间的SQL注入的唯一困难之处在于无处不在的游戏玩家的灾难，即延迟。人类可以轻松地坐下来，心理上考虑延迟，获取一系列返回的值，并明智地检查输出并计算出*cgris*是*chris*。对于机器来说，这要困难得多；因此，我们应该尝试减少延迟。
- en: We will be creating a script that makes multiple requests to a server, records
    the response time, and returns an average time. This can then be used to calculate
    fluctuations in responses in time-based attacks known as **jitter**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，该脚本向服务器发出多个请求，记录响应时间，并返回平均时间。然后可以用来计算时间攻击中响应波动，这种攻击被称为**抖动**。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Identify the URLs you wish to attack and provide to the script through a `sys.argv`
    variable:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您希望攻击的URL，并通过`sys.argv`变量提供给脚本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot is an example of the output produced when using this
    script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时产生的输出示例如下：
- en: '![How to do it…](img/B04044_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B04044_04_01.jpg)'
- en: How it works…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We import the libraries we require for this script, as with every other script
    we''ve done in this book so far. We set the counter `I` to zero and create an
    empty list for the times we are about to generate:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了这个脚本所需的库，就像我们在本书中做的其他脚本一样。我们将计数器`I`设置为零，并创建一个空列表，用于我们即将生成的时间：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the counter `I`, we run `100` requests to the target URL and append the
    response time of the request to list we created earlier. `R.elapsed` is a `timedelta`
    object, not an integer, and therefore must be called with `.total_seconds()` in
    order to get a usable number for our later average. We then add one to the counter
    to account for this loop and so that the script ends appropriately:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计数器`I`，我们向目标URL运行`100`个请求，并将请求的响应时间附加到我们之前创建的列表中。`R.elapsed`是一个`timedelta`对象，而不是整数，因此必须使用`.total_seconds()`调用它，以便获得我们后来平均值的可用数字。然后我们将计数器加一，以便在此循环中计数，并使脚本适当地结束：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the loop is complete, we calculate the average of the `100` requests by
    calculating the total values of the list with `sum` and dividing it by the number
    of values in the list with `len`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，我们通过使用`sum`计算列表的总值并使用`len`除以列表中的值来计算`100`个请求的平均值。
- en: We then return a basic output for ease of understanding.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们返回一个基本的输出，以便理解。
- en: There's more…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This is a very basic way of performing this action and only really performs
    the function as a standalone script to prove a point. To be performed as part
    of another script, we would do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行此操作的一种非常基本的方式，实际上只是作为一个独立的脚本来证明一个观点。要作为另一个脚本的一部分执行，我们将执行以下操作：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Identifying URL-based SQLi
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别基于URL的SQLi
- en: So, we've looked at fuzzing before for XSS and error messages. This time, we're
    doing something similar but with SQL Injection, instead. The crux of any SQLi
    starts with a single quotation mark, tick, or apostrophe, depending on your personal
    choice of word. We throw a tick into the URL targeted and check the response to
    see what version of SQL is running if successful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前已经看过XSS和错误消息的模糊处理。这一次，我们做的是类似的事情，但是用SQL注入代替。任何SQLi的关键都始于一个单引号，勾号或撇号，取决于您个人选择的单词。我们将一个撇号扔进目标URL中，并检查响应，以查看如果成功，正在运行的SQL版本是什么。
- en: We will create a script that sends the basic SQL Injection string to our targeted
    URL, record the output, and compare to known phrases in error messages to identify
    the underlying system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，将基本的SQL注入字符串发送到我们的目标URL，记录输出，并与错误消息中已知的短语进行比较，以识别底层系统。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script we will be using is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is an example of the output produced when using this script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时产生的输出示例如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We import our libraries and set our URL manually. We can set it as a `sys.argv`
    variable if needs be; however, I have hardcoded it here to show the expected format.
    We set the initial injection string as a single quotation mark and print that
    the test is starting:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入我们的库并手动设置我们的URL。如果需要，我们可以将其设置为`sys.argv`变量；但是，我在这里将其硬编码为了显示预期的格式。我们将初始注入字符串设置为单引号，并打印测试正在开始：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We make our first request as our provided URL and the apostrophe:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的第一个请求作为我们提供的URL和撇号：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next few lines are our detection methods to identify what the underlying
    database is. The MySQL standard error is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行是我们的检测方法，用于识别底层数据库是什么。MySQL标准错误是：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Correspondingly, our detection attempt reads in the text of response and searches
    for the `MySQL` string and, if so, prints out that the attempt was successful:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，我们的检测尝试读取响应文本，并搜索`MySQL`字符串，如果成功，则打印出尝试成功：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For MS SQL, an example error message is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MS SQL，一个示例错误消息是：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since there are multiple potential error messages, we need to identify one
    constant that occurs across as many of them as possible. For this, I have chosen
    `native client,` though `Microsoft SQL` could also be used:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个潜在的错误消息，我们需要确定尽可能多的错误消息中发生的一个常量。为此，我选择了`native client`，尽管`Microsoft SQL`也可以使用：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The standard error message for PostgreSQL is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的标准错误消息是：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Interestingly, for what is always a syntax error in SQL, the only solution
    that regularly uses the `syntax` word is `PostGRES,` which allows us to use that
    as the distinguishing word:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，对于SQL中总是语法错误的情况，唯一经常使用`syntax`一词的解决方案是`PostGRES`，这使我们可以将其用作区分词：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last system we check is Oracle. An example error message for Oracle is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查的最后一个系统是Oracle。Oracle的一个示例错误消息是：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'ORA is the prefix for the majority of Oracle errors and therefore can be used
    as the identifier here. There are only a few fringe cases where a non-ORA error
    message would apply to a trailing tick:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ORA是大多数Oracle错误的前缀，因此可以在这里用作标识符。只有少数边缘情况下，非ORA错误消息会应用于尾随的单引号：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the event in which none of these apply, we have a final `else` statement
    that declares the parameter is not injectable and that an error was made in picking
    this parameter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以上情况都不适用，我们有一个最终的`else`语句，声明参数不可注入，并且在选择该参数时出错。
- en: 'An example output is shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出的屏幕截图：
- en: '![How it works…](img/B04044_04_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04044_04_02.jpg)'
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Tying this script in with the spider found in [Chapter 1](ch01.html "Chapter 1. Gathering
    Open Source Intelligence"), *Gathering Open Source Intelligence*, would make for
    a quick efficient way of identifying injectable URLs across a web page. A method
    of identifying parameters to inject would be necessary, which can be achieved
    through simple regex manipulation in most cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本与[第1章](ch01.html "第1章。收集开源情报")中找到的蜘蛛联系起来，*收集开源情报*，将成为识别网页上可注入URL的快速高效方法。在大多数情况下，需要一种识别要注入的参数的方法，这可以通过简单的正则表达式操作来实现。
- en: A set of useful SQLi test pages were made by Audi-1 and can be found at [https://github.com/Audi-1/sqli-labs](https://github.com/Audi-1/sqli-labs).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Audi-1制作了一组有用的SQLi测试页面，可以在[https://github.com/Audi-1/sqli-labs](https://github.com/Audi-1/sqli-labs)找到。
- en: Exploiting Boolean SQLi
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用布尔SQLi
- en: There are times when all you can get from a page is a yes or no. It's heartbreaking
    until you realize that that's the SQL equivalent of saying *I LOVE YOU*. All SQLi
    can be broken down into yes or no questions, depending on how patient you are.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只能从页面上得到一个是或否的答案。当你意识到这就是SQL等价于说“我爱你”的时候，这是令人心碎的。所有的SQLi都可以分解成是或否的问题，取决于你的耐心。
- en: We will create a script that takes a `yes` value and a URL and returns results
    based on a predefined attack string. I have provided an example attack string
    but this will change, depending on the system you are testing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，它接受一个`yes`值和一个URL，并根据预定义的攻击字符串返回结果。我提供了一个示例攻击字符串，但这将根据您正在测试的系统而变化。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following script is how yours should look:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是您的脚本应该的样子：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, the user must identify a string that only occurs when the SQLi is
    successful. Alternatively, the script may be altered to respond to the absence
    of proof of a failed SQLi. We provide this string as a `sys.argv` variable. We
    also create the two iterators that we will use in this script and have set them
    to `1`, as MySQL starts counting from `1` instead of `0` like the failed system
    it is. We also create an empty list for our future answer and instruct the user
    that the script is starting:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户必须识别仅在SQLi成功时发生的字符串。或者，可以修改脚本以响应SQLi失败的证据缺失。我们将此字符串作为`sys.argv`变量提供。我们还创建了我们将在此脚本中使用的两个迭代器，并将它们设置为`1`，因为MySQL从`1`开始计数，而不是像失败的系统那样从`0`开始。我们还为我们未来的答案创建了一个空列表，并告知用户脚本正在启动：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our payload here basically requests the length of the password we are attempting
    to return and compares it to a value that will be iterated:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的有效载荷基本上请求我们试图返回的密码长度，并将其与将要迭代的值进行比较：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then repeat the next loop forever as we have no idea how long the password
    is. We submit the payload to the target URL in a `POST` request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们永远重复下一个循环，因为我们不知道密码有多长。我们将有效载荷提交到目标URL以进行`POST`请求：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each time we check to see if the `yes` value we set originally is present in
    the response text and, if so, we end the while loop setting the current value
    of `i` as the parameter length. The `break` command is the part that ends the
    `while` loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次检查我们最初设置的`yes`值是否出现在响应文本中，如果是，我们结束`while`循环，将`i`的当前值设置为参数长度。`break`命令是结束`while`循环的部分：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we don''t detect the `yes` value, we add `1` to `i` and continue the loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有检测到`yes`值，我们将`i`加`1`并继续循环：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the identified length of the target string, we iterate through each character
    and, using the `asciivalue`, each possible value of that character. For each value,
    we submit it to the target URL. Because the ascii table only runs up to `127`,
    we cap the loop to run until the `asciivalue` has reached `126`. If it reaches
    `127`, something has gone wrong:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目标字符串的已识别长度，我们遍历每个字符，并使用`asciivalue`，每个可能的字符值。对于每个值，我们将其提交到目标URL。因为ascii表只运行到`127`，我们将循环限制到`asciivalue`达到`126`为止。如果达到`127`，则出现了问题：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We check to see if our yes string is present in the response and, if so, break
    to go onto the next character. We append our successful message to our answer
    string in character form, converting it with the `chr` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查我们的是字符串是否出现在响应中，如果是，就跳转到下一个字符。我们将成功的消息以字符形式附加到我们的答案字符串中，并使用`chr`命令进行转换：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the `yes` value is not present, we add to `asciivalue` to move on to the
    next potential character for that position and pass:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`yes`值不存在，我们将`asciivalue`添加到移动到下一个可能的字符位置并通过：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we reset `asciivalue` for each loop, and then when the loop hits the
    length of the string, we finish, printing the whole recovered string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个循环重置`asciivalue`，然后当循环达到字符串的长度时，我们完成，打印整个恢复的字符串：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Potentially, this script could be altered to handle iterating through tables
    and recovering multiple values through better crafted SQL Injection strings. Ultimately,
    this provides a base plate, as with the later Blind SQL Injection script, for
    developing more complicated and impressive scripts to handle challenging tasks.
    See the *Exploiting Blind SQL Injection* script for an advanced implementation
    of these concepts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在地，这个脚本可以被修改以处理遍历表并通过更好设计的SQL注入字符串恢复多个值。最终，这提供了一个基础，就像后来的盲目SQL注入脚本一样，用于开发更复杂和令人印象深刻的脚本来处理具有挑战性的任务。查看*利用盲目SQL注入*脚本，了解这些概念的高级实现。
- en: Exploiting Blind SQL Injection
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用盲目SQL注入
- en: Sometimes, life hands you lemons; blind SQL Injection points are some of those
    lemons. When you're reasonably sure you've found an SQL Injection vulnerability
    but there are no errors and you can't get it to return your data, in these situations
    you can use timing commands within SQL to cause the page to pause in returning
    a response and then use that timing to make judgments about the database and its
    data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，生活会给你柠檬；盲目的SQL注入点就是其中之一。当你相当确定已经找到了SQL注入漏洞，但没有错误，也无法让它返回你的数据时，在这些情况下，你可以在SQL中使用时间命令来导致页面暂停返回响应，然后利用这个时间来判断数据库及其数据。
- en: We will create a script that makes requests to the server and returns differently
    timed responses, depending on the characters it's requesting. It will then read
    those times and reassemble strings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，向服务器发出请求，并根据请求的字符返回不同时间的响应。然后它将读取这些时间并重新组装字符串。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本如下：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'As ever, we import the required libraries and declare the lists that we need
    to fill later on. We also have a function here that states that the script has
    indeed started. With some time-based functions, the user can be left waiting a
    while. In this script, I have also included cookies using the `request` library.
    For this sort of attack, it is likely that authentication is required:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们导入所需的库并声明我们需要稍后填充的列表。我们还在这里有一个函数，说明脚本确实已经开始。在某些基于时间的函数中，用户可能需要等待一段时间。在这个脚本中，我还使用了`request`库来包含cookies。对于这种攻击，可能需要进行身份验证：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We set our payload up in a dictionary along with a submit button. The attack
    string is simple enough to understand with some explanation. The initial tick
    has to be escaped to be treated as text within the dictionary. That tick breaks
    the SQL command initially and allows us to input our own SQL commands. Next, we
    say that in the event of the first command failing, perform the following command
    with `OR`. We then tell the server to sleep for one second for every character
    in the first row in the password column. Finally, we close the statement with
    a semicolon and comment out any trailing characters with a hash (or pound if you''re
    American and/or wrong):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在字典中设置了我们的有效载荷以及一个提交按钮。攻击字符串足够简单，通过一些解释就可以理解。初始的撇号必须被转义为字典内的文本。该撇号最初中断了SQL命令，并允许我们输入自己的SQL命令。接下来，我们说在第一个命令失败的情况下，执行以下命令与`OR`。然后，我们告诉服务器为密码列中第一行中的每个字符休眠一秒。最后，我们用分号关闭语句，并用井号（或者如果你是美国人和/或错误的话，用英镑）注释掉任何尾随字符：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then set length of time the server took to respond as the `firstreponsetime`
    parameter. We will use this to understand how many characters we need to brute-force
    through this method in the following chain:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将服务器响应所花费的时间长度设置为`firstreponsetime`参数。我们将使用这个参数来理解我们需要通过这种方法暴力破解多少个字符：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We create a loop that will set `x` to be all numbers from `1` to the length
    of the string identified and perform an action for each one. We start from `1`
    here because MySQL starts counting from `1` rather than zero, like Python:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个循环，将`x`设置为从标识的字符串的长度为`1`到所有数字，并对每个数字执行一个操作。我们从这里开始是因为MySQL从`1`开始计数，而不是像Python一样从零开始：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We make a similar payload as before, but this time we are saying sleep for
    the ascii value of `X` character of the password in the password column, row one.
    So, if the first character was a lower case a, then the corresponding ascii value
    is 97, and therefore the system would sleep for 97 seconds. If it was a lower
    case b, it would sleep for 98 seconds, and so on:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了一个类似之前的有效载荷，但这次我们说在密码列的密码的第一个字符的ascii值处休眠。因此，如果第一个字符是小写a，那么对应的ascii值是97，因此系统会休眠97秒。如果是小写b，它将休眠98秒，依此类推：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We submit our data each time for each character place in the string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次为字符串中的每个字符位置提交我们的数据。
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We take the response time from each request to record how long the server sleeps
    and then convert that time back from an ascii value into a letter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取每个请求的响应时间，记录服务器休眠的时间，然后将该时间从ascii值转换回字母：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each iteration, we print out the password as it is currently known and
    then eventually print out the full password:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次迭代，我们打印出当前已知的密码，然后最终打印出完整的密码：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script provides a framework that can be adapted to many different scenarios.
    Wechall, the web app challenge website, sets a time-limited, Blind SQLi challenge
    that has to be completed in a very short time period. The following is our original
    script, which has been adapted to this environment. As you can see, I''ve had
    to account for smaller time differences in differing values and server lag, and
    also incorporated a checking method to reset the testing value each time and submit
    it automatically:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本提供了一个可以适应许多不同情况的框架。Wechall，这个网站挑战网站，设置了一个有时间限制的盲目SQLi挑战，必须在很短的时间内完成。以下是我们的原始脚本，已经适应了这个环境。正如你所看到的，我不得不考虑到不同值的较小时间差异和服务器延迟，并且还包括了一个检查方法，每次重置测试值并自动提交它：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Encoding payloads
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码有效载荷
- en: One method of halting SQL Injection is filtering through either server side
    text manipulation or **Web App Firewalls** (**WAFs**). These systems target specific
    phrases commonly associated with attacks such as `SELECT`, `AND`, `OR`, and spaces.
    These can be easily evaded by replacing these values with less obvious ones, thus
    highlighting the issue with blacklists in general.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止SQL注入的一种方法是通过服务器端文本操作或**Web应用程序防火墙**（**WAFs**）进行过滤。这些系统针对与攻击常见相关的特定短语，如`SELECT`，`AND`，`OR`和空格。这些可以通过用不太明显的值替换这些值来轻松规避，从而突显了黑名单的一般问题。
- en: We will create a script that takes attack strings, looks for potentially escaped
    strings, and provides alternative attack strings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，该脚本接受攻击字符串，查找潜在的转义字符串，并提供替代的攻击字符串。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following is our script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的脚本：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot is an example of the output produced when using this
    script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是使用此脚本时产生的输出的示例：
- en: '![How to do it…](img/B04044_04_03.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B04044_04_03.jpg)'
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This script requires no libraries! How shocking! We create an empty list for
    the values that we are about to create and dictionary of the substitute values
    that we intend to add. I've put five example values in. Spaces and `%20` are commonly
    escaped by WAFs as URLs tend to not include spaces unless something inappropriate
    is being requested.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本不需要任何库！真是令人震惊！我们为即将创建的值创建一个空列表，并创建一个意图添加的替代值的字典。我放了五个示例值。空格和`%20`通常被WAFs转义，因为URL通常不包括空格，除非请求了不当的内容。
- en: 'More specifically, tuned systems may escape SQL specific words such as `SELECT`,
    `AND`, and `OR`. These are the very basic values and can be added to or replaced
    as you see fit:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，调整过的系统可能会避开SQL特定词语，比如`SELECT`，`AND`和`OR`。这些都是非常基本的值，可以根据需要添加或替换：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I''ve hardcoded the original string as an example, so we can see how it works.
    I''ve included a valid SQLi string with all of the above values embedded to prove
    it''s usage:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将原始字符串硬编码为示例，这样我们就可以看到它是如何工作的。我已经包含了一个包含上述所有值的有效SQLi字符串，以证明它的用法：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We create a second version of the original string, so that we can create a
    cumulative result and a standalone result for each substitution:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建原始字符串的第二个版本，以便我们可以为每个替换创建一个累积结果和一个独立结果：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We take each dictionary item in turn and assign each key and value to the parameters
    key and value, respectively:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次取每个字典项，并将每个键和值分配给参数键和值：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We look to see if the initial term is present and then, if so, replace it with
    the key value. For example, if a space is present, we will replace it with `%50`,
    which is the tab character URL-encoded:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看初始术语是否存在，如果存在，则用键值替换它。例如，如果存在空格，我们将用`%50`替换它，这是URL编码的制表符字符：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This string, each iteration, will reset to the original value that we set at
    the beginning of the script. We then take that string and add to the list we created
    earlier:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串，在每次迭代时，都会重置为我们在脚本开头设置的原始值。然后我们将该字符串添加到之前创建的列表中：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We perform the same actions as the preceding with the iterative string that
    replaces itself each turn to create a multi-encoded version:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行与之前相同的操作，使用迭代字符串来创建一个多次编码的版本：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we make the list unique by turning it into a set and return it to
    the user row by row:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将其转换为集合使列表变得唯一，并逐行将其返回给用户：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Again, this can be made into an internal function rather than being used as
    a standalone script. This can alternatively be achieved by using the following
    script:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这可以成为一个内部函数，而不是作为独立脚本使用。也可以通过使用以下脚本来实现：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
