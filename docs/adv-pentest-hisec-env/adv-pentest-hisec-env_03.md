# 第三章。枚举：明智地选择你的目标

要成功渗透一个安全的环境，你必须对你所面对的情况有很好的理解。收集到的枚举数据将有助于确定目标优先级。在本章结束时，你应该能够选择哪些目标是你初始攻击的理想候选人。某些攻击类型比其他攻击类型更“嘈杂”，因此有针对性的攻击更不容易被注意到。由于开源社区的辛勤工作，我们有大量的工具可用来帮助我们枚举网络。在本章中，我们将讨论以下内容：

+   如何将另一台计算机添加到我们的虚拟实验室

+   高级 Nmap 扫描技术

+   向你的武器库添加自定义 Nmap 脚本

+   使用 SNMP 节省时间

+   使用 PBNJ 为你的目标网络建立基线

+   避免枚举尝试-混淆敌人

### 注意

本章中的一些示例利用防火墙和 IDS 日志，让读者了解某些扫描和技术对网络的影响。我们将在后面的章节中审查它们的安装和配置。

# 向我们的实验室添加另一台虚拟机

我们已经到达了书中另一台系统对我们的实验室有益的地方。在本节中，我们将在我们的网络上安装另一台机器，这样我们就可以尝试描述的枚举技术。

### 注意

虽然有益，但在这一点上安装另一个虚拟系统并不是绝对必要的。所有的例子都在书中有清晰的记录。

在本文中，我们将使用 Ubuntu **10.04 LTS 64 位**作为示例。你可以从[`www.ubuntu.com/download/ubuntu/download`](http://www.ubuntu.com/download/ubuntu/download)下载 Ubuntu 10.04 LTS。一旦你获得了 ISO 的副本，我们就可以开始安装。

在 VirtualBox 中准备一个新的虚拟机，步骤如下：

+   **名字：***Ubuntu_TestMachine_1*

+   **操作系统：***Linux*，**版本：***Ubuntu 或 Ubuntu 64（64 位）*

+   **内存：***最低 512*

+   **创建新的硬盘：***VDI，动态分配，最小 10GB*![向我们的实验室添加另一台虚拟机](img/7744_03_01.jpg)

启动**Ubuntu_TestMachine_1**虚拟机，并使用**First Run Wizard**选择你已经下载的 Ubuntu ISO 作为安装媒体。按照标准的 Ubuntu 安装过程使用完整的虚拟机（VBOX ATA）驱动器。

在安装过程中选择以下设置：

1.  你的名字是什么：学生

1.  你想用什么名字登录：学生

1.  选择一个密码：1easyPassword

1.  这台计算机的名字是什么？：Phobos

1.  需要我的密码登录：已选择

一旦你成功安装了 Ubuntu，它就需要更新。打开一个终端窗口，方法是转到左上角菜单，选择**应用程序|附件|终端**，然后输入：

```
# sudo apt-get update 

```

接着：

```
# sudo apt-get upgrade 

```

由于我们将使用这个系统作为典型网络上可能看到的示例，我们需要安装一些有趣的服务。

1.  打开一个终端会话，输入以下命令，它将安装 Apache、MySQL 和 PHP：

```
# sudo apt-get install lamp-server 

```

1.  安装将继续，在下载了一些文件之后，你将需要输入你选择的**MySQL**根用户的密码。

1.  确认你的密码并按*Enter*。

系统已经更新，我们有一些有趣的端口可以用于扫描。现在我们可以关闭新的客户机，并使用**VM VirtualBox Manager Settings**图标将网络设置更改为**内部网络**，名称设置为：**Vlab_1**。将**网络适配器**设置为**内部网络**允许我们的 BackTrack 系统与新创建的 Ubuntu 机器共享相同的子网。

![向我们的实验室添加另一台虚拟机](img/7744_03_02.jpg)

## 配置和测试我们的 Vlab_1 客户端

让我们启动我们的两台虚拟机，然后配置和测试网络连接。

### BackTrack 手册 ifconfig

在**BT5_R1_Tester1**中打开终端，然后键入以下内容：

```
# ifconfig eth1 192.168.50.10 netmask 255.255.255.0 broadcast 192.168.50.255 promisc 

```

我们已经将位于我们的虚拟`VLab_1`段上的`eth1`设置为 IP 地址`192.168.50.10`，**网络掩码**设置为`255.255.255.0`，并将`广播`地址设置为`192.168.50.255`。作为额外的奖励，我们还将设备设置为**淫乱**模式。

### 提示

为了使淫乱模式工作，必须启用它。该选项位于**VM Manager**的**网络设置**下。默认情况下，此设置对所有网络适配器都禁用。

淫乱模式允许您监视网络段上的流量。

### Ubuntu——手动 ifconfig

通过使用顶部菜单栏并单击**应用程序|附件|终端**在`Ubuntu_TestMachine_1`中打开终端。键入`sudo ifconfig`以检查当前配置。如果一切配置正确，`eth0`应该没有分配 IP 地址。我们将通过重复用于我们的 BackTrack 机器的步骤来纠正这种情况。这次我们将使用`eth0`而不是`eth1`，并且我们不会将此网络适配器置于淫乱模式。

```
# sudo ifconfig eth0 192.168.50.20 netmask 255.255.255.0 broadcast 192.168.50.255 

```

### 验证连接

我们将尝试 ping 这些机器以验证连接。在**BT5_R1_Tester1**上键入：

```
# ping 192.168.50.20 

```

在**Ubuntu_TestMachine_1**上键入：

```
# ping 192.168.50.10 

```

如果一切配置正确，您应该看到类似以下截图的内容：

![验证连接](img/7744_03_03.jpg)

### 重启后保持 IP 设置

如果您希望静态分配网络信息而无需每次手动输入此信息，可以编辑适当的以太网设备的`/etc/network/interfaces`文件。

### 提示

可以为两台虚拟机完成以下步骤。确保为每台机器使用正确的 IP 和适配器信息。

以下是在 BackTrack 客户机中更改该文件所需更改的示例：

```
auto eth1
iface eth1 inet static
address 192.168.50.10
netmask 255.255.255.0
network 192.168.50.0
broadcast 192.168.50.255

```

在修改此文件后，请务必重新启动网络服务（/etc/init.d/networking `restart）。

### 提示

Ubuntu 用户可以使用`ufw`（简化防火墙）来管理基于主机的 iptables 防火墙。本章中提到使用基于主机的防火墙的示例利用了这一事实。有关 UFW 的更多信息可以在网站[`help.ubuntu.com/10.04/serverguide/C/firewall.html`](http://https://help.ubuntu.com/10.04/serverguide/C/firewall.html)上找到。

这个防火墙很容易配置，而且非常稳定。UFW 默认情况下是禁用的，但可以通过简单地键入：`sudo ufw enable`来启用。

# Nmap——了解你

如果您正在阅读本文，很可能您以前使用过 Nmap。对于那些没有使用过的人，这是一个强大的枚举工具的简短描述。Nmap（网络映射器）自 1997 年以来一直存在，最初由 Gordon“Fyodor”Lyon 创建。即使您以前从未使用过该程序，您可能至少在许多出现过的电影中看到了它的输出。

Nmap 可用于扫描网络、监视服务、协助系统清单任务等。根据选择的选项，Nmap 将能够提供操作系统类型、开放端口等信息。如果这还不够，Nmap 脚本引擎可以用于进一步扩展基本功能。

根据[`nmap.org`](http://nmap.org)网站的说法，Nmap 5 现在包含了 177 个脚本。这些脚本的目的范围从猜测**Apple Filing Protocol**密码到验证是否可以建立到 X 服务器的连接。

Nmap 套件还包括：

+   **ZenMap：**Nmap 的图形用户界面。

+   **Ncat：**基于 netcat，但更新了更大的功能集，如 ncat 链接、SSL 支持等。二进制文件可用。

+   **Ncrack：**用于测试认证实现和密码强度。支持许多常用协议。

+   **Ndiff：**可用于对网络进行基线测试。将 nmap 扫描与彼此进行比较。

+   **Nping：** 允许您创建自定义数据包，然后将其集成到您的扫描中。能够执行原始数据包操作。

### 注意

以下部分中使用的一些示例显示了需要结合防火墙和 IDS 来展示工具行为的某些方面的样本输出。设置这些设备在本书的后续章节中有详细介绍，但超出了本章的范围。

## 常见的 Nmap 扫描类型和选项

Nmap 命令语法：`nmap -{type(s)} -{opt(s)} {target}`

**有用的选项：**

| **扫描选项** | **标题** | **功能** |
| --- | --- | --- |
| `-g` | 指定源端口 | 使用指定的源端口发送数据包。 |
| `--spoof_mac` | 伪装 Mac | 创建一个假的 Mac 地址来发送数据包。可以随机化 MAC 地址。 |
| `-S` | 源 IP 地址 | 伪装源 IP 地址或告诉 Nmap 使用哪个 IP。 |
| `-e` | 选择以太网接口 | 确定要在哪个以太网发送和接收数据包。 |
| `-F` | 快速扫描 | 将默认扫描减少到 nmap-services 文件中的 100 个端口。 |
| `-p` | 指定端口范围 | 确定要扫描哪些端口。 |
| `-R` | 反向查找 | 强制反向查找。 |
| `-N` | DNS 解析 | 执行反向查找。 |
| `-n` | 无 DNS 解析 | 不进行反向查找。 |
| `-h` | 帮助文本 | 提供 Nmap 帮助文本。 |
| `-6` | 启用 IPv6 | 扫描 IPv6。 |
| `-A` | 侵略性 | 同时启动许多选项，如版本和脚本扫描。谨慎使用。 |
| `-T(0-5)` | 定时选项 | 确定您希望扫描的侵略性。 |
| `--scan_delay` | 添加延迟 | 在探测之间添加延迟。 |
| `-sV` | 服务版本 | 探测服务软件版本。 |

**有用的类型：**

| **扫描类型** | **标题** | **功能** |
| --- | --- | --- |
| `-sA` | ACK 扫描 | 检查端口是否有状态。用于测试防火墙。 |
| `-sP` | Ping 扫描 | 用于快速网络发现。 |
| `-sR` | RPC 扫描 | 定位 RPC 应用程序。可能会在成功扫描的主机上留下日志条目。现在这是`-sV`的别名。 |
| `-sS` | TCP SYN 扫描 | 非常快速和隐蔽。半开放扫描。 |
| `-sT` | TCP 扫描 | 建立完整连接。效率低下。非常吵闹的扫描类型，容易被注意到。 |
| `-sU` | UDP 扫描 | 确定某些 UDP 端口是否开放。 |
| `-sX` | XMAS 扫描 | 对某些防火墙配置有用的隐秘扫描。查找 RST 数据包以确定端口是否关闭。适用于扫描 UNIX 系统。 |
| `-sL` | 列表扫描 | 列出将被扫描的 IP 地址。使用`-n`确保不会在网络上发送数据包。 |
| `-sO` | IP 协议扫描 | 搜索主机上正在使用的 IP 协议。 |
| `-sM` | FIN/ACK | 隐蔽扫描。对基于 UNIX 的系统有用。查找 RST 数据包。 |
| `-sI` | 空闲扫描 | 僵尸主机扫描，非常隐蔽的扫描。 |
| `-sW` | 窗口扫描 | 查看 RST 数据包的 TCP 窗口值，以确定端口是开放还是关闭。 |

**输出类型：**

| **输出类型** | **标题** | **功能** |
| --- | --- | --- |
| `-oA` | 全部 | 可 grep，正常，XML。 |
| `-oG` | 可 grep | 格式化为 grep。 |
| `-oX` | XML | 将结果输出到 XML。 |
| `-oN` | 正常 | 人类可读的输出。 |

## 基本扫描 —— 热身

我们将从对我们的**Ubuntu_TestMachine_1**在`192.168.50.20`上进行一些基本扫描开始。在这里，我们将使用`-A`选项执行简单的扫描，以确定目标系统上有哪些端口是开放的。

```
# nmap -A 192.168.50.20 
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2050-12-22 14:32 EDT
Nmap scan report for 192.168.50.20
Host is up (0.00045s latency).
Not shown: 999 closed ports
PORT STATE SERVICE VERSION
80/tcp open http Apache httpd 2.2.14 ((Ubuntu))
|_http-title: Site doesn't have a title (text/html).
MAC Address: 08:00:27:64:38:C7 (Cadmus Computer Systems)
Device type: general purpose
Running: Linux 2.6.X
OS details: Linux 2.6.19 - 2.6.35
Network Distance: 1 hop
TRACEROUTE
HOP RTT ADDRESS
1 0.46 ms 192.168.50.20
OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 8.07 seconds

```

通过查看突出显示的结果，我们可以确定在`80/tcp`端口上有一个运行着`Apache httpd web server version 2.2.14`的开放端口。我们还看到目标上运行的操作系统是 Linux 2.6.x。此外，`-A`标志启动了一个`traceroute`命令，告诉我们目标只有一跳远。

### 注意

NMAP 的`-A`扫描非常吵闹，当需要隐蔽时不应使用。

这是从一个非常简单的命令中获得的大量信息。让我们继续了解这个强大工具的一些更高级的功能。 

## 其他 Nmap 技术

Nmap 可用于各种目的。除了作为快速网络发现工具外，它还可以用于隐秘地基线测试您的网络、指纹服务、绘制防火墙规则，并配置为绕过 IDS 签名。我们现在将尝试一些 Nmap 为我们提供的更高级功能。这些信息绝不是全面的，因此我们将专注于能帮助我们测试安全环境的功能。

### 保持隐秘

网络扫描过程涉及向网络主机发送特制的数据包并检查特定标准的结果。基于这些结果，您有望确定网络上有哪些主机、它们正在运行什么服务以及这些服务的版本水平。然后，这些信息用于决定哪些类型的攻击可能会成功。我们可以使用几种方法来尝试确定这些信息，有些方法类似于在街上大声喊自己的名字，而其他方法则类似于在夜间悄悄行走。

在安全环境中，您可能会处理寻找特定行为的 IDS，例如：发送了多少数据包以及发送速度如何，流量是否异常等。防火墙将倾向于标记任何异常的连接尝试。为了确保您有一点机会保持不被发现，需要采取某些措施。

#### 花点时间

您可以使用以下 nmap 选项更改扫描的时间：

+   **-T(0-5)**模板允许您设置扫描的侵略性。这是最简单的检测规避方法。0 是偏执狂，5 是疯狂，应仅在局域网上使用。这比单独设置这些选项要快得多，但会减少您对扫描的控制。

+   **--max-hostgroup**将限制一次只扫描一个主机。您可以更改值为您感到舒适的任何值，但请记住，IDS 在检查其签名时会合并您发送的探针（例如，2 分钟内的 5 个探针等）。

+   **--max-retries:**在渗透测试中，这是一个您可能不想调整的设置，除非您非常确定网络的稳定性。如果您非常偏执并且不担心在扫描中错过潜在的易受攻击的系统，可以将此值减少为 0。

+   **-max-parallelism** **10**将只允许同时有 10 个未完成的探测。使用此选项来控制同时发送的探测数量。

+   **--scan-delay**允许您在探测之间设置暂停。

让我们在以下命令中尝试一些这些选项：

```
# nmap -P0 -n -sS --max_hostgroup 1 --max_retries 0 --max_parallelism 10 192.168.50.0/24 

```

重传上限将被触发；端口将在扫描完成时放弃。到扫描完成时，我们将知道 192.168.50.X 子网上有哪些系统是活动的。

### 注意

在使用`--max_parallelism`时不要使用`--scan_delay`选项，因为它们彼此不兼容。

#### 尝试不同的扫描类型

这是从 192.168.50.10 到 192.168.75.11 的典型扫描结果。

```
root@bt:~# nmap -T5 192.168.50.10 
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 18:50 EDT
Nmap scan report for 192.168.50.10
Host is up (0.0017s latency).
Not shown: 995 closed ports
PORT STATE SERVICE
21/tcp open ftp
79/tcp open finger
80/tcp open http
110/tcp open pop3
443/tcp open https
Nmap done: 1 IP address (1 host up) scanned in 13.19 seconds

```

从此输出中，我们可以看到 21、79、80、110 和 443 在此主机上是打开的。

### 注意

大多数 IDS 即使在默认配置下也会检测到此扫描类型；但是，网络和基于主机的防火墙可能会默认忽略流量，除非特别配置以记录允许的流量。如果您想看到结果，请打开 UFW 并使用它来打开和关闭特定端口。此练习可能有助于充分理解结果输出。

如果您尝试使用有状态的基于主机的防火墙阻止到端口 79 和 21 的流量进行扫描，您将看到类似以下的流量：

```
root@bt:~# nmap -T5 192.168.50.10 

```

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 18:56 EDT
Nmap scan report for 192.168.50.10
Host is up (0.0014s latency).
Not shown: 995 closed ports
PORT STATE SERVICE
21/tcp filtered ftp
79/tcp filtered finger
80/tcp open http
110/tcp open pop3
443/tcp open https
Nmap done: 1 IP address (1 host up) scanned in 14.22 seconds

```

通过仔细审查突出显示的代码，我们可以看到端口状态为`filtered`，端口为`21`和`79`。尽管我们无法确定端口是否打开，但我们知道它们以某种方式存在于目标机器上。

##### SYN 扫描

使用`-sS`对 192.168.50.10 的一个完全开放的主机进行扫描，从 192.168.75.11 我们看到以下结果：

```
root@bt:~# nmap -sS -T5 192.168.50.10 

```

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 19:09 EDT
Nmap scan report for 192.168.50.10
Host is up (0.0019s latency).
Not shown: 995 closed ports
PORT STATE SERVICE
21/tcp filtered ftp
79/tcp filtered finger
80/tcp open http
110/tcp open pop3
443/tcp open https
Nmap done: 1 IP address (1 host up) scanned in 14.23 seconds

```

就像前面的例子一样，这表明我们至少有五个开放或被过滤的端口可用。在尝试枚举目标网络时，一定要使用不同的扫描类型，否则你可能会错过一些对你的测试工作有重大影响的东西！

##### 空扫描

如果我们尝试的唯一扫描是空扫描，我们会非常失望：

```
root@bt:~# nmap -sN -T5 192.168.50.10 

```

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 19:15 EDT
Nmap scan report for 192.168.50.10
Host is up (0.00051s latency).
All 1000 scanned ports on 192.168.50.10 are open|filtered
Nmap done: 1 IP address (1 host up) scanned in 24.24 seconds

```

这告诉我们所有的端口都是`open|filtered`。我们可以假设有一些防火墙的动作，但我们并没有立即学到任何有用的东西。

##### ACK 扫描

由于我们在空扫描中没有找到任何东西，我们继续使用 ACK 扫描类型。

```
root@bt:~# nmap -sA -T5 192.168.50.10 

```

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 19:18 EDT
Nmap scan report for 192.168.50.10
Host is up (0.00059s latency).
Not shown: 999 filtered ports
PORT STATE SERVICE
443/tcp unfiltered https
Nmap done: 1 IP address (1 host up) scanned in 61.22 seconds

```

至少这次扫描为我们提供了一个未经过滤的端口。如果我们真的想要进行测试，我们需要所有的开放端口，而不仅仅是一个！

##### 结论

使用不同的扫描类型可能会更容易引起注意，但有时需要收集你需要的数据。理想情况下，你应该从最不引人注意的扫描类型开始扫描，然后根据你收集的信息类型逐步提升。在继续下一个子网之前一定要仔细检查，特别是如果你有充分的理由相信有一些有价值的端口可用但没有显示出来。

### 推卸责任——是僵尸干的！

由于保持不被发现的几率很小，我们需要试图转移责任。我们可以使用空闲扫描让僵尸主机承担我们扫描的所有责任。

### 提示

`nmap.org`网站对空闲扫描的工作原理有非常详细和全面的描述。请查看[`nmap.org/book/idlescan.html`](http://nmap.org/book/idlescan.html)以获取关于这些工作原理的完整概述。

关于空闲扫描（-sI）的一个重要事项是，你需要找到一个具有良好的 TCP 序列预测评级的僵尸主机。空闲扫描的名字很贴切，因为我们用作替罪羊的机器必须尽可能地空闲。许多行业人士建议使用网络打印机作为完美的僵尸主机，因为它们通常没有持续的流量，它们的序列预测难度评级通常非常低。

空闲扫描的第一步是找到可能的僵尸主机。你可以通过执行以下操作（详细模式、操作系统检测、无 ping、无名称解析）来找到 TCP 序列预测评级：

```
# nmap -v -O -Pn -n 192.168.50.10 

```

你需要关注的输出部分如下：

```
Network Distance: 1 hop
TCP Sequence Prediction: Difficulty=195 (Good luck!) 
IP ID Sequence Generation: Sequential

```

上面的系统并不理想，但应该可以用作僵尸主机。难度评级越高，你尝试使用这台机器作为僵尸的可能性就越小。此外，生成是顺序的事实将提高扫描成功的可能性。

让我们回顾一下空闲扫描的概念：

1.  向僵尸主机发送 SYN/ACK，然后僵尸主机会返回一个带有片段标识号（IPID）的 RST。

1.  一个特制的数据包带有僵尸主机的 IP 地址被发送到目标机器。

1.  目标机器上的关闭端口会导致向僵尸主机发送一个 RST，此时什么也不会发生。另一方面，打开的端口会导致目标机器用我们伪造的数据包的 IP 地址回复一个 SYN/ACK，这又会导致我们的僵尸主机向目标机器发送一个 RST，一旦它意识到没有有效的连接。IPID 现在已经增加了！

1.  我们通过向僵尸主机发送另一个 SYN/ACK 并检查 IPID 是否增加了 2 次来关闭循环，一次是为了我们的 RST，一次是为了目标机器的 RST。

1.  重复直到所有目标机器的端口都被探测到！

当看到僵尸扫描是如何工作的时候，很容易看出空闲扫描的正确使用可以有助于减缓蓝队（防御安全专业人员）的速度。

那么，这个命令的语法是什么？有这么大的能力，肯定很难吧？当您查看以下命令结构时，您可能会感到惊喜：

```
nmap -p 23,53,80,1780,5000 -Pn -sI 192.168.1.88 192.168.1.111 

```

在这里，我们使用了`-p`来启动对我们已知已打开的 TCP 端口的扫描；我们还指示我们不想进行 ping（这会暴露我们）使用`-Pn`，然后使用`192.168.1.88`作为我们的僵尸和`192.168.1.111`作为我们的目标启动了一个空闲扫描（-sI）。这在这个示例网络上产生了以下输出：

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 22:09 EDT
Idle scan using zombie 192.168.1.88 (192.168.1.88:80); Class: Incremental
Nmap scan report for 192.168.1.111
Host is up (0.036s latency).
PORT STATE SERVICE
23/tcp open telnet
53/tcp open domain
80/tcp open http
1780/tcp open unknown
5000/tcp open upnp
MAC Address: 30:46:9A:40:E0:EE (Netgear)
Nmap done: 1 IP address (1 host up) scanned in 1.18 seconds

```

如果我们查看 Wireshark 的输出，我们可以看到一些奇怪的活动来自`192.168.1.88`到`192.168.1.111`：

责任转嫁——僵尸做了这件事！

从 Wireshark 的结果来看，我们看到之前的 Nmap 命令在我们的网络上从`192.168.1.88`到`192.168.1.111`发起了大量的流量。这种流量将启动所需的活动，以增加告诉我们目标系统具有开放端口的 IPID。

### IDS 规则，如何避免它们

要真正避免 IDS 规则的唯一方法是了解它们是什么，并在虚拟环境中测试您的攻击。我们将在本书的一个整章中致力于避免检测。请准备花时间了解 IDS 寻找什么，并使用我们已经描述的方法来管理您的扫描以执行检测规避。

### 使用诱饵

Nmap 诱饵的使用可能是一个有趣的概念。我们告诉 Nmap 向扫描中添加额外的主机。您将不会从这些诱饵中得到任何响应，但它们会使管理员更难以确定哪个 IP 正在主动扫描，哪个 IP 只是在那里搅浑水。理想情况下，您将启动一个扫描，其中有足够多的活动诱饵来降低目标管理员的检测能力。

### 注意

在扫描时使用活动诱饵。这将使确定哪个系统正在主动扫描变得更加困难。活动诱饵是当前在网络上活动的 IP。

需要注意的是，在使用诱饵时，您可以执行许多扫描类型。您不会受到限制，可以毫不犹豫地使用所有技巧。

让我们在我们的虚拟实验室中尝试一下：

```
# nmap -D192.168.75.10,192.168.75.11,192.168.75.1,ME -p 80,21,22,25,443 -Pn 192.168.75.2 

```

在这里，我们调用 Nmap，然后跟随`-D`开关，这将导致我们执行诱饵扫描。我们接着这个命令使用我们选择的诱饵列表，这些诱饵在这种情况下都是活动的机器。再次，我们不想发送 ping 请求，所以我们使用`-Pn`来停止这个动作。所选的端口范围是使用`-p`设置为`80,21,22,25`和`443`。

### 提示

`ME`可以用来代替键入本地主机 IP 地址。

这次扫描的结果如下：

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 23:03 EDT
Nmap scan report for 192.168.75.2
Host is up (0.00036s latency).
PORT STATE SERVICE
21/tcp filtered ftp
22/tcp filtered ssh
25/tcp filtered smtp
80/tcp open http
443/tcp filtered https
MAC Address: 08:00:27:DF:92:32 (Cadmus Computer Systems)
Nmap done: 1 IP address (1 host up) scanned in 14.35 seconds

```

这里没有什么新的；我们再次确定了哪些端口是打开的、过滤的或关闭的。真正的魔术发生在电线上。让我们来看看网络防火墙看到了什么：

使用诱饵

如果您查看源字段，您应该注意到我们使用的诱饵现在正在填充已设置为记录所有流量的防火墙过滤器。使用足够的诱饵，您可以创建一种风暴，从而完全混淆和延迟网络管理员在执行枚举时。

### 提示

如果您想要查看此扫描的实际操作，可以在 BackTrack 机器上使用 Wireshark。我们还将在后面的章节中完全涵盖将防火墙添加到实验室中。

## 将自定义 Nmap 脚本添加到您的武器库

Nmap 脚本引擎允许您创建和使用执行许多不同功能的自定义脚本。如前所述，Nmap 已经为您打包了许多这些脚本。Nmap 脚本引擎的完整详细指南可在[`nmap.org/book/nse.html`](http://nmap.org/book/nse.html)上找到。通过使用`--script`选项，您可以调用自己的脚本，或者从已经可用的大量脚本库中进行选择。

### 注意

确保您**完全**了解您运行的任何脚本。NSE 非常强大，如果您不了解每个步骤，可能会造成损害！不要盲目运行您找到的所有脚本，否则您可能会后悔。

### 如何决定脚本是否适合您

使用 Nmap 的`--script-help`选项将允许您显示特定脚本的几个有用字段，而无需实际运行它。例如，如果我们查看 BackTracks nmap 的脚本文件夹`/usr/local/share/nmap/scripts`并执行`ls -lah`，我们会看到一长串未知的内容：

```
# cd /usr/local/share/nmap/scripts
# ls -lah

```

```
-rw-r--r-- 1 root root 2.7K 2011-07-19 21:02 afp-brute.nse
-rw-r--r-- 1 root root 5.5K 2011-07-19 21:02 afp-ls.nse
-rw-r--r-- 1 root root 5.0K 2011-07-19 21:02 afp-path-vuln.nse
-rw-r--r-- 1 root root 5.3K 2011-07-19 21:02 afp-serverinfo.nse
-rw-r--r-- 1 root root 2.5K 2011-07-19 21:02 afp-showmount.nse
-rw-r--r-- 1 root root 15K 2011-07-19 21:02 asn-query.nse
-rw-r--r-- 1 root root 2.0K 2011-07-19 21:02 auth-owners.nse
-rw-r--r-- 1 root root 831 2011-07-19 21:02 auth-spoof.nse
-rw-r--r-- 1 root root 8.6K 2011-07-19 21:02 backorifice-brute.nse
-rw-r--r-- 1 root root 9.3K 2011-07-19 21:02 backorifice-info.nse
-rw-r--r-- 1 root root 5.4K 2011-07-19 21:02 banner.nse
-rw-r--r-- 1 root root 2.9K 2011-07-19 21:02 broadcast-avahi-dos.nse
-rw-r--r-- 1 root root 1.5K 2011-07-19 21:02 broadcast-dns-service-discovery.nse
-rw-r--r-- 1 root root 3.4K 2011-07-19 21:02 broadcast-dropbox-listener.nse
-rw-r--r-- 1 root root 3.6K 2011-07-19 21:02 broadcast-ms-sql-discover.nse
-rw-r--r-- 1 root root 1.8K 2011-07-19 21:02 broadcast-netbios-master-browser.nse

```

此列表比本书中显示的内容要多得多，并且正在不断更新。不久前，Fyodor 在 Defcon 18 会议上提供了关于 Nmap 脚本引擎的精彩演讲，添加到存储库中的脚本数量一直在增加。

那么，如果我们想了解`banner.nse`呢？这个脚本看起来很有趣，我们可以根据名称做出假设，但最好查看作者提供的描述，方法是键入：

```
# nmap --script-help "banner.nse" 

```

这导致以下输出：

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-29 23:50 EDT
banner
Categories: discovery safe
http://nmap.org/nsedoc/scripts/banner.html
A simple banner grabber which connects to an open TCP port and prints out anything sent by the listening service within five seconds.
The banner will be truncated to fit into a single line, but an extra line may be printed for every increase in the level of verbosity requested on the command line.

```

因此，在这种情况下，我们的假设很可能是正确的。我们不仅了解到`banner.nse`文件用于连接到开放的 TCP 端口进行横幅抓取，而且它被认为属于`发现`和`安全`类别，这两个类别在使用命令行的脚本选项时可以调用。您还可以访问[`nmap.org/nsedoc/`](http://nmap.org/nsedoc/)以便轻松获取脚本信息。

我们的实验室中还没有`banner.nse`可以使用的内容，但让我们继续运行由简单的`-sC`选项启动的 50 多个脚本。如果您还没有查看 Nmap NSE 网站以查看这些脚本，您可能希望快速访问一下，以确保在尝试在生产网络上运行之前，您完全了解正在启动的脚本。

### 注意

虚拟实验室中的 Ubuntu 机器已更新，以便为本示例提供有趣的服务。您的输出很可能会有所不同。

查看以下命令产生的输出：

```
# nmap -Pn -sC 192.168.50.11 

```

```
Starting Nmap 5.59BETA1 ( http://nmap.org ) at 2011-10-30 00:19 EDT
Nmap scan report for 192.168.50.11
Host is up (0.00090s latency).
Not shown: 995 closed ports
PORT STATE SERVICE
21/tcp open ftp
|_ftp-bounce: no banner
79/tcp open finger
| finger:
| Debian GNU/Linux Copyright (c) 1993-1999 Software in the Public Interest
|
| Your site has been rejected for some reason.
|
| This may be caused by a missing RFC 1413 identd on your site.
|
| Contact your and/or our system administrator.
|_
80/tcp open http
|_http-title: Site doesn't have a title (text/html).
110/tcp open pop3
|_pop3-capabilities: capa APOP
443/tcp open https
|_http-title: eBox Platform
|_http-methods: No Allow or Public header in OPTIONS response (status code 403)
|_sslv2: server still supports SSLv2
Nmap done: 1 IP address (1 host up) scanned in 18.39 seconds

```

`-sC`选项为我们提供了许多其他扫描类型无法呈现的细节。这是有代价的。您刚刚看到的许多脚本在网络和/或正在运行的主机上非常明显。通过查看先前的输出，我们现在可以看到不仅`port 110`上打开了`pop3`，而且它还具有`capa`和`APOP`功能。我们现在也知道该系统将支持连接到`SSLv2`，这是一个已知的易受攻击的协议，我们可能可以利用它来获取优势。

### 向数据库添加新脚本

所有这些预加载的脚本都很棒，但是如果您想要将其他脚本添加到您的工具库中，无论是因为您自己编写了它们，还是因为您信任的某人提供了最新和最棒的东西，并且您想在执行渗透测试时利用它，那么这可能非常简单！

1.  将`script .nse`文件添加到其他 Nmap NSE 脚本所在的目录中。

1.  运行以下命令以更新通过类别捆绑脚本的数据库：

```
# nmap -script-updatedb 

```

1.  现在您可以通过 nmap `--script "scriptname.nse`"或使用脚本关联的分类分组来使用新脚本。

# SNMP：一个等待被发现的信息宝库。

**简单网络管理协议（SNMP）**通常由繁忙的管理员和开发人员管理不善。经常会看到默认的 community 字符串，或者在测试的整个组织中重复使用的 community 字符串。您将希望确保您的客户端使用最安全的 SNMP 版本，并且您不能简单地走进建筑物，拔掉电话，然后嗅探 community 字符串。较新版本的 SNMP 包括强加密以避免此类缺陷。

## SNMPEnum

幸运的是，有许多可用的工具可以简化对 SNMP 的测试。我们将首先使用 SNMPEnum，这是一个 Perl 脚本，可以在 BackTrack 5 R1 的`/pentest/enumeration/snmp/snmpenum`目录中找到。

如果您想跟随这些示例，您可以跳过几章并跟随 pfSense 安装和配置演练，或者可以设置 Ubuntu 机器以使用 SNMP。可以按以下步骤操作：

在本例中，已设置了防火墙虚拟设备，并启用了非常薄弱的 community 字符串"public"的 SNMP。

在这里，我们将展示`snmpenum.pl`向渗透测试人员披露的信息类型。

```
# ./snmpenum.pl 192.168.121.252 public linux.txt > myFW.txt 

```

这个命令调用了`snmpenum.pl` Perl 脚本，并传递了目标 IP`192.168.121.252`和选定的 community 字符串`public. linux.txt`，该字符串在`snmpenum`工具的工作目录中找到，给定导入文件中。我们已经指定输出放在`myFW.txt`中，因为成功连接到 SNMP 守护程序提供了如此丰富的信息。以下是我们刚刚学到的一些更有趣的部分：

```
----------------------------------------
LISTENING UDP PORTS
----------------------------------------
0
53
67
161
514
57613
----------------------------------------
LISTENING TCP PORTS
----------------------------------------
53
80

```

哇！我们仅仅通过向运行在这个路由器/防火墙上的 SNMP 守护程序发送一个简单的请求，就已经成功获取了这个设备的所有开放端口。在这种情况下，我们可以简单地跳过尝试运行 Nmap（这很遗憾，因为我们在本章中已经学到了很多关于它！），并开始我们的横幅抓取练习。然而，在`myFW.txt`文件中还有更多内容：

```
----------------------------------------
SYSTEM INFO
----------------------------------------
pfSense.localdomain 744728609 FreeBSD 8.1-RELEASE-p4

```

现在我们还知道这台机器的确切名称，它的用途是什么（快速检查`google.com`将告诉您有关 pfSense 的一切），以及我们正在处理的操作系统和版本。

我们还可以从我们运行的 SNMP 扫描中得到什么？

```
----------------------------------------
RUNNING PROCESSES
----------------------------------------
kernel
init
g_event
g_up
g_down
crypto
crypto returns
sctp_iterator
pfpurge
xpt_thrd
audit
idle
intr
ng_queue
yarrow
pagedaemon
vmdaemon
pagezero
idlepoll
bufdaemon
vnlru
syncer
softdepflush
md0
check_reload_status
check_reload_status
devd
login
sshlockout_pf
sh
sh
syslogd
tcpdump
logger
php
inetd
lighttpd
sleep
php
php
php
php
dhcpd
php
dnsmasq
bsnmpd
ntpd
ntpd
sh
cron
minicron
minicron
minicron
kernel

```

如果在测试过程中存在可以利用的缺陷，那么此时您拥有了您所需的一切。我鼓励您访问制造商的网站，并熟悉您可以通过 SNMP 获取的信息类型。如果使用正确，它对组织非常有益；但是，如果未正确配置 SNMP，则可能会导致失败。

## SNMPCheck

BackTrack 中包含的另一个很棒的工具是`snmpcheck`，由`Nothink.org`的 Matteo Cantoni 提供。这个 Perl 脚本允许您枚举 SNMP 设备，并将输出放在非常易于阅读的友好格式中。

```
# ./pentest/enumeration/snmp/snmpcheck/snmpcheck-1.8.pl -t 192.168.75.1 

```

这个命令假设设备将响应于`public` community 字符串，但您可以通过添加`-c`开关轻松更改要使用的字符串。在成功扫描时，输出将类似于以下内容：

```
snmpcheck.pl v1.8 - SNMP enumerator
Copyright (c) 2005-2011 by Matteo Cantoni (www.nothink.org)
[*] Try to connect to 192.168.75.2
[*] Connected to 192.168.75.2
[*] Starting enumeration at 2011-10-30 04:03:57
[*] System information
-------------------------------------------------------------
Hostname : pfSense.localdomain
Description : pfSense.localdomain 744728609 FreeBSD 8.1-RELEASE-p4
Uptime system : 11 hours, 02:32.69
Uptime SNMP daemon : 46 minutes, 47.88
Contact : Lee Allen
Location : USA
Motd : -
[*] Devices information
-------------------------------------------------------------
Id Type Status Description
1 Other Running nexus0:
10 Other Running isab0: PCI-ISA bridge
11 Other Running isa0: ISA bus
12 Other Running orm0: ISA Option ROMs
13 Other Running pmtimer0:
14 Other Running sc0: System console
15 Other Running vga0: Generic ISA VGA
18 Other Down ppc0: Parallel port
19 Other Down uart0: ns8250
[*] Storage information
-------------------------------------------------------------
Real Memory Metrics
Device id : 1
Device type : Ram
Filesystem type : BerkeleyFFS
…
[*] Software components
-------------------------------------------------------------
1\. FreeBSD: FreeBSD 8.1-RELEASE-p4 #0: Tue Sep 13 16:58:57 EDT 2011
2\. bsdinstaller-2.0.2011.0913
3\. gettext-0.18.1.1
4\. grub-0.97_4
[*] Mountpoints
-------------------------------------------------------------
Swap:/dev/ad0s1b
/, type: ufs, dev: /dev/ad0s1a
/dev, type: devfs, dev: devfs
/var/run, type: ufs, dev: /dev/md0
/var/dhcpd/dev, type: devfs, dev: devfs
[*] Enumerated 192.168.75.2 in 3.70 seconds

```

前面的输出已经大大缩短，但我们在这里提供的内容应该可以让您了解到这个工具向渗透测试人员提供的数据类型。

### 注意

`snmpcheck`已经移植到了 Metasploit，并可以直接从该框架中使用。

## 当 SNMP community 字符串不是"public"时

很可能您不会找到许多设置为默认的 community 字符串。那时，您必须深入了解您的工具集，并赚取您的报酬。有许多实用程序可协助执行诸如暴力破解 SNMP community 名称之类的操作。我最喜欢的之一就是`onesixtyone`。这个扫描程序速度快且高效，将并行发送请求以加快速度。

### 提示

在测试时，请记住以下几点：仅因为某个工具对大多数任务非常有效，并不意味着它对所有任务都有效。有可能您需要回到您的工具箱并尝试其他方法。您了解工具功能的越多，您在测试中成功的可能性就越大。例如，onesixtyone 在进行 SNMP 请求时正在寻找特定值。我虚拟实验室中使用的防火墙可能不使用此值，因此对该工具来说是不可见的。在看到我们在前面部分获得的丰富知识后，仅仅因为我们只使用了一个工具就错过这些信息，这不是很糟糕吗？

onesixtyone 的命令语法很简单：

```
# ./onesixtyone -c dict.txt 192.168.50.10 

```

我们让 onesixtyone 使用提供的`dict.txt`文件来检查`192.168.50.10`，在我的虚拟网络上结果如下：

```
Scanning 1 hosts, 49 communities
192.168.50.10 [public] Linux Phobos 2.6.32-34-generic #77-Ubuntu SMP Tue Sep 13 19:39:17 UTC 2011 x86_64

```

查看这些结果，我们注意到我们扫描的主机使用的是 Ubuntu Linux 操作系统，并且具有先前未知的公共社区字符串。让我们在主机上更改这个，并看看在使用相同命令时我们的表现如何：

```
Scanning 1 hosts, 50 communities

```

正如预期的那样，由于我们的列表中不再有社区名称，我们无法找到它。我们可以创建我们自己的`dict.txt`文件，或者添加到已经提供给我们的文件中。

### 注意

处理字典文件时，最好有几个可用来满足特定需求。最好至少有三个可用于 SNMP 目的。一个具有许多默认值，另一个具有人们用于社区名称的常用名称，最后一个是一个包含许多名称的大文件，可以根据公司名称、用户名等定制给您的客户。

# 使用 scanPBNJ 创建网络基线

进行渗透测试时，了解在一段时间内发生了什么以及发生了什么变化是很重要的。管理员通常工作繁忙，可能仍需要在您进行测试时完成工作。确保您不是在一个不断变化的领域上进行测试的一种方法是抓取您正在测试的网络的基线。PBNJ 非常擅长这项任务。scanPBNJ 的网站位于[`pbnj.sourceforge.net`](http://pbnj.sourceforge.net)，该工具也作为 BackTrack 5 R1 发行版的一部分提供。关于`scanPBNJ`的关键注意事项是它使用 Nmap 扫描网络，然后将结果与扫描执行时间戳一起存储到数据库中。

## 设置 MySQL 用于 PBNJ

BackTrack 预装了 MySQL。我们将利用这一点，让 PBNJ 将我们的扫描结果存储到一个 MySQL 数据库中进行准备。

### 启动 MySQL

在命令行中键入以下内容：

```
# service mysql start 

```

服务应该已经启动。您也可以使用相同的方式使用`service stop`或`service restart`。

### 准备 PBNJ 数据库

准备 PBNJ 数据库，按以下步骤进行：

```
# mysql -uroot -ptoor 

```

```
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 48
Server version: 5.1.41-3ubuntu12.10 (Ubuntu)
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

```

```
mysql> CREATE DATABASE BTpbnj; 

```

```
Query OK, 1 row affected (0.02 sec)

```

```
mysql> CREATE USER 'tester'@'localhost' IDENTIFIED BY 'password'; 

```

```
Query OK, 0 rows affected (0.01 sec)

```

```
mysql> GRANT ALL ON BTpbnj.* TO 'tester'@'localhost'; 

```

```
Query OK, 0 rows affected (0.01 sec)

```

```
mysql> exit 

```

我们已经创建了一个名为`BTpbnj`的数据库，添加了一个名为`tester`的用户，密码为`password`，授予该用户完整的数据库访问权限，并退出了数据库。

现在我们需要编辑 PBNJ 配置文件以使用我们新创建的数据库。在根目录下创建一个名为`.pbnj-2.0/`的目录（mkdir `-p .pbnj-2.0)`，然后切换到该隐藏目录。执行以下命令将您的`mysql.yaml`配置文件复制到`config.yaml`：

```
root@bt:~/.pbnj-2.0# cp /usr/share/doc/pbnj/examples/mysql.yaml config.yaml 

```

文件复制后，我们需要使用 nano 编辑几个项目：

```
# nano config.yaml 

```

```
# Configuration file for PBNJ 2.0
# YAML:1.0
#
# Config for connecting to a DBI database
# SQLite, mysql etc
db: mysql 
# for SQLite the name of the file. For mysql the name of the database
database: BTpbnj 
# Username for the database. For SQLite no username is needed.
user: "tester" 
# Password for the database. For SQLite no password is needed.
passwd: "password" 
# Password for the database. For SQLite no host is needed.
host: "127.0.0.1" 
# Port for the database. For SQLite no port is needed.
port: "3306" 

```

需要更改`config.yaml`中突出显示的以下字段以匹配以下内容：

+   数据库：**mysql**

+   数据库：**BTpbnj**

+   用户：**"tester**"

+   密码：**"password**"

+   主机：**"127.0.0.1**"

+   端口：**"3306**"

通过首先使用*CTRL + O*保存您的工作，然后使用*CTRL + X*退出 nano。

## 第一次扫描

在这里我们扫描`192.168.75.0/24：`

```
# /usr/local/bin/scanpbnj -a "-p- -T4" 192.168.75.0/24 

```

这个命令启动了`scanpbnj`，并使用`-a`标志使用了现在熟悉的 Nmap 标志之一。在这个示例中，我们针对了`192.168.75.0/24`网络。

### 注意

如果按照示例进行操作，请用您的实验室或网络的 IP 范围替换`192.168.75.0/24`。

扫描完成后，您将在屏幕上看到以下输出的类似内容：

```
--------------------------------------
Starting Scan of 192.168.75.2
Inserting Machine
Inserting Service on 53:tcp domain
Inserting Service on 80:tcp http
Scan Complete for 192.168.75.2
--------------------------------------

```

就是这样。我们现在在数据库中记录了我们`192.168.75.0/24`网络上的内容，准备好供我们审查。

### 注意

默认扫描设置将在前 1025 个端口上执行 Nmap 的非常详细的操作系统检测，SYN 扫描，排除了很少使用的端口 0。

## 审查数据

现在信息已经在数据库中，但我们如何审查它呢？因为我们决定使用 MySQL，所以我们可以依赖于我们以前的 MySQL 知识来执行任何我们喜欢的类型的查询！以下是一些示例：

登录数据库，并告诉它使用`BTpbnj`数据库：

```
# mysql -utester -ppassword 

```

```
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 52
Server version: 5.1.41-3ubuntu12.10 (Ubuntu)
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

```

```
mysql> use BTpbnj; 

```

```
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed

```

一旦我们登录，让我们尝试一些查询：

```
mysql> show tables; 

```

```
+------------------+
| Tables_in_BTpbnj |
+------------------+
| machines |
| services |
+------------------+
2 rows in set (0.00 sec)

```

MySQL`BTpbnj`数据库中有两个表。

```
mysql> describe machines; 

```

```
+-----------------+---------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-----------------+---------+------+-----+---------+-------+
| mid | int(11) | NO | PRI | NULL | |
| ip | text | YES | | NULL | |
| host | text | YES | | NULL | |
| localh | int(11) | YES | | NULL | |
| os | text | YES | | NULL | |
| machine_created | text | YES | | NULL | |
| created_on | text | YES | | NULL | |
+-----------------+---------+------+-----+---------+-------+
7 rows in set (0.01 sec)

```

现在我们有一些字段可以基于它们进行下一个查询。注意`created_on`和`machine_created`字段。当执行基线时，这些时间戳非常有用。

```
mysql> select ip,os,created_on from machines where ip = "192.168.75.2"; 

```

```
+--------------+------------+--------------------------+
| ip | os | created_on |
+--------------+------------+--------------------------+
| 192.168.75.2 | unknown os | Sun Oct 30 10:57:39 2011 |
+--------------+------------+--------------------------+
1 row in set (0.00 sec)

```

我们从数据库中选择了`ip,os`和`created_on`字段。现在让我们继续了解一些更有趣的信息。

```
mysql> describe services; 

```

```
+-----------------+---------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-----------------+---------+------+-----+---------+-------+
| mid | int(11) | YES | | NULL | |
| service | text | YES | | NULL | |
| state | text | YES | | NULL | |
| port | int(11) | YES | | NULL | |
| protocol | text | YES | | NULL | |
| version | text | YES | | NULL | |
| banner | text | YES | | NULL | |
| machine_updated | text | YES | | NULL | |
| updated_on | text | YES | | NULL | |
+-----------------+---------+------+-----+---------+-------+
9 rows in set (0.00 sec)

```

通过查看这些信息，我们可以看到我们现在能够一次性查询所有主机，而不仅仅是一个主机。此外，这个数据库的输出可以是 XML 格式，然后传输到我们用来跟踪渗透测试结果的任何工具。

### 提示

MySQL 命令可以从命令行运行，以便将输出导出到您选择的格式。在调用 MySQL 命令时使用`-X`或`-H`开关，以保存到各自的文件类型。大多数渗透测试人员需要对 MySQL 命令语法有很好的理解才能发挥其作用。

让我们看看我们的简单扫描收集了什么类型的数据：

```
mysql> select * from services; 

```

```
+------+---------+-------+------+----------+-----------------|
| mid | service | state | port | protocol | version | banner | machine_updated | updated_on |
+------+---------+-------+------+----------+-----------------+
| 42 | domain | up | 53 | tcp | unknown version | unknown product | 1319986659 | Sun Oct 30 10:57:39 2011 |
| 42 | http | up | 80 | tcp | unknown version | unknown product | 1319986659 | Sun Oct 30 10:57:39 2011 |
+------+---------+-------+------+----------+-----------------+

```

使用数据库存储您的发现非常高效，强烈建议。扫描您的虚拟实验室，并测试一些不同的提取数据的方法。通过明智地使用这些数据，可以快速确定网络环境、标准软件版本和其他对于确定下一阶段渗透测试中应该关注的目标至关重要的信息。

# 枚举避免技术

正如本章内容所示，攻击者可以利用免费提供的工具和技术获得大量关键基础设施信息。作为渗透测试人员，我们不能仅仅专注于攻击网络，我们还必须充分了解足以提供建议和指导给我们的客户的缓解控制措施。公司可以使用几种方法，使攻击者更难以获取必要的信息，以便对客户的资产进行隐蔽、成功的攻击。

## 命名约定

管理员应该被鼓励使用不透露有关设备信息的命名方案。例如，如果您使用您的 Nmap-Fu 或 DNS-Fu 来提取主机名，并发现机器被标记如下：

+   `dns1.example.com`

+   `mail.example.com`

+   `domainserver`

+   `devserver`

+   管理员枢纽点

+   流氓 WAP

这将立即让您了解您想要首先定位的系统。更好的命名方法可能是一些标记化，比如 ST1 = DNS 服务器，或者所有开发服务器的名称中都包含 71。这将使入侵者更难理解，同时也允许有效的管理员快速识别资产的用途。

## 端口敲击

经常情况下，管理员可以选择使用**端口敲击**来避免端口枚举尝试。这个概念可以很简单，就是要求某人在连接到有效的管理端口（如 SSH）之前，先连接到一个秘密端口。

更高级的端口敲击用法是设置一个 telnet 服务器，并让基于主机的防火墙触发规则，暂时阻止 IP 连接到系统上的任何端口，一旦它触及 telnet 端口。

## 入侵检测和规避系统

尽管这些并不能提供供应商经常声称的完美安全性，但正确配置的入侵检测系统（基于主机或基于网络）可以在检测枚举尝试方面产生重大影响。这些设备应该作为公司深度防御策略的一部分，并且应该得到适当的管理、监控和更新，以提供对公司安全状况最大的益处。

## 触发点

策略性地放置系统，当被访问时发出警报，可以用作类似于在物理安全中使用周界运动探测器的早期警报系统。管理员可以在一个段上设置一个系统，当进行恶意连接尝试时自动发送警报或启动某些操作。

管理员应避免试图通过在系统上尽可能开放更多的端口来“增加吸引力”，因为这可能会泄露系统的用途。需要注意的一点是，如果在环境中使用这样的系统，就必须像网络上的其他系统一样保持同样的勤勉。在您的网络上有一个未打补丁的系统肯定会成为攻击者的目标；然而，给攻击者一个快速获得网络内立足点的方法绝对不是一个好主意。一旦建立了一个枢纽点，攻击者的工作就变得更容易了，而在您能够对触发点警报做出反应的时候，攻击者可能已经在其他系统上为您的网络设置了后门。

## SNMP 锁定

确保管理员以安全的方式使用 SNMP。如前所示，SNMP 可以被用来获取大量的信息，在攻击者手中，这基本上就成了终极目标。SNMP 应该使用最新的可用安全机制，如加密。如果您已经验证了安全性，应该使用最新版本的 SNMP。它还应该被锁定并限制只能被某些主机访问。最重要的是，公共社区应该被移除。

### 注意

有时，由于各种原因，您的客户可能无法使用最新版本的 SNMP。在这种情况下，尽量保护协议的安全性。例如，您可以建议他们将 SNMP 锁定到特定主机。

# 摘要

到目前为止，我们已经讨论了枚举网络所需的几种方法。我们创建了一个额外的机器，加入到我们的虚拟实验室中，以便我们可以测试这些方法，并获得在实际网络上执行这些操作所需的经验。

您应该对可用的工具和技术有很好的了解，比如用于 SNMP 暴力破解的 onesixtyone，或用于网络扫描的 Nmap。通过 PBNJ 数据的力量，我们确定了以 MySQL 格式获取网络基线的简单方法，然后使用这些数据快速选择下一阶段渗透测试的正确目标。

在下一章中，我们将深入探讨利用的主题。您将学习从网络上编译或重写概念验证（POC）利用代码，使用 Metasploit，破解密码，以及手动利用远程漏洞。
