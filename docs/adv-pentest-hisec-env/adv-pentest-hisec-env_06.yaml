- en: Chapter 6. Exploits and Client-Side Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。利用和客户端攻击
- en: Client-side attacks characteristically require user interaction. A careless
    visit to a website can result in devastation. Generally speaking, a client-side
    attack will be focused on the "client" machine used by individuals at home or
    in the office. In a properly secured environment these hosts will be protected
    using a combination of security mechanisms and practices such as white listing,
    network segmentation, host-based firewalls, file integrity monitors, system configuration
    hardening, and antivirus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端攻击通常需要用户交互。对网站的粗心访问可能会导致灾难。一般来说，客户端攻击将集中在个人在家里或办公室使用的“客户端”机器上。在一个适当安全的环境中，这些主机将通过安全机制和实践的组合来保护，如白名单、网络分割、基于主机的防火墙、文件完整性监视器、系统配置硬化和防病毒软件。
- en: With proper training, users are well aware that clicking on unknown links, opening
    e-mail attachments, or even plugging in an untrusted device may have the potential
    to be harmful. Unfortunately, convenience often supersedes common sense and as
    such, users will continue to repeat old mistakes. After all, shouldn't all of
    these protection mechanisms installed by the administrators protect the user from
    everything?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的培训，用户清楚地知道点击未知链接、打开电子邮件附件，甚至插入不受信任的设备可能具有潜在的危害。不幸的是，方便往往超过常识，因此用户将继续重复旧错误。毕竟，管理员安装的所有这些保护机制难道不应该保护用户免受一切伤害吗？
- en: In large environments, desktops, workstations, and even printers are typically
    considered non-critical. The focus is on expensive servers and systems that are
    essential to keeping the business running. A skilled attacker will be well aware
    of this mentality. If unable to effortlessly penetrate the network using web application
    vulnerabilities, the attacker may often move on to using a blend of social engineering
    and client-side attacks. If successful, these attacks will cut through a perimeter
    as quickly as a hot knife cuts through butter. Additionally, a fully compromised
    client machine can then be set up as a gateway into the otherwise secured network.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型环境中，台式机、工作站甚至打印机通常被视为非关键设备。重点放在昂贵的服务器和对业务运行至关重要的系统上。熟练的攻击者会充分了解这种心态。如果无法轻松地利用Web应用程序漏洞渗透网络，攻击者通常会转而使用社会工程和客户端攻击的混合方式。如果成功，这些攻击将像热刀切黄油一样迅速穿透边界。此外，一个完全被攻陷的客户端机器可以被设置为进入本来被保护的网络的网关。
- en: In this chapter, we will investigate methods that assist us in testing the effectiveness
    of a corporation's security awareness training, and client-side protection mechanisms.
    The research performed during the information gathering stages of your testing
    will finally be used to the fullest extent. Furthermore, we look at some of the
    techniques and tools used by security researchers and crafty attackers to bypass
    even those system controls that at first glance seem theoretically sound.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些方法，帮助我们测试公司的安全意识培训和客户端保护机制的有效性。在测试的信息收集阶段进行的研究将得到充分利用。此外，我们将研究一些安全研究人员和狡猾攻击者使用的技术和工具，以绕过那些乍一看理论上似乎合理的系统控制。
- en: Buffer overflows — A refresher
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出 - 复习
- en: Buffer overflows are the bread and butter of attackers in the wild. When this
    type of vulnerability is properly exploited, an attack may lead to complete system
    compromise in mere seconds. Ideally, many of these vulnerabilities may be prevented
    by the proper implementation of a security development lifecycle. If your client
    does not have such practices, you may be required to perform steps above and beyond
    standard penetration testing and prove that there are flaws in the (often internally
    developed) applications being deployed across the enterprise.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出是野外攻击者的基本技能。当这种类型的漏洞被正确利用时，攻击可能在短短几秒钟内导致系统完全被攻陷。理想情况下，通过正确实施安全开发生命周期，许多这些漏洞可以被预防。如果您的客户没有这样的做法，您可能需要执行超出标准渗透测试的步骤，并证明企业部署的（通常是内部开发的）应用程序存在缺陷。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all buffer overflow vulnerabilities can be used to create remote exploits.
    Also of note is that not all buffer overflows are exploitable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有缓冲区溢出漏洞都可以用于创建远程利用。还要注意的是，并非所有缓冲区溢出都是可利用的。
- en: More often than not, programming errors that allow for buffer overflows are
    not intentional, or due to lazy developers. Frequently, buffer overflow vulnerabilities
    are missed during the application development stages because of either the complexity
    of the application, or the fact that the original codebase is decades old and
    yet is still being built upon. Considering the fact that software developers are
    regularly faced with unreasonable deadlines and demands from their management
    chain, we should not be surprised that sometimes security flaws can be overlooked
    or missed during the software development lifecycle. It is not shocking for a
    developer to receive requirements based on eleventh-hour decisions. Logically,
    this is counterproductive to ensuring the security of the application being developed.
    As with any other technology, security needs to be built into the entire process
    and not added as an afterthought. The priority of the developer becomes pumping
    out code modifications rather than focusing on both stability and security.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，允许缓冲区溢出的编程错误并非故意或是由于开发人员的懒惰。缓冲区溢出漏洞在应用程序开发阶段经常被忽视，要么是因为应用程序的复杂性，要么是因为原始代码库已经存在几十年，但仍在不断地进行开发。考虑到软件开发人员经常面临不合理的最后期限和来自管理层的要求，我们不应该感到惊讶，有时安全漏洞会在软件开发生命周期中被忽视或遗漏。开发人员接到的要求基于最后一刻的决定，这在逻辑上是不利于确保正在开发的应用程序的安全性。与任何其他技术一样，安全需要内置到整个过程中，而不是作为事后添加。开发人员的优先事项变成了推出代码修改，而不是专注于稳定性和安全性。
- en: To address these types of errors, code compilers and operating systems will
    include mechanisms that are meant to prevent the exploitation of this type of
    code. In order to fully understand how to bypass these mechanisms you will need
    to have at minimum a basic understanding of what buffer overflows are and how
    you can verify that your clients are fully protected against this type of attack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些类型的错误，代码编译器和操作系统将包括旨在防止利用这种类型代码的机制。为了充分理解如何绕过这些机制，您至少需要基本了解什么是缓冲区溢出，以及如何验证您的客户端是否完全受到保护，以防此类攻击。
- en: '"C"ing is believing — Create a vulnerable program'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"看见"才会相信 —— 创建一个易受攻击的程序'
- en: To fully comprehend just how simple it can be to overlook these errors we will
    be producing our own vulnerable program. Open up a 32-bit BackTrack virtual system
    and take the opportunity to connect to the Internet and perform your updates.
    After updating you will more than likely need to download the debugger we will
    be using. As of now it is not included as part of BackTrack 5 R1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解忽视这些错误有多简单，我们将制作我们自己的易受攻击的程序。打开一个32位的BackTrack虚拟系统，并利用这个机会连接到互联网并进行更新。更新后，您很可能需要下载我们将使用的调试器。目前，它不包括在BackTrack
    5 R1的一部分中。
- en: 'We will be using the GNU Debugger. You can learn additional information about
    this tool at: [http://www.gnu.org/s/gdb/](http://www.gnu.org/s/gdb/).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GNU调试器。您可以在以下网址了解有关此工具的其他信息：[http://www.gnu.org/s/gdb/](http://www.gnu.org/s/gdb/)。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples use the 32-bit version of BackTrack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用BackTrack的32位版本。
- en: 'To get the GNU debugger you will need to install it using the `apt-get` install
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得GNU调试器，您需要使用`apt-get` install命令进行安装：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have installed `gdb`, disconnect the Internet connection to your BackTrack
    virtual machine again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完`gdb`后，再次断开BackTrack虚拟机的互联网连接。
- en: The first order of business is to compile a small program that will be used
    to demonstrate a buffer overflow in action. We take advantage of a well known
    flaw in the `scanf` function for this purpose. Open up a terminal session in BackTrack
    and create a file named `bovrflow.c` in nano.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是编译一个小程序，用于演示缓冲区溢出的情况。我们利用`scanf`函数中一个众所周知的缺陷来实现这个目的。在BackTrack中打开一个终端会话，并使用nano创建一个名为`bovrflow.c`的文件。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Be sure to save your work before exiting to the terminal. In this program,
    we have intentionally used `scanf()` with the `%s` conversions because `scanf()`
    does not sanitize the input to ensure that it does not exceed the size of the
    assigned buffer. More information about this vulnerability can be located at:
    [https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html](http://https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出到终端之前，请确保保存您的工作。在这个程序中，我们故意使用了`scanf()`与`%s`转换，因为`scanf()`不会对输入进行消毒，以确保它不会超出分配的缓冲区大小。有关此漏洞的更多信息可以在以下位置找到：[https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html](http://https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html)。
- en: 'Due to safety restricting built into the **GCC** compiler we must use `-fno-stack-protector`
    to compile this code. At the command prompt issue the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**GCC**编译器内置了安全限制，我们必须使用`-fno-stack-protector`来编译此代码。在命令提示符下，发出以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous command we have invoked the `gcc` compiler, chosen the output
    filename to be `bovrflow`, disabled the stack protector functionality of the compiler,
    and targeted the `bovrflow.c` source code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，我们调用了`gcc`编译器，选择了输出文件名为`bovrflow`，禁用了编译器的堆栈保护功能，并针对`bovrflow.c`源代码进行了定位。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because we are running as root in BackTrack we do not have to worry about changing
    the file permissions to executable before attempting to run it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在BackTrack中以root身份运行，所以在尝试运行之前，我们不必担心更改文件权限为可执行。
- en: Turning ASLR on and off in BackTrack
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在BackTrack中打开和关闭ASLR
- en: 'Linux uses Address Space Layout Randomization (ASLR) by default. You should
    understand how to check to see if this is enabled, as well as having the ability
    to turn it on and off. Let''s take a look at the `ldd` command. This command will
    list a program''s shared library dependencies. If you have ASLR enabled, the memory
    addresses will change each time they are invoked:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux默认使用地址空间布局随机化（ASLR）。您应该了解如何检查是否启用了ASLR，以及如何能够打开和关闭它。让我们来看看`ldd`命令。这个命令将列出程序的共享库依赖关系。如果启用了ASLR，内存地址在每次调用时都会改变：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On close inspection, it becomes obvious that the memory addresses are changing
    each time. Now let''s turn off ASLR (off is 0, on is 2) by changing the `randomize_va_space`
    value and compare the results:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，显然内存地址每次都在变化。现在让我们通过更改`randomize_va_space`值来关闭ASLR（关闭为0，打开为2），并比较结果：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For Linux distributions other than BackTrack, Exec-Shield can be enabled and
    disabled in the same manner. Example: `echo 0 > /proc/sys/kernel/exec-shield`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BackTrack以外的Linux发行版，可以以相同的方式启用和禁用Exec-Shield。例如：`echo 0 > /proc/sys/kernel/exec-shield`。
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The memory addresses are identical regardless of how many times you attempt
    to run the command. This indicates that you have turned off the randomization
    produced by ASLR.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您尝试运行命令多少次，内存地址都是相同的。这表明您已关闭了ASLR产生的随机化。
- en: Understanding the basics of buffer overflows
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解缓冲区溢出的基础知识
- en: 'Assuming that `boverflow.c` compiled properly and ASLR is turned off, we can
    now execute our intentionally vulnerable program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`boverflow.c`编译正确，并且ASLR已关闭，我们现在可以执行我们有意使其易受攻击的程序：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your output should be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应该如下：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this prompt type a sequence of 21 characters such as `AAAA` and press *Enter:*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此提示符下，输入一个包含21个字符的序列，例如`AAAA`，然后按*Enter*：
- en: '[PRE19]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By entering only four characters the program executed the instructions and exited
    properly after displaying the characters you had typed. Now let's overflow the
    buffer to analyze the result. This time run the program but type more than 21
    characters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入只有四个字符，程序执行了指令，并在显示您输入的字符后正常退出。现在让我们溢出缓冲区以分析结果。这次运行程序，但输入超过21个字符。
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By entering more data than the buffer could handle we have generated a **segmentation
    fault**. This is exactly what we are looking for. Let's take a look at what is
    occurring in memory space when this program is running. At the prompt invoke the
    `gdb` debugger.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入比缓冲区能处理的数据更多，我们生成了一个**分段错误**。这正是我们要寻找的。让我们看看这个程序在运行时内存空间发生了什么。在提示符下调用`gdb`调试器。
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The debugger will provide us with detailed memory information about the `bovrflow`
    program. Let''s take a look at what happens when we run the program from within
    `gdb` without overflowing the buffer. We type *r* at the gdb prompt to **run**
    the program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器将为我们提供有关`bovrflow`程序的详细内存信息。让我们看看在不溢出缓冲区的情况下从`gdb`中运行程序时会发生什么。我们在gdb提示符下键入*r*来**运行**程序：
- en: '[PRE24]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nothing interesting to see here, but this test is a good sanity check to ensure
    everything is working properly. Now we need to take a look at what occurs when
    we cause the segmentation error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么有趣的，但这个测试是一个很好的理智检查，以确保一切正常工作。现在我们需要看一下当我们引起分段错误时会发生什么：
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once again we run the program; this time however we use a sequence of 22 characters
    and intentionally cause a segmentation fault. When reviewing the results, it becomes
    obvious that something is not quite right. Take notice of the reference to the
    `SIGSEGV`, segmentation fault. We will need to take advantage of this error and
    exploit the evident vulnerability. Unfortunately, there is a bit more that we
    need to understand before moving on to creating our shellcode. After all, so far
    all we know is that we can cause the application to crash. To progress we must
    look at our register addresses to further comprehend what occurred in memory space
    during the crash. Type *i r* at the prompt:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序；但是这一次我们使用了一个包含22个字符的序列，并故意导致了一个分段错误。在审查结果时，显然有些不对劲。注意到对`SIGSEGV`，分段错误的引用。我们需要利用这个错误并利用明显的漏洞。不幸的是，在继续创建我们的shellcode之前，我们需要了解更多。毕竟，到目前为止，我们只知道我们可以使应用程序崩溃。为了进展，我们必须查看我们的寄存器地址，以进一步理解崩溃时内存空间发生了什么。在提示符下键入*i
    r*：
- en: '[PRE28]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can see our input at `ebp` as `0x41414141`. Let's run the program again and
    add a few more A's and see what happens.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`ebp`处看到我们的输入为`0x41414141`。让我们再次运行程序，并添加几个A，看看会发生什么。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not understand what we are looking at when we see `0x41414141`, perform
    a quick search on `google.com` for "ASCII conversion chart", find one that you
    are comfortable with and print it out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解当我们看到`0x41414141`时我们在看什么，请在`google.com`上进行快速搜索，找到一个您喜欢的ASCII转换表，并打印出来。
- en: '[PRE30]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Press *r* to restart the program within the debugger.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按*r*在调试器中重新启动程序。
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Press *y* to let the debugger know you would like to completely restart.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按*y*让调试器知道您想要完全重新启动。
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time we need to type 24 *A's* and press *Enter*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '这次我们需要输入24个*A*并按*Enter*。 '
- en: '[PRE33]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our segmentation fault is returning something strange now… When we typed only
    12 characters earlier our output indicated `0xb7e8bb00 in __libc_start_main ()`
    from `/lib/tls/i686/cmov/libc.so.6`, but now we return `0xb7004141 in ?? ()` instead.
    We can even see some of our *A''s* coming through now. Take a look at our information
    registers again:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分段错误现在返回了一些奇怪的东西...当我们之前只输入12个字符时，输出指示`0xb7e8bb00 in __libc_start_main ()`来自`/lib/tls/i686/cmov/libc.so.6`，但现在我们返回的是`0xb7004141
    in ?? ()`。我们甚至可以看到一些我们的*A*现在出现了。再次查看我们的信息寄存器：
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Take a look at `eip`. We can see that with 24 characters the address is `0xb7004141`
    whereas with only 12 A's we were looking at `0xb7e8bb00`. This is significant.
    We need to try one more thing to make this truly apparent. Run the program from
    within the debugger once more. This time use a total of 26 A's and completely
    overwrite EIP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`eip`。我们可以看到，使用24个字符时，地址为`0xb7004141`，而只有12个A时，我们看到的是`0xb7e8bb00`。这是重要的。我们需要尝试一件事情，使这一点变得显而易见。再次从调试器中运行程序。这次使用总共26个A，并完全覆盖EIP。
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now EIP is completely overridden with A's. We have demonstrated how a user could
    manipulate the stack. In the next section, we review and exploit a small sample
    program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在EIP完全被A覆盖了。我们已经演示了用户如何操纵堆栈。在下一节中，我们将审查并利用一个小样本程序。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are up for a challenge, perform additional research and try to gain a
    root shell or open nano by exploiting `bovrflow`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想挑战自己，请进行额外的研究，并尝试通过利用`bovrflow`来获得root shell或打开nano。
- en: 'At this point we have covered the basic concept of how the stack can be manipulated.
    Advanced attackers will understand and take advantage of these flaws whenever
    possible. Under many circumstances you will not have time to fully check every
    single application for vulnerabilities such as buffer overflows, but it is good
    to understand the basic premise of the attacks we will be using as we move further
    into the chapter. If you find that you might enjoy vulnerability research I highly
    recommend that you check out the following resources:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何操纵堆栈的基本概念。高级攻击者将了解并利用这些漏洞，以便在可能的情况下利用这些漏洞。在许多情况下，您将没有时间完全检查每个应用程序是否存在缓冲区溢出等漏洞，但了解我们将在本章中进一步使用的攻击的基本原理是很好的。如果您发现自己可能会喜欢漏洞研究，我强烈建议您查看以下资源：
- en: '| **Excellent resources to learn more about buffer overflow vulnerabilities
    and more:** |   |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **了解更多关于缓冲区溢出漏洞和更多的优秀资源：** |   |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Smashing The Stack For Fun And Profit* by Aleph One | [http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *Smashing The Stack For Fun And Profit* by Aleph One | [http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)
    |'
- en: '| *Buffer Overflow Tutorial* by Mudge | [http://insecure.org/stf/mudge_buffer_overflow_tutorial.html](http://insecure.org/stf/mudge_buffer_overflow_tutorial.html)
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *Mudge的缓冲区溢出教程* | [http://insecure.org/stf/mudge_buffer_overflow_tutorial.html](http://insecure.org/stf/mudge_buffer_overflow_tutorial.html)
    |'
- en: '| The Corelan Team''s website. This team is amazing. Check out their tutorials
    and forums! | [http://www.corelan.be/](http://www.corelan.be/) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Corelan团队的网站。这个团队很棒。查看他们的教程和论坛！ | [http://www.corelan.be/](http://www.corelan.be/)
    |'
- en: '| IHASOMGSECURITYSKILLS Blog by "sickn3ss" Impressive write ups that are easy
    to follow along with. Check out the tutorials. | [http://sickness.tor.hu/](http://sickness.tor.hu/)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| "sickn3ss"的IHASOMGSECURITYSKILLS博客。令人印象深刻的写作，易于跟随。查看教程。 | [http://sickness.tor.hu/](http://sickness.tor.hu/)
    |'
- en: Introduction to fuzzing
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试简介
- en: Any time that an application allows for input, be it directly from the user
    such as when entering credentials, opening a file, or even from changing the data
    in RAM, there is a chance that the input can be used to cause havoc. Attackers
    will not spend hours, or days typing away (well, some might!) at a username and
    password prompt or an unknown connection to an obscure port. Instead, they will
    take advantage of tools that are focused on exactly this task welcome to the world
    of fuzzers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序允许输入时，无论是直接来自用户（例如输入凭据、打开文件，甚至从更改RAM中的数据），都有可能利用输入来造成混乱。攻击者不会花费数小时或数天在用户名和密码提示或对一个不知名端口的连接上输入（好吧，有些人可能会！）。相反，他们将利用专注于这一任务的工具，欢迎来到模糊器的世界。
- en: A fuzzer will typically be used to generate and output data; this data could
    be manipulated and formatted in various ways and there are published algorithms
    that assist in making the job even easier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊器通常用于生成和输出数据；这些数据可以以各种方式进行操作和格式化，并且有已发布的算法可以帮助使工作变得更加容易。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that **input** is a very broad term. When thinking about input
    vectors be sure to consider every method of input available to the application
    being tested. Something as seemingly trivial as streaming a song or even reading
    a filename could provide possible attack vectors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住**输入**是一个非常广泛的术语。在考虑被测试应用程序的每种输入方法时，请务必考虑每种输入向量。似乎微不足道的事情，如播放一首歌曲甚至读取文件名，都可能提供可能的攻击向量。
- en: 'Whenever a situation arises where a program allows for an uncontrolled input,
    there is probably a fuzzer waiting to handle the task. Let''s create a small program
    and take a look at what a fuzzer might do to assist in finding a vulnerability
    or abnormality in an application. We will use a well known and often demonstrated
    vulnerability in the `strcpy()` function. Open up the BackTrack instance and create
    the following program:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当出现程序允许不受控制的输入的情况时，可能会有一个模糊器等待处理任务。让我们创建一个小程序，看看模糊器可能如何帮助找到应用程序中的漏洞或异常。我们将使用`strcpy()`函数中的一个众所周知且经常演示的漏洞。打开BackTrack实例并创建以下程序：
- en: '[PRE42]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As mentioned previously, we are creating a scenario in which the `stuff` char
    buffer can be overloaded. `int main(int argc, char** argv)` instructs the program
    to accept the input after the file is invoked and before *Enter* is pressed and
    assigns it to `argv` which we can then copy to the `stuff` variable. If `stuff`
    is unable to contain the amount of data or the type of data presented, a segmentation
    fault will occur.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在创建一个场景，其中`stuff`字符缓冲区可以被超载。`int main(int argc, char** argv)`指示程序在调用文件之后并在按下*Enter*之前接受输入，并将其分配给`argv`，然后我们可以将其复制到`stuff`变量中。如果`stuff`无法包含所呈现的数据的数量或类型，将发生分段错误。
- en: Be sure to compile it using the `-fno-stack-protector` argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`-fno-stack-protector`参数进行编译。
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Give the program a try with and without attempting to cause the segmentation
    fault:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在尝试和不尝试引起分段错误的情况下运行程序：
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we need to give it a try with enough input to cause a crash:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要尝试足够的输入来导致崩溃：
- en: '[PRE46]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As expected, at 208 chars we generate an intentional segmentation fault. Now
    assume that you did not know this in advance and it could possible take hundreds
    or thousands of characters to crash this program. This is why we would want to
    use a fuzzer to automate the attack. Let''s make a **very** basic proof of concept
    using shell scripting:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在208个字符时，我们生成了一个有意的分段错误。现在假设您事先不知道这一点，可能需要数百或数千个字符才能使程序崩溃。这就是为什么我们希望使用模糊器来自动执行攻击。让我们使用shell脚本制作一个**非常**基本的概念验证：
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this simplistic representation of a fuzzer we ask for the amount of letter
    A''s that we want to test against the program. We then run a loop that will iterate
    through each of the items until the counter is back down to 1 again. If we run
    the program and choose 10 we receive the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的模糊器表示中，我们要求输入我们想要针对程序进行测试的A的数量。然后，我们运行一个循环，直到计数器再次降至1。如果我们运行程序并选择10，我们将收到以下输出：
- en: '[PRE50]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Try to see what happens when you choose 208 A's. The program is not sophisticated
    and will not exit cleanly. Nor will you have any indicator as to what happened,
    or why any A's after 207 did not display.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试看看当您选择208个A时会发生什么。该程序并不复杂，不会干净地退出。您也不会有任何指示器表明发生了什么，或者为什么207个之后的A没有显示。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Challenge yourself to modify this simple program, or to recreate it in a more
    appropriate scripting or programming language such as Python or Ruby.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己修改这个简单的程序，或者用更合适的脚本语言或编程语言（如Python或Ruby）重新创建它。
- en: The basic concept of fuzzing should be apparent after these exercises. There
    are books dedicated to just this subject, and as such we will only be able to
    scratch the surface of the true art form that fuzzing can be.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习，模糊测试的基本概念应该是明显的。有一些专门致力于这个主题的书籍，因此我们只能浅尝辄止，模糊测试可能是真正艺术形式的表面。
- en: Introducing vulnserver
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍vulnserver
- en: We will be using vulnserver ([http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html](http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html))
    as our target during several of the following exercises. This intentionally vulnerable
    application was created by Stephen Bradshaw to provide himself and the security
    community with an application that can be used to practice various security-related
    tasks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个练习中，我们将使用vulnserver（[http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html](http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html)）作为我们的目标。这个有意漏洞的应用程序是由Stephen
    Bradshaw创建的，旨在为自己和安全社区提供一个可以用来练习各种与安全相关的任务的应用程序。
- en: Ideally, the program is to be run on a Windows-based machine; as we are trying
    to keep the book focused on open source and freely available programs we will
    run the server on our BackTrack machine. This will be sufficient to learn about
    more about the fuzzing tools available in BackTrack.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，该程序应在基于Windows的机器上运行；由于我们试图让这本书专注于开源和免费可用的程序，我们将在我们的BackTrack机器上运行服务器。这将足以了解BackTrack中提供的更多关于模糊测试工具的信息。
- en: 'Download the vulnserver application to your BackTrack machine, unzip it, review
    the LICENSE and README files carefully, and after disconnecting the BackTrack
    instance from the Internet again, start `vulnserver.exe` up using the following
    command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将vulnserver应用程序下载到您的BackTrack机器上，解压缩它，仔细查看许可证和README文件，并在再次断开BackTrack实例与互联网的连接后，使用以下命令启动`vulnserver.exe`：
- en: '[PRE54]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This command will use `wine` to run your `vulnserver.exe` application on port
    4444\. To test that the server is working properly open up a terminal session
    and connect to the server using `netcat` as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用`wine`在端口4444上运行您的`vulnserver.exe`应用程序。要测试服务器是否正常工作，请打开一个终端会话，并使用`netcat`连接到服务器，如下所示：
- en: '[PRE56]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You will be presented with an introduction screen from vulnserver:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到vulnserver的介绍屏幕：
- en: '[PRE57]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As mentioned by the prompt you may enter HELP to receive information about
    available inputs:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所述，您可以输入HELP以获取有关可用输入的信息：
- en: '[PRE58]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will be using different fuzzers that come preinstalled on BackTrack 5 R1
    to inject malformed, random, or mutated data into these inputs. To get more familiar
    with the server feel free to poke around. Here is an example of a valid input:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预先安装在BackTrack 5 R1上的不同模糊测试工具向这些输入注入畸形、随机或变异的数据。要更熟悉服务器，随时随地随意探索。以下是一个有效输入的示例：
- en: '[PRE60]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The application expected an input which we provided as LTER AAAAAA. As there
    is not a problem with this input the application returns back to the normal state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序期望一个我们提供的输入，我们提供了LTER AAAAAA。由于这个输入没有问题，应用程序会返回到正常状态。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For detailed information about the vulnserver application, please visit Stephen
    Bradshaw's blog. While there you will also find that it contains several great
    tutorials relating to his vulnserver application and more that are well written
    and easy to follow.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关vulnserver应用程序的详细信息，请访问Stephen Bradshaw的博客。在那里，您还会发现它包含了与他的vulnserver应用程序相关的几个很棒的教程，这些教程写得很好，易于理解。
- en: Fuzzing tools included in BackTrack
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BackTrack中包含的模糊测试工具
- en: Luckily, for us it is not necessary for the typical penetration tester to spend
    months and years preparing the perfect fuzzer. The community has already provided
    us with an abundance of these wonderful tools and compared to writing them, their
    usage is a breeze!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于典型的渗透测试人员来说，不需要花费数月甚至数年来准备完美的模糊测试工具。社区已经为我们提供了大量这些精彩的工具，与编写它们相比，它们的使用非常简单！
- en: Bruteforce Exploit Detector (BED)
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bruteforce Exploit Detector (BED)
- en: The **Bruteforce Exploit Detector (BED)** does exactly what the name implies.
    The program will allow you to send data to the target application in hopes that
    a crash will occur. Although this method does work in certain situations, at times
    more control is needed when trying to find vulnerable applications. BackTrack
    5 R1 has BED preinstalled at `/pentest/fuzzers/bed`. BED provides the ability
    to fuzz several, often used protocols without modification.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bruteforce Exploit Detector (BED)**正如其名称所示。该程序将允许您向目标应用程序发送数据，希望会发生崩溃。尽管这种方法在某些情况下确实有效，但在尝试查找易受攻击的应用程序时，有时需要更多的控制。BackTrack
    5 R1在`/pentest/fuzzers/bed`预安装了BED。BED提供了在不修改的情况下模糊测试几种常用协议的能力。'
- en: '[PRE62]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Besides the plugins provided by the developers of the Bruteforce Exploit Detector,
    you may also easily create your own plugins. Take a look at the `/pentest/fuzzers/bed/docs`
    directory `dummy.pm` file. This skeleton provides you with a skeleton that can
    be modified to suite our needs. Change directory to `/pentesting/fuzzers/bed/bedmod`
    and `cat` a couple of the files that you see such as `ftp.pm` to get a better
    idea of what a fully functional plugins looks like. When you are comfortable with
    the format, create a new file in the `bedmod` folder and name it `vserver.pm`.
    The following code has been created using the `dummy.pm` example template. Enter
    this code into `vserver.pm:`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Bruteforce Exploit Detector的开发人员提供的插件之外，您还可以轻松创建自己的插件。查看`/pentest/fuzzers/bed/docs`目录中的`dummy.pm`文件。这个模板为您提供了一个可以根据我们的需求进行修改的模板。切换到`/pentesting/fuzzers/bed/bedmod`目录，并`cat`一些文件，比如`ftp.pm`，以更好地了解完全功能的插件是什么样子的。当您对格式感到满意时，在`bedmod`文件夹中创建一个新文件，并将其命名为`vserver.pm`。以下代码是使用`dummy.pm`示例模板创建的。将此代码输入到`vserver.pm`中：
- en: '[PRE64]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At first glance this code may seem complicated. If you take a look at the highlighted
    code you will see the most important aspect of our particular plugin. We have
    instructed BED to send data to each of the inputs that were provided to us by
    the HELP command. The default port is set to 4444 and the login is blank because
    it is not required for this type of application. There is one more modification
    that needs to occur before we can use the `vserver.pm` plugin. Open up the `/pentest/fuzzers/bed/bed.pl`
    file for editing and add `vserver` to the `@plugins` variable on line #14:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这段代码可能看起来很复杂。如果你看一下高亮显示的代码，你会看到我们特定插件的最重要的方面。我们已经指示BED向我们通过HELP命令提供的每个输入发送数据。默认端口设置为4444，登录为空，因为对于这种类型的应用程序不需要。在我们可以使用`vserver.pm`插件之前还需要进行一些修改。打开`/pentest/fuzzers/bed/bed.pl`文件进行编辑，并在第14行的`@plugins`变量中添加`vserver`：
- en: '[PRE65]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Save the changes you have made to `bed.pl` and exit your editor. Assuming you
    have already started `vulnserver.exe` on port 4444, let''s give our new plugin
    a try:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你对`bed.pl`所做的更改并退出编辑器。假设你已经在4444端口上启动了`vulnserver.exe`，让我们尝试一下我们的新插件：
- en: '[PRE66]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`Bed.pl` is definitely doing something, but we do not really get any feedback
    on precisely what is occurring. If you wait long enough you will receive notice
    of a crash.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bed.pl`确实在做一些事情，但我们并没有确切地得到任何反馈。如果你等待足够长的时间，你会收到崩溃的通知。'
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_01.jpg)'
- en: Unfortunately, the vulnserver application is still receiving connections and
    thus `bed.pl` will continue the brute forcing process. Also, at this point we
    do not know what caused the crash. When we click on **Close** we are rewarded
    with some debugging information from the vulnserver console, but this behavior
    should not always be expected when working with client modified or created applications.
    Often debugging will be disabled on production applications to avoid giving potential
    attackers too much information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，vulnserver应用程序仍在接收连接，因此`bed.pl`将继续暴力破解过程。此外，此时我们不知道是什么导致了崩溃。当我们点击**关闭**时，我们会从vulnserver控制台获得一些调试信息，但在处理客户端修改或创建的应用程序时，这种行为并不总是可以预期的。通常情况下，为了避免给潜在攻击者提供过多信息，生产应用程序会禁用调试。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We did not code in anything that would stop the program if certain statements
    (such as GOODBYE) did not appear after the `EXIT` command was initiated. Because
    of this the Bruteforce Exploit Detector did not detect that there was an issue!
    Challenge yourself to add this functionality to your plugin!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有编写任何会在`EXIT`命令启动后停止程序的语句（比如GOODBYE）。因此，Bruteforce Exploit Detector没有检测到问题！挑战自己，为你的插件添加这个功能！
- en: Let's take a look at the terminal that is providing usage feedback from `stdout:`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下从`stdout`提供使用反馈的终端：
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is of note that EIP has been overwritten with `41414141`. This is a good
    indicator that an exploit of this stack overflow is likely to be possible. Also
    notice that the server output indicates that connectivity requests are occurring.
    The server did not completely crash, only this connection. This can be used to
    your advantage if you need to create your own exploit later.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，EIP已被覆盖为`41414141`。这是一个很好的指示，表明可能存在对这个堆栈溢出的利用。还要注意服务器输出表明正在发生连接请求。服务器并没有完全崩溃，只是这个连接。如果以后需要创建自己的利用，这可以为你带来好处。
- en: Now that we know there is an issue with the application we need to get an idea
    of what was sent to cause the crash. Usually your fuzzer would provide this information
    for you, but in this case `bed.pl` just keeps on chugging.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道应用程序存在问题，我们需要了解是什么导致了崩溃。通常情况下，你的模糊器会为你提供这些信息，但在这种情况下，`bed.pl`仍在继续运行。
- en: '[PRE69]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Wait until the Wireshark GUI has completely loaded and select the option that
    captures `lo` (this will allow you to witness the local traffic) from the middle
    of the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 等到Wireshark GUI完全加载并选择捕获`lo`的选项（这将允许你观察本地流量）从屏幕中间。
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_02.jpg)'
- en: Let's reproduce the error, but this time we will watch the packets in **Wireshark**
    as they traverse the local loopback interface. Restart the `vulnserver`, and then
    start `bed.pl` again using the `vserver` plugin. Once everything has started click
    over to Wireshark and take a look at the packets that are being passed. You can
    right-click on any of the messages in Wireshark and select **Follow TCP Stream**
    to see the messages in an easy to read format.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重现错误，但这次我们将在**Wireshark**中观察数据包，因为它们穿过本地环回接口。重新启动`vulnserver`，然后再次使用`vserver`插件启动`bed.pl`。一切都开始后，切换到Wireshark并查看正在传递的数据包。你可以右键单击Wireshark中的任何消息，然后选择**跟踪TCP流**以查看消息的易于阅读的格式。
- en: 'If you wait until the crash occurs you can search the stream in Wireshark that
    looks to be the most obvious cause of the crash. Keep in mind that we do not have
    any delays in the code so the last connection made is not necessarily the connection
    that caused the error to occur. In this particular case it was noted in the `vulnserver`
    console that the last connection to be made before the crash was:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等到崩溃发生，你可以在Wireshark中搜索看起来最明显导致崩溃的流。请记住，我们的代码中没有任何延迟，所以最后建立的连接不一定是导致错误发生的连接。在这种情况下，注意到在`vulnserver`控制台上，在崩溃发生之前最后建立的连接是：
- en: '[PRE70]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you go to Wireshark and enter `tcp.stream eq 41041` into the **Filter** menu
    you will be presented with only those packets that make up the messages we are
    interested in. Pick one of the filtered messages, right-click on it, and take
    a look at the TCP stream.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去Wireshark并在**过滤器**菜单中输入`tcp.stream eq 41041`，你将只看到组成我们感兴趣的消息的数据包。选择其中一个被过滤的消息，右键单击它，然后查看TCP流。
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_03.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_03.jpg)'
- en: 'It looks like the last message to be sent to vulnserver was:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来最后一条发送到vulnserver的消息是：
- en: '[PRE71]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Reviewing previous messages without using the filter we can determine that
    `KSTET` typically sends a response **(KSTET** `SUCCESSFUL)` upon successful acceptance
    of input:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用过滤器的情况下查看以前的消息，我们可以确定`KSTET`通常在成功接受输入后发送响应**(KSTET** `SUCCESSFUL)`：
- en: '[PRE72]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can test this input to see if we can manually replicate the error. Stop and
    restart the vulnserver and manually `netcat` to `127.0.0.1` port 4444.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这个输入，看看我们是否可以手动复制错误。停止并重新启动vulnserver，然后手动`netcat`到`127.0.0.1`端口4444。
- en: '[PRE73]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: At this point the application will crash and the **Program Error** pop up will
    appear once more. Click on **Close** in the **Program Error** window. Once again
    we can review the output from the debugger and note that EIP (the current instruction
    being processed) has been overwritten by 41414141.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此时应用程序将崩溃，并且**Program Error**弹出窗口将再次出现。单击**Program Error**窗口中的**Close**。再次可以从调试器的输出中查看，并注意EIP（当前正在处理的指令）已被41414141覆盖。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These are the type of repeatable errors we should be looking for when attempting
    to ensure the security posture of the environments being tested. Depending on
    the scope of the test, at this point the business may only require the details
    of the potential vulnerability. If the scope allows, an exploit for the application
    could be created to prove that the vulnerability could lead to loss of important
    data, assets, or revenue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试确保正在测试的环境的安全姿态时，我们应该寻找这种可重复的错误。根据测试的范围，此时业务可能只需要潜在漏洞的详细信息。如果范围允许，可以创建一个应用程序的利用来证明漏洞可能导致重要数据、资产或收入的损失。
- en: 'SFUZZ: Simple fuzzer'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFUZZ：简单模糊器
- en: Simple fuzzer known as SFUZZ created by Aaron Conole is a great tool if you
    want to start taking the fuzzing business seriously. SFUZZ is powerful and useful
    to someone who is not ready to expend the time needed to properly learn how to
    fully use SPIKE. Also, there are times when using a smaller, simpler tool is just
    more efficient.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由Aaron Conole创建的简单模糊器SFUZZ是一个很好的工具，如果你想认真开始进行模糊化业务。对于那些还没有准备好花时间来学习如何充分使用SPIKE的人来说，SFUZZ是强大且有用的。此外，有时使用更小、更简单的工具更有效率。
- en: If you are still learning about exploit development then SFUZZ makes a great
    stepping stone and will definitely continue to be a valuable addition to your
    penetration testing knowledge base throughout the years ahead; at times it is
    very convenient to have tools that are quick and easy to configure!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在学习利用开发，那么SFUZZ将成为一个很好的垫脚石，并且在未来的几年中肯定会继续成为您渗透测试知识库中的宝贵补充；有时，拥有快速且易于配置的工具非常方便！
- en: 'Browse to the `/pentest/fuzzers/sfuzz` directory and familiarize yourself with
    the directory structure. If sfuzz is invoked without arguments you will be presented
    with the available startup switches:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`/pentest/fuzzers/sfuzz`目录，并熟悉目录结构。如果没有参数调用sfuzz，您将看到可用的启动开关：
- en: '[PRE78]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Although there are example scripts available we will need to create our own
    if we would like to be able to fuzz the vulnserver application. Create the following
    script named `basic.verserver` in the `sfuzz-sample` directory:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有示例脚本可用，但如果我们想要能够模糊化vulnserver应用程序，我们需要创建自己的脚本。在`sfuzz-sample`目录中创建以下名为`basic.verserver`的脚本：
- en: '[PRE80]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In this script we instruct sfuzz to use the `basic-fuzz-strings.list` when
    performing the fuzzing activity. We then add a delay of 200 milliseconds and restrict
    the sequence length to 2010\. This fuzzer is so simple that we then list the commands
    to be sent followed by the FUZZ variable which is replaced by the application
    with fuzzed output. We must save the file, ensure that the vulnserver is running
    on port 4444, and then proceed with starting the sfuzz script:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们指示sfuzz在执行模糊化活动时使用`basic-fuzz-strings.list`。然后我们添加了200毫秒的延迟，并将序列长度限制为2010。这个模糊器非常简单，然后列出要发送的命令，然后是由应用程序用模糊输出替换的FUZZ变量。我们必须保存文件，确保vulnserver正在4444端口上运行，然后继续启动sfuzz脚本：
- en: '[PRE81]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This will start the fuzzing process and will also let you see the data that
    is being passed. One technique that could be used is to perform a very fast scan
    to see if any crashes occur and then rerun the scan again using more refined parameters
    and at a slower pace. This will ensure that the exception is caught easily.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动模糊化过程，并让您看到正在传递的数据。可以使用一种技术进行非常快速的扫描，以查看是否发生任何崩溃，然后使用更精细的参数再次运行扫描，并以较慢的速度进行。这将确保异常很容易被捕获。
- en: 'As expected, our fuzzer script was able to crash the vulnserver with the following
    output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们的模糊器脚本能够使用以下输出使vulnserver崩溃：
- en: '[PRE82]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Once again, the test did not catch the failure and sfuzz continued to send data
    to the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试没有捕捉到失败，sfuzz继续向应用程序发送数据。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember the exploitable program "fuzzme" that we wrote earlier in the chapter?
    Challenge yourself to use sfuzz to fuzz the fuzzme program! HINT: Use `basic.cmd`
    as a guide on how to write your script.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本章前面编写的可利用程序"fuzzme"吗？挑战自己使用sfuzz来模糊化fuzzme程序！提示：使用`basic.cmd`作为编写脚本的指南。
- en: As previously stated, the art of fuzzing can be extremely useful, but the path
    to mastering it will take dedication and continual practice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前所述，模糊化的艺术可能非常有用，但掌握它需要专注和持续的练习。
- en: Fast-Track
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fast-Track
- en: Penetration testing is often restricted to particular timeframes. This is a
    chief complaint of many penetration testers because after all, the attackers in
    the wild are not restricted by these business imposed timeframes at all. Thankfully,
    we can rely on tools such as Metasploit, SET, or Fast-Track to assist us in covering
    ground as quickly as possible. Fast-Track was developed by David Kennedy aka ReL1K,
    and Joey Furr aka j0fer, to automate many of the attacks that a penetration tester
    will need to perform frequently.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试通常受到特定时间范围的限制。这是许多渗透测试人员的主要抱怨，因为毕竟，野外的攻击者根本不受这些业务强加的时间范围的限制。幸运的是，我们可以依靠诸如Metasploit、SET或Fast-Track之类的工具，尽快地扩大范围。Fast-Track是由David
    Kennedy（又名ReL1K）和Joey Furr（又名j0fer）开发的，用于自动化渗透测试人员经常需要执行的许多攻击。
- en: Menu driven and sleek in design, Fast-Track enables you to quickly perform tasks
    such as generating payloads, quickly set up client-side attacks, or even convert
    payloads from binary to hex.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track是一个菜单驱动且设计精美的工具，它使您能够快速执行诸如生成有效负载、快速设置客户端攻击，甚至将有效负载从二进制转换为十六进制等任务。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fast-Track can be used from the command line (-c) , a browser GUI (-g), or an
    interactive menu driven console (-i) by adding the appropriate argument when invoking
    the program. As with any penetration testing tool, please read the license files
    and warnings before using Fast-Track. Penetration testing tools should ONLY be
    used against systems that you have proper and legal authority to test.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track可以通过命令行(-c)、浏览器GUI(-g)或交互式菜单驱动控制台(-i)使用，只需在调用程序时添加适当的参数。与任何渗透测试工具一样，请在使用Fast-Track之前阅读许可文件和警告。渗透测试工具应该只用于您有适当和合法权限进行测试的系统。
- en: We will be using only a portion of this great tool, but understanding all of
    its features is a valuable addition to anyone's penetration testing arsenal.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用这个强大工具的一部分，但了解其所有功能对于任何渗透测试人员来说都是一个有价值的补充。
- en: 'Fast-Track can be found in BackTrack 5 R1 at `/pentesting/exploits/fastrack`
    . To start the program in web GUI mode simply type:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track可以在BackTrack 5 R1的`/pentesting/exploits/fastrack`中找到。要以Web GUI模式启动程序，只需键入：
- en: '[PRE83]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This command has initiated the Fast-Track Web GUI written by David Kennedy.
    Open up Firefox and browse to `http://127.0.0.1:44444` as instructed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令已启动了由David Kennedy编写的Fast-Track Web GUI。打开Firefox并浏览到`http://127.0.0.1:44444`，如指示。
- en: The sidebar menu includes many of the options we will be discussing while using
    the menu driven user interface. Browse around the menu and familiarize yourself
    with the application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏菜单包括我们在使用菜单驱动用户界面时将要讨论的许多选项。浏览菜单并熟悉应用程序。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure not to launch any attacks unless you fully understand what you are doing
    and the BackTrack machine is segmented and not on the Internet or a production
    environment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您完全了解自己在做什么，BackTrack机器被分割并且不在互联网或生产环境中，否则不要发动任何攻击。
- en: 'Exit out of your browser and cancel out of the Fast-Track. At the command line
    type the following to open up the menu-driven Fast-Track interface:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 退出浏览器并取消Fast-Track。在命令行中键入以下内容以打开菜单驱动的Fast-Track界面：
- en: '[PRE85]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Updating Fast-Track
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Fast-Track
- en: As with any other tool, we should update everything before we begin. Type *1*
    to select Fast-Track Updates and press *Enter:*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他工具一样，我们在开始之前应该更新所有内容。键入*1*选择Fast-Track更新，然后按*Enter*：
- en: '[PRE87]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Use the Update Fast-Track, Metasploit 3 Update and Exploit-DB Exploits in sequence
    from 1-3\. Once the updates are complete use *q* to exit back to the main menu.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序使用1-3从1到3选择更新Fast-Track、Metasploit 3更新和Exploit-DB漏洞。更新完成后，使用*q*退出返回到主菜单。
- en: Client-side attacks with Fast-Track
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fast-Track进行客户端攻击
- en: Fast-Track includes an option to set up a web page that will exploit any known
    vulnerabilities that the client machine is susceptible to. All of the work is
    done for you except getting someone to visit your machine. If the scope of your
    testing includes phishing, you could craft a specific message in e-mail and have
    the user follow a link back to the page that Fast-Track will set up for you.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track包括一个选项，可以设置一个网页，利用客户端机器易受攻击的任何已知漏洞。除了让某人访问您的机器之外，所有工作都已经完成。如果您的测试范围包括网络钓鱼，您可以在电子邮件中制作特定消息，并让用户点击链接返回Fast-Track为您设置的页面。
- en: Select option **5\. Mass Client-Side Attack** from the menu and press *Enter*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择选项**5. 大规模客户端攻击**，然后按*Enter*。
- en: You will be required to type the IP address that you would like to listen on.
    The BackTrack machine I am using is listening on `VLAN1` at `192.168.1.205`. You
    will need to know what your IP address is and enter it here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要输入要监听的IP地址。我正在使用的BackTrack机器在`VLAN1`上监听`192.168.1.205`。您需要知道您的IP地址是什么，并在此处输入。
- en: '[PRE89]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: When prompted to enter the payload that you would like to use, select **2\.
    Generic Bind Shell** and press *Enter*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示输入要使用的有效负载时，选择**2. 通用绑定Shell**，然后按*Enter*。
- en: Type `no` to ARP poison the host. Unless you know what you are doing and fully
    understand ARP poisoning and all of its inherent risks, use of this option is
    not advised. If you are in a segmented lab environment is it incredible to witness
    how this function works though, so you should definitely look into it!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`no`来ARP欺骗主机。除非您知道自己在做什么并完全了解ARP欺骗及其固有风险，否则不建议使用此选项。如果您在分割的实验室环境中，看到这个功能是令人难以置信的，所以您一定要深入了解它！
- en: 'You will be presented with a new pop-up command prompt that resembles the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个新的弹出命令提示符，类似于以下内容：
- en: '![Client-side attacks with Fast-Track](img/7744OS_06_04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![使用Fast-Track进行客户端攻击](img/7744OS_06_04.jpg)'
- en: 'Now any system that connects to this server will encounter the following web
    page:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任何连接到该服务器的系统都将遇到以下网页：
- en: '![Client-side attacks with Fast-Track](img/7744OS_06_05.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![使用Fast-Track进行客户端攻击](img/7744OS_06_05.jpg)'
- en: If the system that connects to this website is vulnerable to any of the exploits
    that Fast-Track attempts, you will be presented with a generic bind shell to that
    system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接到这个网站的系统容易受到Fast-Track尝试的任何漏洞的影响，您将看到一个通用绑定Shell。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will revisit this function during our post-exploitation chapter where we
    fully exploit a unit and follow up with the post-exploitation stages. At this
    point it is most important to understand the types of tools that are available
    not only to penetration testers, but to the public in general. If a business you
    are testing is susceptible to the exploits targeted by the Mass Client Attack
    Web Server, then it is extremely important that affected systems are updated and
    hardened ASAP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后期利用章节中重新讨论这个功能，在那里我们将充分利用一个单元，并跟进后期利用阶段。在这一点上，最重要的是要了解不仅对渗透测试人员，而且对公众来说可用的工具类型。如果您正在测试的企业容易受到Mass
    Client Attack Web Server针对的漏洞的影响，那么受影响的系统尽快更新和加固是非常重要的。
- en: The options in Fast-Track are well documented and the web features give great
    walkthroughs of this tool. Use your lab to try some of the exploits out, especially
    if you have Windows XP licenses laying around.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track中的选项都有很好的文档，网络功能提供了这个工具的很好的演练。使用您的实验室尝试一些漏洞利用，特别是如果您有Windows XP许可证。
- en: Social Engineering Toolkit
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社会工程工具包
- en: The **Social Engineering Toolkit (SET)** was created by David Kennedy [ReL1K]
    and the SET development team of JR DePre [pr1me], Joey Furr [j0fer], and Thomas
    Werth. With a wide variety of attacks available, this toolkit is an absolute "must
    have" for anyone who is serious about performing penetration testing. We will
    only provide a brief introduction to the Social Engineering Toolkit. SET is simple
    to use and the SET development team has created excellent documentation that is
    freely available at [http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)](http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 社会工程工具包（SET）是由David Kennedy [ReL1K]和SET开发团队JR DePre [pr1me]，Joey Furr [j0fer]和Thomas
    Werth创建的。该工具包提供了各种各样的攻击方式，对于那些认真进行渗透测试的人来说，这是一个绝对“必备品”。我们只会对社会工程工具包进行简要介绍。SET使用简单，SET开发团队已经创建了出色的文档，可以在[http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)](http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET))免费获取。
- en: 'SET comes preinstalled on BackTrack and can be invoked at the command line
    using:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SET已经预装在BackTrack上，并且可以在命令行中调用：
- en: '[PRE90]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before you may use the software you must read and accept the BSD license AND
    that you will not use this tool for any unlawful practice. This agreement covers
    any future usage as well, and you will not be prompted again after accepting by
    pressing *Y(es)* at the prompt.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用软件之前，您必须阅读并接受BSD许可协议，并且您不会将此工具用于任何非法行为。此协议也涵盖了任何将来的使用，一旦接受了，您将不会再次被提示，只需按*Y(es)*。
- en: '![Social Engineering Toolkit](img/7744OS_06_06.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![社会工程工具包](img/7744OS_06_06.jpg)'
- en: 'After updating the framework (remember to disconnect from the Internet again
    after performing your upgrades!) choose **1) Social-Engineering Attacks** to receive
    a listing of possible attacks that can be performed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更新框架后（记得在升级后再次断开与互联网的连接！），选择**1)社会工程攻击**以获得可以执行的可能攻击的列表：
- en: '[PRE91]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We will start with the Website Vectors. Enter *2* to move to the next menu.
    For this example, we will take a look at the first option on the list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网站向量开始。输入*2*以进入下一个菜单。在这个例子中，我们将查看列表上的第一个选项。
- en: '[PRE92]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following menu provides three options. We will be using one of the provided
    templates for this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个菜单提供了三个选项。在这个例子中，我们将使用其中一个提供的模板：
- en: '[PRE93]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: At the next menu select option **1\. Java Required** as your template.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜单中，选择**1\.需要Java**作为您的模板。
- en: '[PRE94]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When asked which payload you want to use, review the options carefully and select
    option 3 which is the reverse TCP VNC server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及要使用哪种有效载荷时，请仔细查看选项，并选择选项3，即反向TCP VNC服务器。
- en: '![Social Engineering Toolkit](img/7744OS_06_07.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![社会工程工具包](img/7744OS_06_07.jpg)'
- en: We will select the Backdoored Executable for our payload. The development team
    has provided a rating for each encoder type. At times you may need to try different
    types before you find one that suits your testing needs. These encoders will assist
    you in bypassing an antivirus that is present on the host machine.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择Backdoored可执行文件作为我们的有效载荷。开发团队为每种编码器类型提供了评级。有时您可能需要尝试不同类型，直到找到适合您测试需求的类型。这些编码器将帮助您绕过主机上存在的防病毒软件。
- en: Antivirus is typically signature based, so if you are able to change the signature
    of the file enough, the antivirus protection will be unable to detect your payload.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 防病毒软件通常是基于签名的，因此如果您能够改变文件的签名，防病毒保护将无法检测到您的有效载荷。
- en: '![Social Engineering Toolkit](img/7744OS_06_08.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![社会工程工具包](img/7744OS_06_08.jpg)'
- en: 'Select the default listener port at 443 and press *Enter* to continue. That''s
    it! All you have to do now is wait for someone to connect to your web server.
    If you have an available Window machine and browse to the site you will see the
    following website:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 选择默认的监听端口443并按*Enter*继续。就是这样！现在您所要做的就是等待有人连接到您的Web服务器。如果您有一个可用的Windows机器并浏览到该网站，您将看到以下网站：
- en: '![Social Engineering Toolkit](img/7744OS_06_09.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![社会工程工具包](img/7744OS_06_09.jpg)'
- en: We will revisit this exercise in the post exploitation chapter where we fully
    exploit the target system and take control of the network from within.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后期利用章节中重新讨论这个练习，我们将充分利用目标系统并从中控制网络。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Client-side attacks are often the easiest method of getting into a secured environment.
    We understand that through the clever use of different attack vectors an attacker
    is able to take advantage of the inexperience or kindness of our users in order
    to gain access to client-side computers. Developers are often unable to check
    for every possible flaw in their programs in the timeframes they are allotted
    and as such many of these vulnerabilities remain undiscovered by the quality assurance
    teams and developers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端攻击通常是进入受保护环境的最简单方法。我们知道，通过巧妙地利用不同的攻击向量，攻击者能够利用用户的经验不足或善良来访问客户端计算机。开发人员通常无法在规定的时间内检查其程序的每个可能的缺陷，因此许多这些漏洞都未被质量保证团队和开发人员发现。
- en: In this chapter, we have had a chance to not only learn about buffer overflow
    vulnerabilities, but actually create our own vulnerable application. We then took
    advantage of this vulnerability using manual techniques as well as automated fuzzing
    tools such as sfuzz and bed. We learned how to create our own modules and also
    how to modify existing modules to fit our specific needs.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们不仅有机会了解缓冲区溢出漏洞，而且实际上创建了我们自己的易受攻击的应用程序。然后，我们利用了这个漏洞，使用手动技术以及自动模糊测试工具，如sfuzz和bed。我们学会了如何创建我们自己的模块，以及如何修改现有的模块以适应我们的特定需求。
- en: In addition, we discussed Fast-Track and the Social Engineering Toolkit and
    walked through setting up a mass web attack in Fast-Track and a Java applet attack
    in SET. Using the knowledge gained during these walkthroughs you should be able
    to review and test the other options in your home lab to the point that you become
    comfortable using these tools in a production testing environment. When reviewing
    SET we also touched upon antivirus avoidance and repackaging our payloads. In
    future chapters we will revisit these tools to completely exploit and take control
    of a controlled networking environment.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们讨论了Fast-Track和社会工程工具包，并演示了在Fast-Track中设置大规模网络攻击和在SET中进行Java小程序攻击的步骤。利用这些演示中获得的知识，您应该能够在家庭实验室中审查和测试其他选项，直到您能够在生产测试环境中熟练使用这些工具。在审查SET时，我们还涉及了防病毒和重新打包我们的有效负载。在未来的章节中，我们将重新审视这些工具，完全利用并控制受控网络环境。
- en: In the next chapter, we learn the steps necessary to locate and gather information
    from compromised hosts. This stage includes learning about the most commonly used
    commands needed to perform post exploitation as well as steps on escalating privilege
    and adding persistent access to the compromised machines and more.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习定位和收集受损主机信息所需的步骤。这个阶段包括学习执行后期利用所需的最常用命令，以及提升特权和向受损机器添加持久访问权限等步骤。
