# 第六章：利用和客户端攻击

客户端攻击通常需要用户交互。对网站的粗心访问可能会导致灾难。一般来说，客户端攻击将集中在个人在家里或办公室使用的“客户端”机器上。在一个适当安全的环境中，这些主机将通过安全机制和实践的组合来保护，如白名单、网络分割、基于主机的防火墙、文件完整性监视器、系统配置硬化和防病毒软件。

通过适当的培训，用户清楚地知道点击未知链接、打开电子邮件附件，甚至插入不受信任的设备可能具有潜在的危害。不幸的是，方便往往超过常识，因此用户将继续重复旧错误。毕竟，管理员安装的所有这些保护机制难道不应该保护用户免受一切伤害吗？

在大型环境中，台式机、工作站甚至打印机通常被视为非关键设备。重点放在昂贵的服务器和对业务运行至关重要的系统上。熟练的攻击者会充分了解这种心态。如果无法轻松地利用 Web 应用程序漏洞渗透网络，攻击者通常会转而使用社会工程和客户端攻击的混合方式。如果成功，这些攻击将像热刀切黄油一样迅速穿透边界。此外，一个完全被攻陷的客户端机器可以被设置为进入本来被保护的网络的网关。

在本章中，我们将研究一些方法，帮助我们测试公司的安全意识培训和客户端保护机制的有效性。在测试的信息收集阶段进行的研究将得到充分利用。此外，我们将研究一些安全研究人员和狡猾攻击者使用的技术和工具，以绕过那些乍一看理论上似乎合理的系统控制。

# 缓冲区溢出 - 复习

缓冲区溢出是野外攻击者的基本技能。当这种类型的漏洞被正确利用时，攻击可能在短短几秒钟内导致系统完全被攻陷。理想情况下，通过正确实施安全开发生命周期，许多这些漏洞可以被预防。如果您的客户没有这样的做法，您可能需要执行超出标准渗透测试的步骤，并证明企业部署的（通常是内部开发的）应用程序存在缺陷。

### 注意

并非所有缓冲区溢出漏洞都可以用于创建远程利用。还要注意的是，并非所有缓冲区溢出都是可利用的。

通常情况下，允许缓冲区溢出的编程错误并非故意或是由于开发人员的懒惰。缓冲区溢出漏洞在应用程序开发阶段经常被忽视，要么是因为应用程序的复杂性，要么是因为原始代码库已经存在几十年，但仍在不断地进行开发。考虑到软件开发人员经常面临不合理的最后期限和来自管理层的要求，我们不应该感到惊讶，有时安全漏洞会在软件开发生命周期中被忽视或遗漏。开发人员接到的要求基于最后一刻的决定，这在逻辑上是不利于确保正在开发的应用程序的安全性。与任何其他技术一样，安全需要内置到整个过程中，而不是作为事后添加。开发人员的优先事项变成了推出代码修改，而不是专注于稳定性和安全性。

为了解决这些类型的错误，代码编译器和操作系统将包括旨在防止利用这种类型代码的机制。为了充分理解如何绕过这些机制，您至少需要基本了解什么是缓冲区溢出，以及如何验证您的客户端是否完全受到保护，以防此类攻击。

## "看见"才会相信 —— 创建一个易受攻击的程序

为了充分理解忽视这些错误有多简单，我们将制作我们自己的易受攻击的程序。打开一个 32 位的 BackTrack 虚拟系统，并利用这个机会连接到互联网并进行更新。更新后，您很可能需要下载我们将使用的调试器。目前，它不包括在 BackTrack 5 R1 的一部分中。

我们将使用 GNU 调试器。您可以在以下网址了解有关此工具的其他信息：[`www.gnu.org/s/gdb/`](http://www.gnu.org/s/gdb/)。

### 注意

以下示例使用 BackTrack 的 32 位版本。

要获得 GNU 调试器，您需要使用`apt-get` install 命令进行安装：

```
# apt-get install gdb

```

安装完`gdb`后，再次断开 BackTrack 虚拟机的互联网连接。

首要任务是编译一个小程序，用于演示缓冲区溢出的情况。我们利用`scanf`函数中一个众所周知的缺陷来实现这个目的。在 BackTrack 中打开一个终端会话，并使用 nano 创建一个名为`bovrflow.c`的文件。

```
# nano bovrflow.c

```

```
/* This program contains an intentional vulnerability for learning purposes. */
#include <stdio.h>
#include <string.h>
int main()
{
char lstring[10];
/* ask for the user to enter a long string */
printf("Enter a long string:");
/* scanf is known to be susceptible to buffer overflow when %s conversion is used*/
scanf("%s", lstring);
/*Print out the string that was typed*/
printf("You entered: %s\n",lstring);
return 0;
}

```

在退出到终端之前，请确保保存您的工作。在这个程序中，我们故意使用了`scanf()`与`%s`转换，因为`scanf()`不会对输入进行消毒，以确保它不会超出分配的缓冲区大小。有关此漏洞的更多信息可以在以下位置找到：[`buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html`](http://https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html)。

由于**GCC**编译器内置了安全限制，我们必须使用`-fno-stack-protector`来编译此代码。在命令提示符下，发出以下命令：

```
# gcc -o bovrflow -fno-stack-protector bovrflow.c

```

在上一个命令中，我们调用了`gcc`编译器，选择了输出文件名为`bovrflow`，禁用了编译器的堆栈保护功能，并针对`bovrflow.c`源代码进行了定位。

### 注意

因为我们在 BackTrack 中以 root 身份运行，所以在尝试运行之前，我们不必担心更改文件权限为可执行。

## 在 BackTrack 中打开和关闭 ASLR

Linux 默认使用地址空间布局随机化（ASLR）。您应该了解如何检查是否启用了 ASLR，以及如何能够打开和关闭它。让我们来看看`ldd`命令。这个命令将列出程序的共享库依赖关系。如果启用了 ASLR，内存地址在每次调用时都会改变：

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb786e000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7701000)
/lib/ld-linux.so.2 (0xb786f000)

```

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb780a000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb769d000)
/lib/ld-linux.so.2 (0xb780b000)

```

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb78b5000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7748000)
/lib/ld-linux.so.2 (0xb78b6000)

```

仔细检查后，显然内存地址每次都在变化。现在让我们通过更改`randomize_va_space`值来关闭 ASLR（关闭为 0，打开为 2），并比较结果：

```
# echo 0 > /proc/sys/kernel/randomize_va_space 

```

### 注意

对于 BackTrack 以外的 Linux 发行版，可以以相同的方式启用和禁用 Exec-Shield。例如：`echo 0 > /proc/sys/kernel/exec-shield`。

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb7fe4000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7e77000)
/lib/ld-linux.so.2 (0xb7fe5000)

```

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb7fe4000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7e77000)
/lib/ld-linux.so.2 (0xb7fe5000)

```

```
# root@bt:~ # ldd bovrflow 

```

```
linux-gate.so.1 => (0xb7fe4000)
libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7e77000)
/lib/ld-linux.so.2 (0xb7fe5000)

```

无论您尝试运行命令多少次，内存地址都是相同的。这表明您已关闭了 ASLR 产生的随机化。

## 了解缓冲区溢出的基础知识

假设`boverflow.c`编译正确，并且 ASLR 已关闭，我们现在可以执行我们有意使其易受攻击的程序：

```
# ./bovrflow 

```

您的输出应该如下：

```
Enter a long string:

```

在此提示符下，输入一个包含 21 个字符的序列，例如`AAAA`，然后按*Enter*：

```
Enter a long string:AAAAAAAAAAAAAAAAAAAAA
You entered: AAAAAAAAAAAAAAAAAAAAA

```

通过输入只有四个字符，程序执行了指令，并在显示您输入的字符后正常退出。现在让我们溢出缓冲区以分析结果。这次运行程序，但输入超过 21 个字符。

```
root@bt:~/overflow# ./bovrflow 

```

```
Enter a long string:AAAAAAAAAAAAAAAAAAAAAA
You entered: AAAAAAAAAAAAAAAAAAAAAA
Segmentation fault 

```

通过输入比缓冲区能处理的数据更多，我们生成了一个**分段错误**。这正是我们要寻找的。让我们看看这个程序在运行时内存空间发生了什么。在提示符下调用`gdb`调试器。

```
# gdb bovrflow 

```

```
GNU gdb (GDB) 7.1-ubuntu
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law. Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /root/overload/bovrflow...(no debugging symbols found)...done.
(gdb)

```

调试器将为我们提供有关`bovrflow`程序的详细内存信息。让我们看看在不溢出缓冲区的情况下从`gdb`中运行程序时会发生什么。我们在 gdb 提示符下键入*r*来**运行**程序：

```
(gdb) r 

```

```
Starting program: /root/bovrflow
Enter a long string:AAAAAA
You entered: AAAAAA
Program exited normally.
(gdb)

```

这里没有什么有趣的，但这个测试是一个很好的理智检查，以确保一切正常工作。现在我们需要看一下当我们引起分段错误时会发生什么：

```
(gdb) r 

```

```
Starting program: /root/bovrflow
Enter a long string:AAAAAAAAAAAAAAAAAAAAAA
You entered: AAAAAAAAAAAAAAAAAAAAAA
Program received signal SIGSEGV, Segmentation fault.
0xb7e8bb00 in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6

```

再次运行程序；但是这一次我们使用了一个包含 22 个字符的序列，并故意导致了一个分段错误。在审查结果时，显然有些不对劲。注意到对`SIGSEGV`，分段错误的引用。我们需要利用这个错误并利用明显的漏洞。不幸的是，在继续创建我们的 shellcode 之前，我们需要了解更多。毕竟，到目前为止，我们只知道我们可以使应用程序崩溃。为了进展，我们必须查看我们的寄存器地址，以进一步理解崩溃时内存空间发生了什么。在提示符下键入*i r*：

```
(gdb) i r 

```

```
eax 0x0 0
ecx 0xbffff4f8 -1073744648
edx 0xb7fcc360 -1208171680
ebx 0xb7fcaff4 -1208176652
esp 0xbffff540 0xbffff540
ebp 0x41414141 0x41414141
esi 0x0 0
edi 0x0 0
eip 0xb7e8bb00 0xb7e8bb00 <__libc_start_main+16>
eflags 0x10292 [ AF SF IF RF ]
cs 0x73 115
ss 0x7b 123
ds 0x7b 123
es 0x7b 123
fs 0x0 0
gs 0x33 51

```

我们可以在`ebp`处看到我们的输入为`0x41414141`。让我们再次运行程序，并添加几个 A，看看会发生什么。

### 注意

如果您不理解当我们看到`0x41414141`时我们在看什么，请在`google.com`上进行快速搜索，找到一个您喜欢的 ASCII 转换表，并打印出来。

```
(gdb) r 

```

按*r*在调试器中重新启动程序。

```
The program being debugged has been started already.
Start it from the beginning? (y or n) y

```

按*y*让调试器知道您想要完全重新启动。

```
Starting program: /root/overload/bovrflow
Enter a long string:AAAAAAAAAAAAAAAAAAAAAAAA

```

这次我们需要输入 24 个*A*并按*Enter*。 

```
You entered: AAAAAAAAAAAAAAAAAAAAAAAA
Program received signal SIGSEGV, Segmentation fault.
0xb7004141 in ?? ()

```

我们的分段错误现在返回了一些奇怪的东西...当我们之前只输入 12 个字符时，输出指示`0xb7e8bb00 in __libc_start_main ()`来自`/lib/tls/i686/cmov/libc.so.6`，但现在我们返回的是`0xb7004141 in ?? ()`。我们甚至可以看到一些我们的*A*现在出现了。再次查看我们的信息寄存器：

```
(gdb) info registers 

```

```
eax 0x0 0
ecx 0xbffff4f8 -1073744648
edx 0xb7fcc360 -1208171680
ebx 0xb7fcaff4 -1208176652
esp 0xbffff540 0xbffff540
ebp 0x41414141 0x41414141
esi 0x0 0
edi 0x0 0
eip 0xb7004141 0xb7004141
eflags 0x10292 [ AF SF IF RF ]
cs 0x73 115
ss 0x7b 123
ds 0x7b 123
es 0x7b 123
fs 0x0 0
gs 0x33 51

```

看一下`eip`。我们可以看到，使用 24 个字符时，地址为`0xb7004141`，而只有 12 个 A 时，我们看到的是`0xb7e8bb00`。这是重要的。我们需要尝试一件事情，使这一点变得显而易见。再次从调试器中运行程序。这次使用总共 26 个 A，并完全覆盖 EIP。

```
(gdb) r 

```

```
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/overload/bovrflow

```

```
Enter a long string:AAAAAAAAAAAAAAAAAAAAAAAAAA 

```

```
You entered: AAAAAAAAAAAAAAAAAAAAAAAAAA
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

```

```
(gdb) i r 

```

```
eax 0x0 0
ecx 0xbffff4f8 -1073744648
edx 0xb7fcc360 -1208171680
ebx 0xb7fcaff4 -1208176652
esp 0xbffff540 0xbffff540
ebp 0x41414141 0x41414141
esi 0x0 0
edi 0x0 0
eip 0x41414141 0x41414141
eflags 0x10292 [ AF SF IF RF ]
cs 0x73 115
ss 0x7b 123
ds 0x7b 123
es 0x7b 123
fs 0x0 0
gs 0x33 51

```

现在 EIP 完全被 A 覆盖了。我们已经演示了用户如何操纵堆栈。在下一节中，我们将审查并利用一个小样本程序。

### 注意

如果您想挑战自己，请进行额外的研究，并尝试通过利用`bovrflow`来获得 root shell 或打开 nano。

到目前为止，我们已经介绍了如何操纵堆栈的基本概念。高级攻击者将了解并利用这些漏洞，以便在可能的情况下利用这些漏洞。在许多情况下，您将没有时间完全检查每个应用程序是否存在缓冲区溢出等漏洞，但了解我们将在本章中进一步使用的攻击的基本原理是很好的。如果您发现自己可能会喜欢漏洞研究，我强烈建议您查看以下资源：

| **了解更多关于缓冲区溢出漏洞和更多的优秀资源：** |   |
| --- | --- |
| *Smashing The Stack For Fun And Profit* by Aleph One | [`insecure.org/stf/smashstack.html`](http://insecure.org/stf/smashstack.html) |
| *Mudge 的缓冲区溢出教程* | [`insecure.org/stf/mudge_buffer_overflow_tutorial.html`](http://insecure.org/stf/mudge_buffer_overflow_tutorial.html) |
| Corelan 团队的网站。这个团队很棒。查看他们的教程和论坛！ | [`www.corelan.be/`](http://www.corelan.be/) |
| "sickn3ss"的 IHASOMGSECURITYSKILLS 博客。令人印象深刻的写作，易于跟随。查看教程。 | [`sickness.tor.hu/`](http://sickness.tor.hu/) |

# 模糊测试简介

每当应用程序允许输入时，无论是直接来自用户（例如输入凭据、打开文件，甚至从更改 RAM 中的数据），都有可能利用输入来造成混乱。攻击者不会花费数小时或数天在用户名和密码提示或对一个不知名端口的连接上输入（好吧，有些人可能会！）。相反，他们将利用专注于这一任务的工具，欢迎来到模糊器的世界。

模糊器通常用于生成和输出数据；这些数据可以以各种方式进行操作和格式化，并且有已发布的算法可以帮助使工作变得更加容易。

### 注意

请记住**输入**是一个非常广泛的术语。在考虑被测试应用程序的每种输入方法时，请务必考虑每种输入向量。似乎微不足道的事情，如播放一首歌曲甚至读取文件名，都可能提供可能的攻击向量。

每当出现程序允许不受控制的输入的情况时，可能会有一个模糊器等待处理任务。让我们创建一个小程序，看看模糊器可能如何帮助找到应用程序中的漏洞或异常。我们将使用`strcpy()`函数中的一个众所周知且经常演示的漏洞。打开 BackTrack 实例并创建以下程序：

```
# nano fuzzme.c 
#include <stdio.h>
#include <string.h>
int main(int argc, char** argv)
{
bdcode(argv[1]);
return 0;
}
int bdcode(char *bdinput)
{
char stuff[200];
strcpy(stuff, bdinput);
printf("You passed the following data to fuzzme: %s\n",stuff);
return 0;
}

```

如前所述，我们正在创建一个场景，其中`stuff`字符缓冲区可以被超载。`int main(int argc, char** argv)`指示程序在调用文件之后并在按下*Enter*之前接受输入，并将其分配给`argv`，然后我们可以将其复制到`stuff`变量中。如果`stuff`无法包含所呈现的数据的数量或类型，将发生分段错误。

确保使用`-fno-stack-protector`参数进行编译。

```
# gcc -o fuzzme -fno-stack-protector fuzzme.c 

```

尝试在尝试和不尝试引起分段错误的情况下运行程序：

```
# ./fuzzme AAAAAAAAAA 

```

```
You passed the following data to fuzzme: AAAAAAAAAA

```

现在我们需要尝试足够的输入来导致崩溃：

```
root@bt:~# ./fuzzme AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

```

```
You passed the following data to fuzzme: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault

```

如预期的那样，在 208 个字符时，我们生成了一个有意的分段错误。现在假设您事先不知道这一点，可能需要数百或数千个字符才能使程序崩溃。这就是为什么我们希望使用模糊器来自动执行攻击。让我们使用 shell 脚本制作一个**非常**基本的概念验证：

```
# nano myfuzzr.sh 

```

```
# !/bin/bash
COUNTER=1
FUZZY=A
FUZZIER=A
echo "How many A's would you like to try?"
read COUNTER
while [ $COUNTER -ge 1 ]; do
let COUNTER=COUNTER-1
FUZZY="$FUZZY$FUZZIER"
echo `./fuzzme $FUZZY`
done

```

在这个简单的模糊器表示中，我们要求输入我们想要针对程序进行测试的 A 的数量。然后，我们运行一个循环，直到计数器再次降至 1。如果我们运行程序并选择 10，我们将收到以下输出：

```
# ./myfuzzr.sh 

```

```
How many A's would you like to try?

```

```
10

```

```
You passed the following data to fuzzme: AA
You passed the following data to fuzzme: AAA
You passed the following data to fuzzme: AAAA
You passed the following data to fuzzme: AAAAA
You passed the following data to fuzzme: AAAAAA
You passed the following data to fuzzme: AAAAAAA
You passed the following data to fuzzme: AAAAAAAA
You passed the following data to fuzzme: AAAAAAAAA
You passed the following data to fuzzme: AAAAAAAAAA

```

尝试看看当您选择 208 个 A 时会发生什么。该程序并不复杂，不会干净地退出。您也不会有任何指示器表明发生了什么，或者为什么 207 个之后的 A 没有显示。

### 注意

挑战自己修改这个简单的程序，或者用更合适的脚本语言或编程语言（如 Python 或 Ruby）重新创建它。

通过这些练习，模糊测试的基本概念应该是明显的。有一些专门致力于这个主题的书籍，因此我们只能浅尝辄止，模糊测试可能是真正艺术形式的表面。

# 介绍 vulnserver

在接下来的几个练习中，我们将使用 vulnserver（[`grey-corner.blogspot.com/2010/12/introducing-vulnserver.html`](http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html)）作为我们的目标。这个有意漏洞的应用程序是由 Stephen Bradshaw 创建的，旨在为自己和安全社区提供一个可以用来练习各种与安全相关的任务的应用程序。

理想情况下，该程序应在基于 Windows 的机器上运行；由于我们试图让这本书专注于开源和免费可用的程序，我们将在我们的 BackTrack 机器上运行服务器。这将足以了解 BackTrack 中提供的更多关于模糊测试工具的信息。

将 vulnserver 应用程序下载到您的 BackTrack 机器上，解压缩它，仔细查看许可证和 README 文件，并在再次断开 BackTrack 实例与互联网的连接后，使用以下命令启动`vulnserver.exe`：

```
# wine vulnserver.exe 4444 

```

```
Starting vulnserver version 1.00
Called essential function dll version 1.00
This is vulnerable software!
Do not allow access from untrusted systems or networks!
Waiting for client connections...

```

此命令将使用`wine`在端口 4444 上运行您的`vulnserver.exe`应用程序。要测试服务器是否正常工作，请打开一个终端会话，并使用`netcat`连接到服务器，如下所示：

```
# nc 127.0.0.1 4444 

```

您将看到 vulnserver 的介绍屏幕：

```
Welcome to Vulnerable Server! Enter HELP for help.

```

如提示所述，您可以输入 HELP 以获取有关可用输入的信息：

```
HELP 

```

```
Valid Commands:
HELP
STATS [stat_value]
RTIME [rtime_value]
LTIME [ltime_value]
SRUN [srun_value]
TRUN [trun_value]
GMON [gmon_value]
GDOG [gdog_value]
KSTET [kstet_value]
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

```

我们将使用预先安装在 BackTrack 5 R1 上的不同模糊测试工具向这些输入注入畸形、随机或变异的数据。要更熟悉服务器，随时随地随意探索。以下是一个有效输入的示例：

```
LTER AAAAAA 

```

```
LTER COMPLETE

```

该应用程序期望一个我们提供的输入，我们提供了 LTER AAAAAA。由于这个输入没有问题，应用程序会返回到正常状态。

### 注意

有关 vulnserver 应用程序的详细信息，请访问 Stephen Bradshaw 的博客。在那里，您还会发现它包含了与他的 vulnserver 应用程序相关的几个很棒的教程，这些教程写得很好，易于理解。

# BackTrack 中包含的模糊测试工具

幸运的是，对于典型的渗透测试人员来说，不需要花费数月甚至数年来准备完美的模糊测试工具。社区已经为我们提供了大量这些精彩的工具，与编写它们相比，它们的使用非常简单！

## Bruteforce Exploit Detector (BED)

**Bruteforce Exploit Detector (BED)**正如其名称所示。该程序将允许您向目标应用程序发送数据，希望会发生崩溃。尽管这种方法在某些情况下确实有效，但在尝试查找易受攻击的应用程序时，有时需要更多的控制。BackTrack 5 R1 在`/pentest/fuzzers/bed`预安装了 BED。BED 提供了在不修改的情况下模糊测试几种常用协议的能力。

```
/pentest/fuzzers/bed# ./bed.pl 

```

```
BED 0.5 by mjm ( www.codito.de ) & eric ( www.snake-basket.de )
Usage:
./bed.pl -s <plugin> -t <target> -p <port> -o <timeout> [ depends on the plugin ]
<plugin> = FTP/SMTP/POP/HTTP/IRC/IMAP/PJL/LPD/FINGER/SOCKS4/SOCKS5
<target> = Host to check (default: localhost)
<port> = Port to connect to (default: standard port)
<timeout> = seconds to wait after each test (default: 2 seconds)
use "./bed.pl -s <plugin>" to obtain the parameters you need for the plugin.
Only -s is a mandatory switch.

```

除了 Bruteforce Exploit Detector 的开发人员提供的插件之外，您还可以轻松创建自己的插件。查看`/pentest/fuzzers/bed/docs`目录中的`dummy.pm`文件。这个模板为您提供了一个可以根据我们的需求进行修改的模板。切换到`/pentesting/fuzzers/bed/bedmod`目录，并`cat`一些文件，比如`ftp.pm`，以更好地了解完全功能的插件是什么样子的。当您对格式感到满意时，在`bedmod`文件夹中创建一个新文件，并将其命名为`vserver.pm`。以下代码是使用`dummy.pm`示例模板创建的。将此代码输入到`vserver.pm`中：

```
package bedmod::vserver;
use Socket;
sub new{
my $this = {};
# define everything you might need
bless $this;
return $this;
}
sub init{
my $this = shift;
%special_cfg=@_;
$this->{proto} = "tcp";
if ($special_cfg{'p'} eq "") { $this->{port}='4444'; }
else { $this->{port} = $special_cfg{'p'}; }
$iaddr = inet_aton($this->{target}) || die "Unknown host: $host\n";
$paddr = sockaddr_in($this->{port}, $iaddr) || die "getprotobyname: $!\n";
$proto = getprotobyname('tcp') || die "getprotobyname: $!\n";
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) || die "socket: $!\n";
connect(SOCKET, $paddr) || die "connection attempt failed: $!\n";
send(SOCKET, "HELP", 0) || die "HELP request failed: $!\n";
$this->{vrfy} = "HELP\r\n";
}
sub getQuit{
return("EXIT\r\n");
}
# what to test without doing a login before
sub getLoginarray{
my $this = shift;
@login = ("");
return(@login);
}
# which commands does this protocol know ?
sub getCommandarray {
my $this = shift;
# the XAXAX will be replaced with the buffer overflow / format string data
# place every command in this array you want to test
@cmdArray = (
"XAXAX\r\n",
"STATS XAXAX\r\n",
"RTIME XAXAX\r\n",
"LTIME XAXAX\r\n",
"SRUN XAXAX\r\n",
"TRUN XAXAX\r\n",
"GMON XAXAX\r\n",
"GDOG XAXAX\r\n",
"KSTET XAXAX\r\n",
"GTER XAXAX\r\n",
"HTER XAXAX\r\n",
"LTER XAXAX\r\n",
"KSTAN XAXAX\r\n"
);
return(@cmdArray);
}
# How to respond to login prompt:
sub getLogin{ # login procedure
my $this = shift;
@login = ("HELP\r\n");
return(@login);
}
# Test anything else you would like to
sub testMisc{
return();
}
1;

```

乍一看，这段代码可能看起来很复杂。如果你看一下高亮显示的代码，你会看到我们特定插件的最重要的方面。我们已经指示 BED 向我们通过 HELP 命令提供的每个输入发送数据。默认端口设置为 4444，登录为空，因为对于这种类型的应用程序不需要。在我们可以使用`vserver.pm`插件之前还需要进行一些修改。打开`/pentest/fuzzers/bed/bed.pl`文件进行编辑，并在第 14 行的`@plugins`变量中添加`vserver`：

```
@plugins = ( "ftp", "smtp", "pop", "http", "irc", "imap", "pjl", "lpd", "finger", "socks4", "socks5", "vserver" );

```

保存你对`bed.pl`所做的更改并退出编辑器。假设你已经在 4444 端口上启动了`vulnserver.exe`，让我们尝试一下我们的新插件：

```
# ./bed.pl -s vserver -t 127.0.0.1 

```

```
BED 0.5 by mjm ( www.codito.de ) & eric ( www.snake-basket.de )
* Normal tests
+ Buffer overflow testing:
testing: 1 XAXAX ...........
testing: 2 STATS XAXAX ...........
testing: 3 RTIME XAXAX ...........
testing: 4 LTIME XAXAX ...........
testing: 5 SRUN XAXAX ...........
testing: 6 TRUN XAXAX ...........
testing: 7 GMON XAXAX ...........
testing: 8 GDOG XAXAX ...........
testing: 9 KSTET XAXAX ...

```

`Bed.pl`确实在做一些事情，但我们并没有确切地得到任何反馈。如果你等待足够长的时间，你会收到崩溃的通知。

![Bruteforce Exploit Detector (BED)](img/7744OS_06_01.jpg)

不幸的是，vulnserver 应用程序仍在接收连接，因此`bed.pl`将继续暴力破解过程。此外，此时我们不知道是什么导致了崩溃。当我们点击**关闭**时，我们会从 vulnserver 控制台获得一些调试信息，但在处理客户端修改或创建的应用程序时，这种行为并不总是可以预期的。通常情况下，为了避免给潜在攻击者提供过多信息，生产应用程序会禁用调试。

### 注意

我们没有编写任何会在`EXIT`命令启动后停止程序的语句（比如 GOODBYE）。因此，Bruteforce Exploit Detector 没有检测到问题！挑战自己，为你的插件添加这个功能！

让我们看一下从`stdout`提供使用反馈的终端：

```
Waiting for client connections...
Unhandled exception: page fault on read access to 0x41414141 in 32-bit code (0x41414141).
Register dump:
CS:0073 SS:007b DS:007b ES:007b FS:0033 GS:003b
EIP:41414141 ESP:00c0e4c0 EBP:41414141 EFLAGS:00210202( R- -- I - - - ) 
EAX:00c0e470 EBX:7bc9cff4 ECX:00000000 EDX:00000065
ESI:7ffccf10 EDI:00401848
Stack dump:
0x00c0e4c0: 41414141 41414141 41414141 41414141
0x00c0e4d0: 41414141 00000000 00000000 00000000
0x00c0e4e0: 00000000 00000000 00000000 00000000
0x00c0e4f0: 00000000 00000000 00000000 00000000
0x00c0e500: 00000000 00000000 00000000 0018ff48
0x00c0e510: 696c6156 6f432064 6e616d6d 0a3a7364
Backtrace:
0x41414141: -- no code accessible --
Modules:
Module Address Debug info Name (22 modules)
PE 400000- 407000 Deferred vulnserver
PE 62500000-62508000 Deferred essfunc
ELF 7b800000-7b97d000 Deferred kernel32<elf>
\-PE 7b810000-7b97d000 \ kernel32
ELF 7bc00000-7bcb9000 Deferred ntdll<elf>
\-PE 7bc10000-7bcb9000 \ ntdll
ELF 7bf00000-7bf04000 Deferred <wine-loader>
ELF 7ed60000-7ed7f000 Deferred libgcc_s.so.1
ELF 7ed90000-7edbd000 Deferred ws2_32<elf>
\-PE 7eda0000-7edbd000 \ ws2_32
ELF 7edbd000-7ee3f000 Deferred msvcrt<elf>
\-PE 7edd0000-7ee3f000 \ msvcrt
ELF 7ef9c000-7efa8000 Deferred libnss_files.so.2
ELF 7efa8000-7efb2000 Deferred libnss_nis.so.2
ELF 7efb2000-7efc9000 Deferred libnsl.so.1
ELF 7efc9000-7efef000 Deferred libm.so.6
ELF 7eff8000-7f000000 Deferred libnss_compat.so.2
ELF b7593000-b7597000 Deferred libdl.so.2
ELF b7597000-b76f1000 Deferred libc.so.6
ELF b76f2000-b770b000 Deferred libpthread.so.0
ELF b771c000-b785c000 Deferred libwine.so.1
ELF b785e000-b787b000 Deferred ld-linux.so.2
Threads:
process tid prio (all id:s are in hex)
0000000e services.exe
00000014 0
00000010 0
0000000f 0
00000011 winedevice.exe
00000018 0
00000017 0
00000013 0
00000012 0
00000074 (D) Z:\root\vulnserver.exe
0000004d 0
00000048 0 <==
00000076 0
00000075 0
0000004b explorer.exe
0000004c 0
Backtrace:
Send failed with error: 10054
Received a client connection from 127.0.0.1:41190
Waiting for client connections...

```

值得注意的是，EIP 已被覆盖为`41414141`。这是一个很好的指示，表明可能存在对这个堆栈溢出的利用。还要注意服务器输出表明正在发生连接请求。服务器并没有完全崩溃，只是这个连接。如果以后需要创建自己的利用，这可以为你带来好处。

既然我们知道应用程序存在问题，我们需要了解是什么导致了崩溃。通常情况下，你的模糊器会为你提供这些信息，但在这种情况下，`bed.pl`仍在继续运行。

```
# wireshark 

```

等到 Wireshark GUI 完全加载并选择捕获`lo`的选项（这将允许你观察本地流量）从屏幕中间。

![Bruteforce Exploit Detector (BED)](img/7744OS_06_02.jpg)

让我们重现错误，但这次我们将在**Wireshark**中观察数据包，因为它们穿过本地环回接口。重新启动`vulnserver`，然后再次使用`vserver`插件启动`bed.pl`。一切都开始后，切换到 Wireshark 并查看正在传递的数据包。你可以右键单击 Wireshark 中的任何消息，然后选择**跟踪 TCP 流**以查看消息的易于阅读的格式。

如果你等到崩溃发生，你可以在 Wireshark 中搜索看起来最明显导致崩溃的流。请记住，我们的代码中没有任何延迟，所以最后建立的连接不一定是导致错误发生的连接。在这种情况下，注意到在`vulnserver`控制台上，在崩溃发生之前最后建立的连接是：

```
Received a client connection from 127.0.0.1:41041 
Waiting for client connections...
wine: Unhandled page fault on read access to 0x41414141 at address 0x41414141 (thread 0048), starting debugger...

```

如果你去 Wireshark 并在**过滤器**菜单中输入`tcp.stream eq 41041`，你将只看到组成我们感兴趣的消息的数据包。选择其中一个被过滤的消息，右键单击它，然后查看 TCP 流。

![Bruteforce Exploit Detector (BED)](img/7744OS_06_03.jpg)

看起来最后一条发送到 vulnserver 的消息是：

```
KSTET AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

```

在不使用过滤器的情况下查看以前的消息，我们可以确定`KSTET`通常在成功接受输入后发送响应**(KSTET** `SUCCESSFUL)`：

```
EXIT
KSTET AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
HELP
EXIT
KSTET SUCCESSFUL

```

我们可以测试这个输入，看看我们是否可以手动复制错误。停止并重新启动 vulnserver，然后手动`netcat`到`127.0.0.1`端口 4444。

```
# nc 127.0.0.1 4444 

```

```
Welcome to Vulnerable Server! Enter HELP for help.

```

```
KSTET AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

```

```
KSTET SUCCESSFUL

```

```
KSTET AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

```

此时应用程序将崩溃，并且**Program Error**弹出窗口将再次出现。单击**Program Error**窗口中的**Close**。再次可以从调试器的输出中查看，并注意 EIP（当前正在处理的指令）已被 41414141 覆盖。

### 提示

在尝试确保正在测试的环境的安全姿态时，我们应该寻找这种可重复的错误。根据测试的范围，此时业务可能只需要潜在漏洞的详细信息。如果范围允许，可以创建一个应用程序的利用来证明漏洞可能导致重要数据、资产或收入的损失。

## SFUZZ：简单模糊器

由 Aaron Conole 创建的简单模糊器 SFUZZ 是一个很好的工具，如果你想认真开始进行模糊化业务。对于那些还没有准备好花时间来学习如何充分使用 SPIKE 的人来说，SFUZZ 是强大且有用的。此外，有时使用更小、更简单的工具更有效率。

如果您仍在学习利用开发，那么 SFUZZ 将成为一个很好的垫脚石，并且在未来的几年中肯定会继续成为您渗透测试知识库中的宝贵补充；有时，拥有快速且易于配置的工具非常方便！

浏览到`/pentest/fuzzers/sfuzz`目录，并熟悉目录结构。如果没有参数调用 sfuzz，您将看到可用的启动开关：

```
/pentest/fuzzers/sfuzz# ./sfuzz 

```

```
[23:11:45] error: must specify an output type.
Simple Fuzzer
By: Aaron Conole
version: 0.6.4
url: http://aconole.brad-x.com/programs/sfuzz.html
EMAIL: apconole@yahoo.com
Build-prefix: /usr/local
-h This message.
-V Version information.
networking / output:
-v Verbose output
-q Silent output mode (generally for CLI fuzzing)
-X prints the output in hex
-b Begin fuzzing at the test specified.
-e End testing on failure.
-t Wait time for reading the socket
-S Remote host
-p Port
-T|-U|-O TCP|UDP|Output mode
-R Refrain from closing connections (ie: "leak" them)
-f Config File
-L Log file
-n Create a new logfile after each fuzz
-r Trim the tailing newline
-D Define a symbol and value (X=y).
-l Only perform literal fuzzing
-s Only perform sequence fuzzing

```

虽然有示例脚本可用，但如果我们想要能够模糊化 vulnserver 应用程序，我们需要创建自己的脚本。在`sfuzz-sample`目录中创建以下名为`basic.verserver`的脚本：

```
include basic-fuzz-strings.list
reqwait=800
maxseqlen=2010
endcfg
KSTET FUZZ
--
FUZZ
--
LHLO FUZZ
--

```

在这个脚本中，我们指示 sfuzz 在执行模糊化活动时使用`basic-fuzz-strings.list`。然后我们添加了 200 毫秒的延迟，并将序列长度限制为 2010。这个模糊器非常简单，然后列出要发送的命令，然后是由应用程序用模糊输出替换的 FUZZ 变量。我们必须保存文件，确保 vulnserver 正在 4444 端口上运行，然后继续启动 sfuzz 脚本：

```
# ./sfuzz -e -S 127.0.0.1 -p 4444 -TO -f /sfuzz-sample/basic.vserver 

```

这将启动模糊化过程，并让您看到正在传递的数据。可以使用一种技术进行非常快速的扫描，以查看是否发生任何崩溃，然后使用更精细的参数再次运行扫描，并以较慢的速度进行。这将确保异常很容易被捕获。

正如预期的那样，我们的模糊器脚本能够使用以下输出使 vulnserver 崩溃：

```
==============================================================
[23:58:30] attempting fuzz - 31.
KSTET AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[23:58:30] info: tx fuzz - (2017 bytes) - scanning for reply.
[23:58:31] read:
Welcome to Vulnerable Server! Enter HELP for help.

```

再次，测试没有捕捉到失败，sfuzz 继续向应用程序发送数据。

### 注意

还记得我们在本章前面编写的可利用程序"fuzzme"吗？挑战自己使用 sfuzz 来模糊化 fuzzme 程序！提示：使用`basic.cmd`作为编写脚本的指南。

正如先前所述，模糊化的艺术可能非常有用，但掌握它需要专注和持续的练习。

# Fast-Track

渗透测试通常受到特定时间范围的限制。这是许多渗透测试人员的主要抱怨，因为毕竟，野外的攻击者根本不受这些业务强加的时间范围的限制。幸运的是，我们可以依靠诸如 Metasploit、SET 或 Fast-Track 之类的工具，尽快地扩大范围。Fast-Track 是由 David Kennedy（又名 ReL1K）和 Joey Furr（又名 j0fer）开发的，用于自动化渗透测试人员经常需要执行的许多攻击。

Fast-Track 是一个菜单驱动且设计精美的工具，它使您能够快速执行诸如生成有效负载、快速设置客户端攻击，甚至将有效负载从二进制转换为十六进制等任务。

### 注意

Fast-Track 可以通过命令行(-c)、浏览器 GUI(-g)或交互式菜单驱动控制台(-i)使用，只需在调用程序时添加适当的参数。与任何渗透测试工具一样，请在使用 Fast-Track 之前阅读许可文件和警告。渗透测试工具应该只用于您有适当和合法权限进行测试的系统。

我们将只使用这个强大工具的一部分，但了解其所有功能对于任何渗透测试人员来说都是一个有价值的补充。

Fast-Track 可以在 BackTrack 5 R1 的`/pentesting/exploits/fastrack`中找到。要以 Web GUI 模式启动程序，只需键入：

```
# ./fast-track.py -g 

```

```
----------------------------------------------------------------
Fast-Track - A new beginning...
Automated Penetration Testing
Written by David Kennedy (ReL1K)
Please read the README and LICENSE before using
this tool for acceptable use and modifications.
-------------------------------------------------------------
Modes:
Interactive Menu Driven Mode: -i
Command Line Mode: -c
Web GUI Mode -g
Examples: ./fast-track.py -i
./fast-track.py -c
./fast-track.py -g
./fast-track.py -g <portnum>
Usage: ./fast-track.py <mode>
***********************************************
******* Performing dependency checks... *******
***********************************************
*** FreeTDS and PYMMSQL are installed. (Check) ***
*** PExpect is installed. (Check) ***
*** ClientForm is installed. (Check) ***
*** Psyco is installed. (Check) ***
*** Beautiful Soup is installed. (Check) ***
Also ensure ProFTP, WinEXE, and SQLite3 is installed from
the Updates/Installation menu.
Your system has all requirements needed to run Fast-Track!
****************************************
Fast-Track Web GUI Front-End
Written by: David Kennedy (ReL1K)
****************************************
Starting HTTP Server on 127.0.0.1 port 44444
*** Open a browser and go to http://127.0.0.1:44444 ***
Type <control>-c to exit..

```

此命令已启动了由 David Kennedy 编写的 Fast-Track Web GUI。打开 Firefox 并浏览到`http://127.0.0.1:44444`，如指示。

侧边栏菜单包括我们在使用菜单驱动用户界面时将要讨论的许多选项。浏览菜单并熟悉应用程序。

### 注意

除非您完全了解自己在做什么，BackTrack 机器被分割并且不在互联网或生产环境中，否则不要发动任何攻击。

退出浏览器并取消 Fast-Track。在命令行中键入以下内容以打开菜单驱动的 Fast-Track 界面：

```
# ./fast-track.py -i 

```

```
***********************************************
******* Performing dependency checks... *******
***********************************************
*** FreeTDS and PYMMSQL are installed. (Check) ***
*** PExpect is installed. (Check) ***
*** ClientForm is installed. (Check) ***
*** Psyco is installed. (Check) ***
*** Beautiful Soup is installed. (Check) ***
Also ensure ProFTP, WinEXE, and SQLite3 is installed from
the Updates/Installation menu.
Your system has all requirements needed to run Fast-Track!
[---] [---]
[---] Fast Track: A new beginning [---]
[---] Written by: David Kennedy (ReL1K) [---]
[---] Lead Developer: Joey Furr (j0fer) [---]
[---] Version: 4.0.1 [---]
[---] Homepage: http://www.secmaniac.com [---]
[---] [---]
Fast-Track Main Menu:
1\. Fast-Track Updates
2\. Autopwn Automation
3\. Nmap Scripting Engine
4\. Microsoft SQL Tools
5\. Mass Client-Side Attack
6\. Exploits
7\. Binary to Hex Payload Converter
8\. Payload Generator
9\. Fast-Track Tutorials
10\. Fast-Track Changelog
11\. Fast-Track Credits
12\. Exit Fast-Track
Enter the number:

```

## 更新 Fast-Track

与任何其他工具一样，我们在开始之前应该更新所有内容。键入*1*选择 Fast-Track 更新，然后按*Enter*：

```
Enter the number: 1 

```

```
Fast-Track Update Menu:
1\. Update Fast-Track
2\. Metasploit 3 Update
3\. Update Exploit-DB Exploits
4\. Update Gerix Wifi Cracker NG
5\. Update Social-Engineer Toolkt
(q)uit
Enter number:

```

按顺序使用 1-3 从 1 到 3 选择更新 Fast-Track、Metasploit 3 更新和 Exploit-DB 漏洞。更新完成后，使用*q*退出返回到主菜单。

## 使用 Fast-Track 进行客户端攻击

Fast-Track 包括一个选项，可以设置一个网页，利用客户端机器易受攻击的任何已知漏洞。除了让某人访问您的机器之外，所有工作都已经完成。如果您的测试范围包括网络钓鱼，您可以在电子邮件中制作特定消息，并让用户点击链接返回 Fast-Track 为您设置的页面。

从菜单中选择选项**5. 大规模客户端攻击**，然后按*Enter*。

您需要输入要监听的 IP 地址。我正在使用的 BackTrack 机器在`VLAN1`上监听`192.168.1.205`。您需要知道您的 IP 地址是什么，并在此处输入。

```
Enter the IP Address to listen on: 192.168.1.205 

```

在提示输入要使用的有效负载时，选择**2. 通用绑定 Shell**，然后按*Enter*。

键入`no`来 ARP 欺骗主机。除非您知道自己在做什么并完全了解 ARP 欺骗及其固有风险，否则不建议使用此选项。如果您在分割的实验室环境中，看到这个功能是令人难以置信的，所以您一定要深入了解它！

您将看到一个新的弹出命令提示符，类似于以下内容：

![使用 Fast-Track 进行客户端攻击](img/7744OS_06_04.jpg)

现在任何连接到该服务器的系统都将遇到以下网页：

![使用 Fast-Track 进行客户端攻击](img/7744OS_06_05.jpg)

如果连接到这个网站的系统容易受到 Fast-Track 尝试的任何漏洞的影响，您将看到一个通用绑定 Shell。

### 提示

我们将在后期利用章节中重新讨论这个功能，在那里我们将充分利用一个单元，并跟进后期利用阶段。在这一点上，最重要的是要了解不仅对渗透测试人员，而且对公众来说可用的工具类型。如果您正在测试的企业容易受到 Mass Client Attack Web Server 针对的漏洞的影响，那么受影响的系统尽快更新和加固是非常重要的。

Fast-Track 中的选项都有很好的文档，网络功能提供了这个工具的很好的演练。使用您的实验室尝试一些漏洞利用，特别是如果您有 Windows XP 许可证。

# 社会工程工具包

社会工程工具包（SET）是由 David Kennedy [ReL1K]和 SET 开发团队 JR DePre [pr1me]，Joey Furr [j0fer]和 Thomas Werth 创建的。该工具包提供了各种各样的攻击方式，对于那些认真进行渗透测试的人来说，这是一个绝对“必备品”。我们只会对社会工程工具包进行简要介绍。SET 使用简单，SET 开发团队已经创建了出色的文档，可以在[`www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)`](http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET))免费获取。

SET 已经预装在 BackTrack 上，并且可以在命令行中调用：

```
/pentest/exploits/set# ./set 

```

### 注意

在您使用软件之前，您必须阅读并接受 BSD 许可协议，并且您不会将此工具用于任何非法行为。此协议也涵盖了任何将来的使用，一旦接受了，您将不会再次被提示，只需按*Y(es)*。

![社会工程工具包](img/7744OS_06_06.jpg)

更新框架后（记得在升级后再次断开与互联网的连接！），选择**1)社会工程攻击**以获得可以执行的可能攻击的列表：

```
Select from the menu:
1) Spear-Phishing Attack Vectors
2) Website Attack Vectors
3) Infectious Media Generator
4) Create a Payload and Listener
5) Mass Mailer Attack
6) Arduino-Based Attack Vector
7) SMS Spoofing Attack Vector
8) Wireless Access Point Attack Vector
9) Third Party Modules
99) Return back to the main menu.

```

我们将从网站向量开始。输入*2*以进入下一个菜单。在这个例子中，我们将查看列表上的第一个选项。

```
1) Java Applet Attack Method 
2) Metasploit Browser Exploit Method
3) Credential Harvester Attack Method
4) Tabnabbing Attack Method
5) Man Left in the Middle Attack Method
6) Web Jacking Attack Method
7) Multi-Attack Web Method
8) Victim Web Profiler
9) Create or import a CodeSigning Certificate
99) Return to Main Menu

```

下一个菜单提供了三个选项。在这个例子中，我们将使用其中一个提供的模板：

```
[TRUNCATED…]
1) Web Templates
2) Site Cloner
3) Custom Import
99) Return to Webattack Menu
set:webattack>1 

```

在下一个菜单中，选择**1\.需要 Java**作为您的模板。

```
1\. Java Required
2\. Gmail
3\. Google
4\. Facebook
5\. Twitter

```

```
set:webattack> Select a template:1 

```

当被问及要使用哪种有效载荷时，请仔细查看选项，并选择选项 3，即反向 TCP VNC 服务器。

![社会工程工具包](img/7744OS_06_07.jpg)

我们将选择 Backdoored 可执行文件作为我们的有效载荷。开发团队为每种编码器类型提供了评级。有时您可能需要尝试不同类型，直到找到适合您测试需求的类型。这些编码器将帮助您绕过主机上存在的防病毒软件。

防病毒软件通常是基于签名的，因此如果您能够改变文件的签名，防病毒保护将无法检测到您的有效载荷。

![社会工程工具包](img/7744OS_06_08.jpg)

选择默认的监听端口 443 并按*Enter*继续。就是这样！现在您所要做的就是等待有人连接到您的 Web 服务器。如果您有一个可用的 Windows 机器并浏览到该网站，您将看到以下网站：

![社会工程工具包](img/7744OS_06_09.jpg)

我们将在后期利用章节中重新讨论这个练习，我们将充分利用目标系统并从中控制网络。

# 摘要

客户端攻击通常是进入受保护环境的最简单方法。我们知道，通过巧妙地利用不同的攻击向量，攻击者能够利用用户的经验不足或善良来访问客户端计算机。开发人员通常无法在规定的时间内检查其程序的每个可能的缺陷，因此许多这些漏洞都未被质量保证团队和开发人员发现。

在这一章中，我们不仅有机会了解缓冲区溢出漏洞，而且实际上创建了我们自己的易受攻击的应用程序。然后，我们利用了这个漏洞，使用手动技术以及自动模糊测试工具，如 sfuzz 和 bed。我们学会了如何创建我们自己的模块，以及如何修改现有的模块以适应我们的特定需求。

此外，我们讨论了 Fast-Track 和社会工程工具包，并演示了在 Fast-Track 中设置大规模网络攻击和在 SET 中进行 Java 小程序攻击的步骤。利用这些演示中获得的知识，您应该能够在家庭实验室中审查和测试其他选项，直到您能够在生产测试环境中熟练使用这些工具。在审查 SET 时，我们还涉及了防病毒和重新打包我们的有效负载。在未来的章节中，我们将重新审视这些工具，完全利用并控制受控网络环境。

在下一章中，我们将学习定位和收集受损主机信息所需的步骤。这个阶段包括学习执行后期利用所需的最常用命令，以及提升特权和向受损机器添加持久访问权限等步骤。
