["```py\nnmap -sS -vvv -Pn -sV<targetIP>\n\n```", "```py\nwget http://www2.census.gov/topics/genealogy/2000surnames/Top1000.xls\n\n```", "```py\n#!/usr/bin/env python\nimport sys, string, arparse, os\nfrom collections import namedtuple\ntry:\n    import xlrd\nexcept:\n    sys.exit(\"[!] Please install the xlrd library: pip install xlrd\")\n```", "```py\ndefcensus_parser(filename, verbose):\n    # Create the named tuple\n    CensusTuple = namedtuple('Census', 'name, rank, count, prop100k, cum_prop100k, pctwhite, pctblack, pctapi, pctaian, pct2prace, pcthispanic')\n```", "```py\n    worksheet_name = \"top1000\"\n    #Define work book and work sheet variables\n    workbook = xlrd.open_workbook(filename)\n    spreadsheet = workbook.sheet_by_name(worksheet_name)\n    total_rows = spreadsheet.nrows - 1\n    current_row = -1\n```", "```py\n    # Define holder for details\n    username_dict = {}\n    surname_dict = {}\n    alphabet = list(string.ascii_lowercase)\n```", "```py\n    while current_row<total_rows:\n        row = spreadsheet.row(current_row)\n        current_row += 1\n        entry = CensusTuple(*tuple(row)) #Passing the values of the row as a tuple into the namedtuple\n        surname_dict[entry.rank] = entry\n        cellname = entry.name\n        cellrank = entry.rank\n        for letter in alphabet:\n            if \".\" not in str(cellrank.value):\n                if verbose > 1:\n                    print(\"[-] Eliminating table headers\")\n                break\n            username = letter + str(cellname.value.lower())\n            rank = str(cellrank.value)\n            username_dict[username] = rank\n```", "```py\n    username_list = sorted(username_dict, key=lambda key: username_dict[key])\n    return(surname_dict, username_dict, username_list)\n```", "```py\nfor item in liste_sort:\n    if not noted.count(item):\n        noted.append(item)\n```", "```py\ndefunique_list(list_sort, verbose):\n    noted = []\n    if verbose > 0:\n        print(\"[*] Removing duplicates while maintaining order\")\n    [noted.append(item) for item in list_sort if not noted.count(item)] # List comprehension\n    return noted\n```", "```py\ndefusername_file_parser(prepend_file, append_file, verbose):\n    if prepend_file:\n        put_where = \"begin\"\n        filename = prepend_file\n    elif append_file:\n        put_where = \"end\"\n        filename = append_file\n    else:\n        sys.exit(\"[!] There was an error in processing the supplemental username list!\")\n    with open(filename) as file:\n        lines = [line.rstrip('\\n') for line in file]\n    if verbose > 1:\n        if \"end\" in put_where:\n            print(\"[*] Appending %d entries to the username list\") % (len(lines))\n        else:\n            print(\"[*] Prepending %d entries to the username list\") % (len(lines))\n    return(lines, put_where)\n```", "```py\ndefcombine_usernames(supplemental_list, put_where, username_list, verbose):\n    if \"begin\" in put_where:\n        username_list[:0] = supplemental_list #Prepend with a slice\n    if \"end\" in put_where:\n    username_list.extend(supplemental_list)\n    username_list = unique_list(username_list, verbose)\n    return(username_list)\n```", "```py\ndefwrite_username_file(username_list, filename, domain, verbose):\n    open(filename, 'w').close() #Delete contents of file name\n    if domain:\n        domain_filename = filename + \"_\" + domain\n        email_list = []\n        open(domain_filename, 'w').close()\n    if verbose > 1:\n        print(\"[*] Writing to %s\") % (filename)\n    with open(filename, 'w') as file:\n         file.write('\\n'.join(username_list))\n    if domain:\n        if verbose > 1:\n            print(\"[*] Writing domain supported list to %s\") % (domain_filename)\n        for line in username_list:\n            email_address = line + \"@\" + domain\n            email_list.append(email_address)\n        with open(domain_filename, 'w') as file:\n            file.write('\\n'.join(email_list))\n    return\n```", "```py\nparser.add_argument(\"-c\", \"--census\", type=str, help=\"The census file that will be used to create usernames, this can be retrieved like so:\\n wget http://www2.census.gov/topics/genealogy/2000surnames/Top1000.xls\", action=\"store\", dest=\"census_file\")\n```", "```py\nif __name__ == '__main__':\n    # If script is executed at the CLI\n    usage = '''usage: %(prog)s [-c census.xlsx] [-f output_filename] [-a append_filename] [-p prepend_filename] [-ddomain_name] -q -v -vv -vvv'''\n    parser = argparse.ArgumentParser(usage=usage)\n```", "```py\n    parser.add_argument(\"-c\", \"--census\", type=str, help=\"The census file that will be used to create usernames, this can be retrieved like so:\\n wget http://www2.census.gov/topics/genealogy/2000surnames/Top1000.xls\", action=\"store\", dest=\"census_file\")\n    parser.add_argument(\"-f\", \"--filename\", type=str, help=\"Filename for output the usernames\", action=\"store\", dest=\"filename\")\n    parser.add_argument(\"-a\",\"--append\", type=str, action=\"store\", help=\"A username list to append to the list generated from the census\", dest=\"append_file\")\n    parser.add_argument(\"-p\",\"--prepend\", type=str, action=\"store\", help=\"A username list to prepend to the list generated from the census\", dest=\"prepend_file\")\n    parser.add_argument(\"-d\",\"--domain\", type=str, action=\"store\", help=\"The domain to append to usernames\", dest=\"domain_name\")\n    parser.add_argument(\"-v\", action=\"count\", dest=\"verbose\", default=1, help=\"Verbosity level, defaults to one, this outputs each command and result\")\n    parser.add_argument(\"-q\", action=\"store_const\", dest=\"verbose\", const=0, help=\"Sets the results to be quiet\")\n    parser.add_argument('--version', action='version', version='%(prog)s 0.42b')\n    args = parser.parse_args()\n```", "```py\n    # Set Constructors\n    census_file = args.census_file   # Census\n    filename = args.filename         # Filename for outputs\n    verbose = args.verbose           # Verbosity level\n    append_file = args.append_file   # Filename for the appending usernames to the output file\n    prepend_file = args.prepend_file # Filename to prepend to the usernames to the output file\n    domain_name = args.domain_name   # The name of the domain to be appended to the username list\n    dir = os.getcwd()                # Get current working directory\n    # Argument Validator\n    if len(sys.argv)==1:\n        parser.print_help()\n        sys.exit(1)\n  if append_file and prepend_file:\n      sys.exit(\"[!] Please select either prepend or append for a file not both\")\n```", "```py\n    if not filename:\n        if os.name != \"nt\":\n             filename = dir + \"/census_username_list\"\n        else:\n             filename = dir + \"\\\\census_username_list\"\n    else:\n        if filename:\n            if \"\\\\\" or \"/\" in filename:\n                if verbose > 1:\n                    print(\"[*] Using filename: %s\") % (filename)\n        else:\n            if os.name != \"nt\":\n                filename = dir + \"/\" + filename\n            else:\n                filename = dir + \"\\\\\" + filename\n                if verbose > 1:\n                    print(\"[*] Using filename: %s\") % (filename)\n```", "```py\n    # Define working variables\n    sur_dict = {}\n    user_dict = {}\n    user_list = []\n    sup_username = []\n    target = []\n    combined_users = []\n```", "```py\n    # Process census file\n    if not census_file:\n        sys.exit(\"[!] You did not provide a census file!\")\n    else:\n        sur_dict, user_dict, user_list = census_parser(census_file, verbose)\n    # Process supplemental username file\n    if append_file or prepend_file:\n        sup_username, target = username_file_parser(prepend_file, append_file, verbose)\n        combined_users = combine_usernames(sup_username, target, user_list, verbose)\n    else:\n        combined_users = user_list\n    write_username_file(combined_users, filename, domain_name, verbose)\n```", "```py\n#/usr/bin/env python\nimport socket, time, argparse, os, sys\n```", "```py\ndefread_file(filename):\n    with open(filename) as file:\n        lines = file.read().splitlines()\n    return lines\n```", "```py\ndefwrite_username_file(username_list, filename, verbose):\n    open(filename, 'w').close() #Delete contents of file name\n    if verbose > 1:\n        print(\"[*] Writing to %s\") % (filename)\n    with open(filename, 'w') as file:\n        file.write('\\n'.join(username_list))\n    return\n```", "```py\ndefverify_smtp(verbose, filename, ip, timeout_value, sleep_value, port=25):\n    if port is None:\n        port=int(25)\n    elif port is \"\":\n        port=int(25)\n    else:\n        port=int(port)\n    if verbose > 0:\n        print \"[*] Connecting to %s on port %s to execute the test\" % (ip, port)\n    valid_users=[]\n    username_list = read_file(filename)\n```", "```py\n    for user in username_list:\n        try:\n            sys.stdout.flush()\n            s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(timeout_value)\n            connect=s.connect((ip,port))\n            banner=s.recv(1024)\n            if verbose > 0:\n                print(\"[*] The system banner is: '%s'\") % (str(banner))\n            command='VRFY ' + user + '\\n'\n            if verbose > 0:\n                print(\"[*] Executing: %s\") % (command)\n                print(\"[*] Testing entry %s of %s\") % (str(username_list.index(user)),str( len(username_list)))\n            s.send(command)\n            result=s.recv(1024)\n            if \"252\" in result:\n                valid_users.append(user)\n                if verbose > 1:\n                    print(\"[+] Username %s is valid\") % (user)\n            if \"550\" in result:\n                if verbose > 1:\n                    print \"[-] 550 Username does not exist\"\n            if \"503\" in result:\n                print(\"[!] The server requires authentication\")\n                break\n            if \"500\" in result:\n                print(\"[!] The VRFY command is not supported\")\n                break\n```", "```py\n        except IOError as e:\n            if verbose > 1:\n                print(\"[!] The following error occured: '%s'\") % (str(e))\n            if 'Operation now in progress' in e:\n                print(\"[!] The connection to SMTP failed\")\n                break\n        finally:\n            if valid_users and verbose > 0:\n                print(\"[+] %d User(s) are Valid\" % (len(valid_users)))\n            elif verbose > 0 and not valid_users:\n                print(\"[!] No valid users were found\")\n            s.close()\n            if sleep_value is not 0:\n                time.sleep(sleep_value)\n            sys.stdout.flush()\n    return valid_users\n```", "```py\nif __name__ == '__main__':\n    # If script is executed at the CLI\n    usage = '''usage: %(prog)s [-u username_file] [-f output_filename] [-iip address] [-p port_number] [-t timeout] [-s sleep] -q -v -vv -vvv'''\n    parser = argparse.ArgumentParser(usage=usage)\n    parser.add_argument(\"-u\", \"--usernames\", type=str, help=\"The usernames that are to be read\", action=\"store\", dest=\"username_file\")\n    parser.add_argument(\"-f\", \"--filename\", type=str, help=\"Filename for output the confirmed usernames\", action=\"store\", dest=\"filename\")\n    parser.add_argument(\"-i\", \"--ip\", type=str, help=\"The IP address of the target system\", action=\"store\", dest=\"ip\")\n    parser.add_argument(\"-p\",\"--port\", type=int, default=25, action=\"store\", help=\"The port of the target system's SMTP service\", dest=\"port\")\n    parser.add_argument(\"-t\",\"--timeout\", type=float, default=1, action=\"store\", help=\"The timeout value for service responses in seconds\", dest=\"timeout_value\")\n    parser.add_argument(\"-s\",\"--sleep\", type=float, default=0.0, action=\"store\", help=\"The wait time between each request in seconds\", dest=\"sleep_value\")\n    parser.add_argument(\"-v\", action=\"count\", dest=\"verbose\", default=1, help=\"Verbosity level, defaults to one, this outputs each command and result\")\n    parser.add_argument(\"-q\", action=\"store_const\", dest=\"verbose\", const=0, help=\"Sets the results to be quiet\")\n    parser.add_argument('--version', action='version', version='%(prog)s 0.42b')\nargs = parser.parse_args()\n    # Set Constructors\n    username_file = args.username_file   # Usernames to test\n    filename = args.filename             # Filename for outputs\n    verbose = args.verbose               # Verbosity level\n    ip = args.ip                         # IP Address to test\n    port = args.port                     # Port for the service to test\n    timeout_value = args.timeout_value   # Timeout value for service connections\n    sleep_value = args.sleep_value       # Sleep value between requests\n    dir = os.getcwd()                    # Get current working directory\n    username_list =[]  \n    # Argument Validator\n    if len(sys.argv)==1:\n        parser.print_help()\n        sys.exit(1)\n    if not filename:\n        if os.name != \"nt\":\n            filename = dir + \"/confirmed_username_list\"\n        else:\n             filename = dir + \"\\\\confirmed_username_list\"\n    else:\n        if filename:\n            if \"\\\\\" or \"/\" in filename:\n                if verbose > 1:\n                    print(\" [*] Using filename: %s\") % (filename)\n        else:\n            if os.name != \"nt\":\n                filename = dir + \"/\" + filename\n            else:\n                filename = dir + \"\\\\\" + filename\n                if verbose > 1:\n                    print(\"[*] Using filename: %s\") % (filename)\n```", "```py\nusername_list = verify_smtp(verbose, username_file, ip, timeout_value, sleep_value, port)\nif len(username_list) > 0:\n    write_username_file(username_list, filename, verbose)\n```"]