- en: Chapter 4. Executing Credential Attacks with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Python执行凭证攻击
- en: There are multiple forms of credential attack, but all too often, they are considered
    as the last step in a penetration test, when all else has failed. This is because
    most new assessors approach it in the wrong manner. When discussing what brand
    new assessors use for credential attacks, the two most common attacks used are
    online dictionary and brute force attacks. They execute a credential attack by
    downloading a giant word list containing passwords and an extensive username list
    and run it against an interface. When the attack fails, the assessor follows up
    and executes a brute force attack.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证攻击有多种形式，但往往被认为是渗透测试的最后一步，当其他方法都失败时。这是因为大多数新的评估者以错误的方式对待它。在讨论新评估者用于凭证攻击的工具时，最常用的两种攻击是在线字典和暴力攻击。他们通过下载包含密码和大量用户名列表的巨大字典，并针对接口运行它。当攻击失败时，评估者会进行暴力攻击。
- en: This attack uses either the same username list or the super user (root) or the
    local administrator account. The majority of the time this will fail as well,
    so in the end dictionary attacks get a bad rap and get moved to the end of the
    engagement. This is ever so wrong, as on most engagements, especially on Internet
    facing postures a credential attack is going to get you access if done right.
    [Chapter 1](ch01.html "Chapter 1. Understanding the Penetration Testing Methodology"),
    *Understanding the Penetration Testing Methodology* and [Chapter 3](ch03.html
    "Chapter 3. Identifying Targets with Nmap, Scapy, and Python"), *Identifying Targets
    with Nmap, Scapy, and Python* introduced you to do some basic dictionary attack
    concepts, this chapter will build on them, and help you understand how and when
    to use them. Before we get started with how you execute these attacks, you need
    to have a firm understanding of the attack types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击要么使用相同的用户名列表，要么使用超级用户（root）或本地管理员帐户。大多数情况下，这也会失败，因此字典攻击最终会被认为是不好的，并被移到参与过程的最后。这是非常错误的，因为在大多数参与过程中，特别是在面向互联网的姿态上，如果正确执行凭证攻击，您将获得访问权限。[第1章](ch01.html
    "第1章。理解渗透测试方法论")，*理解渗透测试方法论*和[第3章](ch03.html "第3章。使用Nmap、Scapy和Python识别目标")，*使用Nmap、Scapy和Python识别目标*向您介绍了一些基本的字典攻击概念，本章将在此基础上进行深入，并帮助您了解如何以及何时使用它们。在开始执行这些攻击之前，您需要对攻击类型有一个牢固的理解。
- en: The types of credential attacks
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凭证攻击的类型
- en: When discussing credential attacks, there is an instant gravitation to password
    attacks. Remember authentication and authorization to a resource usually requires
    two components, the password and the username. Having the most well used password
    in the entire world does you no good, if you do not know the username it belongs
    to. As such, credential attacks are the manner we assess resources using both
    usernames and passwords. Targeted sourcing of usernames will be covered later,
    but for now we have to define the overarching types of password attacks, online
    and offline.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论凭证攻击时，人们很容易就会想到密码攻击。请记住，对资源的认证和授权通常需要两个组件，即密码和用户名。如果您不知道密码所属的用户名，即使您拥有全世界最常用的密码也没有用。因此，凭证攻击是我们使用用户名和密码来评估资源的方式。有针对性地获取用户名的方法将在后面介绍，但现在我们必须定义密码攻击的总体类型，即在线和离线。
- en: Defining the online credential attack
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义在线凭证攻击
- en: The online credential attack is what is done when you are targeting interfaces
    or resources to forcefully authenticate. What this means is you may not know the
    username, password, or both and are trying to determine the correct information
    that will grant you access. These attacks are executed when you have not gained
    access to a resource that would provide you hashes, clear text passwords, or other
    protected forms of data. Instead, you are trying to make educated guesses against
    a resource based on research you have done. Types of online attacks include dictionary,
    brute force and password spray attacks. Remember that resources can be part of
    a federated or centralized system like **Active Directory** (**AD**) or a local
    account on the host itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在线凭证攻击是指当您针对接口或资源进行强制认证时所做的操作。这意味着您可能不知道用户名、密码，或两者都不知道，并且正在尝试确定正确的信息以获得访问权限。这些攻击是在您未能访问能够提供哈希值、明文密码或其他受保护形式数据的资源时执行的。相反，您正在尝试根据您所做的研究来做出合理的猜测。在线攻击的类型包括字典、暴力和密码喷洒攻击。请记住，资源可以是联合或集中系统的一部分，例如**Active
    Directory**（**AD**），或者是主机本身的本地帐户。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For you screaming what about hybrid? Most assessors consider it a form of dictionary
    attack as it is just a list of words permutated anyway. You rarely find a dictionary
    that does not contain hybrid words today anyway. In the 1990s, this was rarer,
    but with better education and more powerful systems with substantiated password
    requirements have changed this situation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喊着“混合攻击呢？”的人，大多数评估者认为它是字典攻击的一种形式，因为它只是一个单词列表的排列。如今，你几乎找不到不包含混合词的字典了。在20世纪90年代，这种情况比较少见，但随着更好的教育和更强大的系统以及经过验证的密码要求，情况已经发生了改变。
- en: Defining the offline credential attack
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义离线凭证攻击
- en: An offline credential attack is when you have already cracked a resource and
    extracted the data such as the hashes and are now attempting to guess them. This
    can be done in a number of manners, depending on the type of hash and the resources
    available, some examples include offline dictionary, rule based attacks, brute
    force, or rainbow table attacks. One of the reasons we call this offline credential
    attacks instead of offline password attacks, is because you are trying to guess
    the clear text version of the password on a system it did not originate from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 离线凭证攻击是指当您已经破解了一个资源并提取了哈希等数据后，现在正在尝试猜测它们。这可以通过多种方式来完成，取决于哈希的类型和可用的资源，一些例子包括离线字典、基于规则的攻击、暴力攻击或彩虹表攻击。我们之所以称之为离线凭证攻击而不是离线密码攻击，是因为您正在尝试猜测密码的明文版本，而这个系统并非密码的原始来源。
- en: Those password hashes may have been salted with random information or by known
    components such as the usernames to create the salt. Ergo, you may still need
    to know the username to crack the hash because the salt is a component of added
    randomness. Now, I have seen a few implementations that use the username as the
    salt for a hashing algorithm and this is a really bad idea. The argument you will
    hear that says this is a good idea comes from the fact that the salt is stored
    with the password anyway just like the username, so why does it matter? Known
    usernames that are used ubiquitously through systems such as root, administrator,
    and admin are known prior to compromising of the system, along with the known
    encryption method which opens up a major vulnerability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密码哈希可能已经用随机信息或已知组件（如用户名）进行了盐化。因此，您可能仍然需要知道用户名才能破解哈希，因为盐是增加随机性的一个组成部分。现在，我已经看到一些实现使用用户名作为哈希算法的盐，这是一个非常糟糕的主意。支持这一观点的论据是，盐和用户名一样都与密码一起存储，那么这有什么关系呢？在系统中广泛使用的已知用户名，如root、administrator和admin，在系统被破坏之前就已知，以及已知的加密方法，这开启了一个重大的漏洞。
- en: This means the salt is based off a username, means it is known prior to getting
    access to the environment and before the engagement began. So that means, you
    have effectively defeated the mechanism put in place to making cracking passwords
    more difficult to include the use of rainbow tables. Making salts known prior
    to an engagement means that rainbow tables are again useful for salted passwords
    as well, if you have a tool that can process the data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着盐是基于用户名的，这意味着在获得对环境的访问权限之前和参与开始之前就已知。因此，您已经有效地打败了为使破解密码更加困难而制定的机制，包括使用彩虹表。在参与开始之前已知盐意味着彩虹表对于盐化密码同样有用，只要您有一个可以处理数据的工具。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Poor salting methods and custom encryption methods can open an organization
    up to compromise.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的盐方法和自定义加密方法可能会使组织面临妥协。
- en: Offline attacks hinge on the premise of taking a word and creating a hash in
    the same format as the protected password using the same method of protection.
    If the protected value is the same as the newly created value, then you have a
    word that will be equivalent and grant access. Most password protection methods
    use hashing to obscure the value, which is a one way function, or in other words,
    it cannot be, so the method cannot be reversed to produce the original value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 离线攻击依赖于采用一个单词并使用相同的保护方法以相同格式创建哈希值作为受保护密码的前提。如果受保护的值与新创建的值相同，那么您将获得一个等效的单词并获得访问权限。大多数密码保护方法使用哈希处理来模糊值，这是一个单向函数，或者换句话说，它不能被逆转，因此该方法无法被逆转以产生原始值。
- en: So when a system accepts a password through its authentication method, it hashes
    the password in the same method and compares the stored hash value to the newly
    computed one. If they equal each other, you have a reasonable level of assurance
    that the passwords are the same and access will be granted. The idea of a reasonable
    level assurance is dependent on how strong the hashing algorithm is. Some hashing
    algorithms are considered weak or broken, such as **Message Digest 5** (**MD5**)
    and **Secure Hashing Algorithm 1** (**SHA-1**). The reason for this is that they
    are susceptible to collisions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当系统通过其认证方法接受密码时，它会以相同的方法对密码进行哈希处理，并将存储的哈希值与新计算的哈希值进行比较。如果它们相等，您就有了合理的保证，密码是相同的，访问将被授予。合理保证的概念取决于哈希算法的强度。一些哈希算法被认为是薄弱或破碎的，例如**消息摘要5**（**MD5**）和**安全哈希算法1**（**SHA-1**）。其原因是它们容易发生碰撞。
- en: A collision means that the mathematical possibility for the data it protects
    does not have enough entropy to guarantee that a different hashed value will not
    equal the same thing. The reality is that two completely different words hashed
    by the same broken algorithm could create the same hash value. As such, this directly
    affects systems authentication methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞意味着所保护数据的数学可能性不具备足够的熵，以保证不同的哈希值不会等于相同的内容。事实上，由相同破碎算法哈希的两个完全不同的单词可能会创建相同的哈希值。因此，这直接影响了系统的认证方法。
- en: When someone accesses the system, the password input is hashed in the same method
    as the password that is stored on the system. If the two values match, that means
    the theoretically the password is the same, unless the hashing algorithm is weak.
    So, when assessing the system, you just have to find a value that creates the
    same hash as the original value. If that occurs, you will be granted access to
    the system, and this is where the weakness of hashes that have known collisions
    come in. You do not need to know the actual value that created the hash, just
    an equivalent value that will create the same hash.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人访问系统时，输入的密码以与系统上存储的密码相同的方法进行哈希处理。如果两个值匹配，那意味着理论上密码是相同的，除非哈希算法是薄弱的。因此，在评估系统时，您只需找到一个值，该值将创建与原始值相同的哈希。如果发生这种情况，您将获得对系统的访问权限，这就是已知碰撞的哈希的弱点所在。您不需要知道创建哈希的实际值，只需找到一个等效值，该值将创建相同的哈希。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing, MD5 is used to verify integrity of file systems and
    data for forensics. Even though MD5 is considered a broken hash, it is still considered
    good enough for forensics and file system integrity. The reason for this is that
    it would take an infeasible amount of work to fool the algorithm with substantial
    data sets like files systems. To manipulate a file system after data had been
    adjusted or extracted to create the same integrity marker is unrealistic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，MD5用于验证取证的文件系统和数据的完整性。尽管MD5被认为是一个破碎的哈希，但它仍被认为对于取证和文件系统的完整性来说是足够好的。其原因是要欺骗算法以大量数据集（如文件系统）需要付出不可行的工作量。在数据被调整或提取后操纵文件系统以创建相同的完整性标记是不现实的。
- en: Now that you have an understanding of both offline and online credential attack
    differences, we need to start generating our data to be used for them. This starts
    with generating usernames, and then verifying them as part of the organization.
    This seems like a minor step, but it is very important as it trims your list of
    targets down, reduces the noise you generate, and improves your chances of compromising
    the organization.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了离线和在线凭据攻击的区别，我们需要开始生成用于它们的数据。首先是生成用户名，然后验证它们是否属于组织的一部分。这似乎是一个小步骤，但它非常重要，因为它可以缩减您的目标列表，减少您产生的噪音，并提高您攻击组织的机会。
- en: Identifying the target
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别目标
- en: We are going to use Metasploitable as an example here, because it will allow
    you to test these concepts in a safe and legal environment. To start with, let
    us do a simple `nmap` scan of the system with a service detection. The following
    command highlights the specific arguments and options, which does SYN scan looking
    for the well-known ports on a system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以Metasploitable为例，因为它将允许您在安全和合法的环境中测试这些概念。首先，让我们对系统进行一个简单的`nmap`扫描，进行服务检测。以下命令突出了特定的参数和选项，它执行SYN扫描，寻找系统上的知名端口。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the results, the host is identified as Metasploitable and
    a number of ports are open to include **Simple Mail Transfer Protocol** (**SMTP**)
    at port 25.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，主机被识别为Metasploitable，并且有许多端口开放，包括端口25上的**简单邮件传输协议**（**SMTP**）。
- en: '![Identifying the target](img/B04315_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![识别目标](img/B04315_04_01.jpg)'
- en: Creating targeted usernames
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有针对性的用户名
- en: When targeting organizations, especially at the perimeter, the easiest way in
    is to compromise an account. This means that you get at least the basic level
    of access of that person and can find ways to elevate your privileges. To do that,
    you need to identify realistic usernames for an organization. The multiple ways
    to do this include researching of people who work for the organization through
    sites like [http://www.data.com/](http://www.data.com/), [https://www.facebook.com/](https://www.facebook.com/),
    [https://www.linkedin.com/hp/](https://www.linkedin.com/hp/), and [http://vault.com/](http://vault.com/).
    You can automate some of this with tools like the `Harvester.py` and `Recon-ng`,
    which source Internet exposures and repositories.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对组织，尤其是在边界方面，最简单的进入方式是攻击一个账户。这意味着您至少获得了该人的基本访问权限，并可以找到提升权限的方法。为此，您需要为组织确定现实的用户名。这可以通过研究在网站上工作的人员来完成，例如[http://www.data.com/](http://www.data.com/)、[https://www.facebook.com/](https://www.facebook.com/)、[https://www.linkedin.com/hp/](https://www.linkedin.com/hp/)和[http://vault.com/](http://vault.com/)。您可以使用`Harvester.py`和`Recon-ng`等工具自动化部分工作，这些工具可以获取互联网暴露和存储库。
- en: This initial research is good, but the amount of time you typically have to
    do this is limited, unlike malicious actors. So what you can do to supplement
    the data you find is generate usernames and then verify them against a service
    port like SMTP with VRFY enabled or Finger. If you find these ports open, especially
    on the Internet for the target organization, the first thing I do is verify my
    username list. This means I can cut down my attack list for the next step, which
    we will cover in [Chapter 5](ch05.html "Chapter 5. Exploiting Services with Python"),
    *Exploiting Services with Python*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这项初步研究很好，但你通常有限的时间来做这件事，不像恶意行为者。所以你可以做的是补充你找到的数据，生成用户名，然后对它们进行验证，例如通过启用了VRFY的SMTP或Finger服务端口。如果你发现这些端口开放，尤其是在互联网上针对目标组织，我首先要做的是验证我的用户名列表。这意味着我可以缩减下一步的攻击列表，我们将在[第5章](ch05.html
    "第5章 利用Python进行服务利用")中进行介绍，*利用Python进行服务利用*。
- en: Generating and verifying usernames with help from the U.S. census
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用美国人口普查生成和验证用户名
- en: For years, the U.S. Government and other countries survey the countries populace
    for details. This information is available to law abiding citizens, as well as
    malicious actors. These details can be used for anything from social engineering
    attacks, sales research, and even telemarketers. Some details are harder to find
    than others, but our favorite bit is the surname list. This list produced in 2000,
    provides us the top 1000 surnames in the U.S. populace.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，美国政府和其他国家对国家人口进行调查。这些信息对守法公民和恶意行为者都是可用的。这些细节可以用于社会工程攻击、销售研究，甚至电话推销。有些细节比其他细节更难找到，但我们最喜欢的是姓氏列表。这个2000年产生的列表为我们提供了美国人口中前1000个姓氏。
- en: If you have ever looked at the components of most organization's usernames,
    it is the first letter of their first name and the entire last name. When these
    two components are combined, it creates a username. Using the U.S. Census top
    1000 list, we can cheat the creation method by downloading the list extracting
    the surnames and prepending every letter in the alphabet to create 26 usernames
    for each surname. This process will produce a list of 26,000 usernames not including
    the details of publically sourced information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经看过大多数组织用户名的组成部分，它通常是他们名字的第一个字母和整个姓氏。当这两个部分组合在一起时，就创建了一个用户名。使用美国人口普查的前1000名姓氏列表，我们可以通过下载列表提取姓氏，并在每个字母前面添加字母表中的每个字母，为每个姓氏创建26个用户名。这个过程将产生一个包括公开信息细节在内的26,000个用户名列表。
- en: When you combine the username list created by searching social media, and using
    tools to identify e-mail addresses, you could have a substantial list. So you
    would need to trim it down. In this example, we are going to show you how to extract
    details from an Excel spreadsheet using Python, and then verify the usernames
    created and combined by other lists against the SMTP service with VRFY running.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将通过社交媒体搜索创建的用户名列表与用于识别电子邮件地址的工具结合使用时，您可能会得到一个庞大的列表。因此，您需要将其缩减。在这个例子中，我们将向您展示如何使用Python从Excel电子表格中提取细节，然后验证由其他列表创建和组合的用户名是否与运行VRFY的SMTP服务匹配。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Westernized Governments often produce similar lists, so make sure you look where
    you are trying to assess and use the information relevant to the organization's
    location. In addition to that, states such as U.S. territories, Alaska and Hawaii
    have vastly different surnames than the rest of the continental U.S. Build your
    list to compensate for these differences.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 西方政府通常会制作类似的列表，因此请确保您正在尝试评估的地方，并使用与组织所在地相关的信息。此外，美国属地、阿拉斯加和夏威夷等州的姓氏与美国大陆其他地区大不相同。构建您的列表以弥补这些差异。
- en: Generating the usernames
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成用户名
- en: 'The first step to this process is downloading the excel spreadsheet, which
    can be found here [http://www.census.gov/topics/population/genealogy/data/2000_surnames.html](http://www.census.gov/topics/population/genealogy/data/2000_surnames.html).
    You can download the specific file directly from the console using `wget` as shown
    following. Keep in mind that you should only download the file; never assess an
    organization or website unless you have permission. The following command does
    the equivalent of visiting the site and clicking the link to download the file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步是下载Excel电子表格，可以在这里找到[http://www.census.gov/topics/population/genealogy/data/2000_surnames.html](http://www.census.gov/topics/population/genealogy/data/2000_surnames.html)。您可以直接使用`wget`从控制台下载特定文件，如下所示。请记住，您应该只下载文件；除非您获得许可，否则不要评估组织或网站。以下命令相当于访问该网站并单击链接下载文件：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now open up the Excel file and see how it is formatted, so that we know how
    to develop the script to pull the details out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Excel文件，看看它的格式，以便我们知道如何开发脚本来提取详细信息。
- en: '![Generating the usernames](img/B04315_04_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![生成用户名](img/B04315_04_02.jpg)'
- en: As you can see, there are 11 columns that define the features of the spreadsheet.
    The two we care about are the name and the rank. The name is the surname we will
    create our username list from, and the rank is the order of occurrence in the
    U.S. Before we build a function to parse the census file, we need to develop a
    means to get the data into the script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有11列定义了电子表格的特征。我们关心的是姓名和排名。姓名是我们将创建用户名列表的姓氏，排名是在美国出现的顺序。在构建解析人口普查文件的函数之前，我们需要开发一种方法将数据传递到脚本中。
- en: The `argparser` library allows you to develop command line options and arguments
    quickly and effectively. The `xlrd` library will be used to analyze the Excel
    spreadsheet, and the string library will be used to develop a list of alphabetical
    characters. The `os` library will confirm what **Operating System** (**OS**) the
    script is being run from, so filename formatting can be handled internally. Finally,
    the collections library will provide the means to organize the data in memory
    pulled out of the Excel spreadsheet. The only library that is not native to your
    Python instance is the `xlrd` one, which can be installed with `pip`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparser`库允许您快速有效地开发命令行选项和参数。`xlrd`库将用于分析Excel电子表格，字符串库将用于开发字母字符列表。`os`库将确认脚本正在运行的**操作系统**（**OS**），因此文件名格式可以在内部处理。最后，collections库将提供在内存中组织从Excel电子表格中提取的数据的方法。唯一不是Python实例的库是`xlrd`，可以使用`pip`安装。'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you have your libraries situated, you can now build out the functions
    to do the work. This script will include the ability to have its level of verbosity
    increased or decreased as well. This is a relatively easy feature to include,
    and it is done by setting the verbose variable to an integer value; the higher
    the value, the more verbose. We will default to a value of 1 and support up to
    a value of 3\. Anything more than that will be treated as a 3\. This function
    will accept the name of the file being passed as well, as you never know it may
    change in the future.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了库，可以开始构建执行工作的函数了。此脚本将包括增加或减少其冗长程度的功能。这是一个相对容易包含的功能，通过将冗长变量设置为整数值来实现；值越高，冗长越多。我们将默认为1，并支持最多3个值。超过这个值将被视为3。此函数还将接受传递的文件名，因为您永远不知道它可能会在将来更改。
- en: We are going to use a form of a tuple called a named tuple to accept each row
    of the spreadsheet. A named tuple allows you to reference the details by coordinates
    or field name depending on how it is defined. As you can guess, this is perfect
    for a spreadsheet or database data. To make this easy for us, we are going to
    define this the same way as the spreadsheet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种名为命名元组的元组形式来接受电子表格的每一行。命名元组允许您根据坐标或字段名称引用详细信息，具体取决于其定义方式。正如您所猜测的，这对于电子表格或数据库数据非常适用。为了使这对我们来说更容易，我们将以与电子表格相同的方式定义它。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, develop the variables to hold the workbook, spreadsheet by the name, and
    the total rows and the initial row of the spreadsheet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开发变量来保存工作簿、电子表格名称、总行数和电子表格的初始行。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, develop the initial variables to hold the resulting values and the actual
    alphabet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开发初始变量来保存结果值和实际字母表。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, each row of the spreadsheet will be iterated through. The `surname_dict`
    holds the raw data from the spreadsheet cells. The `username_dict` will hold the
    username and the rank converted to strings. Each time a point is not detected
    in the rank value, it means that the value is not a `float` and is therefore empty.
    This means the row itself does not contain real data, and it should be skipped.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将遍历电子表格的每一行。`surname_dict`保存电子表格单元格的原始数据。`username_dict`将保存用户名和转换为字符串的排名。每当在排名值中检测不到点时，这意味着该值不是`float`，因此为空。这意味着该行本身不包含真实数据，应该跳过。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember, dictionaries store values referenced by key, but unordered. So what
    we can do is take the values stored in the dictionary and order them by the key,
    which was the rank of the value or the surname. To do this, we are going to take
    a list and have it accept the sorted details returned by a function. Since this
    is a relatively simple function, we can create a nameless function with `lambda`,
    which uses the optional sorted parameter key to call it as it processes the code.
    Effectively, sorted creates an ordered list based on the dictionary key for each
    value in the dictionary. Finally, this function returns the `username_list` and
    both dictionaries if they would be needed in the future.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，字典存储由键引用的值，但是无序的。所以我们可以做的是取出字典中存储的值，并按键（值的等级或姓氏）对它们进行排序。为此，我们将使用一个列表，并让它接受函数返回的排序后的详细信息。由于这是一个相对简单的函数，我们可以使用`lambda`创建一个无名函数，它使用可选的排序参数键来调用它，以便在处理代码时调用它。实际上，排序根据字典键为字典中的每个值创建了一个有序列表。最后，这个函数返回`username_list`和两个字典，如果将来需要的话。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The good news is that is the most complex function in the entire script. The
    next function is a well-known design that takes in a list removes duplicates.
    The function uses the list comprehension, which reduces the size of simple loops
    used to create ordered lists. This expression within the function could have been
    written as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这是整个脚本中最复杂的函数。下一个函数是一个众所周知的设计，它接受一个列表并删除重复项。该函数使用列表推导，它减少了用于创建有序列表的简单循环的大小。函数内的表达式可以写成以下形式：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To reduce the size of this simple execution and to improve readability, we
    instead change it to a list comprehension, as shown in the following excerpt:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这个简单执行的大小并提高可读性，我们改为使用列表推导，如下摘录所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One of the goals from this script is to combine research from other sources
    into the same file that contains usernames. The user can pass a file that can
    be prepended or appended to the details of the census file outputs. When this
    script is run, the user can supply the file as a prepended value or an appended
    value. The script determines which one it is, and then reads in each line stripping
    new line character from each entry. The script then determines if it needs to
    be added to the end or front of the census username list and sets the variable
    value for `put_where`. Finally, both the list and values for `put_where` are returned.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的目标之一是将来自其他来源的研究合并到包含用户名的同一个文件中。用户可以传递一个文件，可以将其添加到人口普查文件输出的详细信息中。当运行这个脚本时，用户可以将文件作为预置值或附加值提供。脚本确定是哪一个，然后读取每一行，剥离每个条目的换行符。然后确定是否需要将其添加到人口普查用户名列表的末尾或开头，并设置`put_where`的变量值。最后，返回列表和`put_where`的值。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All that is needed is a function that combines the two user lists together.
    This function will either prepend the data with a simple split that sticks the
    new user list in front of the census list or appends the data with the extend
    function. The function will then call previous function that was created, which
    reduces non-unique values to unique values. It would be bad to know a password
    lockout limit for a function, and then call the same user accounts more than once,
    locking out the account. The final item returned is the new combined username
    list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一个将两个用户列表合并的函数。这个函数要么使用简单的分割将新用户列表放在人口普查列表的前面，要么使用extend函数将数据附加到人口普查列表后面。然后调用之前创建的函数，将非唯一值减少为唯一值。知道函数的密码锁定限制，然后多次调用相同的用户帐户，锁定帐户是不好的。最终返回的项目是新的合并用户名列表。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last function in this script writes the details to a file. To further improve
    the capabilities of this script, we can create two different types of username
    files: one that includes the domain like an e-mail address and the other a standard
    username list. The supplemental username list with the domain will be treated
    as optional.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的最后一个函数将详细信息写入文件。为了进一步提高脚本的功能，我们可以创建两种不同类型的用户名文件：一个包括类似电子邮件地址的域，另一个是标准用户名列表。带有域的补充用户名列表将被视为可选项。
- en: This function deletes the contents of the files as necessary and iterates through
    the list. If the list is to be a domain list, it simply applies the `@` and the
    domain name to each username as it writes it to the file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据需要删除文件的内容，并遍历列表。如果列表是域列表，它会简单地将`@`和域名应用到每个用户名上，并将其写入文件。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that the functions have been defined, we can develop the main part of the
    script and properly introduce arguments and options.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数已经定义好了，我们可以开发脚本的主要部分，并正确引入参数和选项。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `argparse` library has replaced the `optparse` library, which provided similar
    capabilities. It should be noted that a lot of the weaknesses related to options
    and arguments in scripting languages are addressed very well with this library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`库已经取代了提供类似功能的`optparse`库。值得注意的是，脚本语言中与选项和参数相关的许多弱点在这个库中得到了很好的解决。'
- en: The `argparse` library provides you the ability to setup both short and long
    options that can accept a number of values defined by `types`. These are then
    presented into a variable you have defined with `dest`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`库提供了设置短选项和长选项的能力，可以接受由`types`定义的多个值。然后将它们呈现到您用`dest`定义的变量中。'
- en: Each of these arguments can have specific capabilities defined with the action
    parameter to include storage of values counting and others. Additionally, each
    of these arguments can have `default` values set with the `default` parameter
    as necessary. The other feature that is useful is the `help` parameter, which
    provides feedback in usage and improves documentation. We do not use every script
    that we create on every engagement or every day. See the following example on
    how to add an argument for the `census` file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都可以使用动作参数定义特定功能，包括值计数和其他功能。此外，每个参数都可以使用`default`参数设置`default`值。另一个有用的功能是`help`参数，它提供了用法反馈并改进了文档。我们并不是每次都在每次参与或每天都使用我们创建的每个脚本。请参见以下示例，了解如何为`census`文件添加参数。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With these simple capabilities understood, we can develop the requirements for
    arguments to be passed to the script. First, we verify that this is part of the
    main function, and then we instantiate the `argeparse` as parser. The simple usage
    statement shows what would need to be called to execute the script. The `%(prog)s`
    is functionally equivalent to positing `0` in `argv`, as it represents the script
    name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这些简单的功能后，我们可以开发要传递给脚本的参数的要求。首先，我们验证这是否是主要函数的一部分，然后我们将`argeparse`实例化为解析器。简单的用法语句显示了执行脚本所需调用的内容。`%(prog)s`在功能上等同于在`argv`中放置`0`，因为它代表脚本名称。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have defined the instance in parser, we need to add each argument
    into the parser. Then, we define the variable `args`, which will hold the publically
    referenced values of each stored argument or option.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在解析器中定义了实例，我们需要将每个参数添加到解析器中。然后，我们定义变量`args`，它将保存每个存储参数或选项的公开引用值。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With your arguments defined, you are going to want to validate that they were
    set by the user and that they are easy to reference through your script.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了参数后，您需要验证用户是否设置了它们，并且它们是否易于通过脚本引用。
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar to an argument validator, you are going to want to make sure that an
    output file is set. If it is not set, you can have a default value ready to be
    used as needed. You are going to want to be OS agnostic, so it needs to be setup
    to run in either a Linux/UNIX system or a Windows system. The easiest way to determine
    that is by the direction of the `\` or `/`. Remember that the `\` is used to escape
    characters in scripts, so make sure to put two to cancel out the effect.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与参数验证器类似，您需要确保设置了输出文件。如果没有设置，您可以准备一个默认值以备需要使用。您需要保持操作系统不可知性，因此需要设置为在Linux/UNIX系统或Windows系统中运行。确定的最简单方法是通过`\`或`/`的方向。请记住，`\`用于转义脚本中的字符，因此请确保输入两个以取消效果。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The remaining components that need to be defined are your working variables
    as the functions are called.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要定义的剩余组件是在调用函数时定义的工作变量。
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Following all those details, you can finally get to the meat of the script,
    which is the calling of the activity to create the username file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循所有这些细节之后，您最终可以进入脚本的主要部分，即调用活动以创建用户名文件：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot demonstrates how the script could output a help file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图演示了脚本如何输出帮助文件：
- en: '![Generating the usernames](img/B04315_04_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![生成用户名](img/B04315_04_03.jpg)'
- en: An example of how to run the script and the output can be found here, with the
    prepending of a `username.lst` with the username `msfadmin` in it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处找到运行脚本和输出的示例，其中在`username.lst`中添加了用户名`msfadmin`。
- en: '![Generating the usernames](img/B04315_04_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![生成用户名](img/B04315_04_04.jpg)'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This script can be downloaded from [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/username_generator.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/username_generator.py).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从以下网址下载此脚本[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/username_generator.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/username_generator.py)。
- en: We have our username generator, and we include the name `msfadmin` because we
    have done some initial research on the test box Metasploitable. We know that is
    a standard default account, and we are going to want to verify if it is actually
    in the system. When you initially scan a system and you identify open ports and
    services, and then verify what you are getting ready to attack, this is a normal
    part of research. That research should include looking for default and known accounts
    as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的用户名生成器，并且我们包括名称`msfadmin`，因为我们已经对测试框Metasploitable进行了一些初步研究。我们知道这是一个标准默认帐户，我们将要验证它是否实际存在于系统中。当您最初扫描系统并识别开放端口和服务，然后验证您准备攻击的内容时，这是研究的正常部分。该研究应包括寻找默认和已知帐户。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When executing these types of attacks, it is normal to exclude built in accounts
    for systems that are known like root. On the Windows systems, you should still
    test the Administrator account because that one may be renamed. You should also
    avoid testing for root logins during Double Blind or Red Team exercise at first.
    This will often elicit an alert for security administrative staff.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这些类型的攻击时，通常会排除已知系统内置帐户，例如root。在Windows系统上，您仍应测试管理员帐户，因为该帐户可能已更名。您还应该避免在双盲或红队演习期间首先测试root登录。这通常会引起安全管理人员的警报。
- en: Testing for users using SMTP VRFY
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SMTP VRFY测试用户
- en: 'Now that we have a list of usernames and we know that SMTP is open, we need
    to see if `VRFY` is enabled. This is extremely simple, all you do is telnet into
    port 25 and execute the command `VRFY` followed by a word and hit enter. The great
    part about checking for usernames this way is that if `VRFY` is enabled, something
    is wrong with the secure deployment practices, and if it is Internet facing, they
    are likely not monitoring it. Reduce the number of credential attack guesses in
    an online credential attack against an interface will reduce the chances of being
    caught. The simple commands to execute this are shown in the following figure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用户名列表，并且我们知道SMTP是开放的，我们需要看看`VRFY`是否已启用。这非常简单，你只需telnet到25号端口，执行`VRFY`命令，后跟一个单词，然后按回车键。通过这种方式检查用户名的好处在于，如果`VRFY`已启用，那么安全部署实践存在问题，如果它是面向互联网的，他们可能没有监控它。减少在线凭证攻击接口的凭证猜测次数将减少被抓到的机会。执行此操作的简单命令如下图所示：
- en: '![Testing for users using SMTP VRFY](img/B04315_04_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用SMTP VRFY测试用户](img/B04315_04_05.jpg)'
- en: We did not get a hit for smith, but perhaps others will confirm during this
    attack. Before we write our script, you need to know the different error or control
    messages that can be produced in most SMTP systems. These can vary and you should
    design your script well enough to be modified for that environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有找到smith，但也许其他人在这次攻击中会确认。在编写脚本之前，你需要了解大多数SMTP系统中可能产生的不同错误或控制消息。这些可能会有所不同，你应该设计你的脚本，使其足够灵活，以便在该环境中进行修改。
- en: '| Return code | Meaning |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 返回代码 | 含义 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 252 | The username is on the system. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 252 | 用户名在系统中。 |'
- en: '| 550 | The username is not on the system. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 550 | 用户名不在系统中。 |'
- en: '| 503 | The service requires authentication to use. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 503 | 服务需要身份验证才能使用。 |'
- en: '| 500 | The service does not support VRFY. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 服务不支持VRFY。 |'
- en: Now that you know the basic code responses, you can write a script that takes
    advantage of this weakness.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了基本的代码响应，你可以编写一个利用这个弱点的脚本。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why we are writing a script to take advantage of this when
    Metasploit and other tools have built in modules for this. On many systems, this
    weakness has special timeouts and or throttling requirements to take advantage
    of. Most other tools to include the Metasploit module fail when you are trying
    to get around these roadblocks, so then Python is really your best answer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想为什么我们要编写一个利用这一点的脚本，当Metasploit和其他工具已经内置了这个模块。在许多系统中，利用这一弱点需要特殊的超时和/或节流要求。大多数其他工具，包括Metasploit模块，在你试图绕过这些障碍时会失败，所以Python才是你最好的答案。
- en: Creating the SMTP VRFY script
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SMTP VRFY脚本
- en: Since Metasploit and other attack tools do not take into consideration timeouts
    for the session attempt and delays between each attempt, we need to consider making
    the script more useful by incorporating those tasks. As mentioned previously,
    tools are great and they will often fit 80 percent of the situations you will
    come across, but being a professional means adapting situations a tool may not
    fit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Metasploit和其他攻击工具在会话尝试和每次尝试之间的延迟方面没有考虑超时，我们需要考虑通过合并这些任务使脚本更有用。如前所述，工具很棒，它们通常适用于你遇到的80%的情况，但作为专业人士意味着适应工具可能不适用的情况。
- en: The libraries being used have been common so far, but we added one from [Chapter
    2](ch02.html "Chapter 2. The Basics of Python Scripting"), *The Basics of Python
    Scripting*—the socket library for network interface control and time for control
    of timeouts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的库是常见的，但我们从[第2章](ch02.html "第2章。Python脚本的基础")中添加了一个库，*Python脚本的基础*——用于网络接口控制的socket库和用于控制超时的时间。
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next function reads the files into a list that will be used for testing
    usernames.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数将文件读入一个列表，该列表将用于测试用户名。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, a modification of the `username_generator.py` script function, which wrote
    the data to a combined username file. This provides a confirmed list of usernames
    to a useful output format.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`username_generator.py`脚本函数，将数据写入一个组合的用户名文件。这提供了一个确认的用户名列表，以便用于有用的输出格式。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The last function and most complex one is called `verify_smtp`, which validates
    usernames against the SMTP `VRFY` vulnerability. First, it loads up the usernames
    returned from the `read_file` function and confirms the parameter data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，也是最复杂的一个函数，名为`verify_smtp`，它验证用户名是否存在SMTP `VRFY`漏洞。首先，它加载了从`read_file`函数返回的用户名，并确认了参数数据。
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The script then takes each username out of the list and uses a conditional test
    to try and create connection to the system at the specified IP and port. We capture
    the banner when it connects, build the command with the username, and send the
    command. The returned data is stored in the results variable, which is tested
    for the previous documented response codes. If a 252 response is received, the
    username is appended to the `valid_users` list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后脚本从列表中取出每个用户名，并使用条件测试尝试连接到指定IP和端口的系统。当连接时，我们捕获横幅，使用用户名构建命令，并发送命令。返回的数据存储在结果变量中，并对先前记录的响应代码进行测试。如果收到252响应，则将用户名附加到`valid_users`列表中。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Specific break conditions are set to cause a relative graceful end of this script
    if conditions are met that necessitate the ending of the test. It should be noted
    that each username has a separate connection being established so as to prevent
    a connection from being held open too long, reduce errors, and improve the chances
    that in the future, this script can be made into a multithreaded script, as described
    in [Chapter 10](ch10.html "Chapter 10. Adding Permanency to Python Tools"), *Adding
    Permanency to Python Tools*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的中断条件被设置，以便在满足需要结束测试的条件时，脚本可以相对优雅地结束。值得注意的是，每个用户名都有一个单独的连接被建立，以防止连接被保持太久，减少错误，并提高将来将该脚本制作成多线程脚本的机会，如[第10章](ch10.html
    "第10章。向Python工具添加永久性")中所述，*向Python工具添加永久性*。
- en: The last two components of this script are the exception error handling, and
    the final conditional operation, which closes the connection, delays the next
    execution if necessary and clears the STDOUT.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的最后两个组件是异常错误处理和最终的条件操作，它关闭连接，延迟下一次执行（如果需要）并清除标准输出。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Much of the previous script components are reused here, and they are just tweaked
    for the new script. Take a look and determine the different components for yourself.
    Then understand how to incorporate changes into future changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本组件在这里被重复使用，并且它们只是针对新脚本进行了微调。看一下并确定不同的组件。然后了解如何将更改合并到将来的更改中。
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The final component of the script is the calling of the specific functions to
    execute the script.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一个组件是调用特定函数来执行脚本。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The script has a default help capability, just like the `username_generator.py`
    script, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本具有默认的帮助功能，就像`username_generator.py`脚本一样，如下截图所示：
- en: '![Creating the SMTP VRFY script](img/B04315_04_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建SMTP VRFY脚本](img/B04315_04_06.jpg)'
- en: 'The final version of this script will produce an output like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的最终版本将产生如下输出：
- en: '![Creating the SMTP VRFY script](img/B04315_04_07.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![创建SMTP VRFY脚本](img/B04315_04_07.jpg)'
- en: After executing the following command, which has a username flat file passed
    to it, the IP address of the target, the port of the SMTP service, and the output
    file, the script has a default sleep value of `0.0` and a default timeout value
    of `1` second. If testing over the Internet, you may have to increase this value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令后，将用户名平面文件传递给它，目标的IP地址，SMTP服务的端口和输出文件，脚本具有默认的睡眠值为`0.0`和默认超时值为`1`秒。如果在互联网上进行测试，可能需要增加这个值。
- en: '![Creating the SMTP VRFY script](img/B04315_04_08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建SMTP VRFY脚本](img/B04315_04_08.jpg)'
- en: The one user we validated on the system as of no surprise was the `msfadmin`
    account. Had this been a real system though, you have reduced the number of accounts
    you would need to test effectively narrowing down one half the credential attack
    equation. Now, all you need to do is find a service you want to test against.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在系统上验证的一个用户毫不奇怪地是`msfadmin`账户。不过，如果这是一个真实的系统，你已经减少了需要有效测试的账户数量，从而将凭证攻击方程式缩小了一半。现在，你只需要找到一个想要测试的服务。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This script can be downloaded from [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/smtp_vrfy.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/smtp_vrfy.py).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以从[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/smtp_vrfy.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/smtp_vrfy.py)下载。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of details on manipulating files from external sources
    to connecting to resources at a low level. The end result was the ability to identify
    potential user accounts and validate them. These activities also highlighted the
    proper use of arguments and options with the `argparse` library, and where the
    use of scripts can meet needs that developed tools cannot. All of this has been
    built to exploit the services, that we will cover in the next chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了许多关于从外部来源操作文件到低级连接资源的细节。最终结果是能够识别潜在的用户账户并验证它们。这些活动还突出了`argparse`库的参数和选项的正确使用，以及脚本的使用可以满足开发工具无法满足的需求。所有这些都是为了利用我们将在下一章中介绍的服务而构建的。
