- en: Chapter 8. Exploit Development with Python, Metasploit, and Immunity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Python、Metasploit和Immunity进行利用开发
- en: During research or in a rare engagement, you may need to develop or modify exploits
    to meet your needs. Python is a fantastic language to quickly prototype code for
    testing exploits or to help with the future modification of Metasploit modules.
    This chapter focuses on the methodology to write an exploit, not how to create
    specific exploits for these software products, so that more testing may be necessary
    to improve reliability. To begin, we need to understand how the **Central Processing
    Unit** (**CPU**) registers and how Windows memory is structured for executables
    when they run. Before that, on Windows XP Run Mode **Virtual Machine** (**VM**),
    you will need a few tools to test this out.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究或在罕见的参与中，您可能需要开发或修改利用以满足您的需求。Python是一个很棒的语言，可以快速原型化代码来测试利用，或者帮助未来修改Metasploit模块。本章重点介绍编写利用的方法，而不是如何为这些软件产品创建特定的利用，因此可能需要更多的测试来提高可靠性。首先，我们需要了解**中央处理单元**（**CPU**）寄存器以及Windows内存在运行时的可执行文件结构。在此之前，在Windows
    XP Run Mode虚拟机上，您需要一些工具来测试这一点。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Download and install the following components on Windows XP Run: Mode VM, Python
    2.7, Notepad++, Immunity Debugger, MinGW (with all the basic packages), and Free
    MP3 CD Ripper version 1.0\. Also use your current Kali build to help generate
    the relevant details we are going to highlight as we go through this chapter.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows XP Run Mode VM上下载并安装以下组件：Python 2.7、Notepad++、Immunity Debugger、MinGW（带有所有基本包）和Free
    MP3 CD Ripper版本1.0。还要使用当前的Kali版本来帮助生成我们在本章节中要强调的相关细节。
- en: Getting started with registers
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用寄存器
- en: This explanation is based on x86 systems and the relevant registers that process
    instruction sets for executables. We are not going to discuss in detail all registers
    for brevity, but we will describe the most important ones for the scope of this
    chapter. The registers that are specifically highlighted are 32-bits in size and
    are known as the extended registers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释是基于x86系统和处理可执行文件指令集的相关寄存器。出于简洁起见，我们不会详细讨论所有寄存器，但我们会描述本章节范围内最重要的寄存器。特别强调的寄存器大小为32位，被称为扩展寄存器。
- en: They are extended because they have 16-bits added to the previous 16-bit registers.
    For example, the older 16-bit general purpose registers could be identified by
    simply removing the E from the front of the register name, so EBX also contains
    the 16-bit BX register. The BX register is actually the combination of two smaller
    8-bit registers, the BH and the BL. The H and the L signify the High Byte and
    the Low Byte register. There are extensive books written on this subject alone
    and replicating that information would not be directly useful to our purpose.
    Overall, registers are broken down into two forms for ease of understanding, the
    general purpose registers and the special purpose registers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被扩展了，因为它们在之前的16位寄存器上增加了16位。例如，旧的16位通用寄存器可以通过简单地去掉寄存器名称前面的E来识别，因此EBX也包含16位BX寄存器。BX寄存器实际上是两个较小的8位寄存器BH和BL的组合。H和L表示高字节和低字节寄存器。有大量关于这个主题的书籍，复制这些信息对我们的目的并不直接有用。总的来说，寄存器被分解为两种形式以便理解，通用寄存器和特殊用途寄存器。
- en: Understanding general purpose registers
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解通用寄存器
- en: The four general purpose registers are the EAX, EBX, ECX, and EDX. The reason
    they are called general purposes registers is because mathematical operations
    and storage occur here. Keep in mind that anything can be manipulated, even the
    basic concepts of what the registers would normally be doing. For this description,
    though, the overall purpose is accurate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 四个通用寄存器是EAX、EBX、ECX和EDX。它们被称为通用寄存器，因为数学运算和存储发生在这里。请记住，任何东西都可以被操纵，甚至是寄存器通常应该做的基本概念。尽管如此，总体目的是准确的。
- en: The EAX
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EAX
- en: The accumulator register is used for basic mathematical operations and the return
    value of a function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器寄存器用于基本数学运算和函数的返回值。
- en: The EBX
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EBX
- en: The base register is another general purpose register, but unlike the EAX it
    is not intended for a specific purpose. As such, this register can be used for
    nominal storage as needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基址寄存器是另一个通用寄存器，但与EAX不同，它没有特定的用途。因此，这个寄存器可以根据需要用于名义存储。
- en: The ECX
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ECX
- en: The counter register is used primarily for looping through functions and iterations.
    The ECX register can also be used for general storage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器寄存器主要用于循环函数和迭代。ECX寄存器也可以用于通用存储。
- en: The EDX
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EDX
- en: The data register is used for higher mathematical operations, such as multiplication
    and division. This register also stores function variables throughout the processing
    of the program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据寄存器用于更高级的数学运算，如乘法和除法。这个寄存器还在程序处理过程中存储函数变量。
- en: Understanding special purpose registers
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解特殊用途寄存器
- en: These registers are the ones where the indexing and pointing is handled throughout
    the processing of the program. What this means to you is that this is where the
    magic happens for basic exploit writing - we are, in the end, trying to manipulate
    the overwrite of data here. This is done by orders of operations that happen in
    other registers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器是程序处理过程中处理索引和指向的地方。对您来说，这意味着这是基本利用编写的魔法发生的地方 - 最终，我们试图操纵数据的覆盖发生在这里。这是通过其他寄存器中发生的操作顺序完成的。
- en: The EBP
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EBP
- en: The base pointer tells you where the bottom of the stack is at. When a function
    is first called, this points to the top of the stack, or it is set to the old
    stack pointer value. This is because the stack has shifted or grown.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基指针告诉您堆栈底部在哪里。当首次调用函数时，这指向堆栈顶部，或者设置为旧的堆栈指针值。这是因为堆栈已经移动或增长。
- en: The EDI
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EDI
- en: The destination index register is for pointers to function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地索引寄存器用于指向函数。
- en: The EIP
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EIP
- en: The instruction pointer is considered the goal of basic exploit writing. You
    are trying to overwrite the value of this stored point on the stack, because if
    you control this value, you control the next instruction to be executed by the
    CPU. So, when you see the developers or exploit writers talk about overwriting
    the data on the EIP register, understand that this is not a good thing. It means
    that some design of the program itself has failed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针被认为是基本利用编写的目标。你正在尝试覆盖堆栈上存储的这个值，因为如果你控制这个值，你就控制了CPU要执行的下一条指令。因此，当你看到开发人员或利用编写者谈论覆盖EIP寄存器上的数据时，要明白这不是一件好事。这意味着程序本身的某些设计已经失败了。
- en: The ESP
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ESP
- en: The stack pointer shows the current top of the stack, and this is modified as
    the program is run. So, as items are removed from the top of the stack as they
    are run, the ESP changes where it is pointing to. When new functions are loaded
    onto the stack, the EBP takes the old position of the ESP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈指针显示堆栈的当前顶部，并且在程序运行时会被修改。因此，当项目从堆栈顶部被移除时，ESP会改变其指向位置。当新函数加载到堆栈上时，EBP会取代ESP的旧位置。
- en: Understanding the Windows memory structure
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Windows内存结构
- en: The Windows **Operating System (OS)** memory structure has a number of sections
    that can be broken down into high level components. To understand how to write
    exploits and take advantages of poor programming practices, we first have to understand
    these sections. The following details break this information down into manageable
    chunks. The following figure provides a representative diagram of the Windows
    memory structure for an executable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统（OS）的内存结构有许多部分，可以分解为高级组件。要理解如何编写利用并利用糟糕的编程实践，我们首先必须了解这些部分。以下详细信息将这些信息分解成可管理的部分。以下图提供了一个可执行文件的Windows内存结构的代表性图表。
- en: '![Understanding the Windows memory structure](img/B04315_08_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![理解Windows内存结构](img/B04315_08_1.jpg)'
- en: Now, each of these components is important, but the pieces we use with most
    exploit writing are the stack and the heap.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些组件中的每一个都很重要，但我们在大多数利用编写中使用的是堆栈和堆。
- en: Understanding the stack and the heap
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解堆栈和堆
- en: The stack is used for short term local storage in an ordered manner. Each time
    a function is called, or a thread, a unique stack is assigned of a fixed size
    for that function or thread. Once the function or thread has finished the operations,
    the stack is destroyed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈用于有序的短期本地存储。每次调用函数或线程时，都会为该函数或线程分配一个固定大小的唯一堆栈。一旦函数或线程完成操作，堆栈就会被销毁。
- en: The heap, on the other hand, is where global variables and values are assigned
    in a relatively disorganized manner. The heap is shared by applications and the
    areas of memory are actually managed by the application or process. Once the application
    terminates that specific region of memory is freed. In this example, we are attacking
    the stack, not the heap.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 堆，另一方面，是全局变量和值以相对无序的方式分配的地方。堆由应用程序共享，内存区域实际上由应用程序或进程管理。一旦应用程序终止，该特定内存区域就会被释放。在这个例子中，我们攻击的是堆，而不是堆。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that the exploit examples here are often written in Perl, though
    you can easily convert the code to Python, as highlighted in [Chapter 2](ch02.html
    "Chapter 2. The Basics of Python Scripting"), *The Basics of Python Scripting*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这里的利用示例通常是用Perl编写的，尽管你可以很容易地将代码转换为Python，正如[第2章](ch02.html "第2章。Python脚本的基础")中所强调的，*Python脚本的基础*。
- en: To better understand the difference between the heap and the stack movement,
    see the following figure, which shows the adjustment as memory is allocated for
    global and local resources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解堆和堆栈移动之间的区别，请参见下图，显示了在为全局和局部资源分配内存时的调整。
- en: '![Understanding the stack and the heap](img/B04315_08_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈和堆](img/B04315_08_2.jpg)'
- en: The stack builds up the data from bottom of the stack to the top. The growth
    goes from high memory addresses to low memory addresses. The heap is opposite
    of the stack as it grows in the other direction, toward the higher addresses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈从堆栈底部向上构建数据。增长从高内存地址到低内存地址。堆与堆栈相反，它的增长方向相反，朝着更高的地址。
- en: To understand the way a program would be loaded onto the stack, we create a
    sample code snippet. With this code, you can see how the main function calls `function1`
    and the local variables as they are placed onto the stack. Pay attention to the
    way that the program would normally flow with calls to `function1` and how the
    data is placed on the stack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解程序加载到堆栈上的方式，我们创建了一个示例代码片段。通过这段代码，你可以看到主函数如何调用`function1`以及局部变量如何被放置在堆栈上。注意程序通常如何通过调用`function1`流动以及数据如何放置在堆栈上。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Understanding the stack and the heap](img/B04315_08_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈和堆](img/B04315_08_3.jpg)'
- en: The code loaded on the stack would look similar to this, which highlights how
    the information components are presented. As you can see, the old Base Pointer
    is loaded on to the stack for storage and the new EBP is the old Stack Pointer
    value, since the top of the stack has shifted to its new location.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 加载到堆栈上的代码看起来类似于这样，突出显示了信息组件的呈现方式。正如你所看到的，旧的基址指针被加载到堆栈上进行存储，新的EBP是旧的堆栈指针值，因为堆栈的顶部已经移动到了新的位置。
- en: Items that are put onto the stack are pushed onto it, and items that are run
    or removed from the stack are popped off of it. A stack is a programmable concept
    known as a **Last In First Out** (**LIFO**) structure. Think of it as a stack
    of dishes; to effectively remove dishes you have to take them off the top by one
    or by sets, otherwise you risk breaking things. The safest way, of course, is
    one at a time, which takes longer, but it is traceable and effective. With an
    understanding of the most dynamic parts of the memory structure that we will be
    using to inject our code into, you need to understand the remaining areas of Windows
    memory that will function as the building blocks, which we will manipulate to
    get from injection to shell. Specifically, we are speaking of the program image
    and **Dynamic Link Libraries** (**DLL**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 放入堆栈的项目被推入堆栈，从堆栈中运行或移除的项目被弹出。堆栈是一个编程概念，被称为**后进先出**（**LIFO**）结构。把它想象成一堆盘子；要有效地移除盘子，你必须一次一个或一组地从顶部取下，否则你会有破碎的风险。当然，最安全的方式是一次一个，虽然需要更长的时间，但是它是可追踪和有效的。了解我们将要用来注入代码的内存结构的最动态部分后，你需要了解Windows内存的其余区域，这些区域将作为构建块，我们将操纵它们从注入到shell。具体来说，我们正在谈论程序映像和**动态链接库**（**DLL**）。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, we are attempting to inject shellcode into the memory, which we will
    then use to gain access to the system through a solution such as a Meterpreter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在尝试将shellcode注入内存，然后使用它来通过诸如Meterpreter之类的解决方案访问系统。
- en: Understanding the program image and dynamic-link libraries
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解程序映像和动态链接库
- en: Simply put, the program image is where the actual executable is stored in memory.
    **Portable Executable (PE)** is the defined format for the executable, which contains
    the executable and the DLL. Within the program image component of the memory,
    the following items are defined.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，程序映像是实际可执行文件存储在内存中的地方。**可移植可执行文件（PE）**是可执行文件的定义格式，其中包含可执行文件和DLL。在内存的程序映像组件中，定义了以下项目。
- en: '`PE header`: This contains the definitions for the rest of the PE.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PE头`：这包含了PE的其余部分的定义。'
- en: '`.text`: This component contains the code segment or the executable instructions.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`：该组件包含代码段或可执行指令。'
- en: '`.rdata`: This is the read-only data segment, which contains static constants
    rather than variables.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rdata`：这是只读数据段，包含静态常量而不是变量。'
- en: '`.data`: When the executable is loaded into memory, this area contains the
    static variables after they have been initialized, the global variables and static
    local variables. This area is readable and writeable, but the size does not change
    at runtime, it is determined at execution.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`：当可执行文件加载到内存中时，该区域包含静态变量在初始化后的静态变量、全局变量和静态局部变量。该区域可读可写，但大小在运行时不会改变，它是在执行时确定的。'
- en: '`.rsrc`: This section is where the resources for the executable are stored.
    This includes the icons, menus, dialogs, version information, fonts, and so forth.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rsrc`：这个部分是存储可执行文件资源的地方。这包括图标、菜单、对话框、版本信息、字体等。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many penetration testers manipulate the `.rsrc` component of an executable to
    change the format of payloads so that it appears as something else. This is often
    done to change the way a malicious payload appears on a **Universal Serial Bus
    (USB)** drive. Think about when you do a USB drop when you change your payload
    from looking like an executable to a folder. Most people would want to see what
    is in the folder and would be more likely to double click a fake folder than a
    suspicious executable. Tools like resource tuner make the manipulation of this
    section of the PE very easy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多渗透测试人员操纵可执行文件的`.rsrc`组件，以改变有效载荷的格式，使其看起来像其他东西。这通常是为了改变恶意有效载荷在**通用串行总线（USB）**驱动器上的外观。想象一下当你进行USB投放时，将有效载荷从看起来像可执行文件改为看起来像一个文件夹。大多数人会想要看看文件夹里面有什么，并且更有可能双击一个假的文件夹而不是一个可疑的可执行文件。资源调整器等工具使得对PE的这一部分的操纵变得非常容易。
- en: The final component to understand here for the PE is the DLL, which encompasses
    Microsoft's concept of shared libraries. DLLs are similar to executables, but
    they cannot be called directly, and instead they have to be called by an executable.
    At its core, the idea of DLLs is to provide a method for the capabilities to upgrade
    without requiring the entire program to be recompiled when OS is updated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里理解PE的最后一个组件是DLL，它包括微软的共享库概念。DLL类似于可执行文件，但不能直接调用，而是必须由可执行文件调用。DLL的核心思想是提供一种方法，使能力得以升级，而不需要在操作系统更新时重新编译整个程序。
- en: Because of this, many of the basic building blocks for system operations need
    to be referenced regardless of start-up cycle. This means that even if other components
    are going to be in different memory locations, many core DLLs will stay in the
    same referenced locations. Remember, programs require specific callable instructions
    and many of the foundational DLLs are loaded into the same regions of memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多系统操作的基本构建块需要被引用，无论启动周期如何。这意味着即使其他组件将位于不同的内存位置，许多核心DLL将保持在相同的引用位置。记住，程序需要特定的可调用指令，许多基础DLL都加载到相同的内存区域。
- en: What you need to understand is that we will use these DLLs to find an instruction
    that is reliably put into the same location so that we can reference it. This
    means that across the systems and the reboots, the memory reference will work
    as long as the OS and **Service Pack (SP)** version are the same if you use OS
    DLLs. If you use DLLs that are completely native to the program, you will be able
    to use this exploit across OS versions. For this example, though, we are going
    to use OS DLLs. The discovered instruction will enable us to tell the system to
    jump to our shell code, and in turn, execute it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的是，我们将使用这些DLL来找到一个可靠地放置在相同位置的指令，以便我们可以引用它。这意味着在系统和重启时，只要OS和**Service Pack
    (SP)**版本相同，内存引用就会起作用，如果你使用OS DLLs。如果你使用完全适用于程序的DLLs，你将能够跨OS版本使用这个漏洞。不过，在这个例子中，我们将使用OS
    DLLs。发现的指令将使我们能够告诉系统跳转到我们的shell代码，并依次执行它。
- en: The reason we have to do a reference code in DLL is because we will be unsure
    of the exact location that our code will be loaded into memory each time we initiate
    this attack, so we cannot tell the system our exact memory address to jump to.
    So, instead, we are going to load the stack with our code and then tell the program
    to jump to the top of it by referencing the position.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在DLL中引用代码的原因是，我们无法确定每次发起这种攻击时我们的代码将被加载到内存的确切位置，因此我们无法告诉系统我们要跳转到的确切内存地址。因此，我们将加载栈与我们的代码，并告诉程序通过引用位置跳转到它的顶部。
- en: Remember that this may change each time we execute the program and/or each reboot.
    The stack memory addresses are served as required per program, and we are attempting
    to inject our code directly into this running function's stack. So, we have to
    take advantage of the known and repeatable target instruction sets. We will explain
    the exact process of this in detail, but for now, just know that we use DLLs known
    instruction sets to jump to our shell code. From this area of memory, the other
    components are less important for our exploitation techniques highlighted here,
    but you need to understand them as they are referenced in your debuggers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次执行程序和/或每次重启都可能会改变这一点。栈内存地址根据程序的需要提供，并且我们试图将我们的代码直接注入到这个运行函数的栈中。因此，我们必须利用已知和可重复的目标指令集。我们将详细解释这个过程，但现在，只需知道我们使用DLL已知的指令集来跳转到我们的shell代码。在这个内存区域，其他组件对我们在这里突出的利用技术来说不那么重要，但你需要理解它们，因为它们在你的调试器中被引用。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The PE can be better understood from the following two older articles, *Peering
    Inside the PE: A Tour of the Win32 Portable Executable File Format*, found here
    [https://msdn.microsoft.com/en-us/magazine/ms809762.aspx](https://msdn.microsoft.com/en-us/magazine/ms809762.aspx),
    and An In-Depth Look into the Win32 Portable Executable File Format, found here
    [https://msdn.microsoft.com/en-us/magazine/cc301805.aspx](https://msdn.microsoft.com/en-us/magazine/cc301805.aspx).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'PE可以从以下两篇较旧的文章中更好地理解，*Peering Inside the PE: A Tour of the Win32 Portable Executable
    File Format*，在这里找到[https://msdn.microsoft.com/en-us/magazine/ms809762.aspx](https://msdn.microsoft.com/en-us/magazine/ms809762.aspx)，以及An
    In-Depth Look into the Win32 Portable Executable File Format，在这里找到[https://msdn.microsoft.com/en-us/magazine/cc301805.aspx](https://msdn.microsoft.com/en-us/magazine/cc301805.aspx)。'
- en: Understanding the process environment block
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解进程环境块
- en: The **Process Environment Block** (**PEB**) is where nonkernel components of
    a running process are stored. Information that is needed by systems that should
    not have access to kernel components is stored in memory. Some **Host Intrusion
    Prevention Systems** (**HIPS**) monitor activities in this memory region to see
    if malicious activities are taking place. The PEB contains details related to
    the loaded DLLs, executables, access restrictions, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程环境块**（**PEB**）是存储运行进程的非内核组件的地方。存储在内存中的是系统不应该访问内核组件的信息。一些**主机入侵防护系统**（**HIPS**）监视这个内存区域的活动，以查看是否发生了恶意活动。PEB包含与加载的DLL、可执行文件、访问限制等相关的详细信息。'
- en: Understanding the thread environment block
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解线程环境块
- en: A **Thread Environment Block (TEB)** is spawned for each thread that a process
    has established. The first thread is known as the primary thread and each thread
    after that has its own TEB. Each TEB share the memory allocations of the process
    that initiated them, but they can execute instructions in a manner that makes
    task completion more efficient. Since writeable access is required, this environment
    resides in the nonkernel block of the memory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程建立的线程都会生成一个**线程环境块（TEB）**。第一个线程被称为主线程，之后的每个线程都有自己的TEB。每个TEB共享启动它们的进程的内存分配，但它们可以以使任务完成更有效的方式执行指令。由于需要可写访问权限，这个环境驻留在内存的非内核块中。
- en: Kernel
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核
- en: This is the area of memory reserved for device drivers, the **Hardware Access
    Layer (HAL)**, the cache and other components that programs do not need direct
    access to. The best way to understand the kernel is that this is the most critical
    component of the OS. All communication is brokered as necessary through OS features.
    The attacks we are highlighting here do not depend on a deep understanding of
    the kernel. Additionally, a deep understanding of the Windows kernel would take
    a book of its own. After defining the memory locations, we have to understand
    how data is addressed within it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为设备驱动程序、**硬件访问层（HAL）**、缓存和程序不需要直接访问的其他组件保留的内存区域。理解内核的最佳方法是，这是操作系统最关键的组件。所有通信都是通过操作系统功能必要地进行的。我们在这里突出的攻击并不依赖于对内核的深入理解。此外，对Windows内核的深入理解需要一本专门的书。在定义内存位置之后，我们必须理解数据在其中的寻址方式。
- en: Understanding memory addresses and endianness
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存地址和字节序
- en: When looking at the memory, the data is represented in hexadecimal characters
    0 - F, each of which represents a value of 0 - 15\. For example, the value 0 in
    hexadecimal would be represented as 0000 in binary and the representation of F
    would be 1111 in binary.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 观察内存时，数据用十六进制字符0- F表示，每个字符代表0-15的值。例如，十六进制中的值0将被表示为二进制的0000，而F的表示将是二进制的1111。
- en: Using hexadecimal makes it easier to read memory addresses and easier to write
    them as well. Since we have 32-bit memory addresses, there would be 32 positions
    for specific bits. Since each hexadecimal value represents four bits, the equivalent
    representation can be done in eight hexadecimal characters. Keep in mind these
    hexadecimal characters are paired so that they represent four pairs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制使得阅读内存地址更容易，也更容易编写。由于我们有32位内存地址，因此会有32个位置用于特定位。由于每个十六进制值代表四位，等价表示可以用八个十六进制字符完成。请记住这些十六进制字符是成对出现的，以便它们代表四对。
- en: Intel x86 platforms use a little endian notation for the memory addressing,
    which means the least significant byte comes first. The memory address you read
    has to be reversed to generate the little endian equivalent. To understand manual
    conversion to little endian, take a look at the following image and note that
    you are reversing the order of the pairs, not the pairs themselves. This is because
    the pair represents a byte, and we order by the least significant byte first,
    not the bit, if that was the case the hexadecimal character would change as well,
    unless it was an A or F.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Intel x86平台使用小端表示法来进行内存寻址，这意味着最不重要的字节先出现。你读取的内存地址必须被反转以生成小端等价表示。要理解手动转换为小端，看一下下面的图片，注意你是在反转对的顺序，而不是对本身。这是因为对代表一个字节，我们按照最不重要的字节先出现的顺序，而不是位，如果是这种情况，十六进制字符也会改变，除非它是A或F。
- en: '![Understanding memory addresses and endianness](img/B04315_08_4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![理解内存地址和字节序](img/B04315_08_4.jpg)'
- en: Do not worry we have a cheat, you will often see that Perl exploits written
    with specific memory addresses loaded into variables with a `pack('V', 0xaa01f24d)`.
    This is a neat feature of Perl that allows you to load memory values in little
    endian notation directly into a variable. Python's equivalent is `struct.pack('<I',
    0xaa01f24d)`, which makes representation of memory addresses much simpler. If
    you look at your Metasploit modules, you can see the intended action as well represented
    in this manner `[target['Ret']].pack('V')`. This provides the return action for
    the specified target based on the memory address passed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，我们有一个小技巧，你经常会看到Perl利用程序中加载到变量中的特定内存地址的`pack('V', 0xaa01f24d)`。这是Perl的一个很好的特性，它允许你直接将小端表示的内存值加载到一个变量中。Python的等价表示是`struct.pack('<I',
    0xaa01f24d)`，这使得内存地址的表示更简单。如果你查看你的Metasploit模块，你可以看到以这种方式表示的预期操作`[target['Ret']].pack('V')`。这提供了基于传递的内存地址的指定目标的返回操作。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You know when you run your exploit in Metasploit and you chose a target such
    as Windows XP SP3 or Windows 2008 R2\. That target is usually the specific memory
    address for the EIP to use to call a specific action. Typically, it is `jmp esp`
    to execute the injection, you will see more about reversing Metasploit modules
    later in this Chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Metasploit中运行你的利用程序并选择目标，比如Windows XP SP3或Windows 2008 R2时。该目标通常是EIP要使用的特定内存地址，用于调用特定操作。通常情况下，它是`jmp
    esp`来执行注入，稍后在本章中你将看到更多关于逆向Metasploit模块的内容。
- en: We mentioned earlier that we are trying to overwrite the EIP register with a
    memory value that points to an instruction. That instruction will be chosen based
    on what data we can overwrite while we are building our exploit. The EIP is the
    one area in your exploit code, where you have to worry about Endianness; the rest
    of the exploit is straight forward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，我们试图用指向指令的内存值覆盖EIP寄存器。这个指令将根据我们在构建利用程序时可以覆盖的数据来选择。EIP是你的利用代码中唯一需要担心字节序的地方；其余的利用程序都很直接。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The naming concept of **Little Endian** and **Big Endian** came from *Jonathan
    Swift's book Gulliver's Travels*. As a simple synopsis of the book, the Little
    Endians believed in breaking eggs from the small side of the egg and the Big Endians
    believed in breaking their eggs from the big side. This same concept is what has
    been applied to memory structure naming conventions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**小端**和**大端**的命名概念来自*乔纳森·斯威夫特的《格列佛游记》*。简单概括这本书，小端人相信从蛋的小一侧打破蛋壳，而大端人相信从蛋的大一侧打破蛋壳。这个概念也被应用到了内存结构的命名约定中。'
- en: Understanding the manipulation of the stack
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解堆栈的操作
- en: To understand what we are trying to do with the writing of the exploit, you
    must understand what is happening in memory. We are going to inject data into
    an area of memory where there was no bound checking. This usually means that a
    variable was declared a specific size, and when data was copied into that variable
    there was no verification that the data would fit in it before copying.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们在编写利用程序时要做的事情，你必须理解内存中发生了什么。我们将向内存的一个区域注入数据，而该区域没有边界检查。这通常意味着一个变量声明了一个特定的大小，当数据被复制到该变量时，没有验证数据是否适合在复制之前。
- en: This means that more data can be placed in a variable than what was intended.
    When that happens, the excess data spills into the stack and overwrites saved
    values. One of those saved values includes the EIP. The image below highlights
    how the injected data is pushed onto the stack and can move to overwrite the saved
    values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以将更多的数据放入一个变量中，超出预期的数据会溢出到堆栈并覆盖保存的值。其中一个保存的值包括EIP。下面的图片突出显示了注入数据是如何推送到堆栈上并移动以覆盖保存的值的。
- en: '![Understanding the manipulation of the stack](img/B04315_08_5.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈的操作](img/B04315_08_5.jpg)'
- en: 'We are going to flood the stack with a variety of characters to determine the
    area we need to overwrite. First, we will start with a large set of As, Bs, and
    Cs. The values we see while viewing our debugger data will tell us where on the
    stack we have landed. The differences in character types will help us better determine
    what size our unique character test needs to be. The following figure shows the
    combination of As, Bs, and Cs (that do not appear) on the stack as we overwrite
    it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用各种字符来淹没堆栈，以确定我们需要覆盖的区域。首先，我们将从一组大量的A、B和C开始。在查看调试器数据时看到的数值将告诉我们我们所着陆的堆栈位置。字符类型的差异将帮助我们更好地确定我们独特字符测试的大小需求。下图显示了我们覆盖堆栈时A、B和C的组合（未显示）：
- en: '![Understanding the manipulation of the stack](img/B04315_08_6.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈的操作](img/B04315_08_6.jpg)'
- en: Now after getting a general idea of where the EIP is, we can generate a unique
    patter with the size of the As and Bs added together. This unique pattern will
    be injected back into the vulnerable program. We can then take the unique value
    that overwrites the EIP register and compare it to our pattern. We determine how
    far down our large unique pattern that value falls and determine that is how much
    data is needed be pushed onto the stack to reach the EIP.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在大致了解EIP的位置后，我们可以生成一个大小为A和B相加的唯一模式。这个唯一模式将被注入回易受攻击的程序。然后我们可以取覆盖EIP寄存器的唯一值，并将其与我们的模式进行比较。我们确定我们的大型唯一模式中该值所在的位置，并确定需要推送到堆栈上的数据量，以达到EIP。
- en: Once we have identified where the EIP is, we can locate the instruction we want
    to reference in the EIP by examining the DLLs. Remember, DLLs that are a part
    of the program itself will be more portable, and your exploit will work in more
    than one version of Windows. Windows OS DLLs make writing exploits easier, because
    they are omnipresent and have the required instructions you are looking for.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了EIP的位置，我们可以通过检查DLL来定位EIP中要引用的指令。请记住，程序本身的DLL将更具可移植性，并且您的利用程序将在多个Windows版本中运行。Windows操作系统的DLL使编写利用程序变得更容易，因为它们是无处不在的，并且具有您正在寻找的所需指令。
- en: In this version of the exploit, we are trying to Jump to the ESP as the available
    space is there, and it is easy to build an exploit to take advantage of it. If
    we were using one of the other registers, we would have to look for an instruction
    to jump to that register. We will then have to determine how much space is available
    from the manipulated register down to the EIP. That will help determine how much
    data needs to be filled in that area of the stack, as our shellcode will only
    fill in a small part of that area.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个利用程序的版本中，我们试图跳转到ESP，因为可用空间在那里，并且很容易构建一个利用程序来利用它。如果我们使用其他寄存器，我们将不得不寻找一个指令来跳转到该寄存器。然后我们将不得不确定从被操纵的寄存器到EIP有多少可用空间。这将有助于确定需要填充堆栈该区域的数据量，因为我们的shellcode只会填充该区域的一小部分。
- en: 'Knowing this, we are going to sandwich our shell code with **No Operations**
    (**NOPs**). The NOPs that sit between the shellcode and the EIP are to offset
    the injected shellcode. So when instructions are loaded into the registers, they
    are loaded in appropriate chunks. Otherwise, the shellcode will be out of place.
    Finally, the sled that is loaded last onto the stack is there to take up the rest
    of the space, so when the Jump to ESP is called the code slides down from the
    top to the actual shellcode. See the following image to have a better understanding
    of where we are moving towards:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这一点，我们将用**无操作**（**NOPs**）夹住我们的shell代码。位于shellcode和EIP之间的NOPs是为了抵消注入的shellcode。因此，当指令加载到寄存器中时，它们会以适当的块加载。否则，shellcode将错位。最后，加载到堆栈上的滑梯是为了占据剩余的空间，因此当调用Jump
    to ESP时，代码从顶部滑动到实际的shellcode。查看以下图片以更好地理解我们正在朝着的方向：
- en: '![Understanding the manipulation of the stack](img/B04315_08_7.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈的操作](img/B04315_08_7.jpg)'
- en: With this basic understanding, we can start to work with the Immunity debugger
    on a poorly created C program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本的理解，我们可以开始在一个糟糕创建的C程序上使用Immunity调试器。
- en: Understanding immunity
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解免疫
- en: We need to first start with the way Immunity is setup. Immunity is an awesome
    debugger that is based in Python. So many of the plugins to include Mona are written
    in Python, which means if you need to change something, you just modify the scripts.
    The main screen for Immunity is split into four sections, and when you hook a
    process or execute a program you can see the output of the details, as follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解Immunity的设置方式。Immunity是一个基于Python的强大调试器。许多插件，包括Mona，都是用Python编写的，这意味着如果您需要更改某些内容，只需修改脚本。Immunity的主屏幕分为四个部分，当您挂钩一个进程或执行一个程序时，您可以看到详细信息的输出，如下所示。
- en: '![Understanding immunity](img/B04315_08_8.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![理解免疫](img/B04315_08_8.jpg)'
- en: This layout is the basic appearance in which you will spend most of your time.
    You can call different windows as necessary for reviewing other running components,
    such as DLLs. We will cover more of that later, but let us start with creating
    a basic buffer overflow.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局是您将花费大部分时间的基本外观。您可以根据需要调用不同的窗口来查看其他运行组件，比如DLL。我们稍后会涵盖更多内容，但让我们先从创建一个基本的缓冲区溢出开始。
- en: Understanding basic buffer overflow
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本缓冲区溢出
- en: The following C code lacks appropriate bound checking to enforce variable size
    restrictions on a copy. This is a rudimentary example of poor programming, but
    it is the basis for many exploits that are part of the Metasploit framework.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C代码缺乏适当的边界检查，以强制在复制时对变量大小施加限制。这是一个简单的糟糕编程的例子，但它是Metasploit框架中许多利用程序的基础。
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We take this code and place it into a file called `username_test.cpp`, and
    then compile it with MinGW, as shown following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码放入一个名为`username_test.cpp`的文件中，然后使用MinGW编译它，如下所示：
- en: '![Understanding basic buffer overflow](img/B04315_08_9.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_9.jpg)'
- en: We can then run newly compiled program to see it returns whatever text we provide
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行新编译的程序，看它是否返回我们提供的任何文本。
- en: '![Understanding basic buffer overflow](img/B04315_08_10.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_10.jpg)'
- en: Now, start Immunity and open the `username_test.exe` binary with the argument
    test, as seen below. This does functionally the same thing as both the Python
    script and running it from the command line, which means that you can monitor
    the output from the debugger.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Immunity并使用测试参数打开`username_test.exe`二进制文件，如下所示。这与Python脚本和从命令行运行的功能相同，这意味着您可以监视调试器的输出。
- en: '![Understanding basic buffer overflow](img/B04315_08_11.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_11.jpg)'
- en: Now, we need to provide more data than expected and attempt to trigger an overflow.
    This could easily be done here as we know the limits for this particular binary,
    but if we did not know this, we would have to take a relative guess. To do that,
    we should generate some data, such as a bunch of capital As, and see what happens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提供比预期更多的数据，并尝试触发溢出。这在这里很容易做到，因为我们知道这个特定二进制文件的限制，但如果我们不知道这一点，我们将不得不进行相对猜测。为此，我们应该生成一些数据，比如一堆大写A，然后看看会发生什么。
- en: We could either repeatedly hold down the *Shift* key plus the letter A each
    time we wanted to generate the arguments, or we can create a generator to do a
    similar activity. We can, again, use Python to help us out here. See the simple
    code, which will create files of data as needed, which can be copied and pasted
    into the debugger.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以每次想要生成参数时，要么重复按住*Shift*键再按字母A，要么创建一个生成器来进行类似的活动。我们可以再次使用Python来帮助我们。看看下面的简单代码，它将根据需要创建数据文件，可以复制并粘贴到调试器中。
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of which can be seen in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下图所示：
- en: '![Understanding basic buffer overflow](img/B04315_08_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_12.jpg)'
- en: Now, copy and paste the data into the Immunity debugger arguments and step through
    the program as it runs with the *F7* key. After holding the key down for a period
    of time, you will start to see your binary run with the arguments provided as
    it is processed in the Registers Pane, and as it is processed, 41414141 will be
    picked up in the EAX register. Each of the 41 represents the **American Standard
    Code for Information Interchange** (**ASCII**) letter A. Once you finish running
    the program, you should see the EIP overflowed with the letter A.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将数据复制并粘贴到Immunity调试器参数中，并使用*F7*键逐步运行程序。按住键一段时间后，您将开始看到二进制文件以提供的参数运行，并在寄存器窗格中处理时，EAX寄存器中将捕获到41414141。每个41代表**美国信息交换标准代码**（**ASCII**）的字母A。运行程序结束后，您应该看到EIP被字母A溢出。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The memory addresses you will see in this example will be different than those
    in your own environment, so you need to make sure to generate your final script
    with your memory addresses, not what you see in these images.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将看到的内存地址与您自己的环境中的地址不同，因此您需要确保使用您的内存地址生成最终脚本，而不是使用这些图像中看到的地址。
- en: '![Understanding basic buffer overflow](img/B04315_08_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_13.jpg)'
- en: So, we know that we have provided enough As to overwrite the EIP. This means
    that we have found that we can overwrite the EIP, but we have not provided it
    with anything useful to do, and we do not know where it actually is in the stack.
    Basically, this means that this activity crashed our program instead of doing
    what we wanted to - get a shell.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道我们提供了足够的A来覆盖EIP。这意味着我们已经发现我们可以覆盖EIP，但我们没有为其提供任何有用的内容，并且我们不知道它实际上在堆栈中的位置。基本上，这意味着这个活动使我们的程序崩溃，而不是我们想要的
    - 获得一个shell。
- en: This brings up another point about crafting exploits; often exploits that are
    not well designed, or cannot be designed to work in the memory constraints in
    particular vulnerabilities, will produce a **Denial of Service** (**DoS**) condition.
    Our goal instead is to get a shell on the box, and to do that, we need to manipulate
    what is being pushed into the program. Keep in mind that when you consider services,
    there have been reports of **Remote Code Execution** (**RCE**) attacks available,
    and the only public exploits available result in DoS attacks. This means that
    the environment is very difficult to achieve shell access, or the researcher's
    capabilities to create an exploit in that environment may be limited.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了关于制作利用程序的另一个问题；通常，设计不良的利用程序，或者无法设计以在特定漏洞的内存限制中工作的利用程序，将产生**拒绝服务**（**DoS**）条件。我们的目标是在计算机上获得shell，为此，我们需要操纵推送到程序中的内容。请记住，当您考虑服务时，有关**远程代码执行**（**RCE**）攻击的报告可用，而唯一可用的公开利用程序会导致DoS攻击。这意味着很难在该环境中实现shell访问，或者研究人员在该环境中创建利用程序的能力可能受到限制。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As you go along, if your registers have errors, such as the one in the following
    figure, you have not properly determined your buffer size for follow on development.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行过程中，如果您的寄存器出现错误，例如下图中的错误，那么您没有正确确定后续开发的缓冲区大小。
- en: '![Understanding basic buffer overflow](img/B04315_08_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本缓冲区溢出](img/B04315_08_14.jpg)'
- en: Now that you understand the basics of injecting data into the buffer and overflowing
    it, we can target a real vulnerable solution. We are going to use the Free MP3
    CD Ripper program for this example. This program provides very little tangible
    value in developing an exploit, but developing it is a relatively simple exercise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了将数据注入缓冲区并溢出的基础知识，我们可以针对一个真正易受攻击的解决方案。我们将使用Free MP3 CD Ripper程序作为示例。这个程序在开发利用程序方面提供了非常少的实际价值，但开发它是一个相对简单的练习。
- en: Writing a basic buffer overflow exploit
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本缓冲区溢出利用
- en: We are going to exploit version 1 of the Free MP3 CD Ripper software program.
    To do this, we need to download and install the product from this location [http://free-mp3-cd-ripper.en.softonic.com/](http://free-mp3-cd-ripper.en.softonic.com/).
    To take advantage of this program's weakness, we are going to use the following
    Python script, which will generate a malicious .wav file that can be uploaded
    into the program. The data will be interpreted and will create an overflow condition
    that we can observe and attempt to tailor and build an exploit. As mentioned before,
    we are going to load up a number of different characters into this file so that
    we can guestimate the relative location of the stored EIP value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Free MP3 CD Ripper软件程序的版本1。为此，我们需要从以下位置下载并安装该产品[http://free-mp3-cd-ripper.en.softonic.com/](http://free-mp3-cd-ripper.en.softonic.com/)。为了利用该程序的弱点，我们将使用以下Python脚本，它将生成一个恶意的.wav文件，可以上传到该程序中。数据将被解释，并将创建一个我们可以观察并尝试调整和构建利用的溢出条件。如前所述，我们将加载多种不同的字符到该文件中，以便我们可以估计存储的EIP值的相对位置。
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This script will fill the malicious wave file with four thousand As, one thousand
    Bs, and one thousand Cs. Now, open the program with Immunity, as shown following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将用四千个A，一千个B和一千个C填充恶意的波形文件。现在，打开Immunity程序，如下所示：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_15.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_15.jpg)'
- en: 'Generate the malicious wave file with your new Python script, as shown following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的新Python脚本生成恶意的波形文件，如下所示：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_16.jpg)'
- en: 'Then, load up the new file with the vulnerable program, as shown following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，加载具有易受攻击程序的新文件，如下所示：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_17.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_17.jpg)'
- en: The results of this is that we get a crash solidly in the Bs, as seen below,
    which means our EIP overwrite is somewhere between four thousand and five thousand
    characters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们得到了一个坚实的Bs崩溃，如下所示，这意味着我们的EIP覆盖在四千到五千个字符之间。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_19.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_19.jpg)'
- en: Additionally, we see that we have Bs in EBX, EBP, ESI, and EDI, but what about
    ESP? We need to find room to place our shell code, and the easiest way to do that
    is to work with ESP. So, what we will do is dump the contents of that register—you
    do this by right clicking on the register and viewing the details in the bottom-left
    corner pane of Immunity as show by the two image components.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们看到EBX、EBP、ESI和EDI中都有Bs，但ESP呢？我们需要找到放置我们的shell代码的空间，最简单的方法是使用ESP。所以，我们将转储该寄存器的内容——您可以通过右键单击寄存器并在Immunity的左下角窗格中查看详细信息来执行此操作，如两个图像组件所示。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_20.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_20.jpg)'
- en: As you can see, we have filled the ESP with Bs as well. We need to narrow down
    the locations that we can place our shellcode and location of EIP, so we are going
    to use Metasploit's `pattern_create.rb`. First, we need to find the EIP, so we
    are going to generate five thousand unique characters. When you use this script,
    you will be able to inject the data, and then identify the exact location of the
    overwrite. The figure below highlights how to generate a unique data set generation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们也用Bs填充了ESP。我们需要缩小可以放置我们的shellcode和EIP位置的位置，因此我们将使用Metasploit的`pattern_create.rb`。首先，我们需要找到EIP，所以我们将生成五千个唯一的字符。当您使用此脚本时，您将能够注入数据，然后确定覆盖的确切位置。下图突出显示了如何生成唯一数据集。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_22.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_22.jpg)'
- en: Now, copy the characters out of the output file, and feed them into the program
    again as a new `.wav` file. When we load the new `.wav` file in, we see the program
    again crashes and a value overwrites the EIP.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将字符从输出文件中复制出来，并将它们作为新的`.wav`文件再次输入程序。当我们加载新的`.wav`文件时，我们看到程序再次崩溃，并且一个值覆盖了EIP。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_23.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_23.jpg)'
- en: We need to copy that value and use it to determine the actual offset needed
    for our exploit using the `patter_offset.rb` script by feeding in the memory address
    and the number of characters that we originally asked for.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复制该值，并使用它来确定我们的利用所需的实际偏移量，使用`patter_offset.rb`脚本，通过输入内存地址和我们最初请求的字符数。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_24.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_24.jpg)'
- en: 'So, now we update our fill variable to that value. We have to verify that this
    junk data is going to cause us to land directly on the EIP so that it can be overwritten.
    A test case can be executed to verify that we have pinpointed the EIP by setting
    it explicitly using the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们将我们的填充变量更新为该值。我们必须验证这些垃圾数据是否会导致我们直接落在EIP上，以便可以被覆盖。可以执行一个测试用例来验证我们已经准确找到了EIP，通过使用以下代码明确设置它：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of that code produces the following results, which means that we
    have pinpointed our EIP location:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的输出产生了以下结果，这意味着我们已经准确找到了EIP的位置：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_25.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_25.jpg)'
- en: Now, remember that we verified we overwrote the ESP during our testing. We are
    going to use the area between the ESP and EIP to hold our shell code. So, we are
    looking for the command `jmp esp`, and we are going to use Microsoft's shared
    libraries to do so. The DLLs are loaded and reused throughout each program cycle.
    That means that we can look at DLLs the program uses and attempt to find a memory
    location that can be used to reference the `jmp esp` command. We can then replace
    the EIP value with the memory location of the `jmp esp` instruction from a viable
    DLL.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住我们在测试中验证了我们覆盖了ESP。我们将使用ESP和EIP之间的区域来保存我们的shellcode。因此，我们正在寻找 `jmp esp`
    命令，并且我们将使用微软的共享库来实现。DLL在每个程序周期中都会被加载和重复使用。这意味着我们可以查看程序使用的DLL，并尝试找到一个可以用来引用 `jmp
    esp` 命令的内存位置。然后，我们可以用可行的DLL中 `jmp esp` 指令的内存位置替换EIP值。
- en: 'If you hit the *Alt* + *E*, you will be provided a new window, which contains
    the entire affected program DLLs and the system DLLs. See the following screenshot,
    which highlights those DLLs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下 *Alt* + *E*，你将会看到一个新窗口，其中包含了整个受影响的程序DLL和系统DLL。请看下面的截图，突出显示了这些DLL：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_26.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_26.jpg)'
- en: Program and the system DLLs
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 程序和系统DLL
- en: 'We double-click the `kernel32.dll`, and then right-click to search for a specific
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `kernel32.dll`，然后右键搜索特定命令：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_27.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_27.jpg)'
- en: Once we click on the command, we search for the operation instruction set `jmp
    esp`, which tells the program to jump to ESP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击命令，我们搜索操作指令集 `jmp esp`，它告诉程序跳转到ESP。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_28.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_28.jpg)'
- en: 'We copy the results and get the following information:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们复制结果并获得以下信息：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we set the EIP to the address discovered. This address is a good target
    address because there are no bad characters, such as "\x00". Those characters
    would actually stop the complete execution of our code. There are a number of
    ways to test for bad characters, but there are a few standards we try to avoid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将EIP设置为发现的地址。这个地址是一个很好的目标地址，因为没有坏字符，比如 "\x00"。这些字符实际上会阻止我们的代码完全执行。有很多方法可以测试坏字符，但有一些标准我们尽量避免。
- en: Null ("\x00")
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符 ("\x00")
- en: Form Feed ("\xFF")
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换页符 ("\xFF")
- en: Tab ("\x09")
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制表符 ("\x09")
- en: Line Feed ("\x0A")
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换行符 ("\x0A")
- en: Carriage Return ("\x0D")
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回车符 ("\x0D")
- en: Other characters can be tested for by fuzzing the application with lists of
    potentially bad characters. You inject these lists of character sets from "\x00"
    to "\xFF". When you see the application crash, you have identified a bad character.
    Delete the character from the tuple, store the value, and try again. Once this
    executes without crashing the attack via a bad character, you have determined
    all the viable bad characters. We can test for bad characters after we determine
    how big our remaining stack space is and the offset.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字符可以通过使用潜在的坏字符列表对应用程序进行模糊测试来进行测试。你可以将这些字符集列表从 "\x00" 到 "\xFF" 注入进去。当你看到应用程序崩溃时，你已经确定了一个坏字符。删除元组中的字符，存储该值，然后再试一次。一旦通过一个坏字符执行而不崩溃，你就确定了所有可行的坏字符。在确定了剩余的堆栈空间有多大和偏移量之后，我们可以测试坏字符。
- en: Next is the identification of the stack offset space. It would be ineffective
    to place the shellcode right after the EIP value in the exploit script. That may
    cause characters to be read out of order and, in turn, cause shellcode failure.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是识别堆栈偏移空间。在利用脚本中将shellcode放在EIP值后面是无效的。这可能导致字符被无序读取，进而导致shellcode执行失败。
- en: This is because if we jumped to the ESP and we did not take into consideration
    the slack space, we might offset the code. This means that full instruction sets
    would not be interpreted holistically. This would mean that our code would not
    execute properly. Additionally, if we were imprecise and stuck a ton of NOP data
    between the EIP and ESP, you may take up valuable space that could be used for
    your shellcode. Remember that stack space is limited, so being precise is beneficial.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果我们跳转到ESP而没有考虑到空隙，我们可能会偏移代码。这意味着完整的指令集将无法被整体解释。这意味着我们的代码将无法正确执行。此外，如果我们不精确并在EIP和ESP之间插入大量NOP数据，你可能会占用可用于shellcode的宝贵空间。记住，堆栈空间是有限的，所以精确是有益的。
- en: To test for this, we can write a quick generator script, so we are not messing
    with our actual exploit script. This script helps us test for slack space between
    the EIP and the ESP.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以编写一个快速生成器脚本，这样我们就不会影响我们的实际利用脚本。这个脚本帮助我们测试EIP和ESP之间的空隙。
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We then run the same `pattern_create.rb` script, but just use 1000 characters
    instead of 5000\. Stick the output data into the data variable and run the generator
    script. Load the `exploit.wav` file into the program while monitoring it with
    Immunity, as done before. When the program again crashes, look at the dump of
    the ESP.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行相同的 `pattern_create.rb` 脚本，但只使用1000个字符而不是5000个。将输出数据放入数据变量并运行生成器脚本。在监视程序的同时加载
    `exploit.wav` 文件，就像之前一样。当程序再次崩溃时，查看ESP的转储。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_29.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本缓冲区溢出利用](img/B04315_08_29.jpg)'
- en: When you view the dump, you will see that ten characters are offset initially.
    This means to make the execution of this code more reliable, we need to add a
    NOP of ten or more characters between the EIP and the shellcode. Now, we need
    to determine how much space we have in this location of the stack to inject our
    code. We look at our memory dump and we find the difference between the beginning
    and ending addresses to determine how much room we have. Taking the two addresses,
    we find that we have limited space to play with roughly - 320 bytes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看转储时，你会发现最初偏移了十个字符。这意味着为了使这段代码的执行更可靠，我们需要在EIP和shellcode之间添加十个或更多个字符的NOP。现在，我们需要确定在堆栈的这个位置有多少空间可以注入我们的代码。我们查看我们的内存转储，并找到开始和结束地址之间的差异，以确定我们有多少空间。通过取两个地址，我们发现我们有大约320字节的有限空间可以使用。
- en: If we were doing a single stage payload, there are a number of steps we can
    execute to verify that we are going to stay in range. We are doing a multiple
    stage payload, though, which means we need to have more than the space provided.
    This means we need to modify the stack size in real time, but before that, we
    should confirm that we can get code execution, and you need to understand what
    running out of stack space looks like.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在执行单阶段有效负载，有一些步骤我们可以执行来验证我们是否会保持在范围内。然而，我们正在执行多阶段有效负载，这意味着我们需要比提供的空间更多。这意味着我们需要实时修改堆栈大小，但在那之前，我们应该确认我们可以获得代码执行，并且你需要了解堆栈空间耗尽的情况是什么样的。
- en: Now that we know our stack space and our offset, we can adjust the script to
    search for potential bad characters. Next, we add a NOP sled at the end of the
    code to ensure the execution of the Jump to ESP slides until it hits executable
    code. We do this by calculating the entire area that we have to play with and
    subtracting the offset and the shellcode from it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的堆栈空间和偏移量，我们可以调整脚本以搜索潜在的恶意字符。接下来，我们在代码末尾添加一个NOP滑梯，以确保执行Jump to ESP直到它触及可执行代码。我们通过计算我们可以使用的整个区域，并从中减去偏移量和shellcode来实现这一点。
- en: We then create a NOP sled that takes up the remaining area. The easiest way
    to execute this is by using an equation similar to this `nop = "\x90"*(320-len(shell)-len(offset))`.
    The updated Python code looks like the following. Using the Python following script
    we can test for bad characters; note that we had to do this after our initial
    sizing because our areas of issue are going to be in the remaining stack space.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个占据剩余空间的NOP滑梯。执行这个最简单的方法是使用类似于这个方程的方程`nop = "\x90"*(320-len(shell)-len(offset))`。更新后的Python代码如下所示。使用以下Python脚本，我们可以测试恶意字符；请注意，我们必须在初始大小之后进行这样做，因为我们的问题区域将在剩余的堆栈空间中。
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We should generate our mock shellcode that the program is going to jump to.
    For an initial test case, you want to start with a simple example that will not
    have any other dependencies. So, we can tell the injected code to call an instance
    of `calc.exe`. To do that, all we have to do is use `msfvenom` to generate the
    shell code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该生成我们的模拟shellcode，程序将跳转到这里。对于一个初始测试案例，你希望从一个简单的例子开始，它不会有任何其他依赖关系。所以，我们可以告诉注入的代码调用一个`calc.exe`的实例。要做到这一点，我们只需要使用`msfvenom`来生成shellcode。
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What this does is generate the shellcode in a format that can be placed in a
    Python tuple and removes potential bad characters `'\x00'`, `'\xff'`. Tools like
    `msfvenom` do this for us automatically by using encoders. An encoder's purpose
    is to remove bad characters; there is a big misconception that they are used to
    bypass HIPS like antivirus.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是生成可以放置在Python元组中的shellcode，并删除潜在的恶意字符`'\x00'`，`'\xff'`。像`msfvenom`这样的工具会自动使用编码器来完成这项工作。编码器的目的是删除恶意字符；有一个很大的误解，即它们用于绕过像防病毒软件这样的HIPS。
- en: Years ago, basic signature analysis in HIPS might have not caught an exploit
    because it did not match a very specific signature. Today, security tool developers
    have gotten better and triggers are more analytical by design. So, the fallacy
    of encoders helping stop HIPS solutions from catching an exploit are finally dying
    off.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，在HIPS中进行基本的签名分析可能没有捕获到利用程序，因为它没有匹配一个非常具体的签名。今天，安全工具开发人员已经变得更加优秀，触发器更具分析性。因此，编码器帮助阻止HIPS解决方案捕获利用程序的谬论最终正在消失。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_30.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用程序](img/B04315_08_30.jpg)'
- en: 'Our new exploit with the `calc.exe` code can be seen as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新利用程序与`calc.exe`代码如下所示：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We then run the code to generate the new malicious `.wav` file, and then load
    it into the program to see if the EIP is overwritten and the `calc.exe` binary
    is executed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行代码生成新的恶意`.wav`文件，然后将其加载到程序中，看看EIP是否被覆盖，并且`calc.exe`二进制文件是否被执行。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_31.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用程序](img/B04315_08_31.jpg)'
- en: So now that the basic exploit written, we can update it to establish a session
    shell through this weakness. First, we need to determine what payload size would
    be best for our exploit. This stack space overall is limited, so we can try and
    minimize our footprint initially, but as you will see this will not matter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本的利用程序已经编写好了，我们可以更新它以通过这个弱点建立一个会话shell。首先，我们需要确定对我们的利用程序来说最合适的有效负载大小。总的来说，这个堆栈空间是有限的，所以我们可以尝试最小化我们的足迹，但正如你将看到的那样，这并不重要。
- en: You can generate your payloads by guessing and checking with `msfvenom` and
    the `-s` flag, but this is inefficient and slow. You will find that as payloads
    are generated, they may not be compatible based on the payload type you choose
    and the encoders needed to remove bad characters and size the package, appropriately.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过猜测和使用`msfvenom`和`-s`标志来生成你的有效负载，但这是低效和缓慢的。你会发现，随着有效负载的生成，它们可能根据你选择的有效负载类型和需要删除恶意字符和调整包大小的编码器而不兼容。
- en: 'Instead of playing the guessing game, we can determine a good starting point
    by running the `payload_lengths.rb` script in the `/usr/share/metasploit-framework/tools`
    directory. These scripts provides great details about the payload lengths, but
    consider that we are looking for small payloads below 300 characters if possible.
    So, we can run the script awk for the size of the payload and grep for payloads
    that are used in Windows environments, as shown following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不要玩猜谜游戏，我们可以通过在`/usr/share/metasploit-framework/tools`目录中运行`payload_lengths.rb`脚本来确定一个好的起点。这些脚本提供了有关有效负载长度的详细信息，但请考虑我们正在寻找可能小于300个字符的小有效负载。因此，我们可以运行awk脚本来查找有效负载的大小，并使用grep来查找在Windows环境中使用的有效负载，如下所示：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_32.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用](img/B04315_08_32.jpg)'
- en: 'There were just under 40 results from this commands output, but some good options
    include the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出结果只有不到40个，但一些好的选项包括以下内容：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_33.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用](img/B04315_08_33.jpg)'
- en: On our Metasploit instance, we startup `exploit/multi/handler` that will receive
    the shell.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Metasploit实例上，我们启动`exploit/multi/handler`，它将接收shell。
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_34.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用](img/B04315_08_34.jpg)'
- en: Then, we generate our new shell code a `windows/meterpreter/reverse_nonx_tcp`
    and replace our calculator code with it. We choose this payload type because it
    is a very small Meterpreter, which means that since we know our memory footprint
    could be limited, we have a better chance of success with this exploit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成我们的新shell代码`windows/meterpreter/reverse_nonx_tcp`，并用它替换我们的计算器代码。我们选择这种有效负载类型，因为它是一个非常小的Meterpreter，这意味着由于我们知道我们的内存占用可能受限，我们有更好的机会成功利用这个漏洞。
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These examples have additional bad characters listed in them. Out of habit,
    I usually leave these in when generating payloads. Keep in mind the more bad characters
    you have, the more the encoder has to add operations that do functionally equivalent
    manipulations. This means as you encode more, your payload usually gets bigger.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子中列出了额外的坏字符。出于习惯，我通常在生成有效负载时将这些字符保留下来。请记住，您拥有的坏字符越多，编码器就必须添加执行功能等效操作的操作越多。这意味着随着您的编码越多，您的有效负载通常会变得更大。
- en: 'The output of the command is as follows, and it only has a size of 204 bytes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下，只有204字节的大小：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_35.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用](img/B04315_08_35.jpg)'
- en: 'When placed in the exploit code, we get the following Python exploit:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在利用代码中，我们得到以下Python利用程序：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When executed, we get following results, which shows the exploit generating
    a shell:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下结果，显示利用程序生成了一个shell：
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_36.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本的缓冲区溢出利用](img/B04315_08_36.jpg)'
- en: Now, this example is simple and it may provide a local exploit to the system,
    but there is an issue our exploit fails because it runs out of space. As mentioned
    previously, we have to adjust the area where we are placing our shell code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个例子很简单，它可能为系统提供一个本地利用，但有一个问题，我们的利用失败了，因为空间不够。如前所述，我们必须调整我们放置shell代码的区域。
- en: Understanding stack adjustments
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解堆栈调整
- en: We showed that the code execution failed in mid-exploit because our stage two
    clobbered our stage one code in memory. So, we need more stack space to complete
    this exploit. We can either split our code up in memory if necessary or we can
    simply expand the space in the stack.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们表明代码执行在中间利用失败，因为我们的第二阶段在内存中破坏了我们的第一阶段代码。因此，我们需要更多的堆栈空间来完成这个利用。如果必要的话，我们可以在内存中分割我们的代码，或者我们可以简单地扩展堆栈中的空间。
- en: 'This is done by telling the system to add space to the ESP. You can do this
    in one of two ways: by adding negative space or subtracting positive space. The
    reason for this is because the stack grows from high address to low addresses
    as we mentioned earlier.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过告诉系统向ESP添加空间来完成的。您可以通过两种方式之一来实现这一点：通过添加负空间或减去正空间。这是因为堆栈从高地址向低地址增长，正如我们之前提到的那样。
- en: '![Understanding stack adjustments](img/B04315_08_37.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈调整](img/B04315_08_37.jpg)'
- en: So, we see that we are clobbering the shellcode with this exploit, so we can
    compensate instead by telling the ESP to move to accommodate the necessary space.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到我们正在利用中破坏shellcode，所以我们可以通过告诉ESP移动来补偿必要的空间。
- en: '![Understanding stack adjustments](img/B04315_08_38.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈调整](img/B04315_08_38.jpg)'
- en: To do this, we need to add a hexadecimal adjustment to the front of the shellcode.
    We are going to do this in two different ways. The first way we will highlight
    in this section. We will then explain the second manner of doing it as we reverse
    Metasploit payloads. First we need to figure out how to adjust the actual stack;
    we can do this with the `nasm_shell.rb in the /usr/share/metasploit-framework/tools/nasm_shell.rb`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在shellcode的前面添加一个十六进制调整。我们将以两种不同的方式来做这件事。我们将在本节中重点介绍第一种方式。然后，我们将解释第二种方式，即反向Metasploit有效负载。首先，我们需要弄清楚如何调整实际的堆栈；我们可以使用`/usr/share/metasploit-framework/tools/nasm_shell.rb`中的`nasm_shell.rb`来做到这一点。
- en: Stack adjustment of 80,000 means we are adding this value to the ESP. To do
    that, we need to calculate the ESP adjustment for 80,000, but for that calculation
    we need to change 80,000 to a hexadecimal value. The hexadecimal equivalent is
    13880.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 80,000的堆栈调整意味着我们将这个值添加到ESP。为此，我们需要计算80,000的ESP调整，但为了进行这个计算，我们需要将80,000转换为十六进制值。十六进制等价值为13880。
- en: '![Understanding stack adjustments](img/B04315_08_39.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![理解堆栈调整](img/B04315_08_39.jpg)'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the built in Windows calculator to change from decimal to hexadecimal
    in scientific mode and vice versa.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用内置的Windows计算器在科学模式下从十进制转换为十六进制，反之亦然。
- en: This means we add the following code to our exploit to adjust the stack `adjustment
    = struct.pack('<I',0x81EC80380100)`. We then prepend the shellcode with the adjustment
    value `exploit = fill + eip + offset + adjustment + shell`. Finally, we remove
    our NOP sled, since this is not filling space that our secondary stage will encompass,
    the final code would be similar to this.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在我们的漏洞利用中添加以下代码来调整堆栈`adjustment = struct.pack('<I',0x81EC80380100)`。然后，我们在shellcode之前添加调整值`exploit
    = fill + eip + offset + adjustment + shell`。最后，我们移除我们的NOP sled，因为这不是填充我们的次级阶段将包含的空间，最终的代码将类似于这样。
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is a problem with this method though. If your stack adjustment has bad
    characters in it you would need to eliminate those by encoding it. Since you are
    not usually modifying your stack adjustment at a later point, you can make it
    part of your shell and encode the entire block of code. We will go through that
    process when we reverse a Metasploit module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法存在一个问题。如果您的堆栈调整中有坏字符，您需要通过编码来消除这些字符。由于您通常不会在以后修改您的堆栈调整，您可以将其作为您的shell的一部分，并对整个代码块进行编码。当我们反向一个Metasploit模块时，我们将通过这个过程。
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure to add a comment in your code about your stack adjustment; otherwise,
    when you try to expand this exploit or use other payloads you are going to be
    very frustrated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的代码中添加关于你的堆栈调整的注释；否则，当你尝试扩展这个漏洞利用或使用其他有效负载时，你会非常沮丧。
- en: As a side benefit, if we do this method instead of using NOP sleds, it is less
    likely that the exploit will be caught by HIPS. Now that we have done all that,
    realize there is an easier way to gain access using a standard payload.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个附带的好处，如果我们使用这种方法而不是使用NOP sleds，那么漏洞利用不太可能被HIPS捕捉到。现在我们已经做了所有这些，意识到有一种更简单的方法可以使用标准有效负载来获得访问权限。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you still need NOPs for a real exploit, make sure to use the NOP generators
    available to you through Metasploit. Instead of using "\x90" instructions, the
    code does meaningless mathematical operations. These take up space on the stack
    and provide the same capability.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然需要NOPs来进行真正的漏洞利用，确保使用Metasploit提供给你的NOP生成器。代码不使用"\x90"指令，而是进行无意义的数学运算。这些操作占用了堆栈空间，并提供了相同的功能。
- en: Understanding the purpose of local exploits
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解本地利用的目的
- en: 'It should be noted that the same access could be achieved by executing a payload
    on the system. Generating such a payload would only require us to run the following
    command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，通过在系统上执行有效负载可以实现相同的访问权限。生成这样的有效负载只需要我们运行以下命令：
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, start up a Python web server with the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令启动Python Web服务器：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following figure highlights the output of the relevant commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表突出了相关命令的输出：
- en: '![Understanding the purpose of local exploits](img/B04315_08_40.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![理解本地利用的目的](img/B04315_08_40.jpg)'
- en: Then, achieve the desired results by downloading and executing the payload through
    a browser on the victims system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过浏览器在受害者系统上下载并执行有效负载来实现期望的结果。
- en: '![Understanding the purpose of local exploits](img/B04315_08_41.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![理解本地利用的目的](img/B04315_08_41.jpg)'
- en: So you may be asking yourself, Why did we create this exploit then? If the software
    we just created this exploit for was running as an administrator instead of the
    user we were logged into, then exploiting this solution would be more useful.
    The nature of this program though this scenario is unlikely. As such, generating
    a Metasploit module for an exploit this would not be very useful. Consider instead,
    this exercise is a perfect opportunity to write your first exploit.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能会问自己，那我们为什么要创建这个漏洞利用呢？如果我们刚刚为其创建漏洞利用的软件是以管理员身份而不是我们登录的用户身份运行的，那么利用这个解决方案将更有用。然而，尽管这种情况在这个程序的性质中是不太可能的。因此，为这种漏洞生成Metasploit模块将不会很有用。相反，考虑到这一点，这个练习是写你的第一个漏洞利用的绝佳机会。
- en: There is another consideration when writing exploits, is depending on the program
    your exploit may not be reliable. This means that due to the nuances of the code
    your exploits may or may not consistently work. So, you will have to do substantive
    testing in lab environments prior to execution in real organizations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写漏洞利用时还有另一个考虑因素，那就是根据程序的不同，您的漏洞利用可能不太可靠。这意味着由于代码的细微差别，您的漏洞利用可能会时而有效，时而无效。因此，在真实组织中执行之前，您将不得不在实验环境中进行实质性的测试。
- en: Understanding other exploit scripts
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解其他漏洞利用脚本
- en: In addition to writing malicious files that can be uploaded into a program,
    you may have to generate code that interacts with services over a standalone program
    that accepts arguments, a TCP service, or even a UDP service. Consider the previous
    program we just exploited, if it was different in nature we could exploit it still,
    and just the way the scripts interacted with it would be different. The following
    three examples show what the code would look if it met any of those criteria.
    Of course, the memory addresses and sizes would have to be adjusted for other
    programs you may come across.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写可以上传到程序中的恶意文件之外，您可能还需要生成与服务交互的代码，这些服务可以是接受参数的独立程序、TCP服务，甚至是UDP服务。考虑我们刚刚利用的上一个程序，如果它的性质不同，我们仍然可以利用它，只是脚本与它交互的方式会有所不同。以下三个示例展示了如果满足这些条件，代码会是什么样子。当然，内存地址和大小必须根据您可能遇到的其他程序进行调整。
- en: Exploiting standalone binaries by executing scripts
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过执行脚本利用独立的二进制文件
- en: 'We can even create Python script to wrap around programs that have arguments
    passed to them. That way you can build exploits using wrapper scripts, which inject
    code, as shown following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建Python脚本来包装需要传递参数的程序。这样，您可以使用包装脚本构建漏洞利用，这些脚本注入代码，如下所示：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This form of exploit is the rarest you will encounter as it typically would
    not grant you any additional rights. When creating exploits like these, it is
    usually to see what additional accesses you may be granted through a whitelisted
    program verses user level permissions. Keep in mind, this type of exploit is much
    tougher to write than malicious files, TCP, or UDP services. On the other side
    of the spectrum, the most common exploit that you will likely write is a TCP service
    exploit.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的利用是你可能会遇到的最罕见的，因为通常不会授予你任何额外的权限。创建这类利用时，通常是为了查看通过白名单程序与用户级权限相比可能被授予的额外访问权限。请记住，这种类型的利用比恶意文件、TCP或UDP服务更难编写。在另一方面，你可能会编写的最常见的利用是TCP服务利用。
- en: Exploiting systems by TCP service
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过TCP服务利用系统
- en: Most often, you will come across services that can be exploited over TCP. This
    means, for analysis, you would have to setup a test box, which had Immunity or
    some other debugger and the service running. You would have to attach Immunity
    to that service and test your exploit as you have done previously.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会发现可以通过TCP进行利用的服务。这意味着，为了进行分析，你需要设置一个测试盒，其中安装了Immunity或其他调试器以及正在运行的服务。你需要将Immunity连接到该服务并测试你之前所做的利用。
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Had the TFTP service highlighted in [Chapter 7](ch07.html "Chapter 7. Cracking
    the Perimeter with Python"), *Cracking the Perimeter with Python*, been vulnerable
    to potential buffer overflow attacks, we would have looked at creating an exploit
    for the UDP service.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[第7章](ch07.html "第7章。用Python破解边界")中突出显示的TFTP服务容易受到潜在的缓冲区溢出攻击，我们将考虑为UDP服务创建一个利用。
- en: Exploiting systems by UDP service
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过UDP服务利用系统
- en: Generating Exploits for UDP Services is very much like a TCP service. The only
    difference is you are working with a different communication protocol.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 生成UDP服务的利用与TCP服务非常相似。唯一的区别是你正在使用不同的通信协议。
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that you have seen the basics of the most common types of exploits you may
    write, let us look at reversing a Metasploit module.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了你可能编写的最常见类型的利用的基础知识，让我们来看一下如何反向操作Metasploit模块。
- en: Reversing Metasploit modules
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向操作Metasploit模块
- en: Many times you may find that a service is exploitable, but the Metasploit module
    is not built to exploit that service version or the specific OS version. This
    is not uncommon, just think back to writing the exploit earlier. Depending on
    what DLLs may have been referenced, the module may not be updated for a specific
    OS. Additionally, if newer version of an OS comes out and the program or service
    is still viable, you may need to expand the module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，你可能会发现一个服务是可利用的，但Metasploit模块并没有构建用于利用该服务版本或特定操作系统版本的功能。这并不罕见，只需回想一下之前编写利用的情况。根据可能已被引用的DLL，该模块可能没有针对特定操作系统进行更新。此外，如果新版本的操作系统发布，而程序或服务仍然可行，你可能需要扩展该模块。
- en: Think back to [Chapter 5](ch05.html "Chapter 5. Exploiting Services with Python"),
    *Exploiting Services with Python*, and how we did research to find if a Kernel
    was vulnerable. Consider how doing similar research may result in references to
    potential buffer overflow vulnerabilities. You can either start from scratch,
    or you can reverse a Metasploit module into a standalone Python script and easily
    test for the expanded capabilities. You can then incorporate the changes into
    the Metasploit module, or even create your own.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第5章](ch05.html "第5章。用Python利用服务")中的*用Python利用服务*，以及我们如何进行研究以查找内核是否存在漏洞。考虑进行类似研究可能会导致对潜在缓冲区溢出漏洞的引用。你可以从头开始，也可以将Metasploit模块反向操作为一个独立的Python脚本，并轻松测试扩展功能。然后，你可以将更改合并到Metasploit模块中，甚至创建你自己的模块。
- en: We are going to reverse the Metasploit module for the Sami FTP Server 2.0.1,
    conceptually verses actually. For brevity, we are not going to show the entire
    code of the exploit, but you can examine it in your installation of Metasploit
    here at `/usr/share/metasploit-framework/modules/exploits/windows/ftp`. Additional
    details about this module can be found here at [http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list](http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对Sami FTP Server 2.0.1的Metasploit模块进行反向操作，从概念上来说，实际上是。为了简洁起见，我们不会展示整个利用代码，但你可以在Metasploit的安装目录下的`/usr/share/metasploit-framework/modules/exploits/windows/ftp`中查看。关于这个模块的更多细节可以在这里找到：[http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list](http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list)。
- en: The first thing to do when reversing a Metasploit module is to setup the actual
    exploit. This will reveal the necessary parameters that would be need to be set
    to exploit the actual service. As you can see we need usernames, passwords, and
    the relevant payload.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 反向操作Metasploit模块时的第一件事是设置实际的利用。这将揭示需要设置的用于利用实际服务的必要参数。正如你所看到的，我们需要用户名、密码和相关有效载荷。
- en: '![Reversing Metasploit modules](img/B04315_08_42.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![反向操作Metasploit模块](img/B04315_08_42.jpg)'
- en: Next, we look at the actual payload; I find it easier to copy it into a code
    editor like Notepad++. This allows you to see what brackets and delineations would
    normally be needed. Unlike previous examples of writing exploits, we are going
    to start with the actual shellcode, because this is going to take the most effort.
    So, look at the payload section of the actual Metasploit module.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下实际的有效载荷；我发现将其复制到像Notepad++这样的代码编辑器中会更容易。这样可以让你看到通常需要哪些括号和分隔符。与以前编写利用的示例不同，我们将从实际的shellcode开始，因为这将需要最大的努力。因此，看一下实际Metasploit模块的有效载荷部分。
- en: '![Reversing Metasploit modules](img/B04315_08_43.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![反向操作Metasploit模块](img/B04315_08_43.jpg)'
- en: As you can see, there is a stack adjustment of 3500 to accommodate the placement
    of shellcode more accurately. You can again calculate this with the same method
    highlighted above. In the newer Metasploit modules, instead of `PrependEncoder`
    you will see `StackAdjustment` with a plus or minus value. So, you, as a module
    developer do not have to actually calculate the hexadecimal code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，堆栈调整为3500，以更准确地容纳shellcode的放置。您可以再次使用上面突出显示的相同方法进行计算。在较新的Metasploit模块中，您将看到`PrependEncoder`而不是`StackAdjustment`，带有加号或减号的值。因此，作为模块开发人员，您不必实际计算十六进制代码。
- en: Stack adjustment of `-3500` means we are adding this value to the ESP. To do
    that, we need to calculate the ESP adjustment for `-3500`, but for that calculation
    we need to change -`3500` to a hexadecimal value. The hexadecimal equivalent is
    `-0xDAC`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈调整为`-3500`意味着我们将这个值添加到ESP。为此，我们需要计算`-3500`的ESP调整，但是为了进行这个计算，我们需要将`-3500`改为十六进制值。十六进制等价值为`-0xDAC`。
- en: '![Reversing Metasploit modules](img/B04315_08_44.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_44.jpg)'
- en: Now, we take that adjustment data and print it into a hexadecimal file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调整数据打印成十六进制文件。
- en: '![Reversing Metasploit modules](img/B04315_08_45.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_45.jpg)'
- en: As you saw in the payload section of the module, there are known bad characters.
    When we generate our initial payload, we will incorporate those into the payload
    generation. Now, we generate the payload with those features.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在模块的有效负载部分看到的，有已知的不良字符。当我们生成初始有效负载时，我们将这些字符纳入到有效负载生成中。现在，我们使用这些特性生成有效负载。
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Reversing Metasploit modules](img/B04315_08_46.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_46.jpg)'
- en: We verify that the payload was generated with the `hexdump` command.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证了使用`hexdump`命令生成的有效负载。
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The figure below shows the output of that payload:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了有效负载的输出：
- en: '![Reversing Metasploit modules](img/B04315_08_47.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_47.jpg)'
- en: 'To combine the stack adjustment code and the actual payload, we can do the
    method highlighted in the following figure, which shows the simplicity of this
    command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结合堆栈调整代码和实际有效负载，我们可以使用下图中突出显示的方法，显示了这个命令的简单性：
- en: '![Reversing Metasploit modules](img/B04315_08_48.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_48.jpg)'
- en: After executing this, we verify the combination of the two components, and as
    you can see the adjustment hexadecimal code was placed at the front of the shellcode.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们验证了两个组件的组合，如您所见，调整的十六进制代码被放置在shellcode的前面。
- en: '![Reversing Metasploit modules](img/B04315_08_49.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_49.jpg)'
- en: Now, encode the data into a usable format for the script removing bad characters
    we know typically break exploits.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将数据编码为脚本可用的格式，删除我们通常知道会破坏漏洞的不良字符。
- en: '[PRE20]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The resulting output is the actual shellcode that would be used for this exploit:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出是实际用于此漏洞利用的shellcode：
- en: '![Reversing Metasploit modules](img/B04315_08_50.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_50.jpg)'
- en: Now, we can start crafting our exploit using all the features in the Metasploit
    module. We are going to use the target code to extract the `Offset` and `Ret`
    data. The `Ret` holds the return address for the EIP, and the `Offset` provides
    the data necessary to adjust the placement of the shellcode.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用Metasploit模块中的所有功能来构建我们的漏洞利用。我们将使用目标代码来提取`Offset`和`Ret`数据。`Ret`保存EIP的返回地址，`Offset`提供了调整shellcode放置位置所需的数据。
- en: '![Reversing Metasploit modules](img/B04315_08_51.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_51.jpg)'
- en: Generating the return address component of our exploit is very straightforward.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 生成我们的漏洞利用的返回地址组件非常简单。
- en: '[PRE21]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Setting up the offset can be different per module, and you may need to do additional
    mathematical operations to get the right value. So, always look at the actual
    exploit code as highlighted, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 设置偏移量可能因模块而异，您可能需要进行额外的数学运算来获得正确的值。因此，始终查看实际的漏洞利用代码，如下所示：
- en: '![Reversing Metasploit modules](img/B04315_08_52.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![逆向Metasploit模块](img/B04315_08_52.jpg)'
- en: We see the offset has the length of the IP address removed from the size. This
    creates an updated offset value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到偏移量的长度减去了IP地址的大小。这创建了一个更新的偏移值。
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that junk data is generated with random text. So, we can generate
    our NOPs in a similar manner.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到生成了随机文本的垃圾数据。因此，我们可以以类似的方式生成我们的NOPs。
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we need to create the order of operations to inject the exploit code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建注入漏洞代码的操作顺序。
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see this has all been very straight forward using the knowledge leveraged
    in the previous sections. The last component is to setup the handler to interact
    with the FTP service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用前面章节中的知识一切都非常简单。最后一个组件是设置处理程序与FTP服务进行交互。
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The end result is a Python exploit that can be tested and run against the actual
    server. This gives a great starting point for testing as well. If you find Metasploit
    modules do not work perfectly, reversing them to create a standalone gives you
    the opportunity to troubleshoot possible issues.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个可以测试并运行在实际服务器上的Python漏洞利用。这为测试提供了一个很好的起点。如果发现Metasploit模块不完美，将其逆向创建一个独立的模块，可以帮助您排除可能的问题。
- en: Remember exploits have a rating system with how reliable they are. If the exploit
    has a lower reliability rating, it means that it may not produce the desired results
    consistently. This gives you the opportunity to try and improve the actual Metasploit
    module and contribute back to the community. For example, this exploit has a Low
    rating; consider testing and trying to improve it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，漏洞利用有一个可靠性评级系统。如果漏洞利用的可靠性评级较低，意味着它可能无法始终产生期望的结果。这为您提供了尝试改进实际Metasploit模块并为社区做出贡献的机会。例如，这个漏洞利用的评级是低的；考虑测试并尝试改进它。
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, this specific exploit was developed for Windows XP SP 3\. You can now use
    this code to try and target different platforms. A standalone Python exploit means
    you have the necessary capabilities to expand the exploit. You can then add additional
    targets to the Metasploit module. This can be done by modifying the following
    section of a module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个特定的漏洞利用是为Windows XP SP 3开发的。您现在可以使用这段代码来尝试并针对不同的平台。独立的Python漏洞利用意味着您有必要的能力来扩展漏洞利用。然后，您可以将额外的目标添加到Metasploit模块中。这可以通过修改模块的以下部分来实现。
- en: '![Reversing Metasploit modules](img/B04315_08_53.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![反向工程Metasploit模块](img/B04315_08_53.jpg)'
- en: 'The following would be how the code in the actual module could be updated with
    other relevant targets:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际模块中的代码如何更新以包含其他相关目标的方式：
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From this example, we have seen how to reverse a Metasploit module to create
    a standalone exploit, which can be used to expand target selection and improve
    reliability in future exploits.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们看到了如何反向工程Metasploit模块以创建一个独立的漏洞利用，这可以用来扩展目标选择并提高未来漏洞利用的可靠性。
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you choose to create new Metasploit modules or updates with different capabilities
    and you do not want to break your current install, you can load custom modules
    into Metasploit. Those details are well documented in the following location [https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择创建新的Metasploit模块或具有不同功能的更新，并且不想破坏当前的安装，您可以将自定义模块加载到Metasploit中。这些细节在以下位置有很好的文档记录[https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules)。
- en: Understanding protection mechanisms
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解保护机制
- en: There are entire books dedicated to some of the tools out there for administrators
    and developers, which will prevent many exploits. They include items such as **Data
    Execution Prevention** (**DEP**), which would stop code like ours from working
    if the code and OS were configured to take advantage of it. This is done by preventing
    execution of data on the stack. We can bypass DEP by simply overwriting the **Structured
    Exception Handling** (**SEH**) to run our own code instead.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有一整本书专门介绍了一些供管理员和开发人员使用的工具，这些工具可以防止许多漏洞利用。它们包括**数据执行防护**（**DEP**），如果代码和操作系统配置为利用它，它将阻止像我们这样的代码运行。这是通过阻止在堆栈上执行数据来实现的。我们可以通过简单地覆盖**结构化异常处理**（**SEH**）来绕过DEP，以运行我们自己的代码。
- en: Stack Canaries, which are basically mathematical constructs in the stack, check
    when the return pointer is called. If the value has changed then something has
    gone wrong and an exception is raised. If an attacker determines the value the
    guard is checking for, it can be injected into the shellcode to prevent an exception.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 栈金丝雀是栈中的数学构造，检查返回指针何时被调用。如果值发生了变化，那么出现了问题，并引发了异常。如果攻击者确定了守卫正在检查的值，它可以被注入到shellcode中以防止异常。
- en: Finally, there is **Address Space Layer Randomization** (**ASLR**), which randomizes
    locations in memory we take advantage of. ASLR is much tougher to beat than the
    other two, but it basically defeated by building your exploit in memory with components
    of shared libraries that have to maintain consistent memory locations. Without
    these consistent shared libraries, the OS would be unable to execute basic process
    initially. This technique is known as **Return-Oriented Programming** (**ROP**)
    chaining.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有**地址空间层随机化**（**ASLR**），它随机化了我们利用的内存位置。ASLR比其他两种方式更难打败，但它基本上是通过在内存中构建具有维持一致内存位置的共享库组件的漏洞利用来打败的。没有这些一致的共享库，操作系统将无法执行基本的进程。这种技术被称为**返回导向编程**（**ROP**）链接。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave an overview of Windows memory structures and how we
    try to take advantage of poor coding practices. We then highlighted how to generate
    your own exploits using Python code using targeted testing and proof of concept
    code. This chapter then rounded out, how to reverse Metasploit modules to create
    standalone exploits that can be used to improve current modules capabilities or
    generate new exploits. In the next chapter, we will highlight how to automate
    reporting of details found during a penetration test and how to parse **eXtensible
    Markup Language** (**XML**).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了Windows内存结构以及我们如何利用糟糕的编码实践。然后，我们强调了如何使用Python代码生成自己的漏洞利用，使用有针对性的测试和概念验证代码。本章最后介绍了如何反向工程Metasploit模块以创建独立的漏洞利用，以改进当前模块的功能或生成新的漏洞利用。在下一章中，我们将介绍如何自动报告渗透测试期间发现的细节以及如何解析**可扩展标记语言**（**XML**）。
