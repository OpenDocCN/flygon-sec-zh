# 第一章：混淆

Python 是最适合初学者的语言，这也是它如此受欢迎的原因。您可以用几行代码编写强大的代码，最重要的是，您可以完全精确地处理任意大的整数。本书涵盖了基本的密码学概念；经典的加密方法，如凯撒密码和 XOR；混淆和扩散的概念，决定了加密系统的强度；使用混淆隐藏数据；对数据进行哈希以确保完整性和密码；以及强大的加密方法和对这些方法的攻击，包括填充预言攻击。您不需要有编程经验来学习这些内容。您不需要任何特殊的计算机；任何可以运行 Python 的计算机都可以完成这些项目。我们不会发明新的加密技术，只是学习如何使用标准的现有技术，这些技术不需要任何比基本代数更复杂的东西。

我们将首先处理混淆，即加密的基本概念，以及隐藏数据以使其更难阅读的老式加密技术。后一种过程是加密模块与其他方法结合使用以制定更强大、更现代的加密技术的基本活动之一。

在本章中，我们将涵盖以下主题：

+   关于密码学

+   安装和设置 Python

+   凯撒密码和 ROT13

+   base64 编码

+   XOR

# 关于密码学

最近，随着所有货币（如比特币、以太坊和莱特币）的引入，密码一词变得过载。当我们将密码称为一种保护形式时，我们指的是应用于系统中的通信链路、存储设备、软件和消息的密码学概念。密码学在保护关键系统和敏感信息方面具有悠久而重要的历史。

在第二次世界大战期间，德国人使用 Enigma 机器加密通信，而盟军则竭尽全力破译这种加密。Enigma 机器使用一系列转子将明文转换为密文，通过了解转子的位置，盟军能够将密文解密为明文。这是一个重大的成就，但需要大量的人力和资源。今天仍然有可能破解某些加密技术；然而，攻击加密系统的其他方面，如协议、集成点甚至用于实现加密的库，往往更为可行。

密码学有着悠久的历史；然而，如今，您将遇到新概念，如区块链，可以用作帮助保护物联网的工具。区块链基于一组众所周知的密码原语。密码学的其他新方向包括抗量子算法，这些算法可以抵御理论上的量子计算机的攻击，并使用诸如 BB84 和 BB92 之类的协议来利用量子纠缠的概念，并为使用经典加密算法创建高质量的密钥。

# 安装和设置 Python

Python 从来都不容易安装。为了继续，请确保我们已经在我们的机器上设置了 Python。我们将看到如何在 macOS 或 Linux 上使用 Python 以及如何在 Windows 上安装它。

# 在 Mac 或 Linux 上使用 Python

在 macOS 或 Linux 系统上，您无需安装 Python，因为它已经包含在内。您只需要打开一个终端窗口并输入`python`命令。这将使您进入交互模式，在这里您可以逐个执行`python`命令。您可以通过执行`exit()`命令来关闭交互模式。因此，基本上，要创建一个脚本，我们使用`nano`文本编辑器，然后输入文件名。然后输入`python`命令并保存文件。然后可以使用`python`后跟脚本名称来运行脚本。因此，让我们看看如何在 macOS 或 Linux 上使用 Python，以下是具体步骤：

1.  在 macOS 或 Linux 系统上打开终端并运行`python`命令。这将打开 Python 的交互模式，如下面的截图所示：

![](img/00005.jpeg)

1.  当你使用`print`命令时，它会立即打印`Hello`：

```py
>>> print "Hello"
Hello
```

1.  然后，我们将使用以下命令离开：

```py
>>> exit()
```

1.  如前所述，要在交互模式下使用 Python，我们将输入如下命令：

```py
$ nano hello.py
```

1.  在`hello.py`文件中，我们可以写入如下命令：

```py
print "HELLO"
```

1.  按*Ctrl* + *X*保存文件，然后只有在你修改了文件后才按*Y*和*Enter*。

1.  现在，让我们输入 Python，然后输入脚本名称：

```py
$ python hello.py
```

当你运行它时，你会得到以下输出：

![](img/00006.jpeg)

前面的命令运行脚本并打印出`HELLO`；如果你有 macOS 或 Linux 系统，这就是你所需要做的。

# 在 Windows 上安装 Python

如果你使用 Windows，你需要下载并安装 Python。

以下是你需要遵循的步骤：

1.  从[`www.python.org/downloads/`](https://www.python.org/downloads/)下载 Python

1.  在命令提示符窗口中运行它

1.  用 Python 开始交互模式

1.  使用`exit()`关闭

要创建一个脚本，你只需使用记事本，输入文本，用*Ctrl* + *S*保存文件，然后用`python`后跟脚本名称运行它。让我们开始安装。

使用之前给出的链接打开 Python 页面并下载 Python。它为您提供各种版本的 Python。在本书中，我们将使用 Python 2.7.12。

有时，你无法立即安装它，因为 Windows 将其标记为不受信任：

1.  你必须先在属性中解除阻止，这样它才能运行，并运行安装程序

1.  当你按照安装程序的步骤进行时，你会看到一个名为 Add python.exe to path 的可选步骤。你需要选择那个选项

该选项的目的是使 Python 能够在终端窗口中从命令行运行，Windows 上称为命令提示符。

现在让我们继续我们的安装：

1.  打开终端并输入以下命令：

```py
$ python
```

1.  当你运行它时，你会看到它有效。所以，现在我们将输入一个命令：

```py
print "HELLO"
```

参考以下截图：

![](img/00007.jpeg)

1.  我们可以使用之前显示的`exit()`命令退出。

1.  现在，如果我们想要制作一个脚本，我们输入以下命令：

```py
notepad hello.py
```

1.  这将打开记事本：

![](img/00008.jpeg)

1.  我们想要创建一个文件。在文件中，我们输入以下命令：

```py
print "HELLO"
```

1.  然后保存并关闭它。为了运行它，我们需要输入以下命令：

```py
$ python hello.py
```

它运行并打印`HELLO`。

通常，当你在 Windows 上安装 Python 时，它无法正确设置路径，所以你必须执行以下命令来创建一个符号链接；否则，Python 将无法从命令行正确启动：

1.  `**cd c: \Windows**`

1.  `**mklink /H python.exe**`

1.  `**c: \python27\python.exe**`

在下一节中，我们将看看凯撒密码和 ROT13 混淆技术。

# 凯撒密码和 ROT13

在本节中，我们将解释什么是凯撒密码以及如何在 Python 中实现它。然后，我们将考虑其他`shift`值，模运算和 ROT13。

凯撒密码是一个古老的技巧，你只需将字母向字母表中的后三个字符移动。这是一个例子：

+   明文：`ABCDEFGHIJKLMNOPQRSTUVWXYZ`

+   密文：`DEFGHIJKLMNOPQRSTUVWXYZABC`

所以，`HELLO`变成了`KHOOR`。

为了实现它，我们将使用`string.find()`方法。Python 的交互模式非常适合测试新方法，因此很容易创建一个字符串。你可以制作一个非常简单的脚本来实现凯撒密码，使用一个名为`alpha`的字符串来表示字母表。然后你可以从用户那里获取输入，这就是明文方法，然后设置一个值`n`，它等于字符串的长度，字符串输出等于一个空字符串。然后我们有一个循环，它重复了`n`次，找到字符串中的字符，然后找到该字符在`alpha`字符串中的位置。然后打印出这三个值，以便我们可以确保脚本正常工作，然后它将`loc`（位置）加上`3`，并将相应的字符放入字符串输出中，然后再次打印出部分值，以便我们可以看到脚本是否正常工作。最后，我们打印出最终的输出。添加额外的打印语句是开始编程的一个很好的方法，因为你可以发现错误。

# 在 Python 中实现凯撒密码

让我们继续打开终端，并按照以下步骤在 Python 中实现凯撒密码：

1.  我们将首先在 Python 的交互模式下使用它，然后制作一个只包含一些字母的字符串来测试这种方法：

```py
>>> str = "ABCDE"
>>> str.find("A")
0
>>> str.find("B")
1
>>> exit()
```

1.  因为我们了解了字符串方法的工作原理，我们将退出并进入`nano`文本编辑器，查看我们脚本的第一个版本：

```py
$ nano caesar1.py
```

1.  当你运行这个命令时，你会得到以下代码：

```py
alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
str_in = raw_input("Enter message, like HELLO: ")

n = len(str_in)
str_out = ""

for i in range(n):
   c = str_in[i]
   loc = alpha.find(c)
   print i, c, loc, 
   newloc = loc + 3
   str_out += alpha[newloc]
   print newloc, str_out

print "Obfuscated version:", str_out
```

你可以在脚本中看到字母表和用户输入。你计算字符串的长度，对于每个字符，`C`将是正在处理的一个字符，`loc`将是该字符的数字位置，`newloc`将是`loc`加上`3`，然后我们可以将该字符添加到字符串输出中。让我们看看这个。

1.  使用*Ctrl*+*X*离开，然后输入以下命令：

```py
$ python caesar1.py
```

1.  当你运行这个命令时，你会得到以下输出：

```py
Enter message, like HELLO:
```

1.  如果我们输入`HELLO`，它会打印出`KHOOR`的正确答案：

![](img/00009.jpeg)

当我们运行这个脚本时，它接受`HELLO`的输入，并将其逐个字符地分解开来，以便对每个字符进行处理。`H`被发现是第 7 个字符，所以加上`3`得到`10`，结果是`K`。它逐个字符地显示了它的工作原理。因此，脚本的第一个版本是成功的。

为了进一步清理代码，我们将删除不必要的`print`语句并切换到`shift`变量。我们将创建一个`shift`变量。它也来自原始输入，但我们必须将其转换为整数，因为原始输入被解释为`文本`，您不能将`文本`添加到整数。这是接下来的脚本中唯一的更改。如果您给它一个`3`的`shift`值，您会得到`KHOOR`；如果您给它一个`10`的`shift`值，您会得到`ROVVY`；但如果您输入一个`14`的`shift`值，它会崩溃，显示字符串索引超出范围。这里的问题是，我们已经多次添加到`loc`变量，最终，我们超过了`Z`，变量就不再有效了。为了改进这一点，在向变量添加内容后，我们将检查它是否大于或等于`26`，以及是否可以从中减去`26`。一旦您运行这个，您可以使用`14`的移位，这将起作用。我们可以使用`24`的移位，它也可以工作。但是，如果我们使用`44`的移位，它又超出范围了。这是因为当超过`26`时，仅仅减去`26`一次并不够，正确的解决方案是模运算。如果我们加上`％26`，它将计算数字模`26`，这将防止它离开`0`到`25`的范围。它将除以`26`并保留余数，这在这种情况下是预期的。随着我们在密码学中继续前进，我们将看到模函数更多次。您可以输入任何您选择的`shift`值，比如`300`，它永远不会崩溃，但会将其转换为`0`到`25`之间的数字。

让我们看看脚本如何处理其他移位值：

1.  看看凯撒脚本：

```py
$ nano caesar2.py
```

1.  运行它时，您将得到以下内容：

![](img/00010.jpeg)

1.  这是一个允许我们改变`shift`值但不处理`shift`值变得太大的脚本。让我们运行以下命令：

```py
$ python caesar2.py
```

1.  如果输入`HELLO`并给它一个`3`的移位，它是好的，但如果我们再次运行它并给它一个`20`的移位，它就会崩溃：

![](img/00011.jpeg)

因此，预料之中，这个有一些限制。

1.  让我们继续看`caesar3`：

```py
$ nano caesar3.py
```

1.  运行后，我们得到以下输出：

![](img/00012.jpeg)

`Caesar3`试图通过捕捉它来解决这个问题，如果我们知道加法导致它大于或等于`26`，则从中减去`26`。

1.  让我们运行以下命令：

```py
$ python caesar3.py
```

1.  我们将给它`shift`字符和`shift`为`20`，它会很好：

![](img/00013.jpeg)

1.  如果我们给它一个`40`的偏移量，它就不起作用：

![](img/00014.jpeg)

有一些改进，但我们仍然无法处理任何`shift`值。

1.  让我们继续到`caesar4`：

```py
$ nano caesar4.py
```

1.  当您运行命令时，您将得到这个：

![](img/00015.jpeg)

这是使用百分号进行模运算的脚本，这不会失败。

1.  让我们运行以下命令：

```py
$ python caesar4.py
```

1.  当您运行命令时，您将得到这个：

![](img/00016.jpeg)

这是处理所有凯撒移位值的脚本。

# ROT13

ROT13 只不过是一个`shift`等于`13`个字符的凯撒密码。在接下来的脚本中，我们将硬编码移位为`13`。如果您运行一次 ROT13，它会将`HELLO`更改为`URYYB`，如果您再次使用相同的过程对其进行加密，输入`URYYB`，它将变回`HELLO`，因为第一个移位只是`13`个字符，再移位`13`个字符将总移位变为`26`，这样就可以很好地包裹，这就是这个脚本有用和重要的地方：

1.  现在让我们看一下使用以下命令的 ROT13 脚本：

```py
$ nano rot13.py
```

1.  当您运行上述命令时，您可以看到脚本文件：

![](img/00017.jpeg)

1.  它与我们上次凯撒密码移位的脚本完全相同，移位为`13`。按照这里所示的脚本运行：

```py
$ python rot13.py
```

以下是输出：

![](img/00018.jpeg)

1.  如果我们输入消息`URYYB`并运行它，它会变回`HELLO`：

![](img/00019.jpeg)

这很重要，因为有很多具有这种属性的加密函数；当你加密一次然后再次加密时，你会反转这个过程。它不会变得更加加密，而是变得未加密。在下一节中，我们将涵盖 base64 编码。

# base64 编码

我们现在将讨论将 ASCII 数据编码为字节，并对这些字节进行 base64 编码。我们还将涵盖二进制数据的 base64 编码和解码，以恢复原始输入。

# ASCII 数据

在 ASCII 中，每个字符变成一个字节：

+   `A`在十进制中是`65`，在二进制中是`0b01000001`。这里，你在最高位没有`128`，然后在下一个位上有`64`的`1`，最后有`1`，所以你有*64 + 1=65*。

+   接下来是`B`，基数为`66`，`C`，基数为`67`。`B`的二进制是`0b01000010`，`C`的二进制是`0b01000011`。

三个字母的字符串`ABC`可以解释为一个 24 位的字符串，看起来像这样：

![](img/00020.gif)

我们添加了这些蓝线只是为了显示字节的分隔位置。要将其解释为 base64，你需要将其分成 6 位一组。6 位有 64 种组合，所以你需要 64 个字符来编码它。

使用的字符如下：

![](img/00021.jpeg)

我们使用大写字母表示前 26 个，小写字母表示另外 26 个，数字表示另外 10 个，总共 62 个字符。在最常见的 base64 形式中，最后两个字符使用`+`和`/`：

![](img/00022.gif)

如果你有一个 ASCII 字符串有三个字符，它变成 24 位，解释为 3 组 8 位。如果你把它们分成 4 组 6 位，你有 4 个 0 到 63 之间的数字，在这种情况下，它们变成`Q`、`U`、`J`和`D`。在 Python 中，你只需要一个字符串，后面跟着命令：

```py
>>> "ABC".encode("base64")
'QUJD\n'
```

这将进行编码。然后在最后添加一个额外的回车，这既不重要也不影响解码。

如果你有的不是 3 个字节的组合呢？

等号`=`用于指示填充，如果输入字符串长度不是 3 个字节的倍数。

如果输入有四个字节，那么 base64 编码以两个等号结束，只是表示它必须添加两个填充字符。如果有五个字节，就有一个等号，如果有六个字节，那么就没有等号，表示输入完全适合 base64，不需要填充。填充是空的。

你取`ABCD`进行编码，然后你取`ABCD`并加上一个显式的零字节。`x00`表示一个具有八位零的单个字符，你得到相同的结果，只是多了一个`A`和一个等号，如果你用两个零字节填满它，你会得到大写的`A`。记住：大写的`A`是`base64`中的第一个字符。它代表六位零。

让我们来看看 Python 中的 base64 编码：

1.  我们将启动`python`并创建一个字符串。如果你只是用引号创建一个字符串并按*Enter*，它会立即打印出来：

```py
>>> "ABC"
'ABC'
```

1.  Python 会自动打印每次计算的结果。如果我们用`base64`对其进行编码，我们会得到这个结果：

```py
>>> "ABC".encode(""base64")
'QUJD\n'
```

1.  它变成`QUJD`，最后有一个额外的回车，如果我们让它更长：

```py
>>> "ABCD".encode("base64")
'QUJDRA==\n'
```

1.  这里有两个等号，因为我们从四个字节开始，它必须再添加两个字节使其成为 3 的倍数：

```py
>>> "ABCDE".encode("base64")
'QUJDREU=\n'
>>> "ABCDEF".encode("base64")
'QUJDREVG\n'
```

1.  有五个字节的输入，我们有一个等号；有六个字节的输入，我们没有等号，而是一共有八个字符使用`base64`。

1.  让我们回到带有两个等号的`ABCD`：

```py
>>>"ABCD".encode("base64")
'QUJDRA==\n'
```

1.  你可以看到填充是如何通过在这里明确放置它来完成的：

```py
>>> "ABCD\x00\x00".encode("base64")
'QUJDRAA=\n'
```

有一个零的第一个字节，现在我们得到另一个单个等号。

1.  让我们再加入一个字节的零：

```py
>>> "ABCD\x00\x00".encode("base64")
'QUJDRAAA\n'
```

这里没有填充，我们看到最后的字符都是`A`，表明已经填充了二进制零。

# 二进制数据

下一个问题是处理二进制数据。可执行文件是二进制的，而不是 ASCII。此外，图像、电影和许多其他文件都包含二进制数据。ASCII 数据始终以第一个位为零开始，但`base64`可以很好地处理二进制数据。这是一个常见的可执行文件，一个法医实用程序；它以`MZê`开头，并且有不可打印的 ASCII 字符：

![](img/00023.jpeg)

由于这是一个十六进制查看器，您可以看到十六进制的原始数据，在右侧，它尝试将其打印为 ASCII。Windows 程序在开头有这个字符串，并且这个程序不能在 DOS 模式下运行，但它们有很多不可打印的字符，比如`FF`和`0`，这对 Python 来说并不重要。像这样编码数据的简单方法是直接从文件中读取它。您可以使用`with`命令。它将使用文件名和读取二进制模式打开一个文件，并使用句柄`f`读取它。`with`命令在这里只是告诉 Python 打开文件，并且如果由于某些错误无法打开文件，则关闭句柄，然后以完全相同的方式解码它。要解码以这种方式编码的数据，只需取输出字符串，并将`.encode`替换为`.decode`。

现在让我们看看如何处理二进制数据：

1.  我们将首先退出 Python，以便我们可以查看文件系统，然后我们将使用以下命令查找`Ac`文件：

```py
>>> exit()
$ ls Ac*
AccessData Registry Viewer_1.8.3.exe
```

这是文件名。由于这是一个比较长的块，我们只需复制并粘贴它。

1.  现在我们启动 Python 并使用以下命令`clear`屏幕：

```py
$ clear
```

1.  我们将重新开始`python`：

```py
$ python
```

1.  好的，现在我们使用以下命令：

```py
>>> with open("AccessData Registry Viewer_1.8.3.exe", "rb") as f:
... data = f.read()
... print data.encode("base64")
```

这里我们首先输入文件名，然后是读取二进制模式。我们将给它一个文件名句柄`f`。我们将获取所有数据并将其放入一个单一变量数据中。我们可以只对数据进行`base64`编码，它会自动打印出来。如果您在 Python 中有一个预期的块，您必须按*Enter*键两次，以便它知道块已完成，然后`base64`对其进行编码。

1.  您会得到一个很长的`base64`块，这不太可读，但这是处理这种数据的一种方便方式；比如，如果您想要通过电子邮件发送它或将其放入其他文本格式中。因此，为了进行解码，让我们编码一些更简单的东西，以便我们可以轻松地看到结果：

```py
>>> "ABC".encode("base64")
'QUJD\n'
```

1.  如果我们想要使用它，可以使用以下命令将其放入一个`c`变量中：

```py
>>> c = "ABC".encode("base64")
>>> print c
QUJD
```

1.  现在我们可以打印`c`以确保我们得到了预期的结果。我们有`QUJD`，这是我们预期的结果。所以，现在我们可以使用以下命令对其进行解码：

```py
>>> c.decode("base64")
'ABC'
```

`base64`不是加密。它不隐藏任何东西，而只是另一种表示方法。在下一节中，我们将介绍 XOR。

# XOR

本节解释了 XOR 在单个位上的真值表，然后展示了如何在字节上进行操作。XOR 可以撤销自身，因此解密与加密是相同的操作。您可以使用单个字节或多个字节密钥进行 XOR，并且我们将使用循环来测试密钥。以下是 XOR 的真值表：

+   `0 ^ 0 = 0`

+   `0 ^ 1 = 1`

+   `1 ^ 0 = 1`

+   `1 ^ 1 = 0`

如果您输入两个位，并且这两个位相同，则答案是`0`。如果位不同，则答案是`1`。

XOR 一次操作一个位。Python 使用`^`运算符表示 XOR。

真值表显示了它的工作原理。您输入可能是`0`和`1`的位，并将它们进行异或运算，然后最终得到 50%的 1 和 0，这意味着异或不会破坏任何信息。

这是字节的异或：

+   `A 0b01000001`

+   `B 0b01000010`

+   `XOR 0b00000011`

`A`是数字`65`，所以你有`64`的`1`和`1`的`1`；`B`大 1，如果你将它们进行 XOR 操作，所有的位匹配前 6 位，它们都是`0`。最后两位不同，它们变成了`1`。这是二进制值`3`，它不是一个可打印的字符，但你可以将它表示为一个整数。

密钥可以是单字节或多字节。如果密钥是单字节，比如`B`，那么你可以使用相同的字节来加密每个明文字符。只需一直重复使用密钥：

![](img/00024.gif)

为这个字节重复`B`，那个字节也是`B`，依此类推。如果密钥是多字节的，那么你就重复这个模式：

![](img/00025.gif)

你用`B`代表第一个字节，`C`代表下一个字节，然后再次用`B`代表下一个字节，`C`代表下一个字节，依此类推。

在 Python 中，你需要循环遍历字符串的字节并计算一个索引来显示你所在的字节。然后我们从用户那里输入一些文本，计算它的长度，然后遍历从`1`到字符串长度的索引，从`0`开始。然后我们取文本字节并在这里打印出来，这样你就可以看到循环是如何工作的。所以，如果我们给它一个五个字符的明文，比如`HELLO`，它就会一个接一个地打印出字符。

要进行异或操作，我们将输入一个明文和一个密钥，然后取一个文本字节和一个密钥字节，进行异或操作，然后打印出结果。

注意`%len( key)`，这可以防止你超出密钥的末尾。它将一直重复密钥中的字节。因此，如果密钥是三个字节长，这将是模三，所以它将计数为`0`，`1`，`2`，然后回到`0 1 2 0 1 2`，依此类推。这样，你可以处理任意长度的明文。

如果你结合大写和小写字母，你经常会发现 XOR 产生无法打印的字节的情况。在接下来的例子中，我们使用了`HELLO`，`Kitty`和一个`qrs`的密钥。请注意，其中一些字节是可以打印的，而其中一些包含奇怪的字符，比如*Esc*和*Tab*，这些很难打印。因此，处理输出的最佳方式不是尝试将其作为 ASCII 打印，而是将其作为`hex`编码的值打印。我们不是一个接一个地打印字节，而是将它们组合成一个`cipher`变量，最后，我们以`hex`形式打印出整个明文，整个密钥，然后是整个密文。这样，它可以正确处理这些难以打印的奇怪值。

让我们在 Python 中尝试这个循环：

1.  我们打开终端并输入以下命令：

```py
$ nano xor1.py
```

1.  当你运行它时，你会得到以下输出：

![](img/00026.jpeg)

1.  这是第一个`xor1.py`，所以我们从用户那里输入文本，计算它的长度，然后一个接一个地打印出字节，以查看循环是如何工作的。让我们运行它并给它`HELLO`：

![](img/00027.jpeg)

1.  它只是一个接一个地打印出字节。现在，让我们看一下下一个 XOR 2：

![](img/00028.jpeg)

这里输入`text`和`key`，然后以相同的方式进行处理，遍历`text`的每个字节，使用模运算挑选出`key`的正确字节，执行异或操作，然后打印出结果。

1.  所以如果我们在这里运行相同的文件，我们取`HELLO`和一个`key`如下所示：

```py
$ nano xor2.py
$ python xor2.py
```

因此，输出如下：

![](img/00029.jpeg)

它逐个计算字节。请注意，这里我们得到了两个等号，这就是为什么你会使用多字节`key`的原因，因为明文在变化，但密钥也在变化，而这种模式在输出中没有反映出来，所以它是更有效的混淆。

1.  清除并查看第三个`xor2a.py`文件：

![](img/00030.jpeg)

这样你就可以看到，这解决了无法打印的字节的问题。

1.  因此，我们创建了一个名为`cipher`的变量，在这里组合了每个输出字节，最后，我们用`hex`编码它，而不是直接尝试将其打印出来：

![](img/00031.jpeg)

1.  如果你给它`HELLO`，然后输入一个`qrs`的键，它会给你明文`HELLO Kitty`，键，然后是十六进制编码的输出，这可以轻松处理有趣的字符，比如`0 7`和`0 5`。在下一节中，你将看到挑战 1 – 凯撒密码。

# 挑战 1 – 凯撒密码

经过凯撒密码的复习，我们将有一个解决它的例子，然后是你的挑战。记住凯撒密码是如何工作的。你有一个可用字符的字母表，你输入消息和一个`shift`值，然后你只需将字符向前移动那么多步，如果超出字母表的末尾就回到开头。我们最终得到的脚本适用于任何`shift`值，包括正常的数字，比如`3`，甚至大于`26`的数字；它们只是循环并且可以混淆你输入的任何数据。

这是一个例子：

1.  对于密文，你可以尝试从`0`到`25`的所有`shift`值，其中一个将是可读的。这是一个简单的暴力攻击。让我们来看看。

在这里，在 Python 中，去`caesar4`脚本，我们之前有过。它接受一个字符串并将其按你指定的任何值进行移位。如果我们使用那个脚本，我们可以运行它如下：

![](img/00032.jpeg)

1.  然后，如果我们输入`HELLO`并将其移位`3`，它就会变成`KHOOR`。

1.  如果我们想要破解它，我们可以使用以下解决方案脚本：

![](img/00033.jpeg)

1.  所以，如果我们使用那个脚本，我们可以运行它：

![](img/00034.jpeg)

1.  如果我们输入`KHOOR`，它将以各种值进行移位，你可以看到在`23`时可读的值是`HELLO`。所以，我们之前讨论的更长的密文等等的例子，在`3`时变得可读，你会看到它是`DEMONSTRATION`：

![](img/00035.jpeg)

1.  你的挑战是解密这个字符串：`MYXQBKDEVKDSYXC`。

在下一节中，我们将有一个关于`base64`的挑战。

# 挑战 2 – base64

经过`base64`的复习，我们将进行一个例子，向你展示如何解码一些混淆的文本，然后我们为你准备了一个简单的和一个困难的挑战。

这是`base64`的复习：

![](img/00036.jpeg)

`base64`编码文本会变得更长。这是要解码的示例文本：

```py
U2FtcGxliHRleHQ=
```

它解码成示例文本字符串。让我们看看。

参考以下步骤：

1.  如果你在立即模式下运行`python`，它将执行四个简单的任务：

```py
$ python
```

1.  所以，如果我们取`ABC`并用`base64`编码，我们会得到这个字符串：

```py
>>> "ABC".encode("base64")
'QUJD\n'
```

1.  如果我们用`base64`解码它，我们会得到原始文本：

```py
>>> "QUJD".decode("base64")
'ABC'
```

1.  所以，挑战文本如下，如果你解码它，你会得到示例文本字符串：

```py
>>> "U2FtcGxliHRleHQ=".decode("base64")
'Sample text'
```

1.  这对于简单情况足够了；你的第一个挑战看起来是这样的：

```py
Decode this: VGhpcyBpcyB0b28gZWFzeQ==
```

1.  这是一个要解码的长字符串，用于你的更长的挑战：

```py
Decode this:
VWtkc2EwbEliSFprVTJeFl6SlZaMWxUUW5OaU1qbDNVSGM5UFFvPQo=
```

这个长字符串之所以这么长，是因为它被`base64`编码了不止一次，而是多次。所以，你需要尝试解码它，直到它变成可读的内容。在下一节中，我们将有*挑战 3 – 异或*。

# 挑战 3 – 异或

在这一节中，我们将复习异或的工作原理，然后给你一个例子，然后提出两个挑战。

所以，这是我们之前讨论过的一个异或程序：

![](img/00037.jpeg)

你输入任意文本和一个任意的键，然后逐个字节地遍历它们，挑选出一个文本字节和一个键字节，然后用异或结合它们并打印出结果。所以，如果你输入`HELLO`和`qrs`，你会得到用异或加密的东西。

这里有一个例子：

![](img/00038.jpeg)

它会解密成`EXAMPLE`。所以，这是解密；记住异或会解开自己。

如果你想破解其中一个，一个简单的方法就是尝试每个键并打印出每个结果，然后读出可读的键。

所以，我们尝试从`0`到`9`的所有单个数字键。

结果是你输入密文，用每个值加密它，当你得到正确的键值时，它将变成可读的文本。

让我们来看看：

![](img/00039.jpeg)

这是解密例程，它简单地从用户输入文本，然后尝试这个字符串中的每个密钥，`0`到`9`。对于这些中的每一个，它将 XOR 文本组合成一个名为`clear`的变量，以便可以为每个密钥打印一行，然后清晰结果。因此，如果我们运行它并输入我的密文，它会给我们 10 行。

![](img/00040.jpeg)

我们只是浏览了这些行并看到哪一个变得可读，您可以看到正确的密钥和正确的明文在`6`处。第一个挑战就在这里：

![](img/00041.jpeg)

这与我们之前看到的类似。密钥是一个数字，它将解密为可读的内容。这是一个以十六进制格式的更长的示例：

![](img/00042.gif)

密钥是两个 ASCII 数字，因此您将不得不尝试 100 种选择来找到将其转换为可读字符串的方法。

# 总结

在本章中，设置 Python 之后，我们介绍了简单的替换密码、凯撒密码，然后是`base64`编码。我们每次收集六位数据而不是八位数据，然后我们看了 XOR 编码，其中位根据密钥逐个翻转。我们还看到了一个非常简单的真值表。您完成的挑战是破解凯撒密码而不知道密钥，通过将`base64`反向解码以获取原始字节，并尝试所有可能的密钥进行暴力攻击来破解 XOR 加密。在第二章 *哈希*中，我们将介绍不同类型的哈希算法。
