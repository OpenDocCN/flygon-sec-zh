# 第二章：哈希

哈希有两个主要目的：第一个是在文件上放置一个指纹，以便您可以判断它是否已被更改，第二个是隐藏密码，以便您仍然可以识别正确的密码并启用登录，但是窃取哈希的人不能轻松地从中恢复密码。

在本章中，我们将涵盖以下主题：

+   MD5 和 SHA 哈希

+   Windows 密码哈希

+   Linux 密码哈希

+   挑战 1 - 破解 Windows 哈希

+   挑战 2 - 破解多轮哈希

+   挑战 3 - 破解 Linux 哈希

# MD5 和 SHA 哈希

在解释哈希函数是什么之后，我们将处理 MD5，然后是 SHA 系列：SHA-1，SHA-2 和 SHA-3。我们还将获取一些关于破解哈希的信息。

# 哈希是什么？

如前所述，使用哈希的一个目的是在文件上放置一个指纹。您可以使用哈希算法将文件中的所有字节组合在一起，从而创建一个固定的哈希值。如果更改文件的任何部分并重新计算哈希，则会得到完全不同的值。因此，如果您有两个应该相同的文件，您可以计算每个文件的哈希值，如果两个文件的哈希值匹配，则文件相同。

一个非常常见的哈希是 MD5；它已经存在了几十年。它的长度为 128 位，对于哈希函数来说相当短，对于大多数目的来说足够可靠。人们用它来对下载和恶意软件样本等进行指纹识别，有时也用于隐藏密码。它不是一个完美的哈希函数：已知有一些碰撞，并且有一些算法可以在一些计算时间的代价下创建碰撞，这些碰撞是哈希到相同值的文件对。因此，如果您找到两个具有匹配 MD5 的文件，您并不完全确定它们是相同的文件，但它们通常是。

在 Python 中计算它们非常容易。您只需导入哈希库，然后进行计算。您调用哈希库来创建一个新对象。第一个参数是使用的算法，即 MD5。第二个参数是要进行哈希处理的数据的内容。

在这里，我们将使用`HELLO`作为示例，然后您需要在末尾使用十六进制摘要，否则它将只打印数据结构的地址，而不是显示实际值。我们将使用`HELLO`的哈希，MD5 和十六进制，它有 128 位长。因此，这是 128 除以 4，或 32 个十六进制字符，如果您向`HELLO`添加另一个字符，比如感叹号，哈希将完全改变；一个值的哈希与下一个值的哈希之间没有任何相似之处。

**安全哈希算法**（**SHA**）旨在改进 MD5，直到大约一年前，SHA-1 没有发生碰撞，当时一些谷歌公司的研究人员发现了如何在 SHA-1 中发生碰撞，因此谨慎的人们正在转向 SHA-2。还有另一个由**国家标准技术研究所**批准的算法，称为**SHA-3**，几乎没有人使用，因为据所有人的预期，SHA-2 将在很长一段时间内保持安全。但是，如果发生了危及 SHA-2 的情况，SHA-3 将可供我们使用。SHA-2 和 SHA-3 都有各种长度，但最常见的长度是 256 和 512 位。

您可以在 Python 中轻松计算 SHA-1 和 SHA-2 哈希，但 SHA-3 并不常用，它还不是这个哈希库的一部分。因此，如果您使用 SHA-1 算法，您将得到一个 SHA-1 哈希。它看起来像 MD5 哈希，但更长。然后有 SHA-256 和 SHA-512，它们都是 SHA-2 哈希。您可以看到，尽管它们更安全，但它们更长，而且有些不太方便：

![](img/00043.jpeg)

所以，让我们来看看。

打开终端并执行`python`命令以启动 Python 终端：

![](img/00044.jpeg)

然后，您可以运行以下命令：

![](img/00045.jpeg)

您必须导入`hashlib`。然后，您可以添加`hashlib.new`。第一个参数是算法，这种情况下是`md5`。下一个参数是要进行哈希的数据，这里是`HELLO`，然后添加`hexdigest`以查看十六进制值。所以，这是`HELLO`的哈希，如果我们在末尾添加另一个字符，使其变成`HELLOa`，那么我们会得到一个完全不同的答案。

![](img/00046.jpeg)

如果我们想使用不同的算法，我们只需输入 SHA-1：

![](img/00047.jpeg)

现在我们得到了一个很长的哈希值，如果我们添加`sha256`作为字符，我们会得到一个更长的哈希值：

![](img/00048.jpeg)

这些哈希对于几乎任何目的都足够了。

如果您有某物的哈希值，并且想要计算它来自哪些数据，原则上，这并没有唯一的解决方案。不过，在实践中，对于像密码这样的短对象，是有的。因此，如果有人使用`MD5`函数来隐藏密码，这是一些旧的 Web 应用程序所做的，那么您可以通过猜测密码来反转它，直到找到匹配项。没有数学方法可以撤消哈希函数，因此您只需制作一个库。在`MD5`哈希`HELLO`的示例中，如果您只是进行一系列猜测，您将得到正确的答案。这就是哈希破解的工作原理；这不是一个复杂的想法，只是有点不方便。

我们可以获取`HELLO`的 MD5 哈希并继续猜测：

![](img/00049.jpeg)

如果我们在猜测单词，可能需要猜测数百万个单词才能得到所示的值，但是如果我们能够猜到正确的值，当哈希值匹配时，我们就知道它是正确的。这个的难度取决于您每秒可以计算多少个哈希值，而 MD5 和 SHA 系列都设计为非常快速计算，因此您实际上可以尝试数百万个密码。在下一节中，我们将讨论 Windows 密码哈希。

# Windows 密码哈希

在本节中，我们将看到如何使用 Cain 获取哈希，然后了解 MD4 和 Unicode 的工作原理。然后，我们将讨论如何使用 Google 破解哈希和如何使用单词列表破解哈希。

# 使用 Cain 获取哈希

Cain 是一个免费的黑客工具，可以从正在运行的操作系统中收集 Windows 哈希。为了测试它，我们将在 Windows Server 上创建三个帐户，这是 Windows 操作系统的最新版本。您可以使用命令提示符中的用户命令来执行此操作。您可以添加一个名为`John`的用户，密码为`P@sw0rd`，一个名为`Paul`的用户，密码为`P@sw0rd`，以及一个名为`Ringo`的用户，密码为`P@sw0rd999`：

![](img/00050.jpeg)

如果运行 Cain，它可以收集哈希。以下屏幕截图显示了三个用户及其哈希值：

![](img/00051.jpeg)

LM Hash 部分是一个已经不再被任何 Windows 版本使用的过时系统，因此它只包含一个没有信息的虚拟值。当您登录时 Windows 实际使用的哈希称为 NT Hash。请注意，如果两个用户使用相同的密码，它们将具有完全相同的哈希值：`464`值。这是该系统的一个弱点。不幸的是，这是一个非常薄弱且陈旧的密码系统。

# MD4 和 Unicode

这是 Microsoft 使用的算法。它将密码编码为 Unicode 而不是 ASCII，然后当您通过 MD4 运行它（这是一个非常古老的算法，甚至比 MD5 还要古老），它会产生 NT 哈希值：

![](img/00052.jpeg)

使用 Unicode 的原因是因为 Microsoft 是一个国际操作系统，允许您使用中文和日文等语言的密码，这些语言不是每个字符使用 8 位编码，而是每个字符使用 16 位编码。

# 使用 Google 破解哈希

由于密码哈希没有变化，任何两个具有相同密码的用户将具有相同的哈希，过去 24 年来已经破解了单词列表的所有黑客都将他们的结果放在了互联网上，导致了这样一种情况：你可以直接谷歌经常使用的密码哈希：

![](img/00053.jpeg)

如果你只是把一个哈希放到谷歌上，你经常会发现有人已经为你破解了并放在了互联网上。例如，这里有一个`P@sw0rd`，已经有一个已知的结果，所以你可以破解它。这种简单的方法适用于很多密码，但这种技术对于我们用于用户`Ringo`的密码`P@sw0rd999`不起作用。

# 使用单词列表破解哈希

因此，在密码无法破解的情况下，你需要自己计算：

![](img/00054.jpeg)

你只需使用相同的过程。进行一系列的猜测，对它们进行哈希，然后寻找你的答案。如果你的猜测列表最终达到正确的值，你当然会在这里找到它。因此，你可以看到密码`P@sw0rd999`的`5c2c...`。

这很简单，所以让我们在 Python 中试一试。

在终端窗口中，我们将输入`python`命令。接下来我们将导入`hashlib`库：

![](img/00055.jpeg)

因此，你可以看到进行编码的行。我们输入密码，编码为`utf-16le`，这是 Unicode；然后，我们用 MD4 进行哈希，并将其表示为`hexdigest`。

这是`P@sw0rd`的数字。现在，如果我们尝试访问`Ringo`用户，我们需要有一个包含两个哈希值的列表，这些值最终需要达到正确的值：

![](img/00056.jpeg)

如果我们只是按顺序使用`997`，`998`和`999`进行计数，我们将得到我们正在寻找的`5c2c...`值。

# Linux 密码哈希

在本节中，我们将首先讨论如何从操作系统中获取哈希值，然后看看加盐和拉伸过程是如何使 Linux 哈希值更加安全的。然后我们将讨论现代版本的 Linux 使用的特定哈希算法，最后看看如何使用单词列表和 Python 破解哈希。

在这里，我们创建了三个用户来测试软件，方式与我们之前在 Windows 上做的方式类似。`John`和`Paul`有相同的密码，而`Ringo`有不同的密码：

![](img/00057.jpeg)

你可以从`/etc/shadow`文件中获取哈希值，从中我们将打印出最后三条记录。因此，你会看到`John`，`Paul`和`Ringo`，每个用户名后面都跟着`$6`，这表明它是密码的第 6 种类型，这是最现代和安全的形式。然后是一长串随机字符，直到下一个美元符号，然后是一个更长的随机字符串，这就是密码哈希本身。

你可以看到的第一件事是密码哈希，它比 Windows 密码哈希要长得多，更复杂。接下来要观察的是，即使`John`和`Paul`有相同的密码，它们的哈希完全不同，因为在对它们进行哈希之前，它们会添加一个随机的`salt`，以掩盖这些密码是相同的事实，从而使密码更加安全。加盐是在进行哈希之前添加随机字符的过程；这里也使用了拉伸。它不仅仅使用一轮 MD4，而是使用了 5000 轮 SHA-512，这简单地使得计算哈希需要更多的 CPU 时间。这样做的目的是减缓试图制作密码哈希字典的攻击者的速度。

你可以在`/etc/login.defs`文件中找到该方法的详细信息，该文件显示现代版本的 Linux 使用`SHA512`和`5000`轮的加密方法：

![](img/00058.jpeg)

因此，该过程要求你将`salt`与密码结合起来。你执行一个包括 5000 轮 SHA-512 哈希的算法。它实际上有超过 20 个步骤，涉及将两个哈希值放在一起并混合位，但它比仅仅重复相同的哈希算法要复杂一些。

我们将使用`passlive`库。在 Python 中使用它之前，你必须使用`pip install passlib`命令进行安装。一旦你安装好了，你就可以导入`sha512_crypt`模块。以下是你如何使用它：

![](img/00059.jpeg)

让我们开始 Python 终端。然后我们可以像之前展示的那样导入`passlib`库，因为我们已经将其放入`pip install`中。

现在，我们可以计算第一个，它将使用影子文件中的`salt`值并对其进行哈希，如前面的屏幕截图所示。

正如你所看到的，我们得到了正确的结果（以`r7k`开头）。如果我们进行字典攻击，我们将得到一系列密码猜测，如下所示：

![](img/00060.jpeg)

只需尝试它们，直到找到与之匹配的那个。

# 挑战 1 – 破解 Windows 哈希

在对 Windows 哈希进行审查和进行 1 位数哈希的示例之后，我们将给你两个挑战——一个是 2 位数密码，另一个是 7 位数密码。以下是 Python 中 Windows 哈希的样子：

![](img/00061.jpeg)

该算法使用`hashlib`对密码的哈希进行 MD4，但在此之前，将其编码为`utf-16le`，然后计算结果的`hexdigest`以获得长数字，该数字以`464`开头，在这种情况下，这是一个 Windows 密码哈希。

因此，你可以编写一个程序，尝试这个字符串中的所有字符，它将由 10 个数字组成，然后计算每个字符的哈希。你将得到一个简单的包含 10 个值的字典：

![](img/00062.jpeg)

你可以使用一个 1 位数密码来破解这个 1 位数哈希，方法如下：

![](img/00063.jpeg)

因此，这是一个挑战。密码是 00 到 99 之间的 2 位数，这是哈希：

![](img/00064.jpeg)

因此，你需要创建一个循环，尝试 100 个可能的值。

接下来是一个 7 位数密码，这是哈希：

![](img/00065.jpeg)

因此，你将不得不尝试 1000 万个值。这只需要几秒钟，这就是为什么 Windows 密码哈希非常薄弱——你可以每秒尝试数百万个。

# 挑战 2 – 破解多轮哈希

在审查了 Python 中 MD5 和 SHA 的工作原理之后，我们将看到多轮哈希是什么，然后你将得到两个挑战来解决。

MD5 和 SHA 都很容易计算：

![](img/00066.jpeg)

从`hashlib`库中，你只需要使用`hashlib.new`方法，并将算法的名称放在第一个参数中，密码放在第二个参数中，然后将十六进制摘要添加到其中，以便看到十六进制的实际结果，而不仅仅是对象的地址。要进行多轮，你只需重复该过程。

你需要将密码放入`h`，然后使用当前的`h`来计算下一个`h`，并一遍又一遍地重复这个过程。以下是一个打印多轮 MD5 哈希的前 10 轮的小脚本：

![](img/00067.jpeg)

这种技术称为**拉伸**，它被更强大的密码哈希例程所使用，比如我们在前面部分看到的 Linux 密码哈希。

这是你的第一个挑战：一个 3 位数密码使用 MD5 哈希 100 次。从这个哈希中找到它：

![](img/00068.jpeg)

这里还有一个挑战。在这个挑战中，你有一个未知轮数的 SHA-1，但不超过 5000。因此，你只需尝试所有值，并从这个哈希中找到结果的 3 位数密码。

# 挑战 3 – 破解 Linux 哈希

在审查了 Linux 哈希之后，我们将向你展示你的挑战。

Linux 哈希是经过盐处理和拉伸的，有各种版本。我们正在讨论当前版本，即版本 6，也就是最安全的形式：

![](img/00069.jpeg)

哈希是以美元符号开头的长字符串；`6`表示版本，然后是一个美元符号，后面跟着`salt`，再加一个美元符号，后面是哈希。要在 Python 中计算它们，您需要导入一个特殊的 SHA-512 `crypt`库，就像您之前看到的格式一样。

这是您的第三个挑战：以这种格式的 3 位密码。`salt`值为`penguins`，`hash`是以`P`开头的一长串混乱字符。

# 摘要

在本章中，我们介绍了 MD5 和 SHA-1 哈希算法，Windows 密码哈希算法和 Linux 密码哈希算法。在挑战中，您破解了一个 Windows 密码哈希以恢复明文密码，以及使用未知数量的 MD5 和 SHA-1 轮次破解了另一个密码哈希。最后，您破解了 Linux 密码哈希以恢复明文密码。

在第三章，*强加密*中，我们将介绍两种主要的强加密方法，即 AES 和 RSA。
