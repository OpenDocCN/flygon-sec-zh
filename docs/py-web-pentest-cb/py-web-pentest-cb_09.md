# 第九章。报告

在本章中，我们将涵盖以下主题：

+   将 Nmap XML 转换为 CSV

+   从 URL 提取链接到 Maltego

+   从 URL 提取电子邮件到 Maltego

+   将 Sslscan 解析为 CSV

+   使用`plot.ly`生成图表

# 介绍

我们在本书中有各种执行 Web 应用程序测试的方法。因此，我们有所有这些信息。我们从我们的方法中得到控制台输出，但是如何将所有这些收集到一个有用的格式中呢？理想情况下，我们希望输出以一种我们可以使用的格式。或者我们可能希望将来自另一个应用程序（如 Nmap）的输出转换为我们正在使用的格式。这可以是**逗号分隔变量**（**CSV**），或者可能是 Maltego 变换，或者任何您想要使用的其他格式。

你刚才提到的 Maltego 是什么？我听到你问。Maltego 是一个**开源情报**（**OSINT**）和取证应用程序。它有一个漂亮的 GUI，可以帮助您以一种漂亮、漂亮且易于理解的方式可视化您的信息。

# 将 Nmap XML 转换为 CSV

Nmap 是在 Web 应用程序测试的侦察阶段中常用的工具。通常用于使用各种选项扫描端口，以帮助您自定义扫描的方式。例如，您想要进行 TCP 还是 UDP？您想设置什么 TCP 标志？是否有特定的 Nmap 脚本，例如检查**网络时间协议**（**NTP**）反射，但在非默认端口上运行？列表可能是无穷无尽的。

Nmap 输出很容易阅读，但在程序化的方式下并不容易使用。这个简单的示例将把 Nmap 的 XML 输出（通过在运行 Nmap 扫描时使用-oX 标志）转换为 CSV 输出。

## 准备工作

虽然这个示例在实现上非常简单，但您需要安装 Python 的`nmap`模块。您可以使用`pip`或从源文件构建它来实现。您还需要来自 Nmap 扫描的 XML 输出。您可以从扫描您选择的易受攻击的虚拟机或您有权限扫描的站点中获取这些输出。您可以直接使用 Nmap，也可以在 Python 脚本中使用 Python 的`nmap`模块来实现。

## 如何做…

就像我之前提到的，这个示例非常简单。这主要是因为`nmap`库已经为我们做了大部分的工作。

这是我们将用于此任务的脚本：

```py
import sys
import os
import nmap

nm=nmap.Portscanner()
with open(“./nmap_output.xml”, “r”) as fd:
    content = fd.read()
    nm.analyse_nmap_xml_scan(content)
    print(nm.csv())
```

## 工作原理…

因此，在导入必要的模块之后，我们必须初始化 Nmap 的`Portscanner`函数。尽管在这个示例中我们不会进行任何端口扫描，但这是必要的，以便我们可以使用对象中的方法：

```py
nm=nmap.Portscanner()
```

然后，我们有一个`with`语句。那是什么？以前，在 Python 中打开文件时，您必须记住在完成后关闭它。在这种情况下，`with`语句将在其中的所有代码执行完毕后为您关闭文件。如果您记忆力不好，经常忘记在代码中关闭文件，这将非常有用：

```py
with open(“./nmap_output.xml”, “r”) as fd:
```

在`with`语句之后，我们将文件的内容读入`content`变量中（我们可以将此变量命名为任何我们想要的，但为什么要使事情变得过于复杂呢？）：

```py
    content = fd.read()
```

使用我们之前创建的`Portscanner`对象，我们现在可以分析我们提供的 XML 输出的内容，然后将其打印为 CSV：

```py
nm.analyse_nmap_xml_scan(content)
    print(nm.csv())
```

# 从 URL 提取链接到 Maltego

本书中还有另一个示例，说明如何使用`BeautifulSoup`库以编程方式获取域名。这个示例将向您展示如何创建一个本地的 Maltego 变换，然后您可以在 Maltego 中使用它以一种易于使用、图形化的方式生成信息。通过从这个变换中收集的链接，这也可以作为更大的爬虫或抓取解决方案的一部分使用。

## 如何做…

以下代码显示了如何创建一个脚本，将枚举信息输出到 Maltego 的正确格式中：

```py
import urllib2
from bs4 import BeautifulSoup
import sys

tarurl = sys.argv[1]
if tarurl[-1] == “/”:
  tarurl = tarurl[:-1]
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”

url = urllib2.urlopen(tarurl).read()
soup = BeautifulSoup(url)
for line in soup.find_all(‘a’):
  newline = line.get(‘href’)
  if newline[:4] == “http”:
    print”<Entity Type=\”maltego.Domain\”>” 
    print”<Value>”+str(newline)+”</Value>”
    print”</Entity>”
  elif newline[:1] == “/”:
    combline = tarurl+newline
    print”<Entity Type=\”maltego.Domain\”>” 
    print”<Value>”+str(combline)+”</Value>”
    print”</Entity>”
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 它是如何工作的…

首先，我们为这个配方导入所有必要的模块。您可能已经注意到，对于`BeautifulSoup`，我们有以下行：

```py
from bs4 import BeautifulSoup
```

这样，当我们使用`BeautifulSoup`时，我们只需输入`BeautifulSoup`，而不是`bs4.BeautifulSoup`。

然后，我们将提供的目标 URL 分配给一个变量：

```py
tarurl = sys.argv[1]
```

完成后，我们检查目标 URL 是否以`/`结尾。如果是，则通过用`tarurl`变量替换`tarurl`的最后一个字符之外的所有字符，以便在配方中输出完整的相对链接时可以稍后使用：

```py
if tarurl[-1] == “/”:
  tarurl = tarurl[:-1]
```

然后，我们打印出构成 Maltego 变换响应的标签：

```py
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
```

然后，我们使用`urllib2`打开目标`url`并将其存储在`BeautifulSoup`中：

```py
url = urllib2.urlopen(tarurl).read()
soup = BeautifulSoup(url)
```

我们现在使用 soup 来查找所有`<a>`标签。更具体地说，我们将寻找具有超文本引用（链接）的`<a>`标签：

```py
for line in soup.find_all(‘a’):
  newline = line.get(‘href’)
```

如果链接的前四个字符是`http`，我们将其输出为 Maltego 的实体的正确格式：

```py
if newline[:4] == “http”:
    print”<Entity Type=\”maltego.Domain\”>”
    print”<Value>”+str(newline)+”</Value>”
    print”</Entity>”
```

如果第一个字符是`/`，表示链接是相对链接，那么我们将在将目标 URL 添加到链接之后将其输出到正确的格式。虽然这个配方展示了如何处理相对链接的一个示例，但重要的是要注意，还有其他类型的相对链接，比如只是一个文件名（`example.php`），一个目录，以及相对路径点符号（`../../example.php`），如下所示：

```py
elif newline[:1] == “/”:
    combline = tarurl+newline
    if 
    print”<Entity Type=\”maltego.Domain\”>”
    print”<Value>”+str(combline)+”</Value>”
    print”</Entity>”
```

在我们处理页面上的所有链接之后，我们关闭了输出开始时打开的所有标签：

```py
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 还有更多…

`BeautifulSoup`库包含其他可以使您的代码更简单的函数。其中一个函数叫做**SoupStrainer**。SoupStrainer 允许您仅解析您想要的文档部分。我们留下这个作为一个让您探索的练习。

# 将电子邮件提取到 Maltego

本书中还有另一个配方，说明了如何从网站中提取电子邮件。这个配方将向您展示如何创建一个本地的 Maltego 变换，然后您可以在 Maltego 本身中使用它来生成信息。它可以与 URL 蜘蛛变换一起使用，从整个网站中提取电子邮件。

## 如何做…

以下代码显示了如何通过使用正则表达式从网站中提取电子邮件：

```py
import urllib2
import re
import sys

tarurl = sys.argv[1]
url = urllib2.urlopen(tarurl).read()
regex = re.compile((“([a-z0-9!#$%&’*+\/=?^_`{|}~- ]+(?:\.[*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&’*+\/=?^_`” “{|}~- ]+)*(@|\sat\s)(?:a-z0-9?(\.|” “\ sdot\s))+a-z0-9?)”))

print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
emails = re.findall(regex, url)
for email in emails:
  print”    <Entity Type=\”maltego.EmailAddress\”>”
  print”      <Value>”+str(email[0])+”</Value>”
  print”    </Entity>”
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 它是如何工作的…

脚本的顶部导入了必要的模块。之后，我们将提供的 URL 分配为一个变量，并使用`urllib2`打开`url`列表：

```py
tarurl = sys.argv[1]
url = urllib2.urlopen(tarurl).read()
```

然后，我们创建一个匹配标准电子邮件地址格式的正则表达式：

```py
regex = re.compile((“([a-z0-9!#$%&’*+\/=?^_`{|}~-]+(?:\.[a-z0- 9!#$%&’*+\/=?^_`” “{|}~-]+)*(@|\sat\s)(?:a-z0-9?(\.|” “\sdot\s))+a-z0-9?)”))
```

前面的正则表达式应匹配格式为`email@address.com`或电子邮件在地址点 com 中的电子邮件地址。

然后，我们输出了一个有效的 Maltego 变换输出所需的标签：

```py
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
```

然后，我们找到`url`内容中与我们的正则表达式匹配的所有文本实例：

```py
emails = re.findall(regex, url)
```

然后，我们找到我们找到的每个电子邮件地址，并以正确的格式输出到 Maltego 变换响应中：

```py
for email in emails:
  print”    <Entity Type=\”maltego.EmailAddress\”>”
  print”      <Value>”+str(email[0])+”</Value>”
  print”    </Entity>”
```

然后，我们关闭了之前打开的标签：

```py
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

# 将 Sslscan 解析为 CSV

Sslscan 是一种用于枚举 HTTPS 站点支持的密码的工具。了解站点支持的密码对 Web 应用程序测试很有用。如果一些支持的密码较弱，这在渗透测试中更有用。

## 如何做…

这个配方将在指定的 IP 地址上运行 Sslscan，并将结果输出为 CSV 格式：

```py
import subprocess
import sys

ipfile = sys.argv[1]

IPs = open(ipfile, “r”)
output = open(“sslscan.csv”, “w+”)

for IP in IPs:
  try:
    command = “sslscan “+IP

    ciphers = subprocess.check_output(command.split())

    for line in ciphers.splitlines():
      if “Accepted” in line:
        output.write(IP+”,”+line.split()[1]+”,”+ line.split()[4]+”,”+line.split()[2]+”\r”)
  except:
    pass
```

## 它是如何工作的…

我们首先导入必要的模块，并将参数中提供的文件名分配给一个变量：

```py
import subprocess
import sys

ipfile = sys.argv[1]
```

提供的文件名应指向包含 IP 地址列表的文件。我们以只读方式打开此文件：

```py
IPs = open(ipfile, “r”)
```

然后，我们打开一个文件以进行读取和写入输出，而不是使用`r`：

```py
output = open(“sslscan.csv”, “w+”)
```

现在我们有了输入和写输出的地方，我们已经准备好了。我们首先通过 IP 地址进行迭代：

```py
for IP in IPs:
```

对于每个 IP，我们运行 Sslscan：

```py
  try:
    command = “sslscan “+IP
```

然后我们将命令的输出分成几块：

```py
    ciphers = subprocess.check_output(command.split())
```

然后我们逐行查看输出。如果行包含`Accepted`这个词，那么我们会为 CSV 输出排列行的元素：

```py
    for line in ciphers.splitlines():
      if “Accepted” in line:
        output.write(IP+”,”+line.split()[1]+”,”+ line.split()[4]+”,”+line.split()[2]+”\r”)
```

最后，如果由于任何原因尝试对 IP 运行 SSL 扫描失败，我们只需继续下一个 IP 地址：

```py
  except:
  pass
```

# 使用 plot.ly 生成图表

有时候有一个数据的可视化表示真的很好。在这个示例中，我们将使用`plot.ly` python API 来生成一个漂亮的图表。

## 准备就绪

在这个示例中，我们将使用`plot.ly` API 来生成我们的图表。如果您还没有账户，您需要在[`plot.ly`](https://plot.ly)注册一个账户。

一旦您有了账户，您就需要准备好使用`plot.ly`的环境。

最简单的方法是使用`pip`来安装它，所以只需运行以下命令：

```py
$ pip install plotly

```

然后，您需要运行以下命令（用您自己的用户名、API 密钥和流 ID 替换`{username}`、`{apikey}`和`{streamids}`，这些信息可以在`plot.ly`网站的账户订阅下查看）：

```py
python -c “import plotly;  plotly.tools.set_credentials_file(username=’{username}’,  api_key=’{apikey}’, stream_ids=[{streamids}])”

```

如果您正在按照这个示例进行操作，我使用的是在线测试的`pcap`文件：[`www.snaketrap.co.uk/pcaps/hbot.pcap`](http://www.snaketrap.co.uk/pcaps/hbot.pcap)。

我们将枚举`pcap`文件中的所有 FTP 数据包，并将它们根据时间绘制出来。

为了解析`pcap`文件，我们将使用`dpkt`模块。就像之前的示例中使用的`Scapy`一样，`dpkt`可以用来解析和操作数据包。

最简单的方法是使用`pip`来安装它。只需运行以下命令：

```py
$ pip install dpkt

```

## 如何做…

这个示例将读取一个`pcap`文件，并提取任何 FTP 数据包的日期和时间，然后将这些数据绘制成图表：

```py
import time, dpkt
import plotly.plotly as py
from plotly.graph_objs import *
from datetime import datetime

filename = ‘hbot.pcap’

full_datetime_list = []
dates = []

for ts, pkt in dpkt.pcap.Reader(open(filename,’rb’)):
    eth=dpkt.ethernet.Ethernet(pkt) 
    if eth.type!=dpkt.ethernet.ETH_TYPE_IP:
        continue

    ip = eth.data
    tcp=ip.data

    if ip.p not in (dpkt.ip.IP_PROTO_TCP, dpkt.ip.IP_PROTO_UDP):
        continue

    if tcp.dport == 21 or tcp.sport == 21:
        full_datetime_list.append((ts, str(time.ctime(ts))))

for t,d in full_datetime_list:
    if d not in dates:
        dates.append(d)

dates.sort(key=lambda date: datetime.strptime(date, “%a %b %d %H:%M:%S %Y”))

datecount = []

for d in dates:
    counter = 0
    for d1 in full_datetime_list:
        if d1[1] == d:
            counter += 1

    datecount.append(counter)

data = Data([
    Scatter(
        x=dates,
        y=datecount
    )
])
plot_url = py.plot(data, filename=’FTP Requests’)
```

## 工作原理…

我们首先导入必要的模块，并将我们的`pcap`文件的文件名分配给一个变量：

```py
import time, dpkt
import plotly.plotly as py
from plotly.graph_objs import *
from datetime import datetime

filename = ‘hbot.pcap’
```

接下来，我们设置我们将在迭代`pcap`文件时填充的列表。`Full_datetime_list`变量将保存所有 FTP 数据包的日期，而`dates`将用于保存完整列表中唯一的`datetime`：

```py
full_datetime_list = []
dates = []
```

然后我们打开`pcap`文件进行读取，并在`for`循环中迭代。这一部分检查数据包是否是 FTP 数据包，如果是，然后将时间追加到我们的数组中：

```py
for ts, pkt in dpkt.pcap.Reader(open(filename,’rb’)):
    eth=dpkt.ethernet.Ethernet(pkt) 
    if eth.type!=dpkt.ethernet.ETH_TYPE_IP:
        continue

    ip = eth.data
    tcp=ip.data

    if ip.p not in (dpkt.ip.IP_PROTO_TCP, dpkt.ip.IP_PROTO_UDP):
        continue

    if tcp.dport == 21 or tcp.sport == 21:
        full_datetime_list.append((ts, str(time.ctime(ts))))
```

现在我们有了 FTP 流量的`datetime`函数列表，我们可以从中获取唯一的`datetime`函数，并填充我们的`dates`数组：

```py
for t,d in full_datetime_list:
    if d not in dates:
        dates.append(d)
```

然后我们对日期进行排序，以便它们在我们的图表上按顺序排列：

```py
dates.sort(key=lambda date: datetime.strptime(date, “%a %b %d H:%M:%S %Y”))
```

然后，我们只需迭代唯一的日期，并计算在那个时间段内从我们的较大数组中发送/接收的所有数据包，并填充我们的计数器数组：

```py
datecount = []

for d in dates:
    counter = 0
    for d1 in full_datetime_list:
        if d1[1] == d:
            counter += 1

    datecount.append(counter)
```

剩下要做的就是通过 API 调用`plot.ly`，使用我们的日期数组和计数数组作为数据点：

```py
data = Data([
    Scatter(
        x=dates,
        y=datecount
    )
])
plot_url = py.plot(data, filename=’FTP Requests’)
```

当您运行脚本时，它应该会弹出浏览器到您新创建的`plot.ly`图表，如下所示：

![工作原理…](img/B04044_09_01.jpg)

就是这样。`plot.ly`有很多不同的方法来可视化您的数据，值得花点时间去尝试一下。想象一下当老板看到您发送给他们的漂亮图表时会有多么印象深刻。
