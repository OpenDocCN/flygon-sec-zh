# 第五章：网页头部操作

在本章中，我们将涵盖以下主题：

+   测试 HTTP 方法

+   通过 HTTP 标头对服务器进行指纹识别

+   测试不安全的标头

+   通过授权标头进行暴力登录

+   测试点击劫持漏洞

+   通过欺骗用户代理标识替代站点

+   测试不安全的 cookie 标志

+   通过 cookie 注入进行会话固定

# 介绍

渗透测试 Web 服务器的一个关键领域是深入研究服务器处理请求和提供响应的能力。如果你正在渗透测试标准的 Web 服务器部署，例如 Apache 或 Nginx，那么你将希望集中精力打破已部署的配置并枚举/操作站点的内容。如果你正在渗透测试自定义的 Web 服务器，那么最好随身携带 HTTP RFC 的副本（可在[`tools.ietf.org/html/rfc7231`](http://tools.ietf.org/html/rfc7231)获取），并额外测试 Web 服务器如何处理损坏的数据包或意外请求。

本章将重点介绍创建配方，以便以揭示底层 Web 技术并解析响应以突出显示常见问题或进一步测试的关键领域的方式操作请求。

# 测试 HTTP 方法

测试 Web 服务器的一个很好的起点是在`HTTP`请求的开始处，通过枚举`HTTP`方法。`HTTP`方法由客户端发送，并指示 Web 服务器客户端期望的操作类型。

根据 RFC 7231 的规定，所有 Web 服务器必须支持`GET`和`HEAD`方法，所有其他方法都是可选的。由于除了最初的`GET`和`HEAD`方法之外还有很多常见的方法，这使得它成为测试的一个重点，因为每个服务器都将被编写以以不同的方式处理请求和发送响应。

一个有趣的`HTTP`方法是`TRACE`，因为其可用性导致**跨站点跟踪**（**XST**）。TRACE 是一个回环测试，基本上会将其接收到的请求回显给用户。这意味着它可以用于跨站点脚本攻击（在这种情况下称为跨站点跟踪）。为此，攻击者让受害者发送一个带有 JavaScript 有效载荷的`TRACE`请求，然后在返回时在本地执行。现代浏览器现在内置了防御措施，通过阻止通过 JavaScript 发出的 TRACE 请求来保护用户免受这些攻击，因此这种技术现在只对旧浏览器有效，或者在利用其他技术（如 Java 或 Flash）时才有效。

## 如何做…

在这个配方中，我们将连接到目标 Web 服务器，并尝试枚举各种可用的`HTTP`方法。我们还将寻找`TRACE`方法的存在，并在可能的情况下进行突出显示：

```py
import requests

verbs = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'TRACE', 'TEST']
for verb in verbs:
    req = requests.request(verb, 'http://packtpub.com')
    print verb, req.status_code, req.reason
    if verb == 'TRACE' and 'TRACE / HTTP/1.1' in req.text:
      print 'Possible Cross Site Tracing vulnerability found'
```

## 工作原理…

第一行导入了 requests 库；在本节中将经常使用它：

```py
import requests
```

接下来创建了一个我们将发送的`HTTP`方法数组。请注意标准方法——`GET`、`POST`、`PUT`、`HEAD`、`DELETE`和`OPTIONS`——后面是一个非标准的`TEST`方法。这是为了检查服务器如何处理它不期望的输入。一些 Web 框架将非标准动词视为`GET`请求并相应地响应。这可以是绕过防火墙的一种好方法，因为它们可能有一个严格的方法列表来匹配，并且不处理来自意外方法的请求：

```py
verbs = ['GET', 'POST', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE', 'CONNECT', 'TEST']
```

接下来是脚本的主循环。这部分发送 HTTP 数据包；在这种情况下，发送到目标`http://packtpub.com` Web 服务器。它打印出方法和响应状态代码和原因：

```py
for verb in verbs:
    req = requests.request(verb, 'http://packtpub.com')
    print verb, req.status_code, req.reason
```

最后，有一段代码专门用于测试 XST：

```py
if verb == 'TRACE' and 'TRACE / HTTP/1.1' in req.text:
      print 'Possible Cross Site Tracing vulnerability found'
```

此代码在发送`TRACE`调用时检查服务器响应，检查响应是否包含请求文本。

运行脚本会得到以下输出：

![工作原理…](img/B04044_05_01.jpg)

在这里，我们可以看到 Web 服务器正确处理了前五个请求，对所有这些方法返回`200 OK`响应。`TRACE`响应返回`405 Not Allowed`，显示这已被 Web 服务器明确拒绝。这里目标服务器的一个有趣之处是，它对`TEST`方法返回`200 OK`响应。这意味着服务器将`TEST`请求处理为不同的方法；例如，它将其视为`GET`请求。正如前面提到的，这是绕过一些防火墙的好方法，因为它们可能不会处理意外的`TEST`方法。

## 还有更多...

在这个示例中，我们展示了如何测试目标 Web 服务器的 XST 漏洞，并测试它如何处理各种`HTTP`方法。这个脚本可以通过扩展示例`HTTP`方法数组来进一步扩展，以包括各种其他有效和无效的数据值；也许您可以尝试发送 Unicode 数据来测试 Web 服务器如何处理意外的字符集，或者发送一个非常长的 HTTP 方法来测试自定义 Web 服务器中的缓冲区溢出。这些数据的一个很好的资源是回到第三章中的模糊脚本，*漏洞识别*，例如，使用来自 Mozilla 的 FuzzDB 的有效载荷。

# 通过 HTTP 头指纹识别服务器

我们将集中关注的 HTTP 协议的下一部分是 HTTP 头部。这些头部在 Web 服务器的请求和响应中都可以找到，它们在客户端和服务器之间携带额外的信息。任何带有额外数据的区域都是解析服务器信息和寻找潜在问题的好地方。

## 如何做...

以下是一个简单的抓取头部的脚本，它将解析响应头，试图识别正在使用的 Web 服务器技术：

```py
import requests

req = requests.get('http://packtpub.com')
headers = ['Server', 'Date', 'Via', 'X-Powered-By', 'X-Country-Code']

for header in headers:
    try:
  result = req.headers[header]
        print '%s: %s' % (header, result)
    except Exception, error:
        print '%s: Not found' % header
```

## 它是如何工作的...

脚本的第一部分通过熟悉的`requests`库向目标 Web 服务器发出简单的`GET`请求：

```py
req = requests.get('http://packtpub.com')
```

接下来，我们生成一个要查找的头部数组：

```py
headers = ['Server', 'Date', 'Via', 'X-Powered-By', 'X-Country- Code']
```

在这个脚本中，我们在主要代码周围使用了 try/except 块：

```py
try:
  result = req.headers[header]
        print '%s: %s' % (header, result)
except:
print '%s: Not found' % header
```

我们需要这种错误处理，因为头部不是强制的；因此，如果我们尝试从数组中检索不存在的头部的键，Python 将引发异常。为了克服这个问题，如果响应中指定的头部不存在，我们只需打印`Not found`。

以下是针对此示例中目标服务器运行脚本的输出的屏幕截图：

![它是如何工作的...](img/B04044_05_02.jpg)

第一行输出显示了`Server`头，显示了底层 Web 服务器技术。这是查找易受攻击的 Web 服务器版本的好地方，但请注意，可能可以禁用并伪装这个头部，因此不要仅仅依赖这一点来猜测目标服务器平台。

`Date`头包含有用的信息，可以用来猜测服务器的位置。例如，您可以计算相对于您的本地时区的时间差，以粗略地指示它的位置。

`Via`头部被代理服务器（出站和入站）使用，并将显示代理名称，在本例中为`1.1 varnish`。

`X-Powered-By`是常见 Web 框架中使用的标准头部，例如 PHP。默认的 PHP 安装将以 PHP 和版本号作出响应，使其成为另一个很好的侦察目标。

最后一行打印`X-Country-Code`短代码，另一个有用的信息，用于确定服务器的位置。

请注意，所有这些头部都可以在服务器端设置或覆盖，因此不要仅仅依赖这些信息，并谨慎地解析来自远程服务器的数据；即使这些头部也可能包含恶意值。

## 还有更多...

该脚本当前包含服务器的版本，但可以进一步扩展以查询在线 CVE 数据库，例如[`cve.mitre.org/cve/`](https://cve.mitre.org/cve/)，查找影响 Web 服务器版本的漏洞。

还可以使用另一种技术来增加指纹识别的准确性，即检查响应标头的顺序。例如，Microsoft IIS 在`Server`标头之前返回`Date`标头，而 Apache 先返回`Date`然后是`Server`。这种略有不同的顺序可用于验证您可能已经从此示例中的标头值推断出的任何服务器版本。

# 测试不安全的标头

我们之前已经看到 HTTP 响应可以成为枚举底层 Web 框架信息的重要来源。现在，我们将利用`HTTP`标头信息将其提升到下一个级别，以测试不安全的 Web 服务器配置并标记可能导致漏洞的任何内容。

## 准备工作

对于此示例，您需要一个要测试不安全标头的 URL 列表。将这些保存到名为`urls.txt`的文本文件中，每个 URL 占一行，与您的示例一起。

## 操作步骤

以下代码将突出显示从每个目标 URL 接收的任何易受攻击的标头：

```py
import requests

urls = open("urls.txt", "r")
for url in urls:
  url = url.strip()
  req = requests.get(url)
  print url, 'report:'

  try:
    xssprotect = req.headers['X-XSS-Protection']
    if  xssprotect != '1; mode=block':
      print 'X-XSS-Protection not set properly, XSS may be possible:', xssprotect
  except:
    print 'X-XSS-Protection not set, XSS may be possible'

  try:
    contenttype = req.headers['X-Content-Type-Options']
    if contenttype != 'nosniff':
      print 'X-Content-Type-Options not set properly:',  contenttype
  except:
    print 'X-Content-Type-Options not set'

  try:
    hsts = req.headers['Strict-Transport-Security']
  except:
    print 'HSTS header not set, MITM attacks may be possible'

  try:
    csp = req.headers['Content-Security-Policy']
    print 'Content-Security-Policy set:', csp
  except:
    print 'Content-Security-Policy missing'

  print '----'
```

## 工作原理

此示例配置为测试许多站点，因此第一部分从文本文件中读取 URL 并打印出当前目标：

```py
urls = open("urls.txt", "r")
for url in urls:
  url = url.strip()
  req = requests.get(url)
  print url, 'report:'
```

然后在 try/except 块中测试每个标头。这类似于先前的示例，因为标头不是强制性的，所以需要这种编码风格。如果我们尝试引用不存在的标头的键，Python 将引发异常。

第一个`X-XSS-Protection`标头应设置为`1; mode=block`以在浏览器中启用 XSS 保护。如果标头未明确匹配该格式或未设置，则脚本将打印警告：

```py
try:
    xssprotect = req.headers['X-XSS-Protection']
    if  'xssprotect' != '1; mode=block':
      print 'X-XSS-Protection not set properly, XSS may be possible'
  except:
    print 'X-XSS-Protection not set, XSS may be possible'
```

下一个`X-Content-Type-Options`标头应设置为`nosniff`，以防止 MIME 类型混淆。 MIME 类型指定目标资源的内容，例如，text/plain 表示远程资源应为文本文件。一些 Web 浏览器会尝试猜测资源的 MIME 类型，如果未指定，则可能导致跨站脚本攻击；如果资源包含恶意脚本，但仅指示为纯文本文件，则可能绕过内容过滤器并执行。如果未设置标头或响应未明确匹配到`nosniff`，此检查将打印警告：

```py
try:
    contenttype = req.headers['X-Content-Type-Options']
    if contenttype != 'nosniff':
      print 'X-Content-Type-Options not set properly'
  except:
    print 'X-Content-Type-Options not set'
```

接下来的`Strict-Transport-Security`标头用于强制通过 HTTPS 通道进行通信，以防止中间人攻击。缺少此标头意味着通信通道可能会被中间人攻击降级为 HTTP：

```py
  try:
    hsts = req.headers['Strict-Transport-Security']
  except:
    print 'HSTS header not set, MITM attacks may be possible'
```

最终的`Content-Security-Policy`标头用于限制可以在网页上加载的资源类型，例如，限制 JavaScript 可以运行的位置：

```py
  try:
    csp = req.headers['Content-Security-Policy']
    print 'Content-Security-Policy set:', csp
  except:
    print 'Content-Security-Policy missing'
```

示例的输出显示在以下屏幕截图中：

![工作原理...](img/B04044_05_03.jpg)

# 通过 Authorization 标头暴力破解登录

许多网站使用 HTTP 基本身份验证来限制对内容的访问。这在嵌入式设备（如路由器）中尤其普遍。Python 的`requests`库内置支持基本身份验证，可以轻松创建身份验证暴力破解脚本的方法。

## 准备工作

在创建此示例之前，您需要一个密码列表来尝试进行身份验证。创建一个名为`passwords.txt`的本地文本文件，每个密码占一行。查看第二章中的在线资源中的密码列表，了解如何暴力破解密码。此外，花一些时间来勘察目标服务器，因为您需要知道它对失败的登录请求做出何种响应，以便我们可以区分暴力破解是否成功。

## 如何做...

以下代码将尝试通过基本身份验证暴力破解网站的入口：

```py
import requests
from requests.auth import HTTPBasicAuth

with open('passwords.txt') as passwords:
    for password in passwords.readlines():
        password = password.strip()
        req = requests.get('http://packtpub.com/admin_login.html', auth=HTTPBasicAuth('admin', password))
        if req.status_code == 401:
            print password, 'failed.'
        elif req.status_code == 200:
            print 'Login successful, password:', password
            break
        else:
            print 'Error occurred with', password
            break
```

## 工作原理...

这个脚本的第一部分逐行读取密码列表，然后发送一个 HTTP `GET`请求到登录页面：

```py
req = requests.get('http://packtpub.com/admin_login.html', auth=HTTPBasicAuth('admin', password))
```

这个请求有一个额外的`auth`参数，其中包含了用户名`admin`和从`passwords.txt`文件中读取的`password`。当发送带有基本`Authorization`头的 HTTP 请求时，原始数据看起来像下面这样：

![工作原理...](img/B04044_05_04.jpg)

请注意，在`Authorization`头中，数据以编码格式发送，比如`YWRtaW46cGFzc3dvcmQx`。这是用户名和密码以`base64`编码形式的`username:password`；`requests.auth.HTTPBasicAuth`类只是为我们做了这个转换。这可以通过使用`base64`库来验证，如下面的截图所示：

![工作原理...](img/B04044_05_05.jpg)

了解这些信息意味着你仍然可以让脚本在没有外部请求库的情况下运行；相反，它使用`base64`默认库手动创建`Authorization`头。

以下是暴力破解脚本运行的截图：

![工作原理...](img/B04044_05_06.jpg)

## 还有更多...

在这个例子中，我们在授权请求中使用了一个固定的用户名 admin，因为这是已知的。如果这是未知的，你可以创建一个`username.txt`文本文件，并循环遍历每一行，就像我们对密码文本文件所做的那样。请注意，这是一个更慢的过程，并且会创建大量的 HTTP 请求到目标站点，这很可能会使你被列入黑名单，除非你实现速率限制。

## 另请参阅

查看第二章中的*检查用户名有效性*和*暴力破解用户名*的示例，以获取有关用户名和密码组合的更多想法。

# 测试点击劫持漏洞

点击劫持是一种用于欺骗用户在不知情的情况下在目标站点上执行操作的技术。这是通过恶意用户在合法网站上放置一个隐藏的覆盖层来实现的，因此当受害者认为他们正在与合法网站进行交互时，实际上他们点击的是隐藏在顶部覆盖层上的隐藏项目。这种攻击可以被设计成使受害者在不知情的情况下输入凭据或点击和拖动项目。这些攻击可以用于针对银行网站，以诱使受害者转账，也常见于社交网络站点，以试图获得更多的关注或点赞，尽管现在大多数站点都有了防御措施。

## 如何做...

网站可以防止点击劫持的两种主要方法：一种是设置`X-FRAME-OPTIONS`头，告诉浏览器如果它在一个框架内就不要渲染该站点，另一种是使用 JavaScript 来跳出框架（通常称为破框）。这个示例将向你展示如何检测这两种防御，以便你可以识别那些没有这两种防御的网站。

```py
import requests
from ghost import Ghost
import logging
import os

URL = 'http://packtpub.com'
req = requests.get(URL)

try:
    xframe = req.headers['x-frame-options']
    print 'X-FRAME-OPTIONS:', xframe , 'present, clickjacking not likely possible'
except:
    print 'X-FRAME-OPTIONS missing'

print 'Attempting clickjacking...'

html = '''
<html>
<body>
<iframe src="img/'''+URL+'''" height='600px' width='800px'></iframe>
</body>
</html>'''

html_filename = 'clickjack.html'
f = open(html_filename, 'w+')
f.write(html)
f.close()

log_filename = 'test.log'
fh = logging.FileHandler(log_filename)
ghost = Ghost(log_level=logging.INFO, log_handler=fh)
page, resources = ghost.open(html_filename)

l = open(log_filename, 'r')
if 'forbidden by X-Frame-Options.' in l.read():
    print 'Clickjacking mitigated via X-FRAME-OPTIONS'
else:
    href = ghost.evaluate('document.location.href')[0]
    if html_filename not in href:
        print 'Frame busting detected'
    else:
        print 'Frame busting not detected, page is likely vulnerable to clickjacking'
l.close()

logging.getLogger('ghost').handlers[0].close()
os.unlink(log_filename)
os.unlink(html_filename)
```

## 工作原理...

这个脚本的第一部分检查了第一个点击劫持防御，即`X-FRAME-OPTIONS`头，方式与前面的示例类似。`X-FRAME-OPTIONS`有三个值：`DENY`、`SAMEORIGIN`或`ALLOW-FROM <url>`。每个值都提供了不同级别的点击劫持保护，因此，在这个示例中，我们尝试检测是否缺少任何一个：

```py
try:
    xframe = req.headers['x-frame-options']
    print 'X-FRAME-OPTIONS:', xframe , 'present, clickjacking not likely possible'
except:
    print 'X-FRAME-OPTIONS missing'
```

代码的下一部分创建了一个本地的 html `clickjack.html`文件，其中包含了一些非常简单的 HTML 代码，并将它们保存到一个本地的`clickjack.html`文件中：

```py
html = '''
<html>
<body>
<iframe src="img/'''+URL+'''" height='600px' width='800px'></iframe>
</body>
</html>'''

html_filename = 'clickjack.html'
f = open(html_filename, 'w+')
f.write(html)
f.close()
```

这段 HTML 代码创建了一个 iframe，其源设置为目标网站。HTML 文件将被加载到 ghost 中，以尝试渲染网站并检测目标站点是否加载在 iframe 中。Ghost 是一个 WebKit 渲染引擎，所以它应该类似于在 Chrome 浏览器中加载站点时会发生的情况。

代码的下一部分设置 ghost 日志记录以重定向到本地日志文件（默认情况下是打印到`stdout`）：

```py
log_filename = 'test.log'
fh = logging.FileHandler(log_filename)
ghost = Ghost(log_level=logging.INFO, log_handler=fh)
```

接下来的一行在 ghost 中呈现本地 HTML 页面，并包含目标页面请求的任何额外资源：

```py
page, resources = ghost.open(html_filename)
```

然后我们打开日志文件并检查`X-FRAME-OPTIONS`错误：

```py
l = open(log_filename, 'r')
if 'forbidden by X-Frame-Options.' in l.read():
    print 'Clickjacking mitigated via X-FRAME-OPTIONS'
```

脚本的下一部分检查了框架破坏；如果 iframe 中有 JavaScript 代码来检测它正在被加载到 iframe 中，它将会跳出框架，导致页面重定向到目标网站。我们可以通过在 ghost 中执行 JavaScript 并读取当前位置来检测这一点：

```py
href = ghost.evaluate('document.location.href')[0]
```

代码的最后部分是清理，关闭任何打开的文件或任何打开的日志处理程序，并删除临时 HTML 和日志文件：

```py
l.close()

logging.getLogger('ghost').handlers[0].close()
os.unlink(log_filename)
os.unlink(html_filename)
```

如果脚本输出`未检测到框架破坏，页面可能容易受到 clickjacking 攻击`，那么目标网站可以在隐藏的 iframe 中呈现，并用于 clickjacking 攻击。下面的截图显示了一个易受攻击网站的日志示例：

![它是如何工作的...](img/B04044_05_07.jpg)

如果你在 web 浏览器中查看生成的 clickjack.html 文件，它将确认目标 web 服务器可以在 iframe 中加载，因此容易受到 clickjacking 的攻击，如下面的截图所示：

![它是如何工作的...](img/B04044_05_08.jpg)

# 通过欺骗用户代理标识替代站点

一些网站限制访问或根据您用于查看它的浏览器或设备显示不同的内容。例如，一个网站可能会为从 iPhone 浏览的用户显示移动定向主题，或者为使用旧版本且容易受攻击的 Internet Explorer 的用户显示警告。这可能是发现漏洞的好地方，因为这些可能没有经过严格测试，甚至被开发人员遗忘了。

## 如何做...

在这个示例中，我们将向您展示如何欺骗您的用户代理，以便您看起来像是在使用不同的设备，以尝试发现替代内容：

```py
import requests
import hashlib

user_agents = { 'Chrome on Windows 8.1' : 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36',
'Safari on iOS' : 'Mozilla/5.0 (iPhone; CPU iPhone OS 8_1_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12B466 Safari/600.1.4',
'IE6 on Windows XP' : 'Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)',
'Googlebot' : 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)' }

responses = {}
for name, agent in user_agents.items():
  headers = {'User-Agent' : agent}
  req = requests.get('http://packtpub.com', headers=headers)
  responses[name] = req

md5s = {}
for name, response in responses.items():
  md5s[name] = hashlib.md5(response.text.encode('utf- 8')).hexdigest()

for name,md5 in md5s.iteritems():
    if name != 'Chrome on Windows 8.1':
        if md5 != md5s['Chrome on Windows 8.1']:
            print name, 'differs from baseline'
        else:
            print 'No alternative site found via User-Agent spoofing:', md5
```

## 它是如何工作的...

我们首先设置了一个用户代理数组，为每个键分配了友好的名称：

```py
user_agents = { 'Chrome on Windows 8.1' : 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36',
'Safari on iOS' : 'Mozilla/5.0 (iPhone; CPU iPhone OS 8_1_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12B466 Safari/600.1.4',
'IE6 on Windows XP' : 'Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)',
'Googlebot' : 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)' }
```

这里有四个用户代理：Windows 8.1 上的 Chrome，iOS 上的 Safari，Windows XP 上的 Internet Explorer 6，最后是 Googlebot。这提供了各种浏览器和示例，你会期望在每个请求后面找到不同的内容。列表中的最后一个用户代理，Googlebot，是 Google 在为他们的搜索引擎爬取数据时发送的爬虫。

代码的下一部分循环遍历每个用户代理，并在请求中设置`User-Agent`标头：

```py
responses = {}
for name, agent in user_agents.items():
  headers = {'User-Agent' : agent}
```

接下来的部分发送 HTTP 请求，使用熟悉的 requests 库，并将每个响应存储在响应数组中，使用友好的用户名作为键：

```py
req = requests.get('http://www.google.com', headers=headers)
  responses[name] = req
```

代码的下一部分创建了一个`md5s`数组，然后遍历响应，抓取`response.text`文件。从中生成响应内容的`md5`哈希，并将其存储到`md5s`数组中：

```py
md5s = {}
for name, response in responses.items():
  md5s[name] = hashlib.md5(response.text.encode('utf- 8')).hexdigest()
```

代码的最后部分遍历`md5s`数组，并将每个项目与原始基线请求进行比较，在这个示例中是`Chrome on Windows 8.1`：

```py
for name,md5 in md5s.iteritems():
    if name != 'Chrome on Windows 8.1':
        if md5 != md5s['Chrome on Windows 8.1']:
            print name, 'differs from baseline'
        else:
            print 'No alternative site found via User-Agent spoofing:', md5
```

我们对响应文本进行了哈希处理，以使生成的数组保持较小，从而减少内存占用。你可以通过其内容直接比较每个响应，但这样会更慢，并且会使用更多内存来处理。

如果来自 Web 服务器的响应与 Chrome on Windows 8.1 基线响应不同，脚本将打印出用户代理友好的名称，如下面的截图所示：

![它是如何工作的...](img/B04044_05_09.jpg)

## 另请参阅

这个方法是基于能够操纵 HTTP 请求中的标头。查看第三章中的*基于标头的跨站脚本*和*Shellshock 检查*部分，了解更多可以传递到标头中的数据示例。

# 测试不安全的 cookie 标志

HTTP 协议的下一个感兴趣的主题是 cookie。由于 HTTP 是一个无状态协议，cookie 提供了一种在客户端存储持久数据的方式。这允许 Web 服务器通过将数据持久化到 cookie 中来进行会话管理，以便在会话期间保持数据。

Cookies 是通过 HTTP 响应中的`Set-Cookie`头从 Web 服务器设置的。然后它们通过`Cookie`头发送回服务器。这个教程将介绍审核网站设置的 cookie 的方法，以验证它们是否具有安全属性。

## 如何做…

以下是一个枚举目标站点上设置的每个 cookie 并标记任何存在的不安全设置的教程：

```py
import requests

req = requests.get('http://www.packtpub.com')
for cookie in req.cookies:
  print 'Name:', cookie.name
  print 'Value:', cookie.value

  if not cookie.secure:
    cookie.secure = '\x1b[31mFalse\x1b[39;49m'
  print 'Secure:', cookie.secure

  if 'httponly' in cookie._rest.keys():
    cookie.httponly = 'True'
  else:
    cookie.httponly = '\x1b[31mFalse\x1b[39;49m'
  print 'HTTPOnly:', cookie.httponly

  if cookie.domain_initial_dot:
    cookie.domain_initial_dot = '\x1b[31mTrue\x1b[39;49m'
  print 'Loosly defined domain:', cookie.domain_initial_dot, '\n'
```

## 工作原理…

我们枚举从 Web 服务器发送的每个 cookie 并检查它们的属性。前两个属性是 cookie 的`name`和`value`：

```py
  print 'Name:', cookie.name
  print 'Value:', cookie.value
```

然后我们检查 cookie 的`secure`标志：

```py
if not cookie.secure:
    cookie.secure = '\x1b[31mFalse\x1b[39;49m'
  print 'Secure:', cookie.secure
```

`Secure`标志表示 cookie 只能通过 HTTPS 发送。对于用于身份验证的 cookie 来说，这是很好的，因为这意味着如果有人监视开放网络流量，它们无法被窃听。

还要注意`\x1b[31m`代码是一种特殊的 ANSI 转义代码，用于更改终端字体的颜色。在这里，我们用红色突出显示了不安全的标头。`\x1b[39;49m`代码将颜色重置为默认值。请参阅维基百科关于 ANSI 的更多信息[`en.wikipedia.org/wiki/ANSI_escape_code`](http://en.wikipedia.org/wiki/ANSI_escape_code)。

下一个检查是`httponly`属性：

```py
  if 'httponly' in cookie._rest.keys():
    cookie.httponly = 'True'
  else:
    cookie.httponly = '\x1b31mFalse\x1b[39;49m'
  print 'HTTPOnly:', cookie.httponly
```

如果设置为`True`，这意味着 JavaScript 无法访问 cookie 的内容，它被发送到浏览器，只能被浏览器读取。这用于防止 XSS 攻击，因此在渗透测试时，缺少此 cookie 属性是一件好事。

最后，我们检查 cookie 中的域，看它是否以点开头：

```py
if cookie.domain_initial_dot:
    cookie.domain_initial_dot = '\x1b[31mTrue\x1b[39;49m'
  print 'Loosly defined domain:', cookie.domain_initial_dot, '\n'
```

如果 cookie 的`domain`属性以点开头，表示 cookie 用于所有子域，因此可能在预期范围之外可见。

以下截图显示了目标网站中不安全标志以红色突出显示：

![工作原理…

## 还有更多…

我们之前已经看到如何通过提取标头来枚举用于提供网站的技术。某些框架还在 cookie 中存储信息，例如，PHP 创建一个名为**PHPSESSION**的 cookie，用于存储会话数据。因此，这些数据的存在表明使用了 PHP，然后可以进一步枚举服务器以尝试测试其是否存在已知的 PHP 漏洞。

# 通过 cookie 注入进行会话固定

会话固定是一种依赖于会话 ID 的漏洞。首先，攻击者必须能够强制受害者使用特定的会话 ID，方法是在其客户端上设置一个 cookie 或已经知道受害者会话 ID 的值。然后，当受害者进行身份验证时，cookie 在客户端保持不变。因此，攻击者知道会话 ID，现在可以访问受害者的会话。

## 准备工作

这个教程将需要对目标站点执行一些初始的侦察，以确定它是如何进行身份验证的，例如通过`POST`请求中的数据或通过基本的`auth`。它还将需要一个有效的用户帐户进行身份验证。

## 如何做…

这个教程将测试通过 cookie 注入进行会话固定：

```py
import requests

url = 'http://www.packtpub.com/'
req = requests.get(url)
if req.cookies:
  print 'Initial cookie state:', req.cookies
  cookie_req = requests.post(url, cookies=req.cookies, auth=('user1', 'supersecretpasswordhere'))
  print 'Authenticated cookie state:', cookie_req.cookies

  if req.cookies == cookie_req.cookies:
      print 'Session fixation vulnerability identified'
```

## 工作原理…

这个脚本有两个阶段；第一步是向目标网站发送初始的`get`请求，然后显示接收到的 cookie：

```py
req = requests.get(url)
print 'Initial cookie state:', req.cookies
```

脚本的第二阶段向目标站点发送另一个请求，这次使用有效的用户凭据进行身份验证：

```py
cookie_req = requests.post(url, cookies=req.cookies, auth=('user1', 'supersecretpasswordhere'))
```

请注意，这里我们将请求 cookie 设置为之前在初始`GET`请求中收到的 cookie。

脚本最后通过打印最终的 cookie 状态并在经过身份验证的 cookie 与初始请求中发送的 cookie 匹配时打印警告来结束：

```py
print 'Authenticated cookie state:', cookie_req.cookies

if req.cookies == cookie_req.cookies:
  print 'Session fixation vulnerability identified'
```

## 还有更多...

Cookie 是另一个由用户控制并由 Web 服务器解析的数据源。与标头类似，这使得它成为测试 XSS 漏洞的绝佳位置。尝试向 cookie 数据添加 XSS 负载并将其发送到目标服务器，以查看它如何处理数据。请记住，cookie 可能会从 Web 服务器后端读取，也可能会被打印到日志中，因此可能会针对日志读取器进行 XSS 攻击（例如，如果后来由管理员读取）。
