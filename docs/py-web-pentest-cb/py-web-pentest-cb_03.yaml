- en: Chapter 3. Vulnerability Identification
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。漏洞识别
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Automated URL-based Directory Traversal
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化基于URL的目录遍历
- en: Automated Cross-site scripting (parameter and URL)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化跨站脚本（参数和URL）
- en: Automated parameter-based Cross-site scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化基于参数的跨站脚本
- en: Automated fuzzing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模糊测试
- en: jQuery checking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery检查
- en: Header-based Cross-site scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于头部的跨站脚本
- en: Shellshock checking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shellshock检查
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter focuses on identifying traditional web app vulnerabilities from
    the Top 10 **Open Web Application Security Project** (**OWASP**). This would include
    **Cross-site scripting** (**XSS**), Directory Traversal, and those other vulnerabilities
    that are simple enough to check for not to warrant their own chapter. This chapter
    provides a parameter-based and URL-based version of each script to allow for either
    eventuality and cut down on individual script complexity. Most of these tools
    have fully crafted alternatives, such as Burp Intruder. The benefit of seeing
    each tool in its simplistic Python is that it allows you to understand how to
    build and craft your own versions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍从**开放式Web应用安全项目**（**OWASP**）的前10个传统Web应用程序漏洞。这将包括**跨站脚本**（**XSS**），目录遍历以及那些简单到不需要单独章节检查的其他漏洞。本章提供了每个脚本的基于参数和基于URL的版本，以适应任何情况并减少单个脚本的复杂性。大多数这些工具都有完全成熟的替代方案，比如Burp
    Intruder。看到每个工具以其简单的Python形式的好处在于，它让你了解如何构建和制作自己的版本。
- en: Automated URL-based Directory Traversal
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化基于URL的目录遍历
- en: 'Occasionally, websites call files using unrestricted functions; this can allow
    the fabled Directory Traversal or **Direct Object Reference** (**DOR**). In this
    attack, a user can call arbitrary files within the context of the website by using
    a vulnerable parameter. There are two ways this can be manipulated: firstly, by
    providing an absolute link such as `/etc/passwd`, which states from the `root`
    directory browse to the `etc` directory and open the `passwd` file, and secondly,
    relative links that travel up directories in order to reach the `root` directory
    and travel to the intended file.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，网站使用不受限制的函数调用文件；这可能导致传说中的目录遍历或**直接对象引用**（**DOR**）。在这种攻击中，用户可以通过使用一个易受攻击的参数在网站的上下文中调用任意文件。这可以通过两种方式进行操纵：首先，通过提供绝对链接，比如`/etc/passwd`，这表示从`root`目录浏览到`etc`目录并打开`passwd`文件，其次，相对链接，可以向上遍历目录以达到`root`目录并访问目标文件。
- en: We will be creating a script that attempts to open a file that is always present
    on a Linux machine, the aforementioned `/etc/passwd` file by gradually increasing
    the number of up directories to a parameter in a URL. It will identify when it
    has succeeded by the detection of the phrase root that indicates that file has
    been opened.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，尝试逐渐增加URL参数中的向上目录数量，以打开Linux机器上始终存在的文件`/etc/passwd`。它将通过检测到指示文件已被打开的短语root来确定何时成功。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Identify the URL parameter that you wish to test. This script has been configured
    to work with most devices: `etc/passwd` should work with OSX and Linux installations
    and `boot.ini` should work with Windows installations. See the end of this example
    for a PHP web page that can be used against to test the validity of the scripts.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您要测试的URL参数。此脚本已配置为与大多数设备一起使用：`etc/passwd`应该适用于OSX和Linux安装，`boot.ini`应该适用于Windows安装。查看本示例的末尾，以获取可用于测试脚本有效性的PHP网页。
- en: We will be using the requests library that can be installed through `pip`. In
    the author's opinion, it's better than `urllib` in terms of functionality and
    usability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用可以通过`pip`安装的requests库。在作者看来，它在功能和可用性方面比`urllib`更好。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Once you''ve identified your parameter to attack, pass it to the script as
    a command line argument. Your script should be the same as the following script:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定要攻击的参数，请将其作为命令行参数传递给脚本。您的脚本应与以下脚本相同：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is an example of the output produced when using this script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时产生的输出示例如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We import the libraries we require for this script, as with every other script
    we''ve done in the book so far:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入我们在本书中到目前为止所需的库，就像我们做的其他脚本一样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then take our input in the form of a URL. As we are using the `requests`
    library, we should ensure that our URL matches the form requests is expecting,
    which is `http(s)://url`. Requests will remind you of this if you get it wrong:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以URL的形式输入。由于我们使用`requests`库，我们应该确保我们的URL与requests期望的形式匹配，即`http(s)://url`。如果你搞错了，requests会提醒你：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We establish the payloads which we are going to send in each attack in a dictionary.
    The first value in each pair is the file that we wish to attempt to load and the
    second is a value that will definitely be within that file. The more specific
    that second value is, the fewer false positives that will occur; however, this
    may increase the chances of false negatives. Feel free to include your own files
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立我们将在每次攻击中发送的有效载荷的字典。每对中的第一个值是我们希望尝试加载的文件，第二个值是肯定会在该文件中的值。第二个值越具体，错误报告就会越少；但是，这可能会增加错误否定的机会。请随意在这里包含你自己的文件：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We provide the up directory shortcut `../` and assign it to the up variable
    and we set the counter for our loop to `0`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供向上目录的快捷方式`../`并将其分配给向上变量，并将我们的循环计数器设置为`0`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Iteritems` method allows us to go through the dictionary and take each
    key and value, and assign them to variables. We assign the first value as payload
    and the second value as string. We then cap our loop to stop it repeating forever
    in the event of a failure. I have set this to `7` though this can be set to any
    value that you please. Bear in mind the likelihood of a directory structure for
    a web app being any higher than `7`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iteritems`方法允许我们遍历字典并将每个键和值分配给变量。我们将第一个值分配为负载，第二个值分配为字符串。然后我们限制我们的循环，以防失败时无限重复。我将其设置为`7`，尽管这可以设置为任何您喜欢的值。请记住，Web应用程序的目录结构可能高于`7`的可能性：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We craft our request by taking our root URL and appending the current number
    of up directories according to the loop and the payload. This is then sent in
    a post request:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过获取我们的根URL，并根据循环和负载的当前数量附加上级目录的当前数量来构建我们的请求。然后将其发送到一个post请求中：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We check to see whether we have achieved our goal by looking for our intended
    string in the response. If the string is present, we halt the loop and print out
    the attack string, along with the response to the successful attack. This allows
    us to manually verify whether the attack was successful or whether the code needs
    to be refactored, or the web app isn''t vulnerable:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看响应中是否包含我们预期的字符串来检查是否已经实现了我们的目标。如果字符串存在，我们将停止循环，并打印出攻击字符串以及成功攻击的响应。这样可以让我们手动验证攻击是否成功，或者代码是否需要重构，或者Web应用程序是否存在漏洞。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, the counter is added to each loop until it reaches the preset max.
    Once the max is reached, it is set to zero for the next attack string.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，计数器将添加到每个循环，直到达到预设的最大值。一旦达到最大值，它将被设置为下一个攻击字符串。
- en: There's more
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: This recipe can be adapted to work with parameters through the application of
    the principles shown elsewhere in the book. However, due to the rarity of pages
    being called through parameters and intentional brevity, this has not been provided.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以通过应用本书其他地方展示的原则来适应通过参数工作。但是，由于页面通过参数调用的罕见性和故意的简洁性，这一点没有提供。
- en: This can be extended, as earlier mentioned, by adding additional files and their
    commonly occurring strings. It could also be extended to grabbing all interesting
    files once the ability to directory traverse and the depth required to reach root
    has been established.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这可以通过添加额外的文件及其常见的字符串来扩展。一旦已经确定了目录遍历和到达根目录所需的深度，也可以扩展到抓取所有有趣的文件。
- en: 'The following is a PHP web page that will allow you to test this script on
    your own build. Just put it in your `var/www` directory or whichever solution
    you use. Do not leave this active on an unknown network:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个PHP网页，可以让您在自己的构建上测试此脚本。只需将其放在您的`var/www`目录或您使用的其他解决方案中。不要在未知网络上保持此活动状态：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Automated URL-based Cross-site scripting
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化基于URL的跨站脚本攻击
- en: Reflected Cross-site scripting commonly occurs through URL based parameters.
    You should know what Cross-site scripting is, and if you don't, I'm embarrassed
    for you. For real? I have to explain this? Okay. Cross-site scripting is injecting
    JavaScript into a page. It is hacking 101 and the first attack most people encounter
    or hear about. Inefficient methods of blocking Cross-site scripting focus around
    targeting script tags, and with script tags not being necessary to use JavaScript
    in a page, there are numerous ways around this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 反射型跨站脚本攻击通常通过基于URL的参数发生。你应该知道什么是跨站脚本攻击，如果你不知道，我为你感到尴尬。真的吗？我必须解释这个？好吧。跨站脚本攻击是将JavaScript注入到页面中。这是黑客入门课程，也是大多数人遇到或听说的第一种攻击。阻止跨站脚本攻击的低效方法主要集中在针对脚本标签，而脚本标签并不是在页面中使用JavaScript的必要条件，因此有许多绕过方法。
- en: We will create a script that takes a variety of standard evasion techniques
    and applies them to an automated submittal by using the `Requests` library. We
    will know whether the script has succeeded because either the script or an earlier
    version of it will be present on the page following the submittal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，采用各种标准的规避技术，并使用`Requests`库将它们应用于自动提交。我们将知道脚本是否成功，因为要么脚本本身，要么它的早期版本将出现在提交后的页面上。
- en: How to do it…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script we will be using is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本如下：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is an example of the output produced when using this script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时产生的输出示例如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'This script is similar to the earlier Directory Traversal script. We create
    a list of payloads rather than a dictionary this time as the check string and
    payload are the same:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本类似于之前的目录遍历脚本。这次我们创建一个负载列表，而不是字典，因为检查字符串和负载是相同的：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then use a similar loop as before to go through those values and submit
    them one by one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用与之前相似的循环来逐个提交这些值：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each payload is appended to the end of our URL to be sent in an unended parameter
    such as `127.0.0.1/xss/xss.php?comment=`. The payload will be added onto the end
    of that string in order to make a valid statement. We then check to see if that
    string is present in the following page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个负载都被附加到我们的URL的末尾，以便作为未结束的参数发送，例如`127.0.0.1/xss/xss.php?comment=`。负载将被添加到该字符串的末尾，以便形成一个有效的语句。然后我们检查该字符串是否出现在以下页面中：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Cross-site scripting is so simple and very easy to automate and detect as the
    attack string is usually the same as the outcome. The difficulties with Directory
    Traversal or SQLi, as we will encounter later, is that the outcome is not always
    predictable. In the event of a successful Cross-site scripting attack, it is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击非常简单，非常容易自动化和检测，因为攻击字符串通常与结果相同。与目录遍历或SQLi（稍后我们将遇到）的困难在于结果并不总是可预测的。而在成功的跨站脚本攻击中，它是可预测的。
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This attack can be extended by providing more attack strings. Many examples
    can be found in the Mozilla FuzzDB, which we will be using later in the *Automated
    fuzzing* section script. Also, various forms of encoding can be applied using
    the original `urllib` library, which is shown throughout this book in various
    different examples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击可以通过提供更多的攻击字符串来扩展。许多示例可以在Mozilla FuzzDB中找到，我们将在*自动模糊*部分脚本中使用。此外，可以使用原始的`urllib`库应用各种编码形式，这在本书的各种不同示例中都有展示。
- en: Automated parameter-based Cross-site scripting
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动参数化跨站脚本
- en: I've already stated that Cross-site scripting is absurdly easy. Amusingly, it
    is slightly harder to perform stored Cross-site scripting in a scripted fashion.
    I should probably take back my earlier words at this point, but whatever. The
    difficulty here is that systems often take an input structure from one page, submit
    to another page, and return a third page. The following script is designed to
    handle that most complex of structures.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过跨站脚本非常容易。有趣的是，以脚本方式执行存储的跨站脚本略微困难。我可能应该在这一点上收回我先前的话，但无论如何。这里的困难在于系统通常从一个页面接受输入结构，提交到另一个页面，并返回第三个页面。以下脚本旨在处理这种最复杂的结构。
- en: We will create a script that takes three input values, reads, and submits to
    all three correctly and checks for success. It shares code with the earlier URL-based
    Cross-site scripting but differs fundamentally in its execution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，它接受三个输入值，正确读取并提交所有三个值，并检查是否成功。它与之前基于URL的跨站脚本共享代码，但在执行上有根本的不同。
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following script is the functioning test. It is a script that is designed
    to be manually edited in a framework similar to sublime text or an IDE, as stored
    XSS is likely to require fiddling:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是功能测试。这是一个脚本，旨在在类似Sublime Text或IDE的框架中手动编辑，因为存储的XSS可能需要调整：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is an example of the output produced when using this script with
    two successful strings:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此脚本时产生的输出示例，其中包含两个成功的字符串：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We import our libraries as time and time before and establish the URLs we are
    going to attack. Here, `url` is the page with the parameters to attack, `url2`
    is the page that the content is going to be submitted to, and `url3` is the final
    page to be read in order to detect whether the attack was successful. Some of
    these URLs may be shared. They are set in this form because it is very difficult
    to make a point and click script for stored Cross-site scripting:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入我们的库作为时间和时间之前，并建立我们要攻击的URL。在这里，`url`是带有要攻击的参数的页面，`url2`是要提交内容的页面，`url3`是要读取的最终页面，以便检测攻击是否成功。其中一些URL可能是共享的。它们以这种形式设置，因为很难为存储的跨站脚本制作点对点脚本：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then establish a list of payloads. As with the URL-based XSS script, the
    payload, and check value is the same:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们建立一个负载列表。与基于URL的XSS脚本一样，负载和检查值是相同的：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then create an empty dictionary to pair the payload with each identified
    input box:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个空字典，将负载与每个识别的输入框配对：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are aiming to attack every input parameter in a page, so next, we read our
    target page:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是攻击页面中的每个输入参数，因此接下来，我们读取我们的目标页面：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then create a loop for each value that we put in our payloads list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们在负载列表中放置的每个值创建一个循环：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then process the page with `BeautifulSoup`, which is a library that allows
    us to carve pages by their tags and defining characteristics. We use this to identify
    each input field of which we select the name so we can send it content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`BeautifulSoup`处理页面，这是一个允许我们根据标签和定义特征来切割页面的库。我们使用它来识别每个输入字段，以便选择名称，以便我们可以发送内容：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Due to the nature of input boxes in the majority of web pages, any fields named
    `submit` are not to be targeted for Cross-site scripting and instead need to be
    given `submit` as a value in order for our attack to be successful. We create
    an `if` function to detect whether this is the case, using the`.lower()` function
    to easily account for the potential upper case values that may be used. If the
    field isn''t used to verify submittal, we fill it with the current payload in
    use:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数网页中输入框的性质，任何名为`submit`的字段都不应被用于跨站脚本攻击，而是需要给予`submit`作为值，以便我们的攻击成功。我们创建一个`if`函数来检测是否是这种情况，使用`.lower()`函数轻松地考虑可能使用的大写值。如果该字段不用于验证提交，我们将其填充为当前使用的负载：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We send our now assigned values to the targeted page in a post request by using
    the `requests` library, as we have done earlier:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`requests`库将我们现在分配的值发送到目标页面的post请求中，就像我们之前做的那样：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then load the page that would render our content and prepare it for being
    used in the check result function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后加载将呈现我们内容的页面，并准备好用于检查结果函数：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similar to the scripts before, we check if our string was successful by searching
    for it on the page and print the result out if it. We then reset the dictionary
    for the next payload:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的脚本类似，我们通过搜索页面上的字符串来检查我们的字符串是否成功，并在成功时打印结果。然后，我们为下一个负载重置字典：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As before, you can alter this script to include many results or read from a
    file that contains multiple values. Mozilla's FuzzDB, as shown in the following
    recipe, contains a vast number of these values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，您可以修改此脚本以包含许多结果或从包含多个值的文件中读取。正如下面的示例中所示，Mozilla的FuzzDB包含大量这些值。
- en: The following is a setup than can be used to test the script provided in the
    preceding sections. They need to be saved as the filenames provided to work and
    in conjunction with a MySQL database to store the comments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用来测试前面部分提供的脚本的设置。它们需要保存为提供的文件名才能正常工作，并与MySQL数据库一起使用以存储评论。
- en: 'The following is the first interface page named `guestbook.php`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是名为`guestbook.php`的第一个接口页面：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following script is `addguestbook.php`, which places your comment in the
    database:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是`addguestbook.php`，它将您的评论放入数据库中：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final script is `viewguestbook.php`, which draws the comments from the
    database:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最终脚本是`viewguestbook.php`，它从数据库中获取评论：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Automated fuzzing
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动模糊
- en: Fuzzing is the smash and grab of the hacking community. It focuses around sending
    a large amount of invalid content to a page and recording the results. It is the
    reprobates version of SQL Injection and arguably the base form of penetration
    testing (though you LOIC users out there are probably the base form of life form).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Fuzzing是黑客社区的破坏和抢劫。它侧重于向页面发送大量无效内容并记录结果。这是SQL注入的败类版本，可以说是渗透测试的基本形式（尽管你们LOIC用户可能是生命形式的基本形式）。
- en: We will create a script that will take values from the FuzzDB meta-characters
    file and send them to every parameter available and record all the results. This
    is most definitely a brute-force attempt to identify vulnerabilities and requires
    a sensible human being to go through the results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，它将从FuzzDB元字符文件中获取值，并将它们发送到每个可用的参数，并记录所有结果。这绝对是一种暴力尝试来识别漏洞，并需要一个明智的人来查看结果。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this, you will require the FuzzDB from Mozilla. At the time of printing,
    this is available from [https://code.google.com/p/fuzzdb/](https://code.google.com/p/fuzzdb/).
    The file you specifically want for this script is `/fuzzdb-1.09/attack-payloads/all-attacks/interesting-metacharacters.txt`
    within the `fuzzdb` TAR file. I'm reusing the test PHP scripts from the XSS script
    for proof of concept, but you can use this against whatever you like. The aim
    is to trigger an error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您将需要来自Mozilla的FuzzDB。在印刷时，可以从[https://code.google.com/p/fuzzdb/](https://code.google.com/p/fuzzdb/)获取。对于此脚本，您需要`fuzzdb`
    TAR文件中的`/fuzzdb-1.09/attack-payloads/all-attacks/interesting-metacharacters.txt`文件。我正在重用用于概念验证的XSS脚本的测试PHP脚本，但您可以针对任何您喜欢的内容使用此脚本。目标是触发错误。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本如下：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is an example of the output produced when using this script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此脚本时产生的输出示例：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We import our libraries. As this is a testing script again, we establish our
    URLs in the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入我们的库。由于这是一个测试脚本，我们在代码中建立我们的URL：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then open two files. The first will be the FuzzDB meta-characters file.
    I''ve included my path, though it is acceptable to make a copy of the file in
    your working directory. The second file will be the file you write to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打开两个文件。第一个将是FuzzDB元字符文件。我包含了我的路径，但在您的工作目录中复制该文件也是可以接受的。第二个文件将是您要写入的文件：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We create an empty dictionary to be populated by our parameters and attack
    strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个空字典，用于存储我们的参数和攻击字符串：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As the script writes its output to a file, we need to provide some text to
    show that the script is working, so we write a nice and simple message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本将其输出写入文件，我们需要提供一些文本来显示脚本正在运行，因此我们写了一条简单而友好的消息：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We read the original page that accepts input and assign to a variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取接受输入的原始页面并赋给一个变量：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We split out the page with `BeautifilSoup` and identify the only fields we
    want, being the input fields and the name fields from there:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BeautifilSoup`分离页面并识别我们想要的唯一字段，即输入字段和名称字段：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to check again that any fields named submit are provided with `submit`
    as data, otherwise we apply our attack string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次检查是否提供了名为submit的字段，并将`submit`作为数据，否则我们应用我们的攻击字符串：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We submit first a `POST` request sending out dictionary of attack strings mapped
    to input fields and then we request a `GET` request from the page that shows output
    (some errors may occur before the third page so you should consider restricting
    accordingly):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提交一个`POST`请求，发送攻击字符串映射到输入字段的字典，然后我们从显示输出的页面请求一个`GET`请求（在第三页之前可能会出现一些错误，因此您应该相应地进行限制）：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Because the output will be long and messy, we write the output to the file
    that we opened initially, so that it may be easily reviewed by a human being:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出会很长而且混乱，我们将输出写入最初打开的文件，以便人类可以轻松审查：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We reset the dictionary for the next attack string and then provide the user
    with an end of script output for clarity:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重置字典以供下一个攻击字符串使用，然后为了清晰起见，向用户提供脚本结束的输出：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can just keep adding stuff to this recipe. It's designed to be open for
    multiple types of input and attack. FuzzDB contains lots of different attack strings,
    so all of these can be applied. I encourage you to explore.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以不断添加内容到这个脚本中。它被设计为适用于多种类型的输入和攻击。FuzzDB包含许多不同的攻击字符串，因此所有这些都可以应用。我鼓励您去探索。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can test this against the stored XSS PHP pages as I have done.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像我一样针对存储的XSS PHP页面进行测试。
- en: jQuery checking
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery检查
- en: One of the lesser checked but more serious OWASP Top 10 vulnerabilities is the
    use of libraries or modules with known vulnerabilities. This can often mean versions
    of web frameworks that are out of date, but it also includes JavaScript libraries
    that perform specific functions. In this circumstance, we are checking jQuery;
    I have checked other libraries with this script but for the purposes of an example,
    but I will stick to jQuery.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP十大漏洞中较少被检查但更严重的一个是使用已知漏洞的库或模块。这通常意味着过时的web框架版本，但也包括执行特定功能的JavaScript库。在这种情况下，我们正在检查jQuery；我已经用这个脚本检查了其他库，但为了举例，我将坚持使用jQuery。
- en: We will create a script that identifies whether a site uses jQuery, retrieve
    it's version number, and then compare that against the latest version number to
    determine whether it is up to date.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，用于识别网站是否使用jQuery，获取其版本号，然后将其与最新版本号进行比较，以确定是否为最新版本。
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following is our script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的脚本：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is an example of the output produced when using this script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此脚本时产生的输出示例：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'As ever, we import our libraries and create an empty library to house our future
    identified scripts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入我们的库并创建一个空库，用于存放我们未来识别的脚本：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For this script, we have created a simple usage guide that detects whether
    a URL has been provided. It reads the number of `sys.argv`, and if it is not equal
    to `2`, including the script itself, then it prints out a guide:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们创建了一个简单的使用指南，用于检测是否已提供URL。它读取`sys.argv`的数量，如果不等于`2`，包括脚本本身，则打印出指南：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We take our target URL from the `sys.argv` list and open it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`sys.argv`列表中获取目标URL并打开它：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As with before, we use beautiful soup to take the page apart; however, this
    time we are identifying scripts and pulling their `src` values in order to obtain
    the URLs of the `js` libraries being that are used. This collects together all
    the potential libraries that could be jQuery. Bear in mind that if you extend
    the usage to include different types of library, this list of URLs can be very
    useful:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们使用beautiful soup来拆分页面；但是，这次我们正在识别脚本并提取它们的`src`值，以获取正在使用的`js`库的URL。这将收集所有可能是jQuery的潜在库。请记住，如果您扩展使用范围以包括不同类型的库，这个URL列表可能非常有用：
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For each identified script, we then check to see if there is any mention of
    `jquery.min`, which would indicate the core jQuery file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个识别的脚本，我们然后检查是否有任何`jquery.min`的提及，这将指示核心jQuery文件：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then use regex to identify the version number. In jQuery files, this will
    be the first thing mentioned that fits the given regex. The regex looks for `0-9`
    or `a-z` followed by a period that is repeated infinite amount of times. This
    is the format that the majority of version numbers take and jQuery is no different:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用正则表达式来识别版本号。在jQuery文件中，这将是符合给定正则表达式的第一件事。正则表达式寻找`0-9`或`a-z`后跟一个无限次数重复的句点。这是大多数版本号采用的格式，jQuery也不例外：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `re.findall` method finds all strings that match this regex; however, as
    mentioned, we only want the first one. We identify it with comments`[0]`. We check
    to see whether this is equal to the hardcoded values of the current jQuery version,
    at time of writing. These will need to be updated manually. If the value is equal
    to either of the current versions, the script will state that it is up to date,
    alternatively if it is not equal it will print the detected version along with
    an out of date message:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.findall`方法找到与此正则表达式匹配的所有字符串；但是，正如前面提到的，我们只想要第一个。我们用注释`[0]`来标识它。我们检查是否等于当前jQuery版本的硬编码值，在撰写时。这些将需要手动更新。如果该值等于当前版本中的任何一个，脚本将声明其为最新版本，否则，它将打印检测到的版本以及过期消息：'
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This recipe is obviously extendable and can be applied to any JavaScript library
    by simply adding to the detection strings and versions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方显然是可扩展的，可以通过简单地添加检测字符串和版本来应用到任何JavaScript库。
- en: If the string was to be extended to include other libraries, such as insecure
    Django or flask libraries, the script would have to be altered to handle the alternate
    way that they are stated, as they are obviously not declared as JavaScript libraries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要扩展该字符串以包括其他库，比如不安全的Django或flask库，脚本将不得不进行修改，以处理它们声明的替代方式，因为它们显然不是声明为JavaScript库。
- en: Header-based Cross-site scripting
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于标头的跨站脚本
- en: Until now, we have focused on sending payloads through URLs and parameters,
    the two obvious methods of performing attacks. However, there are numerous rich
    and fertile sources of vulnerabilities that often lay untouched. One of these
    will be covered in depth in [Chapter 6](ch06.html "Chapter 6. Image Analysis and
    Manipulation"), *Image Analysis and Manipulation*, for which we can give an intro
    now. Logs are often kept of specific headers of users that are accessing web pages.
    It can be a worthwhile activity performing checks against these logs by performing
    XSS attacks in headers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于通过URL和参数发送有效载荷，这是执行攻击的两种明显方法。然而，通常有许多丰富和肥沃的漏洞来源往往被忽视。其中之一将在[第6章](ch06.html
    "第6章。图像分析和操作")中深入介绍，*图像分析和操作*，现在我们可以先简单介绍一下。通常会记录访问网页的用户的特定标头。通过在标头中执行XSS攻击来执行这些日志的检查可能是一项值得的活动。
- en: We will be creating a script that submits XSS attack strings to all available
    headers and cycles through several possible XSS attacks. We will provide a short
    list of payloads, grab all the headers, and submit them sequentially.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，向所有可用的标头提交XSS攻击字符串，并循环执行几种可能的XSS攻击。我们将提供一个简短的有效载荷列表，抓取所有标头，并依次提交它们。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Identify the URL that you wish to test. See the end of this example for a PHP
    web page that the script can be used against in order to test the validity of
    the scripts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 识别您希望测试的URL。请参见本示例末尾的PHP网页，脚本可以用来测试脚本的有效性。
- en: How to do it…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Once you''ve identified your target web page, pass it to the script as a command
    line argument. Your script should be the same as shown in the following script:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定了目标网页，将其作为命令行参数传递给脚本。您的脚本应该与下面的脚本中所示的相同：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The script won''t provide any output as it targets the admin side of functionality.
    However, you could set it to provide an output on each loop easily with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本不会提供任何输出，因为它针对的是功能的管理员端。但是，您可以轻松地设置它在每个循环中提供输出：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This would return the following every time:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每次返回以下内容：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We import the libraries that we require for this script and take input in the
    form of a `sys.argv` function. You should be fairly en fait with this at this
    point.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入我们脚本所需的库，并以`sys.argv`函数的形式输入。你应该对这一点相当熟悉了。
- en: 'Once again, we can declare our payloads as a list, rather than a dictionary,
    as we are going to pair them with values provided by the web page. We also create
    an empty dictionary to house our future attack pairings:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将我们的有效载荷声明为列表，而不是字典，因为我们将它们与网页提供的值配对。我们还创建一个空字典来容纳我们未来的攻击配对：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then make a `HEAD` request to web page to return only the headers from the
    page we are attacking. It''s possible, though unlikely, that `HEAD` requests may
    be disabled; however, if it is, we can replace this with a standard `GET` request:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对网页进行“HEAD”请求，仅返回我们正在攻击的页面的标头。虽然“HEAD”请求可能被禁用，但这种可能性很小；但是，如果是这样，我们可以将其替换为标准的“GET”请求：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We loop through the payloads that we set up earlier and the headers we pulled
    from the preceding `HEAD` request:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历之前设置的有效载荷和从前面的“HEAD”请求中提取的标头：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For each payload and header, we add them to the empty dictionary that we set
    up earlier, as pairs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个有效载荷和标头，我们将它们添加到之前设置的空字典中，作为一对：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For each iteration of the payloads, we then submit all the headers with that
    payload as we obviously can''t submit multiple of each header:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个有效载荷的迭代，我们然后提交所有具有该有效载荷的标头，因为显然我们无法提交每个标头的多个：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Because the active part of the attack occurs on the client side of the admin,
    either an admin account needs to be utilized to check manually or an admin needs
    to be contacted to see if the attack is activated anywhere in the logging chain.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击的活动部分发生在管理员的客户端，因此需要使用管理员帐户手动检查，或者需要联系管理员以查看攻击是否在日志链的任何位置激活。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following is a setup than can be used to test the preceding script. This
    is very similar to the earlier script for XSS checking. The difference here is
    that the conventional XSS methods will fail due to the `strip_tags` function.
    It demonstrates the situations where unconventional methods are required to perform
    attacks. Obviously, returning the user-agent in a comment is contrived, though
    this is something that is frequent in the wild. They need to be saved as the filenames
    provided to work and in conjunction with a MySQL database to store the comments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用于测试前面脚本的设置。这与用于XSS检查的早期脚本非常相似。这里的区别在于传统的XSS方法将由于“strip_tags”函数而失败。它演示了需要使用非常规方法执行攻击的情况。显然，在注释中返回用户代理是虚构的，尽管这在野外很常见。它们需要保存为提供的文件名以便与MySQL数据库一起工作，并存储评论。
- en: 'The following is the first interface page named `guestbook.php`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是名为`guestbook.php`的第一个界面页面：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following script is `addguestbook.php`, which places your comment in the
    database:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是`addguestbook.php`，它将您的评论放入数据库：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The final script is `viewguestbook.php`, which draws the comments from the
    database:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最终脚本是`viewguestbook.php`，它从数据库中提取评论：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Shellshock checking
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shellshock检查
- en: Moving away from the standard style of attacks against web servers, we're going
    to quickly look at Shellshock, a vulnerability that allowed attackers to make
    shell commands through specific headers. This vulnerability reared its head in
    2014 and gained momentum quickly as one of the biggest vulnerabilities of the
    year. While it has now been mostly fixed, it's a good example of how web servers
    can be manipulated to perform more complex attacks and are likely to be a frequent
    target in **common transfer files** (**CTFs**) for years to come.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱对Web服务器的标准攻击方式，我们将快速查看Shellshock，这是一个漏洞，允许攻击者通过特定标头执行shell命令。这个漏洞在2014年出现，并迅速成为当年最大的漏洞之一。虽然现在它大部分已经修复，但它是Web服务器可以被操纵执行更复杂攻击的一个很好的例子，并且可能在未来的**常见传输文件**（CTF）中成为频繁的目标。
- en: We will create a script that pulls down the headers of a page, identifies whether
    the vulnerable headers are present, and submits an example payload to that header.
    This script relies on external infrastructure supporting this attack to collect
    compromised device call-outs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，该脚本会拉取页面的标头，识别易受攻击的标头是否存在，并向该标头提交一个示例有效载荷。此脚本依赖于外部基础设施来支持此攻击以收集受损设备的呼叫。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Identify the URL you wish to test. Once you''ve identified your target web
    page, pass it to the script as a `sys.argv`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您要测试的URL。一旦确定了目标网页，将其作为`sys.argv`传递给脚本：
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Your script should be the same as the following script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您的脚本应该与以下脚本相同：
- en: '[PRE62]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The script won''t provide output as it targets the admin side of functionality.
    However, you could set it to provide an output on each loop easily with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本不会提供输出，因为它针对的是功能的管理员端。但是，您可以轻松地设置它在每次循环时提供输出：
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This would return the following every time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每次返回以下内容：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We import the libraries that we require for this script and take input in the
    form of a `sys.argv` function. This is getting a bit repetitive, but it gets the
    job done.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了此脚本所需的库，并以`sys.argv`函数的形式接受输入。这有点重复，但它完成了工作。
- en: 'We declare our payload as a singular entity. If you have multiple actions that
    you wish to perform upon the server, you can make this a payload, similar to the
    preceding. We also create an empty dictionary for our header-payload combinations
    and make a `HEAD` request to the target URL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的有效载荷声明为一个单一实体。如果您希望对服务器执行多个操作，可以将其设置为有效载荷，类似于前面的操作。我们还为我们的标头-有效载荷组合创建一个空字典，并向目标URL发出“HEAD”请求：
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The payload set here will ping whichever server you set at the `<url/ip>` space.
    It will send a message in that ping, which is `pwnt`. This allows you to identify
    that the server has actually been compromised and it's not just a random server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此处设置的有效载荷将ping您在“<url/ip>”空间设置的任何服务器。它将在该ping中发送一条消息，即“pwnt”。这使您能够确定服务器实际上已被攻破，而不仅仅是一个随机服务器。
- en: 'We then go through each header we pulled in the initial `HEAD` request and
    check to see if any are the `referrer` or `User-Agent` headers, which are the
    headers vulnerable to the Shellshock attack. If those headers are present, we
    send our attack string against that header:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历我们在初始的“HEAD”请求中提取的每个标头，并检查是否有“referrer”或“User-Agent”标头，这些标头容易受到Shellshock攻击。如果存在这些标头，我们对该标头发送我们的攻击字符串：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once we''ve established if our headers are present and having set the attack
    string against them, we launch our request. If successful, the message should
    appear in our logs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了我们的标头是否存在，并已设置了针对它们的攻击字符串，我们就发出请求。如果成功，消息应该出现在我们的日志中：
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
