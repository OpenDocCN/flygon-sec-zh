- en: Chapter 2. Enumeration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。枚举
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performing a ping sweep with Scapy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy执行ping扫描
- en: Scanning with Scapy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy进行扫描
- en: Checking username validity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户名的有效性
- en: Brute forcing usernames
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴力破解用户名
- en: Enumerating files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举文件
- en: Brute forcing passwords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴力破解密码
- en: Generating e-mail addresses from names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从姓名生成电子邮件地址
- en: Finding e-mail addresses from web pages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网页中查找电子邮件地址
- en: Finding comments in source code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中查找注释
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When you have identified the targets for testing, you'll want to perform some
    enumeration. This will help you to identify some potential paths for further reconnaissance
    or attacks. This is an important step. After all, if you were to try to steal
    something from a safe, you would first take a look to determine whether or not
    you'd need a pin, key, or combination, rather than simply attaching a stick of
    dynamite and potentially destroying the contents.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定了要测试的目标后，你会想要进行一些枚举。这将帮助你确定一些进一步侦察或攻击的潜在路径。这是一个重要的步骤。毕竟，如果你想从保险柜里偷东西，你首先会看一下，确定你是否需要密码、钥匙或组合，而不是简单地绑上一根炸药棒，可能摧毁内容。
- en: In this chapter, we will look at some ways that you can use Python to perform
    active enumeration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些你可以使用Python执行主动枚举的方法。
- en: Performing a ping sweep with Scapy
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy执行ping扫描
- en: One of the first tasks to perform when you have identified a target network
    is to check which hosts are live. A simple way of achieving this is to ping an
    IP address and confirm whether or not a reply is received. However, doing this
    for more than a few hosts can quickly become a draining task. This recipe aims
    to show you how you can achieve this with Scapy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定了目标网络后，要执行的第一个任务之一是检查哪些主机是活动的。实现这一目标的一个简单方法是ping一个IP地址，并确认是否收到回复。然而，对于超过几个主机来说，这样做很快就会变成一项繁重的任务。这个教程旨在向你展示如何使用Scapy实现这一目标。
- en: Scapy is a powerful tool that can be used to manipulate network packets. While
    we will not be going into great depth of all that can be accomplished with Scapy,
    we will use it in this recipe to determine which hosts reply to an **Internet
    Control Message Protocol** (**ICMP**) packet. While you can probably create a
    simple bash script and tie it together with some grep filtering, this recipe aims
    to show you techniques that will be useful for tasks involving iterating through
    IP ranges, as well as an example of basic Scapy usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy是一个强大的工具，可以用来操纵网络数据包。虽然我们不会深入探讨Scapy可以完成的所有功能，但在这个教程中，我们将使用它来确定哪些主机会回复**Internet控制消息协议**（**ICMP**）数据包。虽然你可能可以创建一个简单的bash脚本，并将其与一些grep过滤器结合起来，但这个教程旨在向你展示在涉及迭代IP范围的任务中会有用的技术，以及基本Scapy用法的示例。
- en: 'Scapy can be installed on the majority of Linux systems with the following
    command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy可以通过以下命令安装在大多数Linux系统上：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following script shows how you can use Scapy to create an ICMP packet to
    send and process the response if it is received:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了如何使用Scapy创建ICMP数据包并在收到响应时处理它：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first section of the script will set up suppression of warning messages
    from Scapy when it runs. A common occurrence when importing Scapy on machines
    that do not have IPv6 configured is a warning message about not being able to
    route through IPv6.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一部分将设置在运行Scapy时抑制警告消息。在没有配置IPv6的机器上导入Scapy时，一个常见的情况是收到关于无法通过IPv6路由的警告消息。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next section imports the necessary modules, validates the number of arguments
    received, and sets up a list for storing hosts found to be live:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分导入必要的模块，验证接收到的参数数量，并设置一个用于存储发现的活动主机的列表：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then compile a regular expression that will check that the IP addresses
    are valid. This not only checks the format of the string, but also that it exists
    within the IPv4 address space. This compiled regular expression is then used to
    match against the supplied arguments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编译一个正则表达式，用于检查IP地址的有效性。这不仅检查字符串的格式，还检查它是否存在于IPv4地址空间中。然后使用编译后的正则表达式与提供的参数进行匹配：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the IP addresses have been validated, then further checks are carried
    out to ensure that the range supplied is a valid range and to assign the variables
    that will be used to set the parameters for the loop:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦IP地址被验证，就会进行进一步的检查，以确保提供的范围是有效的，并分配将用于设置循环参数的变量：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next part of the script is purely informational and can be omitted. It
    will print out the IP address range to be pinged or, in the case of both arguments
    supplied being equal, the IP address to be pinged:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一部分纯粹是信息性的，可以省略。它将打印出要ping的IP地址范围，或者在提供的两个参数相等的情况下，要ping的IP地址：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then enter the loop and start by creating an ICMP packet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入循环，并开始创建一个ICMP数据包：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, we use the `sr1` command to send the packet and receive one packet
    back:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`sr1`命令发送数据包并接收一个数据包返回：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we check that a response was received and that the response code was
    `0`. The reason for this is because a response code of `0` represents an echo
    reply. Other codes may be reporting an inability to reach the destination. If
    a response passes these checks, then the IP address is appended to the `livehosts`
    list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查是否收到了响应，以及响应代码是否为`0`。这是因为响应代码为`0`表示回显回复。其他代码可能报告无法到达目的地。如果响应通过了这些检查，那么IP地址将被追加到`livehosts`列表中。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If live hosts have been found, then the script will then print out the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了活动主机，脚本将打印出列表。
- en: Scanning with Scapy
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy进行扫描
- en: Scapy is a powerful tool that can be used to manipulate network packets. While
    we will not be going into great depth of all that can be accomplished with Scapy,
    we will use it in this recipe to determine which TCP ports are open on a target.
    In identifying which ports are open on a target, you may be able to determine
    the types of services that are running and use these to then further your testing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy是一个强大的工具，可用于操纵网络数据包。虽然我们不会深入探讨Scapy可以完成的所有工作，但我们将在本教程中使用它来确定目标上打开的TCP端口。通过识别目标上打开的端口，您可以确定正在运行的服务类型，并使用这些服务进一步进行测试。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This is the script that will perform a port scan on a specific target in a
    given port range. It takes arguments for the target, the start of the port range
    and the end of the port range:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将在给定端口范围内对特定目标执行端口扫描的脚本。它接受目标、端口范围的起始和结束参数：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first thing you notice about this recipe is the starting two lines of the
    script:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本教程中注意到的第一件事是脚本的前两行：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These lines serve to suppress a warning created by Scapy when IPv6 routing
    isn''t configured, which causes the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行用于抑制Scapy在未配置IPv6路由时创建的警告，这会导致以下输出：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This isn't essential for the functionality of the script, but it does make the
    output tidier when you run it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于脚本的功能并不是必需的，但在运行时可以使输出更整洁。
- en: The next few lines will validate the number of arguments and assign the arguments
    to variables for use in the script. The script also checks to see whether the
    start and end of the port range are the same and increments the end port in order
    for the loop to be able to work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行将验证参数的数量并将参数分配给脚本中使用的变量。脚本还会检查端口范围的起始和结束是否相同，并递增结束端口以便循环能够工作。
- en: 'After all of the setting up, we''ll loop through the port range and the real
    meat of the script comes along. First, we create a rudimentary TCP packet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们将循环遍历端口范围，脚本的真正内容随之而来。首先，我们创建一个基本的TCP数据包：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We then use the `sr1` command. This command is an abbreviation of `send/receive1`.
    This command will send the packet we have created and receive the first packet
    that is sent back. The additional parameters we have supplied include a timeout,
    so the script will not hang for closed or filtered ports, and the verbose parameter
    we have set will turn off the output that Scapy normally creates when sending
    packets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`sr1`命令。这个命令是`send/receive1`的缩写。此命令将发送我们创建的数据包并接收返回的第一个数据包。我们提供的其他参数包括超时，因此脚本不会挂起关闭或过滤的端口，我们设置的详细参数将关闭Scapy在发送数据包时通常创建的输出。
- en: The script then checks whether there is a response that contains TCP data. If
    it does contain TCP data, then the script will check for the SYN and ACK flags.
    The presence of these flags would indicate a SYN-ACK response, which is part of
    the TCP protocol handshake and shows that the port is open.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后脚本会检查是否有包含TCP数据的响应。如果包含TCP数据，则脚本将检查SYN和ACK标志。这些标志的存在将指示SYN-ACK响应，这是TCP协议握手的一部分，并显示端口是打开的。
- en: 'If it is determined that a port is open, an output is printed to this effect
    and the next line of code sends a reset:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确定某个端口是打开的，将打印输出以此效果，并且代码的下一行发送重置：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This line is necessary in order to close the connection and prevent a TCP SYN-flood
    attack from occurring if the port range and the number of open ports are large.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是必要的，以便关闭连接并防止发生TCP SYN洪水攻击，如果端口范围和打开端口的数量很大。
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we showed you how Scapy can be used to perform a TCP port scan.
    The techniques used in this recipe can be adapted to perform a UDP port scan on
    a host or a ping scan on a range of hosts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们向您展示了如何使用Scapy执行TCP端口扫描。本教程中使用的技术可以被调整以在主机上执行UDP端口扫描或在一系列主机上执行ping扫描。
- en: This just touches the surface of what Scapy is capable of. For more information,
    a good place to start is on the official Scapy website at [http://www.secdev.org/projects/scapy/](http://www.secdev.org/projects/scapy/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是触及Scapy能力的表面。有关更多信息，一个很好的起点是官方Scapy网站[http://www.secdev.org/projects/scapy/](http://www.secdev.org/projects/scapy/)。
- en: Checking username validity
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户名的有效性
- en: When performing your reconnaissance, you may come across parts of web applications
    that will allow you to determine whether or not certain usernames are valid. A
    prime example of this will be a page that allows you to request a password reset
    when you have forgotten your password. For instance, if the page asks that you
    enter your username in order to have a password reset, it may give different responses
    depending on whether or not a user with that username exists. So, if a username
    doesn't exist, the page may respond with `Username not found`, or something similar.
    However, if the username does exist, it may redirect you to the login page and
    inform you that `Password reset instructions have been sent to your registered
    email address`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行侦察时，您可能会遇到网络应用程序的部分，这些部分将允许您确定某些用户名是否有效。一个典型的例子是当您忘记密码时，页面允许您请求密码重置。例如，如果页面要求您输入用户名以进行密码重置，它可能会根据用户名是否存在而给出不同的响应。因此，如果用户名不存在，页面可能会响应“找不到用户名”或类似的内容。但是，如果用户名存在，它可能会将您重定向到登录页面，并通知您“密码重置说明已发送到您注册的电子邮件地址”。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Each web application may be different. So, before you go ahead and create your
    username checking tool, you will want to perform a reconnaissance. Details you
    will need to find will include the page that is accessed to request a password
    reset, the parameters that you need to send to this page, and what happens in
    the event of a successful or failed outcome.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应用程序可能都不同。因此，在继续创建用户名检查工具之前，您需要进行侦察。您需要找到的详细信息包括访问请求密码重置的页面，需要发送到该页面的参数，以及成功或失败结果的情况。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Once you have the details of how the password reset request works on the target,
    you can assemble your script. The following is an example of what your tool will
    look like:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了目标上密码重置请求的工作原理，就可以组装您的脚本。以下是您的工具的示例：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following shows an example of the output produced when using this script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了使用此脚本时产生的输出示例：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After the number of arguments have been validated and the arguments have been
    assigned to variables, we use the `urllib` module in order to encode the data
    that we are submitting to the page:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证了参数数量并将参数分配给变量之后，我们使用`urllib`模块对要提交到页面的数据进行编码：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then look for the string that indicates that the request failed due to a
    username that does not exist:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们寻找指示请求由于不存在的用户名而失败的字符串：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result of find (`str`) does not give a simple true or false. Instead, it
    will return the position in the string that the substring is found in. However,
    if it does not find the substring you are searching for, it will return `1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: find（`str`）的结果并不是简单的true或false。相反，它将返回在字符串中找到子字符串的位置。但是，如果它没有找到您正在搜索的子字符串，它将返回`1`。
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe can be adapted to other situations. Password resets may request
    e-mail addresses instead of usernames. Or a successful response may reveal the
    e-mail address registered to a user. The important thing is to look out for situations
    where a web application may reveal more than it should.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以适应其他情况。密码重置可能会要求输入电子邮件地址而不是用户名。或者成功的响应可能会显示用户注册的电子邮件地址。重要的是要注意可能会透露比应该更多信息的Web应用程序的情况。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For bigger jobs, you will want to consider using the *Brute forcing usernames*
    recipe instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的工作，您将希望考虑使用*暴力破解用户名*示例。
- en: Brute forcing usernames
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴力破解用户名
- en: For small but regular instances, a small tool that enables you to quickly check
    something will suffice. What about those bigger jobs? Maybe you've got a big haul
    from open source intelligence gathering and you want to see which of those users
    use an application you are targeting. This recipe will show you how to automate
    the process of checking for usernames that you have stored in a file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型但常规的情况，一个快速检查工具就足够了。那么对于更大的工作呢？也许您从开源情报收集中获得了大量数据，并且想要查看这些用户中有多少使用您正在针对的应用程序。这个示例将向您展示如何自动化检查您在文件中存储的用户名的过程。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you use this recipe, you will need to acquire a list of usernames to
    test. This can either be something you have created yourself, or you can use a
    word list found within Kali. If you need to create your own list, a good place
    to start would be to use common names that are likely to be found in a web application.
    These could include usernames such as `user`, `admin`, `administrator`, and so
    on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此示例之前，您需要获取要测试的用户名列表。这可以是您自己创建的内容，也可以使用Kali中找到的字典。如果需要创建自己的列表，一个好的起点是使用可能在Web应用程序中找到的常见名称。这些可能包括用户名，如`user`，`admin`，`administrator`等。
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This script will attempt to check usernames in a list provided to determine
    whether or not an account exists within the application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将尝试检查提供的用户名列表，以确定该应用程序中是否存在帐户：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is an example of the output of this script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此脚本的输出示例：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This script introduces a couple more concepts than basic username checking.
    The first of these is opening files in order to load our list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本引入了比基本用户名检查更多的概念。其中之一是打开文件以加载我们的列表：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This opens the file containing our list of usernames and loads it into our
    `userlist` variable. We then loop through the list of users in the list. In this
    recipe, we also make use of the following line of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开包含我们用户名列表的文件，并将其加载到我们的`userlist`变量中。然后我们循环遍历列表中的用户。在此示例中，我们还使用了以下代码行：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command strips out whitespace, including newline characters, which can
    sometimes change the result of the encoding before being submitted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会去除空格，包括换行符，有时这会改变提交前的编码结果。
- en: If a username exists, then it is appended to a list. When all usernames have
    been checked, the contents of the list are output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户名存在，则将其附加到列表中。当所有用户名都已检查时，将输出列表的内容。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For single usernames, you will want to make use of the *Basic username check*
    recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个用户名，您将希望使用*基本用户名检查*示例。
- en: Enumerating files
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举文件
- en: When enumerating a web application, you will want to determine what pages exist.
    A common practice that is normally used is called spidering. Spidering works by
    going to a website and then following every single link within that page and any
    subsequent pages within that website. However, for certain sites, such as wikis,
    this method may result in the deletion of data if a link performs an edit or delete
    function when accessed. This recipe will instead take a list of commonly found
    filenames of web pages and check whether they exist.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举Web应用程序时，您将希望确定哪些页面存在。通常使用的常见做法是所谓的蜘蛛爬行。蜘蛛爬行通过访问网站，然后跟踪该页面内的每个链接以及该网站内的任何后续页面。但是，对于某些网站，例如维基，如果链接在访问时执行编辑或删除功能，则此方法可能导致数据被删除。此示例将取而代之，它将获取常见的Web页面文件名列表，并检查它们是否存在。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need to create a list of commonly found page names.
    Penetration testing distributions, such as Kali Linux will come with word lists
    for various brute forcing tools and these could be used instead of generating
    your own.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要创建一个常见的页面名称列表。渗透测试发行版，如Kali Linux，将配备各种暴力破解工具的字典，这些字典可以用来代替生成您自己的字典。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following script will take a list of possible filenames and test to see
    whether the pages exist within a website:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将获取可能的文件名列表，并测试页面是否存在于网站中：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following output shows what could be returned when run against **Damn Vulnerable
    Web App** (**DVWA**) using a list of commonly found web pages:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了针对**Damn Vulnerable Web App** (**DVWA**)使用常见网页列表运行时可能返回的内容：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'After importing the necessary modules and validating the number of arguments,
    the list of filenames to check is opened in read-only mode, which is indicated
    by the `r` parameter in the file''s `open` operation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 导入必要的模块并验证参数的数量后，要检查的文件名列表以只读模式打开，这由文件的`open`操作中的`r`参数表示：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the script enters the loop for the list of filenames, any newline characters
    are stripped from the filename, as this will affect the creation of the URLs when
    checking for the existence of the filename. If a preceding `.` exists in the provided
    extension, then that also is stripped. This allows for the use of an extension
    that does or doesn''t have the preceding `.` included, for example, `.php` or
    `php`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本进入文件名列表的循环时，会从文件名中剥离任何换行符，因为这会影响检查文件名存在时URL的创建。如果提供的扩展名中存在前置的`.`，那么也会被剥离。这允许使用包含或不包含前置`.`的扩展名，例如`.php`或`php`：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The main action of the script then checks whether or not a web page with the
    given filename exists by checking for a `HTTP 200` code and catches any errors
    given by a nonexistent page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后脚本的主要操作是检查给定文件名的网页是否存在，通过检查`HTTP 200`代码并捕获任何不存在页面的错误：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Brute forcing passwords
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴力破解密码
- en: Brute forcing may not be the most elegant of solutions, but it will automate
    what could be a potentially mundane task. Through the use of automation, you can
    get tasks completed much more quickly, or at least free yourself up to work on
    something else at the same time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解可能不是最优雅的解决方案，但它将自动化可能是一项单调的任务。通过使用自动化，您可以更快地完成任务，或者至少可以让自己有时间同时处理其他事情。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To be able to use this recipe, you will need a list of usernames that you wish
    to test and also a list of passwords. While this is not the true definition of
    brute forcing, it will lower the number of combinations that you will be testing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，您需要一个要测试的用户名列表，还需要一个密码列表。虽然这不是暴力破解的真正定义，但它会减少您要测试的组合数量。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not have a password list available, there are many available online,
    such as the top 10,000 most common passwords on GitHub here at [https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt](https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有密码列表可用，网上有许多可用的列表，例如GitHub上的前10000个最常见密码，链接在[https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt](https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt)。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'The following code shows an example of how to implement this recipe:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何实现此方法的示例：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following shows an example of the output produced when the script is run:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行脚本时产生的输出示例：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'After the initial importing of the necessary modules and checking the system
    arguments, we set up password checking:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初导入必要的模块并检查系统参数后，我们设置了密码检查：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The filename arguments are stored in variables, which are then opened. The `r`
    variable means that we are opening these files as read-only.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名参数存储在变量中，然后被打开。`r`变量表示我们以只读方式打开这些文件。
- en: 'We also specify our target and initialize an array to store any valid credentials
    that we find:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了目标，并初始化一个数组来存储我们找到的任何有效凭据：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `FailStr` variable in the preceding code is just to make our lives easier
    by having a short variable name to type instead of typing out the entire string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`FailStr`变量只是为了让我们的生活更轻松，通过使用一个简短的变量名来代替整个字符串的输入。
- en: 'The main course of this recipe lies within a nested loop in which our automated
    password checking is carried out:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主要部分在一个嵌套循环中，我们在其中进行自动密码检查：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Within this loop, a request is sent including the username and password as parameters.
    If the response doesn't contain the string indicating that the username and password
    combination is invalid, then we know that we have a valid set of credentials.
    We then add these credentials to the array that we created earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此循环中，将发送一个包含用户名和密码的请求。如果响应不包含指示用户名和密码组合无效的字符串，那么我们知道我们有一组有效的凭据。然后将这些凭据添加到我们之前创建的数组中。
- en: 'Once all the username and password combinations have been tried, we then check
    the array to see whether there are any credentials. If so, we print out the credentials.
    If not, we print out a sad message informing us that we have not found anything:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦尝试了所有的用户名和密码组合，我们就会检查数组，看看是否有任何凭据。如果有，我们就打印出凭据。如果没有，我们就打印出一个悲伤的消息，告诉我们我们什么都没找到：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: If you're looking to find usernames, you may also want to make use of the *Checking
    username validity* and the *Brute forcing usernames* recipes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查找用户名，您可能还想使用*检查用户名有效性*和*暴力破解用户名*的方法。
- en: Generating e-mail addresses from names
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从名称生成电子邮件地址
- en: In some scenarios, you may have a list of employees for a target company and
    you want to generate a list of e-mail addresses. E-mail addresses can be potentially
    useful. You might want to use them to perform a phishing attack, or you might
    want to use them to try and log on to a company's application, such as an e-mail
    or a corporate portal containing sensitive internal documentation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能有一个目标公司的员工名单，并且想要生成一个电子邮件地址列表。电子邮件地址可能会有用。您可能想要使用它们来执行网络钓鱼攻击，或者您可能想要使用它们来尝试登录到公司的应用程序，例如包含敏感内部文档的电子邮件或企业门户。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you can use this recipe, you will want to have a list of names to work
    with. If you don't have a list of names, you might want to consider first performing
    an open source intelligence exercise on your target.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此示例之前，您需要有一个要处理的姓名列表。如果没有姓名列表，您可能首先要考虑对目标进行开源情报练习。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code will take a file containing a list of names and generate
    a list of e-mail addresses in varying formats:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将获取一个包含姓名列表的文件，并生成不同格式的电子邮件地址列表：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main mechanism in this recipe is the use of string concatenation. By joining
    up the first name or first initial with the last name in different combinations
    with an e-mail suffix, you have a list of potential e-mail addresses that you
    can then use in a later test.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的主要机制是使用字符串连接。通过将名字或姓氏的不同组合与电子邮件后缀连接起来，您可以得到一个潜在的电子邮件地址列表，然后可以在以后的测试中使用。
- en: There's more…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The recipe featured shows how a list of names can be used to generate a list
    of e-mail addresses. However, not all the e-mail addresses will be valid. You
    could further narrow this list by using enumeration techniques in a company's
    application that may reveal whether an e-mail address exists. You could also perform
    further open source intelligence investigations, which may allow you to determine
    the correct format for the target organization's e-mail addresses. If you manage
    to achieve this, you can then remove any unnecessary formats from the recipe to
    generate a more concise list of e-mail addresses that will provide greater value
    to you later on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的示例显示了如何使用姓名列表生成电子邮件地址列表。但并非所有电子邮件地址都是有效的。您可以通过在公司的应用程序中使用枚举技术来进一步缩小此列表，这可能会揭示电子邮件地址是否存在。您还可以进行进一步的开源情报调查，这可能会让您确定目标组织的电子邮件地址的正确格式。如果您成功做到了这一点，那么您可以从示例中删除任何不必要的格式，以生成更简洁的电子邮件地址列表，这将在以后为您提供更大的价值。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Once you've got your e-mail addresses, you may want to use them as part of the
    *Checking username validity* recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了电子邮件地址，您可能希望将它们作为*检查用户名有效性*示例的一部分使用。
- en: Finding e-mail addresses from web pages
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网页中查找电子邮件地址
- en: Instead of generating your own e-mail list, you may find that a target organisation
    will have some that exist on their web pages. This may prove to be of higher value
    than e-mail addresses you have generated yourself as the likelihood of e-mail
    addresses on a target organisation's website being valid will be much higher than
    ones you have tried to guess.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与其生成自己的电子邮件列表，您可能会发现目标组织在其网页上存在一些电子邮件地址。这可能会比您自己生成的电子邮件地址具有更高的价值，因为目标组织网站上的电子邮件地址的有效性可能会比您尝试猜测的要高得多。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a list of pages you want to parse for e-mail
    addresses. You may want to visit the target organization's website and search
    for a sitemap. A sitemap can then be parsed for links to pages that exist within
    the website.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，您需要一个要解析电子邮件地址的页面列表。您可能希望访问目标组织的网站，并搜索站点地图。然后可以解析站点地图以获取存在于网站内的页面链接。
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code will parse through responses from a list of URLs for instances
    of text that match an e-mail address format and save them to a file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将解析URL列表的响应，查找与电子邮件地址格式匹配的文本实例，并将它们保存到文件中：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After importing the necessary modules, you will see the assignment of the `regex`
    variable:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 导入必要的模块后，您将看到`regex`变量的赋值：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This attempts to match an e-mail address format, for example `victim@target.com`,
    or victim at target dot com. The code then opens up a file containing the URLs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试匹配电子邮件地址格式，例如`victim@target.com`，或者victim at target dot com。然后，代码打开一个包含URL的文件：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You might notice the use of the parameter `r` . This opens the file in read-only
    mode. The code then loops through the list of URLs. Within the loop, a file is
    opened to save e-mail addresses to:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到参数`r`的使用。这以只读模式打开文件。然后，代码循环遍历URL列表。在循环内，打开一个文件来保存电子邮件地址：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This time, the `a` parameter is used. This indicates that any input to this
    file will be appended instead of overwriting the entire file. The script utilizes
    a sleep timer in order to avoid triggering any protective measures the target
    may have in place to prevent attacks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用了参数`a`。这表示对该文件的任何输入都将被追加而不是覆盖整个文件。脚本利用睡眠计时器以避免触发目标可能已经设置的任何防护措施来防止攻击：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This timer will pause the script for a random amount of time between `10` and
    `100` seconds.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此计时器将暂停脚本，随机间隔时间在`10`和`100`秒之间。
- en: The use of exception handling when using the `urlopen()` method is essential.
    If the response from `urlopen()` is `404 (HTTP not found error)`, then the script
    will error and exit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`urlopen()`方法时，异常处理是至关重要的。如果`urlopen()`的响应是`404（HTTP未找到错误）`，那么脚本将出错并退出。
- en: 'If there is a valid response, the script will then store all instances of e-mail
    addresses in the `emails` variable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有有效的响应，脚本将把所有电子邮件地址的实例存储在`emails`变量中：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will then loop through the `emails` variable and write each item in the
    list to the `emails.txt` file and also output it to the console for confirmation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将循环遍历`emails`变量，并将列表中的每个项目写入`emails.txt`文件，并在控制台上输出以进行确认：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The regular expression matching used in this recipe matches two common types
    of format used to represent e-mail addresses on the Internet. During the course
    of your learning and investigations, you may come across other formats that you
    might like to include in your matching. For more information on regular expressions
    in Python, you may want read the documentation on the Python website for regular
    expressions at [https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的正则表达式匹配了互联网上表示电子邮件地址的两种常见格式。在学习和调查过程中，您可能会遇到其他您想要包含在匹配中的格式。有关Python中正则表达式的更多信息，您可以阅读Python网站上有关正则表达式的文档[https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html)。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the recipe *Generating e-mail addresses from names* for more information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅食谱*从名称生成电子邮件地址*。
- en: Finding comments in source code
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在源代码中查找注释
- en: A common security issue is caused by good programming practices. During the
    development phase of web applications, developers will comment their code. This
    is very useful during this phase, as it helps with understanding the code and
    will serve as useful reminders for various reasons. However, when the web application
    is ready to be deployed in a production environment, it is best practice to remove
    all these comments as they may prove useful to an attacker.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的安全问题是由良好的编程实践引起的。在Web应用程序的开发阶段，开发人员会注释他们的代码。这在开发阶段非常有用，因为它有助于理解代码，并将作为各种原因的有用提醒。然而，当Web应用程序准备在生产环境中部署时，最佳做法是删除所有这些注释，因为它们可能对攻击者有用。
- en: This recipe will use a combination of `Requests` and `BeautifulSoup` in order
    to search a URL for comments, as well as searching for links on the page and searching
    those subsequent URLs for comments as well. The technique of following links from
    a page and analysing those URLs is known as spidering.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将结合使用`Requests`和`BeautifulSoup`来搜索URL中的注释，以及在页面上搜索链接，并在这些后续URL中搜索注释。从页面上跟踪链接并分析这些URL的技术称为爬虫。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following script will scrape a URL for comments and links in the source
    code. It will then also perform limited spidering and search linked URLs for comments:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将在源代码中抓取URL的注释和链接。然后还将执行有限的爬虫并搜索链接的URL以查找注释：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: After the initial import of the necessary modules and setting up of variables,
    the script first gets the source code of the target URL.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的模块并设置变量之后，脚本首先获取目标URL的源代码。
- en: 'You may have noticed that for `Beautifulsoup`, we have the following line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，对于`Beautifulsoup`，我们有以下行：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is so that when we use `BeautifulSoup`, we just have to type `BeautifulSoup`
    instead of `bs4.BeautifulSoup`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们使用`BeautifulSoup`时，我们只需输入`BeautifulSoup`而不是`bs4.BeautifulSoup`。
- en: 'It then searches for all instances of HTML comments and prints them out:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后搜索所有HTML注释的实例并将其打印出来：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The script will then use `Beautifulsoup` in order to scrape the source code
    for any instances of absolute (starting with `http`) and relative (starting with
    `/`) links:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本将使用`Beautifulsoup`来抓取源代码中任何绝对（以`http`开头）和相对（以`/`开头）链接的实例：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once the script has collated a list of URLs linked to from the page, it will
    then search each page for HTML comments.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本整理出从页面链接出去的URL列表，它将搜索每个页面的HTML注释。
- en: There's more…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This recipe shows a basic example of comment scraping and spidering. It is possible
    to add more intelligence to this recipe to suit your needs. For instance, you
    may want to account for relative links that use start with `.` or `..` to denote
    the current and parent directories.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了注释抓取和爬虫的基本示例。可以根据需要为此示例添加更多智能。例如，您可能希望考虑使用以`。`或`..`开头的相对链接来表示当前目录和父目录。
- en: You can also add more control to the spidering part. You could extract the domain
    from the supplied target URL and create a filter that does not scrape links for
    domains external to the target. This is especially useful for professional engagements
    where you need to adhere to a scope of targets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以对爬虫部分进行更多控制。您可以从提供的目标URL中提取域，并创建一个过滤器，不会抓取目标外部的域的链接。这对于需要遵守目标范围的专业工作特别有用。
