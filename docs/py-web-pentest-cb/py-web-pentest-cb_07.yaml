- en: Chapter 7. Encryption and Encoding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。加密和编码
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generating an MD5 hash
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成MD5哈希
- en: Generating an SHA 1/128/256 hash
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成SHA 1/128/256哈希
- en: Implementing SHA and MD5 hashes together
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时实现SHA和MD5哈希
- en: Implementing SHA in a real-world scenario
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实场景中实现SHA
- en: Generating a Bcrypt hash
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成Bcrypt哈希
- en: Cracking an MD5 hash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解MD5哈希
- en: Encoding with Base64
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Base64编码
- en: Encoding with ROT13
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ROT13编码
- en: Cracking a substitution cipher
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解替换密码
- en: Cracking the Atbash cipher
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解Atbash密码
- en: Attacking one-time pad reuse
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击一次性密码重用
- en: Predicting a linear congruential generator
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测线性同余生成器
- en: Identifying hashes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别哈希
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will be covering encryption and encoding in the world of
    Python. Encryption and encoding are two very important aspects of web applications,
    so doing them using Python!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖Python世界中的加密和编码。加密和编码是Web应用程序中非常重要的两个方面，因此使用Python进行它们！
- en: We will be digging into the world of MD5s and SHA hashes, knocking on the door
    of Base64 and ROT13, and taking a look at some of the most popular hashing and
    ciphers out there. We will also be turning back time and looking at some very
    old methods and ways to make and break them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入了解MD5和SHA哈希的世界，敲开Base64和ROT13的大门，并查看一些最流行的哈希和密码。我们还将回到过去，看看一些非常古老的方法以及制作和破解它们的方式。
- en: Generating an MD5 hash
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成MD5哈希
- en: The MD5 hash is one of the most commonly used hashes within web applications
    due to their ease of use and the speed at which they are hashed. The MD5 hash
    was invented in 1991 to replace the previous version, MD4, and it is still used
    to this day.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MD5哈希是Web应用程序中最常用的哈希之一，因为它们易于使用并且哈希速度快。MD5哈希是1991年发明的，用来取代之前的版本MD4，至今仍在使用。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: For this script, we will only need the `hashlib` module.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此脚本，我们只需要`hashlib`模块。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Generating an MD5 hash within Python is extremely simple, due to the nature
    of the module we can import. We need to define the module to import and then decide
    which string we want to hash. We should hard code this into the script, but this
    means the script would have to be modified each time a new string has to be hashed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中生成MD5哈希非常简单，这是因为我们可以导入的模块的性质。我们需要定义要导入的模块，然后决定要对哪个字符串进行哈希。我们应该将其硬编码到脚本中，但这意味着每次需要对新字符串进行哈希时都必须修改脚本。
- en: 'Instead, we use the `raw_input` feature in Python to ask the user for a string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用Python中的`raw_input`功能询问用户要输入的字符串：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `hashlib` module does the bulk of the work for us behind the scenes. Hashlib
    is a giant library that enables users to hash MD5, SHA1, SHA256, and SHA512, among
    others extremely quickly and easily. This is the reasoning for using this module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashlib`模块在幕后为我们做了大部分工作。Hashlib是一个庞大的库，可以让用户非常快速和轻松地对MD5、SHA1、SHA256和SHA512等进行哈希。这就是使用该模块的原因。'
- en: 'We first import the module using the standard method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用标准方法导入模块：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then need the string that we wish to MD5 encode. As mentioned earlier, this
    could be hard-coded into the script but it''s not extremely practical. The way
    around this is to ask for the input from the user by using the `raw_input` feature.
    This can be achieved by:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要要对MD5进行编码的字符串。如前所述，这可以硬编码到脚本中，但这并不是非常实用。解决方法是使用`raw_input`功能向用户询问输入。可以通过以下方式实现：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have the input, we can continue to encode the string using hashlib''s
    built-in functions. For this, we simply call the `.encode()` function after defining
    the string we are going to be using:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了输入，我们可以继续使用hashlib的内置函数对字符串进行编码。为此，在定义要使用的字符串之后，我们只需调用`.encode()`函数：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we can print the output of the string that uses the `.hexdigest()`
    function. If we do not use `hexdigest`, the hex representation of each byte will
    be printed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以打印使用`.hexdigest()`函数的字符串的输出。如果不使用`hexdigest`，则会打印每个字节的十六进制表示。
- en: 'Here is an example of the script in full swing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的完整示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generating an SHA 1/128/256 hash
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成SHA 1/128/256哈希
- en: SHA hashes are also extremely commonly used, alongside MD5 hashes. The early
    implementation of SHA hashes started with SHA1, which is less frequently used
    now due to the weakness of the hash. SHA1 was followed up with SHA128, which was
    then replaced by SHA256.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SHA哈希与MD5哈希一样非常常用。SHA哈希的早期实现始于SHA1，由于哈希的弱点，现在使用较少。SHA1之后是SHA128，然后被SHA256取代。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Once again for these scripts, we will only be requiring the `hashlib` module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些脚本，我们将再次只需要`hashlib`模块。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Generating SHA hashes within Python is also extremely simple by using the imported
    module. With simple tweaks, we can change whether we would like to generate an
    SHA1, SHA128, or SHA256 hash.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中生成SHA哈希也非常简单，只需使用导入的模块。通过简单的调整，我们可以更改是否要生成SHA1、SHA128或SHA256哈希。
- en: 'The following are three different scripts that allow us to generate the different
    SHA hashes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三个不同的脚本，允许我们生成不同的SHA哈希：
- en: 'Here is the script of SHA1:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SHA1的脚本：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the script of SHA128:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SHA128的脚本：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the script of SHA256:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SHA256的脚本：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `hashlib` module once again does the bulk of the work for us here. We can
    utilize the features within the module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashlib`模块再次为我们做了大部分工作。我们可以利用模块内的功能。'
- en: 'We start by importing the module by using:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用以下方法导入模块开始：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then need to prompt for the string to encode using SHA. We ask the user
    for input rather than using hard-coding, so that the script can be used over and
    over again. This can be done with:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要提示输入要使用SHA进行编码的字符串。我们要求用户输入而不是使用硬编码，这样脚本就可以一遍又一遍地使用。可以通过以下方式实现：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once we have the string, we can start the encoding process. The next part depends
    on the SHA encoding that you would like to use:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了字符串，就可以开始编码过程。接下来的部分取决于您想要使用的SHA编码：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to replace `*` with either `1`, `128`, or `256`. Once we have the message
    SHA-encoded, we need to use the `hexdigest()` function once again so the output
    becomes readable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用`*`替换为`1`、`128`或`256`。一旦我们对消息进行了SHA编码，我们需要再次使用`hexdigest()`函数，以便输出变得可读。
- en: 'We do this with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下方式实现：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the output has become readable, we simply need to print the hash output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输出变得可读，我们只需要打印哈希输出：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing SHA and MD5 hashes together
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SHA和MD5哈希的结合
- en: In this section, we will see how SHA and MD5 hash work together.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到SHA和MD5哈希是如何一起工作的。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the following script, we will only require the `hashlib` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的脚本，我们只需要`hashlib`模块。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We are going to tie everything previously done together to form one big script.
    This will output three versions of SHA hashes and also an MD5 hash, so the user
    can choose which one they would like to use:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把之前做过的所有东西联系在一起形成一个大脚本。这将输出三个版本的SHA哈希和一个MD5哈希，所以用户可以选择使用哪一个：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once again, after importing the correct module into this script, we need to
    receive the user input that we wish to turn into an encoded string:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在将正确的模块导入到此脚本之后，我们需要接收用户输入，将其转换为编码字符串：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From here, we can start sending the string through all of the different encoding
    methods and ensuring they are passed through `hexdigest()` so the output becomes
    readable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以开始将字符串通过所有不同的编码方法，并确保它们通过`hexdigest()`，以便输出变得可读：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we have created all of the encoded strings, it is simply a matter of printing
    each of these to the user:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有的编码字符串，只需将每个字符串打印给用户即可：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is an example of the script in action:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本运行的一个示例：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing SHA in a real-world scenario
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在真实世界的场景中实现SHA
- en: The following is an example of real-life SHA implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是真实SHA实现的示例。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, we will need the `hashlib` library and the `uuid` library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们将需要`hashlib`库和`uuid`库。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this real-world example, we will be implementing an SHA256 encoding scheme
    and generating a salt to make it even more secure by defeating precomputed hash
    tables. We will then run it through password-checking to ensure the password was
    typed correctly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个真实世界的示例，我们将实现一个SHA256编码方案，并生成一个盐，使其更加安全，以防止预先计算的哈希表。然后我们将通过密码检查来确保密码被正确输入：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To begin the script, we need to import the correct libraries:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开始脚本之前，我们需要导入正确的库：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then need to define the function that will hash the password. We start by
    creating a salt, using the `uuid` library. Once the salt has been generated, we
    use `hashlib.sha256` to string together the salt encode and the password encode
    and make it readable by using `hexdigest` and finally appending the salt to the
    end of it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义将哈希密码的函数。我们首先创建一个盐，使用`uuid`库。一旦盐被生成，我们使用`hashlib.sha256`将盐编码和密码编码串在一起，并使用`hexdigest`使其可读，最后将盐附加到末尾：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we move onto the check password function. This is what is going to confirm
    our original password is the same as the second one to ensure there were no mistakes.
    This is done by using the same method as before:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向检查密码函数。这将确认我们的原始密码与第二个密码相同，以确保没有错误。这是通过使用与之前相同的方法来完成的：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have created the blocks of code that we need, we can then start asking
    the user for the required input. We start off by asking for the original password
    and using the `hash_password` function to create the hash. This then gets printed
    out to the user. After the first password has been done, we ask for the password
    again to ensure there has been no spelling mistakes. The `check_password` function
    then hashes the password again and compares the original to the new one. If they
    match, the user is informed that the password is correct; if not, the user is
    informed that the passwords do not match:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所需的代码块，我们可以开始要求用户输入所需的输入。我们首先要求原始密码，并使用`hash_password`函数创建哈希。然后将其打印给用户。完成第一个密码后，我们再次要求输入密码，以确保没有拼写错误。`check_password`函数然后再次对密码进行哈希并将原始密码与新密码进行比较。如果匹配，用户将被告知密码是正确的；如果不匹配，用户将被告知密码不匹配：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is an example of the code in use:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的一个使用示例：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding result is an example of a user enter the same password twice.
    Here is an example of the user failing to enter the same password:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的结果是一个用户两次输入相同密码的示例。这是一个用户未能输入相同密码的示例：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generating a Bcrypt hash
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Bcrypt哈希
- en: One of the less commonly used, yet more secure hash functions, is **Bcrypt**.
    Bcrypt hashes were designed to be slow when encrypting and decrypting hashes.
    This design was used to prevent hashes from being easily cracked if hashes got
    leaked to the public, for example from a database exposure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个不太常用但更安全的哈希函数是**Bcrypt**。Bcrypt哈希被设计为在加密和解密哈希时速度较慢。这种设计用于防止哈希泄露到公共场合时容易被破解，例如从数据库泄露。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, we will be using the `bcrypt` module within Python. This can
    be installed by using either `pip` or `easy_install`, albeit you will want to
    ensure version 0.4 is installed and not version 1.1.1, as version 1.1.1 removes
    some functionality from the `Bcrypt` module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们将在Python中使用`bcrypt`模块。这可以通过`pip`或`easy_install`安装，但是您需要确保安装的是版本0.4而不是版本1.1.1，因为版本1.1.1删除了`Bcrypt`模块的一些功能。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Generating Bcrypt hashes within Python is similar to generating other hashes
    such as SHA and MD5, but also slightly different. Like the other hashes, we can
    either prompt the user for a password or hard-code it into the script. The hashing
    in Bcrypt is more complex due to the use of randomly generated salts, which get
    appended to the original hash. This increases the complexity of the hash and therefore
    increases the security of the password stored within the hash function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中生成Bcrypt散列与生成其他散列（如SHA和MD5）类似，但也略有不同。与其他散列一样，我们可以提示用户输入密码，也可以将其硬编码到脚本中。Bcrypt中的哈希更复杂，因为使用了随机生成的盐，这些盐被附加到原始哈希中。这增加了哈希的复杂性，因此增加了哈希函数中存储的密码的安全性。
- en: 'This script also has a `checking` module at the end, which relates to a real-world
    example. It requests the user to re-enter the password they want to hash and ensures
    that it matches the original input. Password confirmation is a very common practice
    among many developers and in the modern age, nearly every registration form uses
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本还在最后有一个`checking`模块，与现实世界的例子有关。它要求用户重新输入他们想要哈希的密码，并确保与原始输入匹配。密码确认是许多开发人员的常见做法，在现代，几乎每个注册表单都使用这种方法：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We start the script off by importing the required module. In this case, we
    only need the `bcrypt` module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过导入所需的模块来启动脚本。在这种情况下，我们只需要`bcrypt`模块：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then request the input from the user by using the standard `raw_input`
    method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用标准的`raw_input`方法从用户那里请求输入：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After we have the input, we can get down to the nitty gritty hashing methods.
    To begin with, we use the `bcrypt.hashpw` function to hash the input. We then
    give it the value of the inputted password and then also randomly generate a salt,
    using `bcrypt.gensalt()`. This can be achieved by using:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了输入之后，我们可以开始使用详细的哈希方法。首先，我们使用`bcrypt.hashpw`函数对输入进行哈希处理。然后我们给它输入的密码的值，然后还随机生成一个盐，使用`bcrypt.gensalt()`。这可以通过使用以下方式实现：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then print the hashed value out to the user, so they can see the hash that
    has been generated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将散列值打印给用户，这样他们就可以看到生成的散列值：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we start the password confirmation. We have to prompt the user for the
    password again so that we can confirm that they entered it correctly:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始密码确认。我们必须提示用户再次输入密码，以便我们确认他们输入正确：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once we have the password, we check whether both passwords match by using the
    `==` feature within Python:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了密码，我们可以使用Python中的`==`功能来检查两个密码是否匹配：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see the script in action as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到脚本的运行情况如下：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Cracking an MD5 hash
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解MD5散列
- en: Since MD5 is a method of encryption and is publicly available, it is possible
    to create a hash collision by using common methods of cracking hashes. This in
    turn "cracks" the hash and returns to you the value of the string before it had
    been put through the MD5 process. This is achieved most commonly by a "dictionary"
    attack. This consists of running a list of words through the MD5 encoding process
    and checking whether any of them are a match against the MD5 hash you are trying
    to crack. This works because MD5 hashes are always the same if the same word is
    hashed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MD5是一种加密方法并且是公开可用的，因此可以使用常见的破解散列方法来创建散列冲突。这反过来“破解”了散列，并向您返回在经过MD5处理之前的字符串的值。这最常见的是通过“字典”攻击来实现的。这包括将一系列单词通过MD5编码过程并检查它们是否与您尝试破解的MD5散列匹配。这是因为如果散列相同，则MD5散列始终相同。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, we will only need the `hashlib` module.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们只需要`hashlib`模块。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To start cracking the MD5 hashes, we need to load a file containing a list
    of words that will be encrypted in MD5\. This will allow us to loop through the
    hashes and check whether we have a match:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始破解MD5散列，我们需要加载一个包含要在MD5中加密的单词列表的文件。这将允许我们循环遍历散列并检查是否有匹配：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We first start by loading the module into Python as normal:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先像平常一样将模块加载到Python中：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need user input for both the hash we would like to crack and also the name
    of the dictionary we are going to load to crack against:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用户输入要破解的散列以及我们要加载以破解的字典的名称：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we have the hash we would like to crack and the dictionary, we can continue
    with the encoding. We need to open the `dictionary` file and encode each string,
    one by one. We can then check to see whether any of the hashes match the original
    one we are aiming to crack. If there is a match, our script will then inform us
    and give us the value:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了要破解的散列和字典，我们就可以继续进行编码。我们需要打开`dictionary`文件并逐个对每个字符串进行编码。然后我们可以检查是否有任何散列与我们要破解的原始散列匹配。如果有匹配，我们的脚本将通知我们并给出值：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now all that''s left to do is run the program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是运行程序：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s have a look at the script in action:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看脚本的运行情况：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Encoding with Base64
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Base64进行编码
- en: Base64 is an encoding method that is used frequently to this day. It is very
    easily encoded and decoded, which makes it both extremely useful and also dangerous.
    Base64 is not used as commonly anymore to encode sensitive data, but there was
    a time where it was.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种经常使用的编码方法。它非常容易编码和解码，这使得它既非常有用又危险。Base64不再常用于编码敏感数据，但曾经有过这样的时期。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Thankfully for the Base64 encoding, we do not require any external modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，对于Base64编码，我们不需要任何外部模块。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To generate the Base64 encoded string, we can use default Python features to
    help us achieve it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成Base64编码的字符串，我们可以使用默认的Python功能来帮助我们实现它：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Encoding a string in Base64 within Python is very simple and can be done in
    a two-line script. To begin we need to have the string fed to us as a user input
    so we have something to work with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中对字符串进行Base64编码非常简单，可以在两行脚本中完成。首先，我们需要将字符串作为用户输入提供给我们，这样我们就有了可以使用的东西：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have the string, we can do the encoding as we print out the result,
    using `msg.encode(''base64'')`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了字符串，我们可以在打印出结果时进行编码，使用`msg.encode('base64')`：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is an example of the script in action:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本运行的示例：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Encoding with ROT13
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROT13编码
- en: ROT13 encoding is definitely not the most secure method of encoding anything.
    Typically, ROT13 was used many years ago to hide offensive jokes on forums as
    a kind of **Not Safe For Work** (**NSFW**) tag so people wouldn't instantly see
    the remark. These days, it's mostly used within **Capture The Flag** (**CTF**)
    challenges, and you'll find out why.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13编码绝对不是编码任何东西的最安全方法。通常，ROT13多年前被用来隐藏论坛上的冒犯性笑话，作为一种**不适宜工作**（**NSFW**）标记，以便人们不会立即看到这个评论。如今，它主要用于**夺旗**（**CTF**）挑战，你会发现原因的。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, we will need quite specific modules. We will be needing the
    `maketrans` feature, and the lowercase and uppercase features from the `string`
    module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们将需要非常具体的模块。我们将需要`maketrans`功能，以及来自`string`模块的小写和大写功能。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To use the ROT13 encoding method, we need to replicate what the ROT13 cipher
    actually does. The 13 indicates that each letter will be moved 13 places along
    the alphabet scale, which makes the encoding very easy to reverse:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ROT13编码方法，我们需要复制ROT13密码实际执行的操作。13表示每个字母将沿字母表移动13个位置，这使得编码非常容易逆转：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This is the first of our scripts that doesn''t simply require the `hashlib`
    module; instead it requires specific features from a string. We can import these
    using the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的脚本中第一个不仅仅需要`hashlib`模块的脚本；而是需要字符串的特定功能。我们可以使用以下导入这些：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we can create a block of code to do the encoding for us. We use the `maketrans`
    feature of Python to tell the interpreter to move the letters 13 places across
    and to keep uppercase within the uppercase and lower within the lower. We then
    request that it returns the value to us:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个代码块来为我们进行编码。我们使用Python的`maketrans`功能告诉解释器将字母移动13个位置，并保持大写和小写。然后我们要求它将值返回给我们：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then need to ask the user for some input so we have a string to work with;
    this is done in the traditional way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要询问用户输入一些内容，这样我们就有一个字符串可以使用；这是以传统方式完成的：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once we have the user input, we can then print out the value of our string
    being passed through our `rot13` block of code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了用户输入，我们就可以打印出我们的字符串通过我们的`rot13`代码块传递的值：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is an example of the code in use:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码使用的示例：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Cracking a substitution cipher
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解替换密码
- en: 'The following is an example of a real-life scenario that was recently encountered.
    A substitution cipher is when letters are replaced by other letters to form a
    new, hidden message. During a CTF that was hosted by "NullCon" we came across
    a challenge that looked like a substitution cipher. The challenge was:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最近遇到的一个真实场景的示例。替换密码是指用其他字母替换字母以形成新的隐藏消息。在由"NullCon"主办的CTF中，我们遇到了一个看起来像替换密码的挑战。挑战是：
- en: 'Find the key:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 找到密钥：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, there is no requirement for any external libraries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，不需要任何外部库。
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To solve this problem, we run our string against values in our periodic dictionary
    and transformed the discovered values into their ascii form. This in returned
    the output of our final answer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将我们的字符串与我们的周期字典中的值进行匹配，并将发现的值转换为它们的ascii形式。这样就返回了我们最终答案的输出：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To start this script off, we first defined the `key` string within the script.
    The `n` variable was then defined as `2` for later use and two empty lists were
    created— list and answer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动这个脚本，我们首先在脚本中定义了`key`字符串。然后定义了`n`变量为`2`以供以后使用，并创建了两个空列表—list和answer：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then started to create the list, which ran through the string and pulled
    out the sets of two letters and appended them to the list value, which was then
    printed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始创建列表，它通过字符串并提取两个字母的集合并将它们附加到列表值，然后打印出来：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Each of the two letters corresponded to a value in the periodic table, which
    relates to a number. Those numbers when transformed into ascii related to a character.
    Once this was discovered, we needed to map the elements to their periodic number
    and store that:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字母分别对应于周期表中的一个值，这与一个数字相关。当这些数字转换为ascii相关的字符时。一旦发现了这一点，我们需要将元素映射到它们的周期数，并存储起来：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We are then able to create a loop that will go through the list of elements
    that we previously created and named as **list**, and map them to the value in
    the `periodic` set of data that we created. As this is running, we can have it
    append the findings into our answer string while transforming the ascii number
    to the relevant letter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建一个循环，它将遍历我们之前创建并命名为**list**的元素列表，并将它们映射到我们创建的`periodic`数据集中的值。在运行时，我们可以让它将发现附加到我们的答案字符串中，同时将ascii数字转换为相关字母：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we need to have the data printed to us:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将数据打印出来：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is an example of the script running:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本运行的示例：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Cracking the Atbash cipher
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解Atbash密码
- en: The Atbash cipher is a simple cipher that uses opposite values in the alphabet
    to transform words. For example, A is equal to Z and C is equal to X.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Atbash密码是一种简单的密码，它使用字母表中的相反值来转换单词。例如，A等于Z，C等于X。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this, we will only need the `string` module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，我们只需要`string`模块。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Since the Atbash cipher works by using the opposite value of a character in
    the alphabet, we can create a `maketrans` feature to substitute characters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Atbash密码是通过使用字母表中字符的相反值来工作的，我们可以创建一个`maketrans`功能来替换字符：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'After importing the correct module, we request the input from the user for
    the value they would like encipher into the Atbash cipher:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 导入正确的模块后，我们要求用户输入他们想要加密到Atbash密码中的值：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we create the `maketrans` feature to be used. We do this by listing the
    first set of characters that we would like to be substituted and then listing
    another set of characters that we will use to replace the previous ones:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建要使用的`maketrans`功能。我们通过列出我们想要替换的第一组字符，然后列出另一组用于替换前一组的字符来实现这一点：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we just need to give a value to the transformation, apply it, and
    print the value out to get the end result:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要给转换一个值，应用它，并打印出值以获得最终结果：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is an example of the script in action:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的示例：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Attacking one-time pad reuse
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击一次性密码重用
- en: The concept of a one-time pad was a fundamental core to early cryptography.
    Basically, a phrase is memorized by the various parties and when a message is
    sent, it is shifted with that phrase for each step. For example, if the phrase
    is `apple` and the message is `i like them`, then we add `a` to `i` to get `j`
    and so on to eventually receive the encoded message.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码的概念是早期密码学的基本核心。基本上，各方记住一个短语，当发送消息时，对每一步都用该短语进行移位。例如，如果短语是`apple`，消息是`i
    like them`，那么我们将`a`加到`i`上得到`j`，以此类推，最终得到编码后的消息。
- en: More recently, a lot of malware engineers and bad software engineers used XORing
    to perform the same activity. Where the vulnerability lies and where we can create
    scripts to be useful is where the same key has been used multiple times. If multiple
    ascii-based strings have been XORed with the same ascii-based strings, we can
    brute the strings at the same time by XORing all of them with ascii values character
    by character.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，许多恶意软件工程师和糟糕的软件工程师使用XOR来执行相同的活动。当漏洞存在且我们可以创建有用的脚本的地方是，同一个密钥已被多次使用。如果多个基于ASCII的字符串已经与相同的基于ASCII的字符串进行了XOR运算，我们可以通过逐个字符地将它们与ASCII值进行XOR运算来同时破解这些字符串。
- en: The following script will take a list of XORed values from a file and brute
    them character by character.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将逐个字符地对文件中的XOR值列表进行暴力破解。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Put a list of XORed phrases in a file. Place that file in the same folder as
    your script (or don't; it just makes it marginally easier if you do).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将XOR短语列表放入一个文件中。将该文件放在与您的脚本相同的文件夹中（或者不放；如果放了，它只会让事情稍微变得容易一点）。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The script should look something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应该看起来像这样：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This script is pretty straightforward. We open a file with the XORed values
    in them and split it by lines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本非常简单。我们打开一个包含XOR值的文件，并按行拆分它：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We shamelessly use the industry standard `XOR` python. Basically, this function
    equates two strings to the same length and `XOR` them together:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无耻地使用了行业标准的`XOR` python。基本上，这个函数将两个字符串等长地等同起来，然后将它们进行`XOR`运算：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then run through all ascii values three times to get all the combinations
    from `aaa` to `zzz` for each line in the `ciphers.txt` file. We assign the value
    of the ascii loops to the key each time:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行所有ASCII值三次，以获取`ciphers.txt`文件中每行的`aaa`到`zzz`的所有组合。我们每次将ASCII循环的值分配给密钥：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then encrypt the line with the generated key and print it out. We can pipe
    this a file with ease, as we''ve shown throughout the book already:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用生成的密钥加密该行并将其打印出来。我们可以轻松地将其导入文件，就像我们在整本书中已经展示的那样：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Predicting a linear congruential generator
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测线性同余生成器
- en: 'LCGs are used in web applications to create quick and easy pseudo-random numbers.
    They are by nature broken and can be easily made to be predictable with enough
    data. The algorithm for an LCG is:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: LCG被用于网络应用程序中创建快速和简单的伪随机数。它们天生就是不安全的，只要有足够的数据，就可以很容易地预测。LCG的算法是：
- en: '![Predicting a linear congruential generator](img/B04044_07_01.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![预测线性同余生成器](img/B04044_07_01.jpg)'
- en: Here, **X** is the current value, **a** is a fixed multiplier, **c** is a fixed
    increment, and **m** is a fixed modulus. If any data is leaked, such as the multiplier,
    modulus, and increment in this example, it is possible to calculate the seed and
    thus the next values.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**X**是当前值，**a**是固定的乘数，**c**是固定的增量，**m**是固定的模数。如果泄漏了任何数据，例如本例中的乘数、模数和增量，就有可能计算出种子，从而计算出下一个值。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The situation here is where an application is generating random 2-digit numbers
    and returning them to you. You have the multiplier, modulus, and increment. This
    may seem strange, but this has happened in live tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的情况是一个应用程序生成随机的两位数并将它们返回给你。你知道乘数、模数和增量。这可能看起来很奇怪，但这在实际测试中确实发生过。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here is the code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We set our three values, the increment, the multiplier, and the modulo as `C`,
    `A`, and `M` respectively:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了三个值，增量、乘数和模数分别为`C`、`A`和`M`：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We then declare the range for the possible size of the seed, which in this
    case would be between one and eight digits long:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明种子可能的大小范围，本例中为1到8位数字：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We then perform our first LCG transformation and generate possible values with
    the first value taken from the web page marked highlighted in the following example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行第一个LCG转换，并使用网页上标记的第一个值生成可能的值，如下例所示：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We take the second value generated by the web page and check the outcome of
    this transform against that:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得网页生成的第二个值，并检查这个转换的结果是否与之相匹配：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If it works, we then perform the next transform with the numbers that matched
    the first transform:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，我们就用与第一个转换匹配的数字执行下一个转换：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We repeat this process 10 times here, but it can be reproduced as many times
    as necessary until we find an output that has matched all the numbers so far.
    We print an alert with that number:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重复这个过程10次，但可以根据需要重复多次，直到找到一个与迄今为止所有数字都匹配的输出。我们打印一个带有该数字的警报：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We then repeat the process 10 more times, with that number as the seed to generate
    the next 10 values to allow us to predict the new values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重复这个过程10次，以该数字作为种子生成下一个10个值，以便我们预测新值。
- en: Identifying hashes
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别哈希
- en: Nearly every web application you use that stores a password of yours, should
    store your credentials in some form of hashed format for added security. A good
    hashing system in place for user passwords can be very useful in case your database
    is ever stolen, as this will extend the time taken for a hacker to crack them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的几乎每个网络应用程序都应该以某种形式以哈希格式存储你的密码，以增加安全性。对于用户密码来说，一个良好的哈希系统可以在数据库被盗时非常有用，因为这将延长黑客破解密码所需的时间。
- en: For this reason, we have numerous different hashing methods, some of which are
    reused throughout different applications, such as MD5 and SHA hashes, but some
    such as Des(UNIX) are less commonly found. Because of this, it is a good idea
    to be able to match a hash value to the hashing function it belongs to. We cannot
    base this purely on hash length as many hashing functions share the same length,
    so to aid us with this we are going to use **regular expressions** (**Regex**).
    This allows us to define the length, the characters used, and whether any numerical
    values are present.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，我们有许多不同的哈希方法，其中一些在不同的应用程序中被重复使用，比如MD5和SHA哈希，但一些如Des(UNIX)则较少见。因此，能够将哈希值与其所属的哈希函数进行匹配是一个好主意。我们不能仅仅基于哈希长度来进行匹配，因为许多哈希函数具有相同的长度，因此为了帮助我们，我们将使用**正则表达式**（**Regex**）。这允许我们定义长度、使用的字符以及是否存在任何数字值。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this script, we will only be using the `re` module.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们将只使用`re`模块。
- en: How to do it…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As previously mentioned, we are going to be basing the script around Regex
    values and using those to map input hashes to the stored hash values. This will
    allow us to very quickly pick out potential matches for the hashes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将围绕正则表达式值构建脚本，并使用这些值将输入哈希映射到存储的哈希值。这将允许我们非常快速地挑选出哈希的潜在匹配项：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: After we import the `re` module, which we are going to be using, we start to
    build our first block of code, which will be the heart of our script. We will
    try to use conventional naming throughout the script to make it more manageable
    further on. We pick the name `hashcheck` for this reason. We use the name `hashtype`
    to represent the names of the hashes that are upcoming in the Regex block of code,
    we use `regexstr` to represent the Regex, and we finally use data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入`re`模块之后，我们将开始构建我们的第一个代码块，这将是我们脚本的核心。我们将尝试在整个脚本中使用常规命名，以使其在以后更易管理。出于这个原因，我们选择了名为`hashcheck`。我们使用名为`hashtype`来表示即将在正则表达式代码块中出现的哈希的名称，我们使用`regexstr`来表示正则表达式，最后使用数据。
- en: 'We create a string called `valid_hash` and give that the value of the iteration
    values after going through the data, which will only happen if we have a valid
    match. This can be seen further down where we give the value result the name of
    matching hash values that we detect using the Regex. We finally print the match
    if one, or more, is found and add our `except` statement to the end:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`valid_hash`的字符串，并为其赋予在通过数据后迭代值的值，这只会在我们有一个有效的匹配时发生。这可以在稍后看到，我们在那里为匹配哈希值的值result赋予了匹配哈希值的名称，我们最终打印匹配（如果找到一个或多个）并在结尾添加我们的`except`语句：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We then ask the user for their input, so we have something to match against
    the Regex. This is done as normal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要求用户输入，这样我们就有了一些东西可以与正则表达式进行匹配。这是正常进行的：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Once this is done, we can move onto the nitty gritty Regex-fu. The reason we
    use Regex is so that we can differentiate between the different hashes, as they
    have different lengths and character sets. This is extremely helpful for MD5 hashes,
    as there are numerous different types of MD5 hashes, such as phpBB3 and MyBB forums.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以继续进行复杂的正则表达式操作。我们使用正则表达式的原因是为了区分不同的哈希值，因为它们具有不同的长度和字符集。这对于MD5哈希非常有帮助，因为有许多不同类型的MD5哈希，比如phpBB3和MyBB论坛。
- en: 'We name the set of Regexs something logical like hashes, and then define them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给一组正则表达式起一个逻辑的名字，比如hashes，然后定义它们：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We then need to find a way to return the data to the user in a manageable way,
    without letting them know each time a non-match is found. We do this by creating
    a counter. We set the value of this counter to `0` and continue. We then create
    a function named `text`, which will become the value of the name of the hash,
    should a match be found. An `if` statement is then used to prevent the unwanted
    messages we previously mentioned. We tell the script that if `text is not none`
    then a match has been found, so we raise the value of the counter and print the
    text. Using the counter idea means any non-matches found will not increase the
    counter and therefore will not be printed to the user:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要找到一种方法以可管理的方式将数据返回给用户，而不让他们每次找到一个非匹配时都知道。我们通过创建一个计数器来实现这一点。我们将这个计数器的值设置为`0`并继续。然后我们创建一个名为`text`的函数，如果找到匹配，它将成为哈希名称的值。然后使用`if`语句来防止我们之前提到的不需要的消息。我们告诉脚本，如果`text不是none`，那么就找到了一个匹配，所以我们提高计数器的值并打印文本。使用计数器的想法意味着任何找到的非匹配都不会增加计数器，因此不会被打印给用户：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We finish the script off by letting the user know if there is no match, in the
    most polite way possible!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以最礼貌的方式告知用户没有匹配来完成脚本！
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here are some examples of the script in action:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本运行的一些示例：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The preceding result finds no matches as there is no hashing system listed
    that outputs two character strings. The following is an example of a successful
    find:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果没有找到匹配，因为没有列出输出两个字符字符串的哈希系统。以下是一个成功找到的示例：
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
