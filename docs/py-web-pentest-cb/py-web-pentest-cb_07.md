# 第七章：加密和编码

在本章中，我们将涵盖以下主题：

+   生成 MD5 哈希

+   生成 SHA 1/128/256 哈希

+   同时实现 SHA 和 MD5 哈希

+   在现实场景中实现 SHA

+   生成 Bcrypt 哈希

+   破解 MD5 哈希

+   使用 Base64 编码

+   使用 ROT13 编码

+   破解替换密码

+   破解 Atbash 密码

+   攻击一次性密码重用

+   预测线性同余生成器

+   识别哈希

# 介绍

在本章中，我们将涵盖 Python 世界中的加密和编码。加密和编码是 Web 应用程序中非常重要的两个方面，因此使用 Python 进行它们！

我们将深入了解 MD5 和 SHA 哈希的世界，敲开 Base64 和 ROT13 的大门，并查看一些最流行的哈希和密码。我们还将回到过去，看看一些非常古老的方法以及制作和破解它们的方式。

# 生成 MD5 哈希

MD5 哈希是 Web 应用程序中最常用的哈希之一，因为它们易于使用并且哈希速度快。MD5 哈希是 1991 年发明的，用来取代之前的版本 MD4，至今仍在使用。

## 做好准备

对于此脚本，我们只需要`hashlib`模块。

## 如何做…

在 Python 中生成 MD5 哈希非常简单，这是因为我们可以导入的模块的性质。我们需要定义要导入的模块，然后决定要对哪个字符串进行哈希。我们应该将其硬编码到脚本中，但这意味着每次需要对新字符串进行哈希时都必须修改脚本。

相反，我们使用 Python 中的`raw_input`功能询问用户要输入的字符串：

```py
import hashlib
message = raw_input("Enter the string you would like to hash: ")
md5 = hashlib.md5(message.encode())
print (md5.hexdigest())
```

## 工作原理…

`hashlib`模块在幕后为我们做了大部分工作。Hashlib 是一个庞大的库，可以让用户非常快速和轻松地对 MD5、SHA1、SHA256 和 SHA512 等进行哈希。这就是使用该模块的原因。

我们首先使用标准方法导入模块：

```py
import hashlib
```

然后我们需要要对 MD5 进行编码的字符串。如前所述，这可以硬编码到脚本中，但这并不是非常实用。解决方法是使用`raw_input`功能向用户询问输入。可以通过以下方式实现：

```py
message = raw_input("Enter what you wish to ask the user here: ")
```

一旦我们有了输入，我们可以继续使用 hashlib 的内置函数对字符串进行编码。为此，在定义要使用的字符串之后，我们只需调用`.encode()`函数：

```py
md5 = hashlib.md5(message.encode())
```

最后，我们可以打印使用`.hexdigest()`函数的字符串的输出。如果不使用`hexdigest`，则会打印每个字节的十六进制表示。

以下是脚本的完整示例：

```py
Enter the string you would like to hash: pythonrules
048c0fc556088fabc53b76519bfb636e

```

# 生成 SHA 1/128/256 哈希

SHA 哈希与 MD5 哈希一样非常常用。SHA 哈希的早期实现始于 SHA1，由于哈希的弱点，现在使用较少。SHA1 之后是 SHA128，然后被 SHA256 取代。

## 做好准备

对于这些脚本，我们将再次只需要`hashlib`模块。

## 如何做…

在 Python 中生成 SHA 哈希也非常简单，只需使用导入的模块。通过简单的调整，我们可以更改是否要生成 SHA1、SHA128 或 SHA256 哈希。

以下是三个不同的脚本，允许我们生成不同的 SHA 哈希：

以下是 SHA1 的脚本：

```py
import hashlib
message = raw_input("Enter the string you would like to hash: ")
sha = hashlib.sha1(message)
sha1 = sha.hexdigest()
print sha1
```

以下是 SHA128 的脚本：

```py
import hashlib
message = raw_input("Enter the string you would like to hash: ")
sha = hashlib.sha128(message)
sha128 = sha.hexdigest()
print sha128
```

以下是 SHA256 的脚本：

```py
import hashlib
message = raw_input("Enter the string you would like to hash: ")
sha = hashlib.sha256(message)
sha256 = sha.hexdigest()
print sha256
```

## 工作原理…

`hashlib`模块再次为我们做了大部分工作。我们可以利用模块内的功能。

我们通过使用以下方法导入模块开始：

```py
import hashlib
```

然后我们需要提示输入要使用 SHA 进行编码的字符串。我们要求用户输入而不是使用硬编码，这样脚本就可以一遍又一遍地使用。可以通过以下方式实现：

```py
message = raw_input("Enter the string you would like to hash: )
```

一旦我们有了字符串，就可以开始编码过程。接下来的部分取决于您想要使用的 SHA 编码：

```py
sha = hashlib.sha*(message)
```

我们需要用`*`替换为`1`、`128`或`256`。一旦我们对消息进行了 SHA 编码，我们需要再次使用`hexdigest()`函数，以便输出变得可读。

我们用以下方式实现：

```py
sha*=sha.hexdigest()
```

一旦输出变得可读，我们只需要打印哈希输出：

```py
print sha*
```

# 实现 SHA 和 MD5 哈希的结合

在这一部分，我们将看到 SHA 和 MD5 哈希是如何一起工作的。

## 准备工作

对于下面的脚本，我们只需要`hashlib`模块。

## 如何做…

我们将把之前做过的所有东西联系在一起形成一个大脚本。这将输出三个版本的 SHA 哈希和一个 MD5 哈希，所以用户可以选择使用哪一个：

```py
import hashlib

message = raw_input("Enter the string you would like to hash: ")

md5 = hashlib.md5(message)
md5 = md5.hexdigest()

sha1 = hashlib.sha1(message)
sha1 = sha1.hexdigest()

sha256 = hashlib.sha256(message)
sha256 = sha256.hexdigest()

sha512 = hashlib.sha512(message)
sha512 = sha512.hexdigest()

print "MD5 Hash =", md5
print "SHA1 Hash =", sha1
print "SHA256 Hash =", sha256
print "SHA512 Hash =", sha512
print "End of list."
```

## 它是如何工作的…

再次，在将正确的模块导入到此脚本之后，我们需要接收用户输入，将其转换为编码字符串：

```py
import hashlib
message = raw_input('Please enter the string you would like to hash: ')
```

从这里开始，我们可以开始将字符串通过所有不同的编码方法，并确保它们通过`hexdigest()`，以便输出变得可读：

```py
md5 = hashlib.md5(message)
md5 = md5.hexdigest()

sha1 = hashlib.sha1(message)
sha1 = sha1.hexdigest()

sha256 = hashlib.sha256(message)
sha256 = sha256.hexdigest()

sha512 = hashlib.sha512(message)
sha512 = sha512.hexdigest()
```

一旦我们创建了所有的编码字符串，只需将每个字符串打印给用户即可：

```py
print "MD5 Hash =", md5
print "SHA1 Hash =", sha1
print "SHA256 Hash =", sha256
print "SHA512 Hash =", sha512
print "End of list."
```

这是脚本运行的一个示例：

```py
Enter the string you would like to hash: test
MD5 Hash = 098f6bcd4621d373cade4e832627b4f6
SHA1 Hash= a94a8fe5ccb19ba61c4c0873d391e987982fbbd3
SHA256 Hash= 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08
SHA512 Hash= ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0 db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff
End of list.

```

# 在真实世界的场景中实现 SHA

以下是真实 SHA 实现的示例。

## 准备工作

对于这个脚本，我们将需要`hashlib`库和`uuid`库。

## 如何做…

对于这个真实世界的示例，我们将实现一个 SHA256 编码方案，并生成一个盐，使其更加安全，以防止预先计算的哈希表。然后我们将通过密码检查来确保密码被正确输入：

```py
#!/usr/bin/python
import uuid
import hashlib

# Let's do the hashing. We create a salt and append it to the password once hashes.

def hash(password):
    salt = uuid.uuid4().hex
    return hashlib.sha512(salt.encode() + password.encode()).hexdigest() + ':' + salt

# Let's confirm that worked as intended.

def check(hashed, p2):
    password, salt = hashed.split(':')
    return password == hashlib.sha512(salt.encode() + p2.encode()).hexdigest()

password = raw_input('Please enter a password: ')
hashed = hash(password)
print('The string to store in the db is: ' + hashed)
re = raw_input('Please re-enter your password: ')

# Let's ensure the passwords matched

if check(hashed, re):
    print('Password Match')
else:
    print('Password Mismatch')
```

## 它是如何工作的…

开始脚本之前，我们需要导入正确的库：

```py
import uuid
import hashlib
```

然后我们需要定义将哈希密码的函数。我们首先创建一个盐，使用`uuid`库。一旦盐被生成，我们使用`hashlib.sha256`将盐编码和密码编码串在一起，并使用`hexdigest`使其可读，最后将盐附加到末尾：

```py
def hash(password):
    salt = uuid.uuid4().hex
    return hashlib.sha512(salt.encode() + password.encode()).hexdigest() + ':' + salt
```

接下来，我们转向检查密码函数。这将确认我们的原始密码与第二个密码相同，以确保没有错误。这是通过使用与之前相同的方法来完成的：

```py
def check(hashed, p2):
    password, salt = hashed.split(':')
    return password == hashlib.sha512(salt.encode() + p2.encode()).hexdigest()
```

一旦我们创建了所需的代码块，我们可以开始要求用户输入所需的输入。我们首先要求原始密码，并使用`hash_password`函数创建哈希。然后将其打印给用户。完成第一个密码后，我们再次要求输入密码，以确保没有拼写错误。`check_password`函数然后再次对密码进行哈希并将原始密码与新密码进行比较。如果匹配，用户将被告知密码是正确的；如果不匹配，用户将被告知密码不匹配：

```py
password = raw_input('Please enter a password: ')
hashed = hash(password)
print('The string to store in the db is: ' + hashed)
re = raw_input('Please re-enter your password: ')
if check(hashed, re):
    print('Password Match')
else:
    print('Password Mismatch')
```

这是代码的一个使用示例：

```py
Please enter a password: password
The string to store in the db is: a8be1e0e023e2c9c1e96187c4b966222ccf1b7d34718ad60f8f000094d39 d8dd3eeb837af135bfe50c7baea785ec735ed04f230ffdbe2ed3def1a240c 97ca127:d891b46fc8394eda85ccf85d67969e82
Please re-enter your password: password
Password Match

```

上面的结果是一个用户两次输入相同密码的示例。这是一个用户未能输入相同密码的示例：

```py
Please enter a password: password1
The string to store in the db is: 418bba0beeaef52ce523dafa9b19baa449562cf034ebd1e4fea8c007dd49cb 1004e10b837f13d59b13236c54668e44c9d0d8dbd03e32cd8afad6eff04541 ed07:1d9cd2d9de5c46068b5c2d657ae45849
Please re-enter your password: password
Password Mismatch

```

# 生成 Bcrypt 哈希

其中一个不太常用但更安全的哈希函数是**Bcrypt**。Bcrypt 哈希被设计为在加密和解密哈希时速度较慢。这种设计用于防止哈希泄露到公共场合时容易被破解，例如从数据库泄露。

## 准备工作

对于这个脚本，我们将在 Python 中使用`bcrypt`模块。这可以通过`pip`或`easy_install`安装，但是您需要确保安装的是版本 0.4 而不是版本 1.1.1，因为版本 1.1.1 删除了`Bcrypt`模块的一些功能。

## 如何做…

在 Python 中生成 Bcrypt 散列与生成其他散列（如 SHA 和 MD5）类似，但也略有不同。与其他散列一样，我们可以提示用户输入密码，也可以将其硬编码到脚本中。Bcrypt 中的哈希更复杂，因为使用了随机生成的盐，这些盐被附加到原始哈希中。这增加了哈希的复杂性，因此增加了哈希函数中存储的密码的安全性。

该脚本还在最后有一个`checking`模块，与现实世界的例子有关。它要求用户重新输入他们想要哈希的密码，并确保与原始输入匹配。密码确认是许多开发人员的常见做法，在现代，几乎每个注册表单都使用这种方法：

```py
import bcrypt
# Let's first enter a password
new = raw_input('Please enter a password: ')
# We'll encrypt the password with bcrypt with the default salt value of 12
hashed = bcrypt.hashpw(new, bcrypt.gensalt())
# We'll print the hash we just generated
print('The string about to be stored is: ' + hashed)
# Confirm we entered the correct password
plaintext = raw_input('Please re-enter the password to check: ')
# Check if both passwords match
if bcrypt.hashpw(plaintext, hashed) == hashed:
    print 'It\'s a match!'
else:
    print 'Please try again.'
```

## 工作原理…

我们首先通过导入所需的模块来启动脚本。在这种情况下，我们只需要`bcrypt`模块：

```py
import bcrypt
```

然后我们可以使用标准的`raw_input`方法从用户那里请求输入：

```py
new = raw_input('Please enter a password: ')
```

在我们有了输入之后，我们可以开始使用详细的哈希方法。首先，我们使用`bcrypt.hashpw`函数对输入进行哈希处理。然后我们给它输入的密码的值，然后还随机生成一个盐，使用`bcrypt.gensalt()`。这可以通过使用以下方式实现：

```py
hashed = bcrypt.hashpw(new, bcrypt.gensalt())
```

然后我们将散列值打印给用户，这样他们就可以看到生成的散列值：

```py
print ('The string about to be stored is: ' + hashed)
```

现在，我们开始密码确认。我们必须提示用户再次输入密码，以便我们确认他们输入正确：

```py
plaintext = raw_input('Please re-enter the password to check: ')
```

一旦我们有了密码，我们可以使用 Python 中的`==`功能来检查两个密码是否匹配：

```py
If bcrypt.hashpw(plaintext, hashed) == hashed:
  print "It\'s a match"
else:
  print "Please try again".
```

我们可以看到脚本的运行情况如下：

```py
Please enter a password: example
The string about to be stored is: $2a$12$Ie6u.GUpeO2WVjchYg7Pk.741gWjbCdsDlINovU5yubUeqLIS1k8e
Please re-enter the password to check: example
It's a match!

Please enter a password: example
The string about to be stored is: $2a$12$uDtDrVCv2vqBw6UjEAYE8uPbfuGsxdYghrJ/YfkZuA7vaMvGIlDGe
Please re-enter the password to check: incorrect
Please try again.

```

# 破解 MD5 散列

由于 MD5 是一种加密方法并且是公开可用的，因此可以使用常见的破解散列方法来创建散列冲突。这反过来“破解”了散列，并向您返回在经过 MD5 处理之前的字符串的值。这最常见的是通过“字典”攻击来实现的。这包括将一系列单词通过 MD5 编码过程并检查它们是否与您尝试破解的 MD5 散列匹配。这是因为如果散列相同，则 MD5 散列始终相同。

## 准备工作

对于这个脚本，我们只需要`hashlib`模块。

## 如何做…

要开始破解 MD5 散列，我们需要加载一个包含要在 MD5 中加密的单词列表的文件。这将允许我们循环遍历散列并检查是否有匹配：

```py
import hashlib
target = raw_input("Please enter your hash here: ")
dictionary = raw_input("Please enter the file name of your dictionary: ")
def main():
    with open(dictionary) as fileobj:
        for line in fileobj:
            line = line.strip()
            if hashlib.md5(line).hexdigest() == target:
                print "Hash was successfully cracked %s: The value is %s" % (target, line)
                return ""
    print "Failed to crack the file."
if __name__ == "__main__":
    main()
```

## 工作原理…

我们首先像平常一样将模块加载到 Python 中：

```py
import hashlib
```

我们需要用户输入要破解的散列以及我们要加载以破解的字典的名称：

```py
target = raw_input("Please enter your hash here: ")
dictionary = raw_input("Please enter the file name of your dictionary: ")
```

一旦我们有了要破解的散列和字典，我们就可以继续进行编码。我们需要打开`dictionary`文件并逐个对每个字符串进行编码。然后我们可以检查是否有任何散列与我们要破解的原始散列匹配。如果有匹配，我们的脚本将通知我们并给出值：

```py
def main():
    with open(dictionary) as fileobj:
        for line in fileobj:
            line = line.strip()
            if hashlib.md5(line).hexdigest() == target:
                print "Hash was successfully cracked %s: The value is %s" % (target, line)
                return ""
    print "Failed to crack the file."
```

现在剩下的就是运行程序：

```py
if __name__ == "__main__":
    main()
```

现在让我们看看脚本的运行情况：

```py
Please enter your hash here: 5f4dcc3b5aa765d61d8327deb882cf99
Please enter the file name of your dictionary: dict.txt
Hash was successfully cracked 5f4dcc3b5aa765d61d8327deb882cf99: The value is password

```

# 使用 Base64 进行编码

Base64 是一种经常使用的编码方法。它非常容易编码和解码，这使得它既非常有用又危险。Base64 不再常用于编码敏感数据，但曾经有过这样的时期。

## 准备工作

值得庆幸的是，对于 Base64 编码，我们不需要任何外部模块。

## 如何做…

要生成 Base64 编码的字符串，我们可以使用默认的 Python 功能来帮助我们实现它：

```py
#!/usr/bin/python
msg = raw_input('Please enter the string to encode: ')
print "Your B64 encoded string is: " + msg.encode('base64')
```

## 工作原理…

在 Python 中对字符串进行 Base64 编码非常简单，可以在两行脚本中完成。首先，我们需要将字符串作为用户输入提供给我们，这样我们就有了可以使用的东西：

```py
msg = raw_input('Please enter the string to encode: ')
```

一旦我们有了字符串，我们可以在打印出结果时进行编码，使用`msg.encode('base64')`：

```py
print "Your B64 encoded string is: " + msg.encode('base64')
```

以下是脚本运行的示例：

```py
Please enter the string to encode: This is an example
Your B64 encoded string is: VghpcyBpcyBhbiBleGFtcGxl

```

# 使用 ROT13 编码

ROT13 编码绝对不是编码任何东西的最安全方法。通常，ROT13 多年前被用来隐藏论坛上的冒犯性笑话，作为一种**不适宜工作**（**NSFW**）标记，以便人们不会立即看到这个评论。如今，它主要用于**夺旗**（**CTF**）挑战，你会发现原因的。

## 准备工作

对于这个脚本，我们将需要非常具体的模块。我们将需要`maketrans`功能，以及来自`string`模块的小写和大写功能。

## 如何做…

要使用 ROT13 编码方法，我们需要复制 ROT13 密码实际执行的操作。13 表示每个字母将沿字母表移动 13 个位置，这使得编码非常容易逆转：

```py
from string import maketrans, lowercase, uppercase
def rot13(message):
   lower = maketrans(lowercase, lowercase[13:] + lowercase[:13])
   upper = maketrans(uppercase, uppercase[13:] + uppercase[:13])
   return message.translate(lower).translate(upper)
message = raw_input('Enter :')
print rot13(message)
```

## 它是如何工作的…

这是我们的脚本中第一个不仅仅需要`hashlib`模块的脚本；而是需要字符串的特定功能。我们可以使用以下导入这些：

```py
from string import maketrans, lowercase, uppercase
```

接下来，我们可以创建一个代码块来为我们进行编码。我们使用 Python 的`maketrans`功能告诉解释器将字母移动 13 个位置，并保持大写和小写。然后我们要求它将值返回给我们：

```py
def rot13(message):
   lower = maketrans(lowercase, lowercase[13:] + lowercase[:13])
   upper = maketrans(uppercase, uppercase[13:] + uppercase[:13])
   return message.translate(lower).translate(upper)
```

然后我们需要询问用户输入一些内容，这样我们就有一个字符串可以使用；这是以传统方式完成的：

```py
message = raw_input('Enter :')
```

一旦我们有了用户输入，我们就可以打印出我们的字符串通过我们的`rot13`代码块传递的值：

```py
print rot13(message)
```

以下是代码使用的示例：

```py
Enter :This is an example of encoding in Python
Guvf vf na rknzcyr bs rapbqvat va Clguba

```

# 破解替换密码

以下是最近遇到的一个真实场景的示例。替换密码是指用其他字母替换字母以形成新的隐藏消息。在由"NullCon"主办的 CTF 中，我们遇到了一个看起来像替换密码的挑战。挑战是：

找到密钥：

```py
TaPoGeTaBiGePoHfTmGeYbAtPtHoPoTaAuPtGeAuYbGeBiHoTaTmPtHoTmGePoAuGe ErTaBiHoAuRnTmPbGePoHfTmGeTmRaTaBiPoTmPtHoTmGeAuYbGeTbGeLuTmPtTm PbTbOsGePbTmTaLuPtGeAuYbGeAuPbErTmPbGeTaPtGePtTbPoAtPbTmGeTbPtEr GePoAuGeYbTaPtErGePoHfTmGeHoTbAtBiTmBiGeLuAuRnTmPbPtTaPtLuGePoHf TaBiGeAuPbErTmPbPdGeTbPtErGePoHfTaBiGePbTmYbTmPbBiGeTaPtGeTmTlAt TbOsGeIrTmTbBiAtPbTmGePoAuGePoHfTmGePbTmOsTbPoTaAuPtBiGeAuYbGeIr TbPtGeRhGeBiAuHoTaTbOsGeTbPtErGeHgAuOsTaPoTaHoTbOsGeRhGeTbPtErGePoAuGePoHfTmGeTmPtPoTaPbTmGeAtPtTaRnTmPbBiTmGeTbBiGeTbGeFrHfAuOs TmPd
```

## 准备工作

对于这个脚本，不需要任何外部库。

## 如何做…

为了解决这个问题，我们将我们的字符串与我们的周期字典中的值进行匹配，并将发现的值转换为它们的 ascii 形式。这样就返回了我们最终答案的输出：

```py
string = "TaPoGeTaBiGePoHfTmGeYbAtPtHoPoTaAuPtGeAuYbGeBiHoTaTmPtHoTmGePoA uGeErTaBiHoAuRnTmPbGePoHfTmGeTmRaTaBiPoTmPtHoTmGeAuYbGeTbGeLuTmP tTmPbTbOsGePbTmTaLuPtGeAuYbGeAuPbErTmPbGeTaPtGePtTbPoAtPbTmGeTbP tErGePoAuGeYbTaPtErGePoHfTmGeHoTbAtBiTmBiGeLuAuRnTmPbPtTaPtLuGeP oHfTaBiGeAuPbErTmPbPdGeTbPtErGePoHfTaBiGePbTmYbTmPbBiGeTaPtGeTmT lAtTbOsGeIrTmTbBiAtPbTmGePoAuGePoHfTmGePbTmOsTbPoTaAuPtBiGeAuYbG eIrTbPtGeRhGeBiAuHoTaTbOsGeTbPtErGeHgAuOsTaPoTaHoTbOsGeRhGeTbPtE rGePoAuGePoHfTmGeTmPtPoTaPbTmGeAtPtTaRnTmPbBiTmGeTbBiGeTbGeFrHfA uOsTmPd"

n=2
list = []
answer = []

[list.append(string[i:i+n]) for i in range(0, len(string), n)]

print set(list)

periodic ={"Pb": 82, "Tl": 81, "Tb": 65, "Ta": 73, "Po": 84, "Ge": 32, "Bi": 83, "Hf": 72, "Tm": 69, "Yb": 70, "At": 85, "Pt": 78, "Ho": 67, "Au": 79, "Er": 68, "Rn": 86, "Ra": 88, "Lu": 71, "Os": 76, "Tl": 81, "Pd": 46, "Rh": 45, "Fr": 87, "Hg": 80, "Ir": 77}

for value in list:
    if value in periodic:
        answer.append(chr(periodic[value]))

lastanswer = ''.join(answer)
print lastanswer
```

## 它是如何工作的…

要启动这个脚本，我们首先在脚本中定义了`key`字符串。然后定义了`n`变量为`2`以供以后使用，并创建了两个空列表—list 和 answer：

```py
string = --snipped--
n=2
list = []
answer = []
```

然后我们开始创建列表，它通过字符串并提取两个字母的集合并将它们附加到列表值，然后打印出来：

```py
[list.append(string[i:i+n]) for i in range(0, len(string), n)]
print set(list)
```

这两个字母分别对应于周期表中的一个值，这与一个数字相关。当这些数字转换为 ascii 相关的字符时。一旦发现了这一点，我们需要将元素映射到它们的周期数，并存储起来：

```py
periodic ={"Pb": 82, "Tl": 81, "Tb": 65, "Ta": 73, "Po": 84, "Ge": 32, "Bi": 83, "Hf": 72, "Tm": 69, "Yb": 70, "At": 85, "Pt": 78, "Ho": 67, "Au": 79, "Er": 68, "Rn": 86, "Ra": 88, "Lu": 71, "Os": 76, "Tl": 81, "Pd": 46, "Rh": 45, "Fr": 87, "Hg": 80, "Ir": 77}
```

然后我们可以创建一个循环，它将遍历我们之前创建并命名为**list**的元素列表，并将它们映射到我们创建的`periodic`数据集中的值。在运行时，我们可以让它将发现附加到我们的答案字符串中，同时将 ascii 数字转换为相关字母：

```py
for value in list:
    if value in periodic:
        answer.append(chr(periodic[value]))
```

最后，我们需要将数据打印出来：

```py
lastanswer = ''.join(answer)
print lastanswer
```

以下是脚本运行的示例：

```py
set(['Pt', 'Pb', 'Tl', 'Lu', 'Ra', 'Pd', 'Rn', 'Rh', 'Po', 'Ta', 'Fr', 'Tb', 'Yb', 'Bi', 'Ho', 'Hf', 'Hg', 'Os', 'Ir', 'Ge', 'Tm', 'Au', 'At', 'Er'])
IT IS THE FUNCTION OF SCIENCE TO DISCOVER THE EXISTENCE OF A GENERAL REIGN OF ORDER IN NATURE AND TO FIND THE CAUSES GOVERNING THIS ORDER. AND THIS REFERS IN EQUAL MEASURE TO THE RELATIONS OF MAN - SOCIAL AND POLITICAL - AND TO THE ENTIRE UNIVERSE AS A WHOLE.

```

# 破解 Atbash 密码

Atbash 密码是一种简单的密码，它使用字母表中的相反值来转换单词。例如，A 等于 Z，C 等于 X。

## 准备工作

对此，我们只需要`string`模块。

## 如何做…

由于 Atbash 密码是通过使用字母表中字符的相反值来工作的，我们可以创建一个`maketrans`功能来替换字符：

```py
import string
input = raw_input("Please enter the value you would like to Atbash Cipher: ")
transform = string.maketrans(
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
"ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba")
final = string.translate(input, transform)
print final
```

## 它是如何工作的…

导入正确的模块后，我们要求用户输入他们想要加密到 Atbash 密码中的值：

```py
import string
input = raw_input("Please enter the value you would like to Atbash Ciper: ")
```

接下来，我们创建要使用的`maketrans`功能。我们通过列出我们想要替换的第一组字符，然后列出另一组用于替换前一组的字符来实现这一点：

```py
transform = string.maketrans(
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
"ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba")
```

最后，我们只需要给转换一个值，应用它，并打印出值以获得最终结果：

```py
final = string.translate(input, transform)
print final
```

以下是脚本的示例：

```py
Please enter the value you would like to Atbash Cipher: testing
gvhgrmt

```

# 攻击一次性密码重用

一次性密码的概念是早期密码学的基本核心。基本上，各方记住一个短语，当发送消息时，对每一步都用该短语进行移位。例如，如果短语是`apple`，消息是`i like them`，那么我们将`a`加到`i`上得到`j`，以此类推，最终得到编码后的消息。

最近，许多恶意软件工程师和糟糕的软件工程师使用 XOR 来执行相同的活动。当漏洞存在且我们可以创建有用的脚本的地方是，同一个密钥已被多次使用。如果多个基于 ASCII 的字符串已经与相同的基于 ASCII 的字符串进行了 XOR 运算，我们可以通过逐个字符地将它们与 ASCII 值进行 XOR 运算来同时破解这些字符串。

以下脚本将逐个字符地对文件中的 XOR 值列表进行暴力破解。

## 准备工作

将 XOR 短语列表放入一个文件中。将该文件放在与您的脚本相同的文件夹中（或者不放；如果放了，它只会让事情稍微变得容易一点）。

## 如何做…

脚本应该看起来像这样：

```py
import sys
import string

f = open("ciphers.txt", "r")

MSGS = f.readlines()

def strxor(a, b):  
    if len(a) > len(b):
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a[:len(b)], b)])
    else:
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b[:len(a)])])

def encrypt(key, msg):
    c = strxor(key, msg)
    return c

for msg in MSGS:
for value in string.ascii_letters:
for value2 in string.ascii_letters:
  for value3 in string.ascii_letters:
key = value+value2+value3
answer = encrypt(msg, key)
print answer[3:]
```

## 它是如何工作的…

这个脚本非常简单。我们打开一个包含 XOR 值的文件，并按行拆分它：

```py
f = open("ciphers.txt", "r")

MSGS = f.readlines()
```

我们无耻地使用了行业标准的`XOR` python。基本上，这个函数将两个字符串等长地等同起来，然后将它们进行`XOR`运算：

```py
def strxor(a, b):  
    if len(a) > len(b):
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a[:len(b)], b)])
    else:
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b[:len(a)])])

def encrypt(key, msg):
    c = strxor(key, msg)
    return c
```

然后，我们运行所有 ASCII 值三次，以获取`ciphers.txt`文件中每行的`aaa`到`zzz`的所有组合。我们每次将 ASCII 循环的值分配给密钥：

```py
for msg in MSGS:
for value in string.ascii_letters:
for value2 in string.ascii_letters:
  for value3 in string.ascii_letters:
key = value+value2+value3
```

然后，我们用生成的密钥加密该行并将其打印出来。我们可以轻松地将其导入文件，就像我们在整本书中已经展示的那样：

```py
answer = encrypt(msg, key)
print answer[3:]
```

# 预测线性同余生成器

LCG 被用于网络应用程序中创建快速和简单的伪随机数。它们天生就是不安全的，只要有足够的数据，就可以很容易地预测。LCG 的算法是：

![预测线性同余生成器](img/B04044_07_01.jpg)

在这里，**X**是当前值，**a**是固定的乘数，**c**是固定的增量，**m**是固定的模数。如果泄漏了任何数据，例如本例中的乘数、模数和增量，就有可能计算出种子，从而计算出下一个值。

## 准备工作

这里的情况是一个应用程序生成随机的两位数并将它们返回给你。你知道乘数、模数和增量。这可能看起来很奇怪，但这在实际测试中确实发生过。

## 如何做…

以下是代码：

```py
C = ""
A = ""
M = ""

print "Starting attempt to brute"

for i in range(1, 99999999):
    a = str((A * int(str(i)+'00') + C) % 2**M)
    if a[-2:] == "47":
        b = str((A * int(a) + C) % 2**M)
        if b[-2:] == "46":
            c = str((A * int(b) + C) % 2**M)
            if c[-2:] == "57":
                d = str((A * int(c) + C) % 2**M)
                if d[-2:] == "56":
                    e = str((A * int(d) + C) % 2**M)
                    if e[-2:] == "07":
                        f = str((A * int(e) + C) % 2**M)
                        if f[-2:] == "38":
                            g = str((A * int(f) + C) % 2**M)
                            if g[-2:] == "81":
                                h = str((A * int(g) + C) % 2**M)
                                if h[-2:] == "32":
                                    j = str((A * int(h) + C) % 2**M)
                                    if j[-2:] == "19":
                                        k = str((A * int(j) + C) % 2**M)
                                        if k[-2:] == "70":
                                            l = str((A * int(k) + C) % 2**M)
                                            if l[-2:] == "53":
                                                print "potential number found: "+l
print "next 9 values are:"
for i in range(1, 10):
    l = str((A * int(l) + C) % 2**M)
    print l[-2:]
```

## 它是如何工作的…

我们设置了三个值，增量、乘数和模数分别为`C`、`A`和`M`：

```py
C = ""
A = ""
M = ""
```

然后，我们声明种子可能的大小范围，本例中为 1 到 8 位数字：

```py
for i in range(1, 99999999):
```

然后，我们执行第一个 LCG 转换，并使用网页上标记的第一个值生成可能的值，如下例所示：

```py
a = str((A * int(str(i)+'00') + C) % 2**M)
```

我们取得网页生成的第二个值，并检查这个转换的结果是否与之相匹配：

```py
    if a[-2:] == "47":
```

如果成功，我们就用与第一个转换匹配的数字执行下一个转换：

```py
        b = str((A * int(a) + C) % 2**M)
```

我们在这里重复这个过程 10 次，但可以根据需要重复多次，直到找到一个与迄今为止所有数字都匹配的输出。我们打印一个带有该数字的警报：

```py
print "potential number found: "+l
```

然后，我们重复这个过程 10 次，以该数字作为种子生成下一个 10 个值，以便我们预测新值。

# 识别哈希

你使用的几乎每个网络应用程序都应该以某种形式以哈希格式存储你的密码，以增加安全性。对于用户密码来说，一个良好的哈希系统可以在数据库被盗时非常有用，因为这将延长黑客破解密码所需的时间。

出于这个原因，我们有许多不同的哈希方法，其中一些在不同的应用程序中被重复使用，比如 MD5 和 SHA 哈希，但一些如 Des(UNIX)则较少见。因此，能够将哈希值与其所属的哈希函数进行匹配是一个好主意。我们不能仅仅基于哈希长度来进行匹配，因为许多哈希函数具有相同的长度，因此为了帮助我们，我们将使用**正则表达式**（**Regex**）。这允许我们定义长度、使用的字符以及是否存在任何数字值。

## 准备工作

对于这个脚本，我们将只使用`re`模块。

## 如何做…

如前所述，我们将围绕正则表达式值构建脚本，并使用这些值将输入哈希映射到存储的哈希值。这将允许我们非常快速地挑选出哈希的潜在匹配项：

```py
import re
def hashcheck (hashtype, regexstr, data):
    try:
        valid_hash = re.finditer(regexstr, data)
        result = [match.group(0) for match in valid_hash]
        if result: 
            return "This hash matches the format of: " + hashtype
    except: pass
string_to_check = raw_input('Please enter the hash you wish to check: ')
hashes = (
("Blowfish(Eggdrop)", r"^\+[a-zA-Z0-9\/\.]{12}$"),
("Blowfish(OpenBSD)", r"^\$2a\$[0-9]{0,2}?\$[a-zA-Z0- 9\/\.]{53}$"),
("Blowfish crypt", r"^\$2[axy]{0,1}\$[a-zA-Z0-9./]{8}\$[a-zA-Z0- 9./]{1,}$"),
("DES(Unix)", r"^.{0,2}[a-zA-Z0-9\/\.]{11}$"),
("MD5(Unix)", r"^\$1\$.{0,8}\$[a-zA-Z0-9\/\.]{22}$"),
("MD5(APR)", r"^\$apr1\$.{0,8}\$[a-zA-Z0-9\/\.]{22}$"),
("MD5(MyBB)", r"^[a-fA-F0-9]{32}:[a-z0-9]{8}$"),
("MD5(ZipMonster)", r"^[a-fA-F0-9]{32}$"),
("MD5 crypt", r"^\$1\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("MD5 apache crypt", r"^\$apr1\$[a-zA-Z0-9./]{8}\$[a-zA-Z0- 9./]{1,}$"),
("MD5(Joomla)", r"^[a-fA-F0-9]{32}:[a-zA-Z0-9]{16,32}$"),
("MD5(Wordpress)", r"^\$P\$[a-zA-Z0-9\/\.]{31}$"),
("MD5(phpBB3)", r"^\$H\$[a-zA-Z0-9\/\.]{31}$"),
("MD5(Cisco PIX)", r"^[a-zA-Z0-9\/\.]{16}$"),
("MD5(osCommerce)", r"^[a-fA-F0-9]{32}:[a-zA-Z0-9]{2}$"),
("MD5(Palshop)", r"^[a-fA-F0-9]{51}$"),
("MD5(IP.Board)", r"^[a-fA-F0-9]{32}:.{5}$"),
("MD5(Chap)", r"^[a-fA-F0-9]{32}:[0-9]{32}:[a-fA-F0-9]{2}$"),
("Juniper Netscreen/SSG (ScreenOS)", r"^[a-zA-Z0-9]{30}:[a-zA-Z0- 9]{4,}$"),
("Fortigate (FortiOS)", r"^[a-fA-F0-9]{47}$"),
("Minecraft(Authme)", r"^\$sha\$[a-zA-Z0-9]{0,16}\$[a-fA-F0- 9]{64}$"),
("Lotus Domino", r"^\(?[a-zA-Z0-9\+\/]{20}\)?$"),
("Lineage II C4", r"⁰x[a-fA-F0-9]{32}$"),
("CRC-96(ZIP)", r"^[a-fA-F0-9]{24}$"),
("NT crypt", r"^\$3\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("Skein-1024", r"^[a-fA-F0-9]{256}$"),
("RIPEMD-320", r"^[A-Fa-f0-9]{80}$"),
("EPi hash", r"⁰x[A-F0-9]{60}$"),
("EPiServer 6.x < v4", r"^\$episerver\$\*0\*[a-zA-Z0-9]{22}==\*[a- zA-Z0-9\+]{27}$"),
("EPiServer 6.x >= v4", r"^\$episerver\$\*1\*[a-zA-Z0- 9]{22}==\*[a-zA-Z0-9]{43}$"),
("Cisco IOS SHA256", r"^[a-zA-Z0-9]{43}$"),
("SHA-1(Django)", r"^sha1\$.{0,32}\$[a-fA-F0-9]{40}$"),
("SHA-1 crypt", r"^\$4\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("SHA-1(Hex)", r"^[a-fA-F0-9]{40}$"),
("SHA-1(LDAP) Base64", r"^\{SHA\}[a-zA-Z0-9+/]{27}=$"),
("SHA-1(LDAP) Base64 + salt", r"^\{SSHA\}[a-zA-Z0- 9+/]{28,}[=]{0,3}$"),
("SHA-512(Drupal)", r"^\$S\$[a-zA-Z0-9\/\.]{52}$"),
("SHA-512 crypt", r"^\$6\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("SHA-256(Django)", r"^sha256\$.{0,32}\$[a-fA-F0-9]{64}$"),
("SHA-256 crypt", r"^\$5\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("SHA-384(Django)", r"^sha384\$.{0,32}\$[a-fA-F0-9]{96}$"),
("SHA-256(Unix)", r"^\$5\$.{0,22}\$[a-zA-Z0-9\/\.]{43,69}$"),
("SHA-512(Unix)", r"^\$6\$.{0,22}\$[a-zA-Z0-9\/\.]{86}$"),
("SHA-384", r"^[a-fA-F0-9]{96}$"),
("SHA-512", r"^[a-fA-F0-9]{128}$"),
("SSHA-1", r"^({SSHA})?[a-zA-Z0-9\+\/]{32,38}?(==)?$"),
("SSHA-1(Base64)", r"^\{SSHA\}[a-zA-Z0-9]{32,38}?(==)?$"),
("SSHA-512(Base64)", r"^\{SSHA512\}[a-zA-Z0-9+]{96}$"),
("Oracle 11g", r"^S:[A-Z0-9]{60}$"),
("SMF >= v1.1", r"^[a-fA-F0-9]{40}:[0-9]{8}&"),
("MySQL 5.x", r"^\*[a-f0-9]{40}$"),
("MySQL 3.x", r"^[a-fA-F0-9]{16}$"),
("OSX v10.7", r"^[a-fA-F0-9]{136}$"),
("OSX v10.8", r"^\$ml\$[a-fA-F0-9$]{199}$"),
("SAM(LM_Hash:NT_Hash)", r"^[a-fA-F0-9]{32}:[a-fA-F0-9]{32}$"),
("MSSQL(2000)", r"⁰x0100[a-f0-9]{0,8}?[a-f0-9]{80}$"),
("MSSQL(2005)", r"⁰x0100[a-f0-9]{0,8}?[a-f0-9]{40}$"),
("MSSQL(2012)", r"⁰x02[a-f0-9]{0,10}?[a-f0-9]{128}$"),
("TIGER-160(HMAC)", r"^[a-f0-9]{40}$"),
("SHA-256", r"^[a-fA-F0-9]{64}$"),
("SHA-1(Oracle)", r"^[a-fA-F0-9]{48}$"),
("SHA-224", r"^[a-fA-F0-9]{56}$"),
("Adler32", r"^[a-f0-9]{8}$"),
("CRC-16-CCITT", r"^[a-fA-F0-9]{4}$"),
("NTLM)", r"^[0-9A-Fa-f]{32}$"),
)
counter = 0
for h in hashes:
    text = hashcheck(h[0], h[1], string_to_check)
    if text is not None:
        counter += 1
        print text
if counter == 0:
    print "Your input hash did not match anything, sorry!"
```

## 工作原理…

在我们导入`re`模块之后，我们将开始构建我们的第一个代码块，这将是我们脚本的核心。我们将尝试在整个脚本中使用常规命名，以使其在以后更易管理。出于这个原因，我们选择了名为`hashcheck`。我们使用名为`hashtype`来表示即将在正则表达式代码块中出现的哈希的名称，我们使用`regexstr`来表示正则表达式，最后使用数据。

我们创建一个名为`valid_hash`的字符串，并为其赋予在通过数据后迭代值的值，这只会在我们有一个有效的匹配时发生。这可以在稍后看到，我们在那里为匹配哈希值的值 result 赋予了匹配哈希值的名称，我们最终打印匹配（如果找到一个或多个）并在结尾添加我们的`except`语句：

```py
def hashcheck (hashtype, regexstr, data):
    try:
        valid_hash = re.finditer(regexstr, data)
        result = [match.group(0) for match in valid_hash]
        if result: 
            return "This hash matches the format of: " + hashtype
    except: pass
```

然后我们要求用户输入，这样我们就有了一些东西可以与正则表达式进行匹配。这是正常进行的：

```py
string_to_check = raw_input('Please enter the hash you wish to check: ')
```

完成这些后，我们可以继续进行复杂的正则表达式操作。我们使用正则表达式的原因是为了区分不同的哈希值，因为它们具有不同的长度和字符集。这对于 MD5 哈希非常有帮助，因为有许多不同类型的 MD5 哈希，比如 phpBB3 和 MyBB 论坛。

我们给一组正则表达式起一个逻辑的名字，比如 hashes，然后定义它们：

```py
hashes = (
("Blowfish(Eggdrop)", r"^\+[a-zA-Z0-9\/\.]{12}$"),
("Blowfish(OpenBSD)", r"^\$2a\$[0-9]{0,2}?\$[a-zA-Z0- 9\/\.]{53}$"),
("Blowfish crypt", r"^\$2[axy]{0,1}\$[a-zA-Z0-9./]{8}\$[a-zA-Z0- 9./]{1,}$"),
("DES(Unix)", r"^.{0,2}[a-zA-Z0-9\/\.]{11}$"),
("MD5(Unix)", r"^\$1\$.{0,8}\$[a-zA-Z0-9\/\.]{22}$"),
("MD5(APR)", r"^\$apr1\$.{0,8}\$[a-zA-Z0-9\/\.]{22}$"),
("MD5(MyBB)", r"^[a-fA-F0-9]{32}:[a-z0-9]{8}$"),
("MD5(ZipMonster)", r"^[a-fA-F0-9]{32}$"),
("MD5 crypt", r"^\$1\$[a-zA-Z0-9./]{8}\$[a-zA-Z0-9./]{1,}$"),
("MD5 apache crypt", r"^\$apr1\$[a-zA-Z0-9./]{8}\$[a-zA-Z0- 9./]{1,}$"),
("MD5(Joomla)", r"^[a-fA-F0-9]{32}:[a-zA-Z0-9]{16,32}$"),
("MD5(Wordpress)", r"^\$P\$[a-zA-Z0-9\/\.]{31}$"),
("MD5(phpBB3)", r"^\$H\$[a-zA-Z0-9\/\.]{31}$"),
("MD5(Cisco PIX)", r"^[a-zA-Z0-9\/\.]{16}$"),
("MD5(osCommerce)", r"^[a-fA-F0-9]{32}:[a-zA-Z0-9]{2}$"),
("MD5(Palshop)", r"^[a-fA-F0-9]{51}$"),
("MD5(IP.Board)", r"^[a-fA-F0-9]{32}:.{5}$"),
("MD5(Chap)", r"^[a-fA-F0-9]{32}:[0-9]{32}:[a-fA-F0-9]{2}$"),
[...cut out...]
("NTLM)", r"^[0-9A-Fa-f]{32}$"),
)
```

然后我们需要找到一种方法以可管理的方式将数据返回给用户，而不让他们每次找到一个非匹配时都知道。我们通过创建一个计数器来实现这一点。我们将这个计数器的值设置为`0`并继续。然后我们创建一个名为`text`的函数，如果找到匹配，它将成为哈希名称的值。然后使用`if`语句来防止我们之前提到的不需要的消息。我们告诉脚本，如果`text 不是 none`，那么就找到了一个匹配，所以我们提高计数器的值并打印文本。使用计数器的想法意味着任何找到的非匹配都不会增加计数器，因此不会被打印给用户：

```py
counter = 0
for h in hashes:
    text = hashcheck(h[0], h[1], string_to_check)
    if text is not None:
        counter += 1
        print text
```

我们通过以最礼貌的方式告知用户没有匹配来完成脚本！

```py
if counter == 0:
    print "Your input hash did not match anything, sorry!"
```

以下是脚本运行的一些示例：

```py
Please enter the hash you wish to check: ok
No Matches

```

前面的结果没有找到匹配，因为没有列出输出两个字符字符串的哈希系统。以下是一个成功找到的示例：

```py
Please enter the hash you wish to check: fd7a4c43ad7c20dbea0dc6dacc12ef6c36c2c382a0111c92f24244690eba65a2
This hash matches the format of: SHA-256

```
