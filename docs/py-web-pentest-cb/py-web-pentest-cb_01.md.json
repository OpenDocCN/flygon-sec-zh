["```py\n$ easy_install shodan\n\n```", "```py\nimport shodan\nimport requests\n\nSHODAN_API_KEY = \"{Insert your Shodan API key}\" \napi = shodan.Shodan(SHODAN_API_KEY)\n\ntarget = 'www.packtpub.com'\n\ndnsResolve = 'https://api.shodan.io/dns/resolve?hostnames=' + target + '&key=' + SHODAN_API_KEY\n\ntry:\n    # First we need to resolve our targets domain to an IP\n    resolved = requests.get(dnsResolve)\n    hostIP = resolved.json()[target]\n\n    # Then we need to do a Shodan search on that IP\n    host = api.host(hostIP)\n    print \"IP: %s\" % host['ip_str']\n    print \"Organization: %s\" % host.get('org', 'n/a')\n    print \"Operating System: %s\" % host.get('os', 'n/a')\n\n    # Print all banners\n    for item in host['data']:\n        print \"Port: %s\" % item['port']\n        print \"Banner: %s\" % item['data']\n\n    # Print vuln information\n    for item in host['vulns']:\n        CVE = item.replace('!','')\n        print 'Vulns: %s' % item\n        exploits = api.exploits.search(CVE)\n        for item in exploits['matches']:\n            if item.get('cve')[0] == CVE:\n                print item.get('description')\nexcept:\n    'An error occured'\n```", "```py\nIP: 83.166.169.231\nOrganization: Node4 Limited\nOperating System: None\n\nPort: 443\nBanner: HTTP/1.0 200 OK\n\nServer: nginx/1.4.5\n\nDate: Thu, 05 Feb 2015 15:29:35 GMT\n\nContent-Type: text/html; charset=utf-8\n\nTransfer-Encoding: chunked\n\nConnection: keep-alive\n\nExpires: Sun, 19 Nov 1978 05:00:00 GMT\n\nCache-Control: public, s-maxage=172800\n\nAge: 1765\n\nVia: 1.1 varnish\n\nX-Country-Code: US\n\nPort: 80\nBanner: HTTP/1.0 301 https://www.packtpub.com/\n\nLocation: https://www.packtpub.com/\n\nAccept-Ranges: bytes\n\nDate: Fri, 09 Jan 2015 12:08:05 GMT\n\nAge: 0\n\nVia: 1.1 varnish\n\nConnection: close\n\nX-Country-Code: US\n\nServer: packt\n\nVulns: !CVE-2014-0160\nThe (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.\n\n```", "```py\n    SHODAN_API_KEY = \"{Insert your Shodan API key}\" \n    target = 'www.packtpub.com'\n\n    dnsResolve = 'https://api.shodan.io/dns/resolve?hostnames=' + target + '&key=' + SHODAN_API_KEY\n    ```", "```py\n    api = shodan.Shodan(SHODAN_API_KEY)\n    ```", "```py\n    resolved = requests.get(dnsResolve)\n    hostIP = resolved.json()[target] \n    ```", "```py\n        host = api.host(hostIP)\n        print \"IP: %s\" % host['ip_str']\n        print \"Organization: %s\" % host.get('org', 'n/a')\n        print \"Operating System: %s\" % host.get('os', 'n/a')\n\n        # Print all banners\n        for item in host['data']:\n            print \"Port: %s\" % item['port']\n            print \"Banner: %s\" % item['data']\n    ```", "```py\n    for item in host['vulns']:\n            CVE = item.replace('!','')\n            print 'Vulns: %s' % item\n            exploits = api.exploits.search(CVE)\n            for item in exploits['matches']:\n                if item.get('cve')[0] == CVE:\n                    print item.get('description')\n    ```", "```py\nimport urllib2\n\nGOOGLE_API_KEY = \"{Insert your Google API key}\" \ntarget = \"packtpub.com\"\napi_response = urllib2.urlopen(\"https://www.googleapis.com/plus/v1/people? query=\"+target+\"&key=\"+GOOGLE_API_KEY).read()\napi_response = api_response.split(\"\\n\")\nfor line in api_response:\n    if \"displayName\" in line:\n        print line\n```", "```py\nGOOGLE_API_KEY = \"{Insert your Google API key}\" \ntarget = \"packtpub.com\"\n```", "```py\napi_response = urllib2.urlopen(\"https://www.googleapis.com/plus/v1/people? query=\"+target+\"&key=\"+GOOGLE_API_KEY).read()\n```", "```py\napi_response = api_response.split(\"\\n\")\n```", "```py\nimport urllib2\nimport json\n\nGOOGLE_API_KEY = \"{Insert your Google API key}\"\ntarget = \"packtpub.com\"\napi_response = urllib2.urlopen(\"https://www.googleapis.com/plus/v1/people? query=\"+target+\"&key=\"+GOOGLE_API_KEY).read()\n\njson_response = json.loads(api_response)\nfor result in json_response['items']:\n      name = result['displayName']\n      print name\n      image = result['image']['url'].split('?')[0]\n  f = open(name+'.jpg','wb+')\n  f.write(urllib2.urlopen(image).read())\n  f.close()\n```", "```py\n      name = result['displayName']\n      print name\n```", "```py\nimage = result['image']['url'].split('?')[0]\n```", "```py\n  f = open(name+'.jpg','wb+')\n  f.write(urllib2.urlopen(image).read())\n  f.close()\n```", "```py\nimport urllib2\nimport json\n\nGOOGLE_API_KEY = \"{Insert your Google API key}\"\ntarget = \"packtpub.com\"\ntoken = \"\"\nloops = 0\n\nwhile loops < 10:\n  api_response = urllib2.urlopen(\"https://www.googleapis.com/plus/v1/people? query=\"+target+\"&key=\"+GOOGLE_API_KEY+\"&maxResults=50& pageToken=\"+token).read()\n\n  json_response = json.loads(api_response)\n  token = json_response['nextPageToken']\n\n  if len(json_response['items']) == 0:\n    break\n\n  for result in json_response['items']:\n        name = result['displayName']\n        print name\n        image = result['image']['url'].split('?')[0]\n    f = open(name+'.jpg','wb+')\n    f.write(urllib2.urlopen(image).read())\n  loops+=1\n```", "```py\ntoken = \"\"\nloops = 0\n\nwhile loops < 10:\n```", "```py\n  api_response = urllib2.urlopen(\"https://www.googleapis.com/plus/v1/people? query=\"+target+\"&key=\"+GOOGLE_API_KEY+\"&maxResults=50& pageToken=\"+token).read()\n```", "```py\n  json_response = json.loads(api_response)\n  token = json_response['nextPageToken']\n```", "```py\n  if len(json_response['items']) == 0:\n    break\n```", "```py\n  loops+=1\n```", "```py\nimport sys\nimport time\nfrom PyQt4.QtCore import *\nfrom PyQt4.QtGui import *\nfrom PyQt4.QtWebKit import *\n\nclass Screenshot(QWebView):\n    def __init__(self):\n        self.app = QApplication(sys.argv)\n        QWebView.__init__(self)\n        self._loaded = False\n        self.loadFinished.connect(self._loadFinished)\n\n    def wait_load(self, delay=0):\n        while not self._loaded:\n            self.app.processEvents()\n            time.sleep(delay)\n        self._loaded = False\n\n    def _loadFinished(self, result):\n        self._loaded = True\n\n    def get_image(self, url):\n        self.load(QUrl(url))\n        self.wait_load()\n\n        frame = self.page().mainFrame()\n        self.page().setViewportSize(frame.contentsSize())\n\n        image = QImage(self.page().viewportSize(), QImage.Format_ARGB32)\n        painter = QPainter(image)\n        frame.render(painter)\n        painter.end()\n        return image\n```", "```py\nimport sys\nimport time\nfrom PyQt4.QtCore import *\nfrom PyQt4.QtGui import *\nfrom PyQt4.QtWebKit import *\n```", "```py\nclass Screenshot(QWebView):\n```", "```py\ndef __init__(self):\n        self.app = QApplication(sys.argv)\n        QWebView.__init__(self)\n        self._loaded = False\n        self.loadFinished.connect(self._loadFinished)\n\ndef wait_load(self, delay=0):\n        while not self._loaded:\n            self.app.processEvents()\n            time.sleep(delay)\n        self._loaded = False\n\ndef _loadFinished(self, result):\n        self._loaded = True\n```", "```py\ndef get_image(self, url):\n        self.load(QUrl(url))\n        self.wait_load()\n\n        frame = self.page().mainFrame()\n        self.page().setViewportSize(frame.contentsSize())\n\n        image = QImage(self.page().viewportSize(), QImage.Format_ARGB32)\n        painter = QPainter(image)\n        frame.render(painter)\n        painter.end()\n        return image\n```", "```py\nimport screenshot\ns = screenshot.Screenshot()\nimage = s.get_image('http://www.packtpub.com')\nimage.save('website.png')\n```", "```py\nimport screenshot\nimport requests\n\nportList = [80,443,2082,2083,2086,2087,2095,2096,8080,8880,8443,9998,4643, 9001,4489]\n\nIP = '127.0.0.1'\n\nhttp = 'http://'\nhttps = 'https://'\n\ndef testAndSave(protocol, portNumber):\n    url = protocol + IP + ':' + str(portNumber)\n    try:\n        r = requests.get(url,timeout=1)\n\n        if r.status_code == 200:\n            print 'Found site on ' + url \n            s = screenshot.Screenshot()\n            image = s.get_image(url)\n            image.save(str(portNumber) + '.png')\n    except:\n        pass\n\nfor port in portList:\n    testAndSave(http, port)\n    testAndSave(https, port)\n```", "```py\nimport screenshot\nimport requests\n```", "```py\nportList = [80,443,2082,2083,2086,2087,2095,2096,8080,8880,8443,9998,4643, 9001,4489]\n\nIP = '127.0.0.1'\n```", "```py\nhttp = 'http://'\nhttps = 'https://'\n```", "```py\ndef testAndSave(protocol, portNumber):\n    url = protocol + IP + ':' + str(portNumber)\n    try:\n        r = requests.get(url,timeout=1)\n\n        if r.status_code == 200:\n            print 'Found site on ' + url \n            s = screenshot.Screenshot()\n            image = s.get_image(url)\n            image.save(str(portNumber) + '.png')\n    except:\n        pass\n```", "```py\nfor port in portList:\n    testAndSave(http, port)\n    testAndSave(https, port)\n```", "```py\nimport Queue\nimport threading\n```", "```py\ndef threader(q, port):\n    q.put(testAndSave(http, port))\n    q.put(testAndSave(https, port))\n```", "```py\nq = Queue.Queue()\n\nfor port in portList:\n    t = threading.Thread(target=threader, args=(q, port))\n    t.deamon = True\n    t.start()\n\ns = q.get()\n```", "```py\nimport Queue\nimport threading\nimport screenshot\nimport requests\n\nportList = [80,443,2082,2083,2086,2087,2095,2096,8080,8880,8443,9998,4643, 9001,4489]\n\nIP = '127.0.0.1'\n\nhttp = 'http://'\nhttps = 'https://'\n\ndef testAndSave(protocol, portNumber):\n    url = protocol + IP + ':' + str(portNumber)\n    try:\n        r = requests.get(url,timeout=1)\n\n        if r.status_code == 200:\n            print 'Found site on ' + url \n            s = screenshot.Screenshot()\n            image = s.get_image(url)\n            image.save(str(portNumber) + '.png')\n    except:\n        pass\n\ndef threader(q, port):\n    q.put(testAndSave(http, port))\n    q.put(testAndSave(https, port))\n\nq = Queue.Queue()\n\nfor port in portList:\n    t = threading.Thread(target=threader, args=(q, port))\n    t.deamon = True\n    t.start()\n\ns = q.get()\n```", "```py\nimport urllib2 \nfrom bs4 import BeautifulSoup\nimport sys\nurls = []\nurls2 = []\n\ntarurl = sys.argv[1] \n\nurl = urllib2.urlopen(tarurl).read()\nsoup = BeautifulSoup(url)\nfor line in soup.find_all('a'):\n    newline = line.get('href')\n    try: \n        if newline[:4] == \"http\": \n            if tarurl in newline: \n            urls.append(str(newline)) \n        elif newline[:1] == \"/\": \n            combline = tarurl+newline urls.append(str(combline)) except: \n               pass\n\n    for uurl in urls: \n        url = urllib2.urlopen(uurl).read() \n        soup = BeautifulSoup(url) \n        for line in soup.find_all('a'): \n            newline = line.get('href') \n            try: \n                if newline[:4] == \"http\": \n                    if tarurl in newline:\n                        urls2.append(str(newline)) \n                elif newline[:1] == \"/\": \n                    combline = tarurl+newline \n                    urls2.append(str(combline)) \n                    except: \n                pass \n            urls3 = set(urls2) \n    for value in urls3: \n    print value\n```", "```py\n$ python spider.py http://www.packtpub.com\n\n```", "```py\nurl = urllib2.urlopen(tarurl).read() \nsoup = BeautifulSoup(url) \n```", "```py\nfor line in soup.find_all('a'): \nnewline = line.get('href') \n```", "```py\nif newline[:4] == \"http\": \nif tarurl in newline: \nurls.append(str(newline)) \n  elif newline[:1] == \"/\": \ncombline = tarurl+newline urls.append(str(combline))\n```", "```py\nfor uurl in urls:\n```"]