- en: Concept Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念处理
- en: 'This chapter will allow us to get familiar with various object-oriented concepts
    in Python. We will see that Python can not only be used as a scripting language,
    but that it also supports a wide range of object-oriented principles and can therefore
    be used to design reusable and scalable software components. As well as this,
    we will explore regular expressions, files, and other I/O-based access including
    JSON, CSV, and XML. Finally, we will discuss exception handling. We will be covering
    the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将使我们熟悉Python中的各种面向对象的概念。我们将看到Python不仅可以用作脚本语言，而且还支持各种面向对象的原则，并且因此可以用来设计可重用和可扩展的软件组件。此外，我们还将探讨正则表达式、文件和其他基于I/O的访问，包括JSON、CSV和XML。最后，我们将讨论异常处理。在本章中，我们将涵盖以下主题：
- en: Object-oriented programming in Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的面向对象编程
- en: Files, directories, and other types of I/O-based access
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件、目录和其他基于I/O的访问类型
- en: Regular expressions in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的正则表达式
- en: Data manipulation and parsing with XML, JSON, and CSV data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML、JSON和CSV数据进行数据操作和解析
- en: Exception handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Object-oriented programming in Python
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的面向对象编程
- en: 'The object-oriented features of any programming language teach us how to deal
    with classes and objects. The same is the case for Python. The general object-oriented
    features that we shall be covering are the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的面向对象特性都教会我们如何处理类和对象。对于Python也是如此。我们将要涵盖的一般面向对象特性包括：
- en: Classes and objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: 'Class relationships: inheritance, composition, association, and aggregation'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类关系：继承、组合、关联和聚合
- en: Abstract classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类
- en: Polymorphism
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Static, instance, and class methods and variables
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态、实例和类方法和变量
- en: Classes and objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: A **class** can be thought of as a template or a blueprint that contains the
    definition of the method and the variables that are to be used with objects of
    that class. An **object** is nothing but an instance of the class, which contains
    actual values rather than variables. A class can also be defined as a collection
    of objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**可以被认为是一个包含了方法和变量定义的模板或蓝图，用于与该类的对象一起使用。**对象**只是类的一个实例，其中包含实际值而不是变量。一个类也可以被定义为对象的集合。'
- en: 'To put this in simple terms, a class is a collection of variables and methods.
    The methods actually define the behavior or the operations that the class performs
    and the variables are the entities upon which the operations are performed. In
    Python, a class is declared with the class keyword, followed by the class name.
    The following example shows how to declare a basic employee class, along with
    some methods and operations. Let''s create a Python script called `Classes.py`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，一个类是变量和方法的集合。方法实际上定义了类执行的行为或操作，而变量是操作所针对的实体。在Python中，使用class关键字声明类，后跟类名。以下示例显示了如何声明一个基本的员工类，以及一些方法和操作。让我们创建一个名为`Classes.py`的Python脚本：
- en: '![](img/88a7d85c-8830-450b-8ebc-e800e20456cd.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88a7d85c-8830-450b-8ebc-e800e20456cd.png)'
- en: 'The following bullet points explain the preceding code and its structure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目符号解释了前面的代码及其结构：
- en: '**`class Id_Generator()`**: In order to declare a class in Python, we need
    to associate it with the class keyword, which is what we did in line 2 of the
    code. Whatever proceeds at an equal indentation forms part of the `Id_Generator`
    class. The purpose of this class is to generate an employee ID for every new employee
    created. It does this with the `generate()` method.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class Id_Generator()`：为了在Python中声明一个类，我们需要将其与class关键字关联起来，这就是我们在代码的第2行所做的。在等同缩进的情况下，`Id_Generator`类的内容是类的一部分。这个类的目的是为每个新创建的员工生成一个员工ID。它使用`generate()`方法来实现这一点。'
- en: '**`def __init__(self)`**: Every class in Python or any other programming language
    has got a constructor. This is either explicitly declared or it is not declared
    and the default constructor is taken implicitly. If you come from a background
    of using Java or C++, you might be used to the name of the constructor being the
    same as the class name, but this is not always the case. In Python, the class
    constructor method is defined using the `__init__` word, and it always takes `self`
    as an argument.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Python或任何其他编程语言中的类都有一个构造函数。这要么是显式声明的，要么没有声明，隐式地采用默认构造函数。如果你来自使用Java或C++的背景，你可能习惯于构造函数的名称与类名相同，但这并不总是这样。在Python中，类构造方法是使用`__init__`单词定义的，并且它总是以`self`作为参数。
- en: '**`self`**: The `self` is similar to a keyword. The `self` in Python represents
    the current instance of the class, and in Python every class method which is an
    instance method must have self as its first argument. This also applies to the
    constructor. It should be noted that while invoking the instance method, we don''t
    need to explicitly pass the instance of a class as an argument; Python implicitly
    takes care of this for us. Any instance-level variable has to be declared with
    the `self` keyword. This can be seen in the constructor—we have declared an instance
    variable ID as `self.id` and initialized it to `0`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self`：`self`类似于关键字。在Python中，`self`表示类的当前实例，并且在Python中，每个类方法都必须将`self`作为其第一个参数。这也适用于构造函数。值得注意的是，在调用实例方法时，我们不需要显式地将类的实例作为参数传递；Python会隐式地为我们处理这个问题。任何实例级变量都必须使用`self`关键字声明。这可以在构造函数中看到——我们已经声明了一个实例变量ID为`self.id`并将其初始化为`0`。'
- en: '**`def generate(self)`**: The `generate` is an instance method that increments
    the ID and returns the incremented ID.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def generate(self)`：`generate`是一个实例方法，它递增ID并返回递增的ID。'
- en: '**`class Employee()`**: The `employee` class is a class that is used to create
    employees with its constructor. It prints the details of the employees with the
    `printDetails` method.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class Employee()`：`employee`类是一个用于创建员工的类，它具有构造函数。它使用`printDetails`方法打印员工的详细信息。'
- en: '**`def __init__(self,Name,id_gen)`**: There can be two kinds of constructor
    – parameterized and unparameterized. Any constructor that takes parameters is
    a parameterized constructor. Here, the constructor of the `employee` class is
    parameterized, because it takes two parameters: the name of the employee to be
    created and the instance of the `Id_Generator` class. In this method, we just
    call the generate method of the `Id_Generator` class, which returns us the employee
    ID. The constructor also initializes the employee name that was passed to the `self` class
    instance variable, which is `name`. It also initializes the other variables, `D_id`
    and `Salary`, to `None`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`def __init__(self,Name,id_gen)`**：构造函数有两种类型——带参数和不带参数。任何带参数的构造函数都是带参数的构造函数。在这里，`employee`类的构造函数是带参数的，因为它接受两个参数：要创建的员工的姓名和`Id_Generator`类的实例。在这个方法中，我们只是调用了`Id_Generator`类的`generate`方法，它会返回员工ID。构造函数还将传递给`self`类实例变量的员工姓名`name`进行初始化。它还将其他变量`D_id`和`Salary`初始化为`None`。'
- en: '**`def printDetails(self)`**: This is the method that will print the details
    of the employee.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`def printDetails(self)`**：这是一个打印员工详细信息的方法。'
- en: 'Lines 24–32: In this section of the code, we first create the instance of the
    `Id_Generator` class and name it `Id_gen`. Then, we create an instance of the
    `Employee` class. Remember that the constructor of the class is invoked at the
    moment in which we create the instance of the class. Since in this case the constructor
    is parameterized, we have to create an instance that takes two parameters, with
    the first being the employee name and the second being the instance of the `Id_Generator`
    class. This is what we did in line 25: `emp1=Employee(''Emp1'',Id_gen)`. As mentioned
    earlier, we don''t need to pass `self` explicitly; Python takes care of this implicitly.
    After that, we assign some values to the `Salary` and `D_id` instance variables
    of the employee class for the `Emp1` instance. We also create another employee
    called `Emp2`, as shown in line 28\. Finally, we print the details of both the
    employees by invoking `emp1.printDetails()` and `emp2.printDetails()`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 24-32行：在代码的这一部分，我们首先创建了`Id_Generator`类的实例并命名为`Id_gen`。然后，我们创建了`Employee`类的一个实例。请记住，类的构造函数在我们创建类的实例时被调用。由于在这种情况下构造函数是带参数的，我们必须创建一个带两个参数的实例，第一个参数是员工姓名，第二个参数是`Id_Generator`类的实例。这就是我们在第25行所做的：`emp1=Employee('Emp1',Id_gen)`。正如前面提到的，我们不需要显式传递`self`；Python会隐式处理这个问题。之后，我们为`Emp1`实例的`Salary`和`D_id`实例变量赋一些值。我们还创建了另一个名为`Emp2`的员工，如第28行所示。最后，我们通过调用`emp1.printDetails()`和`emp2.printDetails()`来打印两个员工的详细信息。
- en: Class relationships
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类关系
- en: 'One of the strongest advantages of object-oriented programming languages is
    code reuse. This reusability is powered by the relationship that exists between
    the classes. Object-oriented programming generally supports four types of relationships:
    inheritance, association, composition, and aggregation. All these relationships
    are based on **is-a**, **has-a**, and **part-of** relationships.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程语言最大的优势之一是代码重用。这种可重用性是由类之间存在的关系所支持的。面向对象编程通常支持四种关系：继承、关联、组合和聚合。所有这些关系都基于**is-a**、**has-a**和**part-of**关系。
- en: Inheritance
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: '**Class inheritance** is a feature that we can use to extend the functionality
    of a class, by reusing the capability of another class. Inheritance strongly promotes
    code reuse. To take a simple example of inheritance, let''s say we have a `Car`
    class. The general attributes of the vehicle class would be `category` (such as
    SUV, sports, sedan, or hatchback), `mileage`, `capacity`, and `brand`. Let''s
    now say that we have another class called `Ferrari`, which, in addition to the
    normal car characteristics, has additional characteristics specific to a sports
    car, such as `Horsepower`, `Topspeed`, `Acceleration`, and `PowerOutput`. In this
    situation, we have use an inheritance relationship between the two classes. This
    type of relationship is an **is-a** relationship between the child and the base
    class. We know that a Ferrari is a car. In this case, the car is the base class,
    and the Ferrari is the child class that inherits common car attributes from the
    parent class and has extended characteristics of its own. Let''s expand the example
    we discussed previously, where we created an `Employee` class. We will now create
    another class called `Programmer` and see how can we establish an inheritance
    relation between the two:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承是一个功能，我们可以使用它来扩展类的功能，通过重用另一个类的能力。继承强烈促进了代码的重用。举个简单的继承例子，假设我们有一个`Car`类。车辆类的一般属性包括`category`（如SUV、运动型、轿车或掀背车）、`mileage`、`capacity`和`brand`。现在假设我们有另一个名为`Ferrari`的类，除了普通汽车的特征外，还具有特定于跑车的额外特征，如`Horsepower`、`Topspeed`、`Acceleration`和`PowerOutput`。在这种情况下，我们在两个类之间建立了继承关系。这种关系是子类和基类之间的**is-a**关系。我们知道Ferrari是一辆车。在这种情况下，汽车是基类，Ferrari是子类，它从父类继承了通用汽车属性，并具有自己的扩展特征。让我们扩展我们之前讨论的例子，我们创建了一个`Employee`类。现在我们将创建另一个名为`Programmer`的类，并看看如何在两者之间建立继承关系：
- en: '![](img/ba8e64e6-daad-48cb-9f20-f5361846cbc3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba8e64e6-daad-48cb-9f20-f5361846cbc3.png)'
- en: 'The following bullet points explain the preceding code and its structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点解释了前面的代码及其结构：
- en: '`Class Programmer(Employee)`: In the preceding case, we have created another
    class called `Programmer` that inherits from the `Employee` base class. There
    is an **is a** relationship between `Programmer` and `Employee`. As well as all
    the variables and methods of the `Employee` class, the `Programmer` class defines
    a few of its own, such as languages, databases, projects, and additional skills.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class Programmer(Employee)`：在前面的情况下，我们创建了另一个名为`Programmer`的类，它继承自`Employee`基类。`Programmer`和`Employee`之间存在**is
    a**关系。除了`Employee`类的所有变量和方法外，`Programmer`类还定义了一些自己的变量和方法，如语言、数据库、项目和其他技能。'
- en: '**`def __init__(self,name,id_gen,lang,db,projects,**add_skills)`**: The `init`
    method of the `Programmer` class takes a few arguments that are self explanatory.
    Notice the invocation to the (`Employee` class) `super().__init__()` super class
    constructor, which is at line 32\. In other high-level languages such as Java
    and C++, we know that the base class or the super class constructor is automatically
    called from the child class constructor and that this is the first statement to
    be executed implicitly from the child class constructor when this is not specified.
    This is not the case with Python. The base class constructor would not be called
    implicitly from the child class constructor and we have to explicitly invoke it
    using the super keyword, as can be seen in line 32.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`def __init__(self,name,id_gen,lang,db,projects,**add_skills)`**：`Programmer`类的`init`方法接受一些自解释的参数。请注意(`Employee`类)
    `super().__init__()` 超类构造函数的调用，位于第32行。在其他高级语言如Java和C++中，我们知道基类或超类构造函数会自动从子类构造函数中调用，当没有指定时，这是隐式从子类构造函数中执行的第一个语句。但在Python中并非如此。基类构造函数不会从子类构造函数中隐式调用，我们必须使用super关键字显式调用它，就像在第32行中看到的那样。'
- en: '**`def printSkillDetails(self)`**: This is the method that helps us explore
    the power of inheritance. We are using the base class variables in this method
    (`iD`, `name`, and `salary`), along with some variables specific to the `Programmer`
    class. This shows how inheritance can be used for reusing code and deriving an
    **is a** relation.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`def printSkillDetails(self)`**：这是帮助我们探索继承力量的方法。我们在这个方法中使用了基类的变量（`iD`，`name`和`salary`），以及一些特定于`Programmer`类的变量。这显示了如何使用继承来重用代码并得到一个**是一个**关系。'
- en: 'Lines 52–62: Finally, we create an instance of the `Programmer` class and invoke
    the `printSkillDetails` method.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第52-62行：最后，我们创建了`Programmer`类的一个实例并调用了`printSkillDetails`方法。
- en: Access modifiers in Python
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的访问修饰符
- en: 'In Python, we don''t have access modifiers in the same way as we do in Java
    and C++. There is a partial workaround however, which  can be used to indicate
    which variables are `public`, `protected`, and `private`. The word **indicate** is
    important here; Python doesn''t prevent the usage of protected or private members,
    it just indicates which members are which. Let''s take a look at an example. Create 
    a class called `AccessSpecifiers.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们没有像Java和C++中那样的访问修饰符。然而，有一种部分解决方法可以用来指示哪些变量是`公共的`，`受保护的`和`私有的`。这里的**指示**一词很重要；Python并不阻止使用受保护或私有成员，它只是指示成员是哪个。让我们看一个例子。创建一个名为`AccessSpecifiers.py`的类：
- en: '![](img/e9df90c1-868b-4c3a-8195-4fc53ec92820.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9df90c1-868b-4c3a-8195-4fc53ec92820.png)'
- en: 'The preceding example shows us how access specifiers can be used in Python.
    Any variable that would be simply declared within a class is public by default,
    as we declared `self.public`. Protected variables in Python are declared by prefixing
    them with an underscore (`_`)  as seen in line 5, `self._protected`. But it must
    be noted that this does not prevent anyone from using them, as can be seen at
    line 23, in which we are using a protected member outside of the class. Private
    members in Python are declared by prefixing them with double underscore (`__`),
    as can be seen at line 6, `self.__private`. Again, however, there is nothing to
    prevent this member from being used outside the class. The way to access them
    is a little different, however; for private members, a specific convention is
    followed if they are to be accessed outside the class: `instance._<className><memberName>`.
    This is called **name mangling.**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子向我们展示了如何在Python中使用访问限定符。在类中简单声明的任何变量默认为公共，就像我们声明的`self.public`一样。Python中的受保护变量是通过在它们前面加下划线(`_`)来声明的，就像第5行中看到的`self._protected`一样。但必须注意的是，这并不能阻止任何人使用它们，就像在第23行中看到的那样，我们在类外部使用了受保护成员。Python中的私有成员是通过在它们前面加双下划线(`__`)来声明的，就像第6行中看到的`self.__private`一样。然而，同样地，没有任何东西可以阻止这个成员在类外部被使用。然而，访问它们的方式有点不同；对于私有成员，如果它们要在类外部被访问，会遵循一个特定的约定：`instance._<className><memberName>`。这被称为**名称修饰**。
- en: What we have learnt here about access modifiers in Python is that Python does
    have notations to denote public, private, and protected members of a class, but
    it doesn't have any way for the members to be used outside their scope, so it's
    merely for identification purposes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里学到的关于Python中访问修饰符的知识是，Python确实有符号来表示类的公共、私有和受保护成员，但它没有任何方式让成员在其范围之外被使用，因此这仅仅是用于标识目的。
- en: Composition
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: '**Composition** in OOP represents the **part of** relationship between classes.
    In this relationship, one class is a part of another class. Let''s consider the
    following example, `Composition.py`, to understand the composition relationship
    between classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的**组合**表示类之间的**部分**关系。在这种关系中，一个类是另一个类的一部分。让我们考虑以下示例`Composition.py`，以了解类之间的组合关系：
- en: '![](img/de3e8ad9-955c-4e15-ab91-a7a3579209c9.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de3e8ad9-955c-4e15-ab91-a7a3579209c9.png)'
- en: In the preceding example, the relation between the Ferrari car and the engine
    is of composition type. This is because the engine is **part of** the car, which
    is of the Ferrari type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，法拉利汽车和发动机之间的关系是组合类型。这是因为发动机是汽车的一部分，而汽车是法拉利类型的。
- en: Association
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: 'The association relationship maintains a **has a** kind of relationship between
    the objects of the classes. The **has a** relation can either be one-to-one or
    one-to-many. In the following example, we can see that there is a one-to-one association
    relationship between the `Employee` and `Manager` classes, as an `Employee` would
    only have one `Manager` class. We also have a one-to-one association relation
    between `Employee` and `Department`. The reverse of these relationships would
    be one-to-many relationships as one `Department` class might have many employees
    and one manager might have many employees reporting to them. The following code
    snippet depicts the association relationship:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关联关系维护了类的对象之间的**拥有**关系。**拥有**关系可以是一对一，也可以是一对多。在下面的例子中，我们可以看到`Employee`和`Manager`类之间存在一对一的关联关系，因为一个`Employee`只会有一个`Manager`类。我们还有一个`Employee`和`Department`之间的一对一关联关系。这些关系的反向将是一对多的关系，因为一个`Department`类可能有很多员工，一个经理可能有很多员工报告给他们。以下代码片段描述了关联关系：
- en: '![](img/beea7cf0-1d8d-4bbe-9cda-18414b49672a.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beea7cf0-1d8d-4bbe-9cda-18414b49672a.png)'
- en: Aggregation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: 'The aggregation relationship is a special kind of **has a** relationship that
    is always one way. It''s also known as a one-way association relationship. For
    example, the relationship between `Employee` and `Address` is a one-way association,
    because an employee will always have an address, but the reverse of this won''t
    always be the case. The following example depicts the aggregation relationship
    between `Employee` and `Address`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合关系是一种特殊的**拥有**关系，它总是单向的。它也被称为单向关联关系。例如，`Employee`和`Address`之间的关系是单向关联，因为员工总是有地址，但反过来并不总是成立。以下示例描述了`Employee`和`Address`之间的聚合关系：
- en: '![](img/994d4a59-bbb2-46e8-9235-d904530cc5c0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/994d4a59-bbb2-46e8-9235-d904530cc5c0.png)'
- en: Abstract classes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: There are many occasions in which we may want to have partial implementation
    of a class such that the class defines its objective with a template and it also
    defines how it must obtain a portion of its objective with the help of a few implemented
    methods. The remaining portion of the class objective can be left out to be implemented
    by the subclass, which is mandatory. To implement use cases such as this, we make
    use of abstract classes. An abstract base class, popularly known as an `abc` class,
    is a class that contains abstract methods. An abstract method is a method that
    does not have an implementation. It simply contains the deceleration and is meant
    to be implemented in the class that would implement or inherit from the abstract
    class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，我们可能希望部分实现一个类，使得该类通过模板定义其目标，并且还定义了它必须如何通过一些已实现的方法获取其目标的一部分。类目标的剩余部分可以留给子类来实现，这是强制性的。为了实现这样的用例，我们使用抽象类。抽象基类，通常称为`abc`类，是一个包含抽象方法的类。抽象方法是一种没有实现的方法。它只包含声明，并且应该在实现或继承抽象类的类中实现。
- en: 'A few important pointers about abstract classes include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于抽象类的一些重要要点包括以下内容：
- en: An abstract method in Python is declared with the `@abstractmethod` decorator.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，抽象方法是使用`@abstractmethod`装饰器声明的。
- en: While an abstract class can contain abstract methods, nothing prevents an abstract
    class from having normal or non-abstract methods as well.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然抽象类可以包含抽象方法，但没有任何阻止抽象类同时拥有普通或非抽象方法的限制。
- en: An abstract class cannot be instantiated.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化。
- en: The subclass of the abstract class must implement all the abstract methods of
    the base class. Failing this, it can't be instantiated.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类的子类必须实现基类的所有抽象方法。如果没有这样做，它就无法被实例化。
- en: If the subclass of an abstract class doesn't implement the abstract methods,
    it automatically becomes an abstract class, which can be then further extended
    by another class.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果抽象类的子类没有实现抽象方法，它将自动成为一个抽象类，然后可以由另一个类进一步扩展。
- en: Abstract classes in Python are implemented using the `abc` module.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的抽象类是使用`abc`模块实现的。
- en: 'Let''s create a class called `Abstract.py` and take a look at how abstract
    classes can be used in Python:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Abstract.py`的类，并看看如何在Python中使用抽象类：
- en: '![](img/5e68c2ad-439d-46e2-91d2-94023f36707a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e68c2ad-439d-46e2-91d2-94023f36707a.png)'
- en: In the preceding example, we created an abstract class called `QueueAbs` that
    inherits from the `Abstract` base class, called `ABC`. The class has got two abstract
    methods, `enqueue` and `dequeue`, and also one concrete method called `printItems()`.
    Then, we created a class called `Queue` that is a subclass of the `QueueAbs` abstract
    base class and that implements the `enqueue` and `dequeue` methods. Finally, we
    make the instance of the `Queue` class and invoke the methods, as shown previously.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个名为`QueueAbs`的抽象类，它继承自名为`ABC`的抽象基类。该类有两个抽象方法，`enqueue`和`dequeue`，还有一个名为`printItems()`的具体方法。然后，我们创建了一个名为`Queue`的类，它是`QueueAbs`抽象基类的子类，并实现了`enqueue`和`dequeue`方法。最后，我们创建了`Queue`类的实例并调用了方法，如前所示。
- en: One thing worth remembering here is that in Java and C#, an abstract class can't
    implement the abstract method. This is not the case with Python. In Python, an
    abstract method may or may not have a default implementation, but this does not
    prevent the subclass from overriding it. Irrespective of whether the abstract
    class method has an implementation or not, it is mandatory for the subclass to
    override it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的一件事是，在Java和C#中，抽象类不能实现抽象方法。但在Python中不是这样。在Python中，抽象方法可能有默认实现，也可能没有，但这并不妨碍子类对其进行重写。无论抽象类方法是否有实现，子类都必须对其进行重写。
- en: Polymorphism
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: '**Polymorphism** refers to the property of an entity whereby it can exist in
    multiple forms. In terms of programming, it refers to the creation of a structure
    or method that can then be used with multiple objects or entities. In Python,
    polymorphism can be implemented in the following ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是指一个实体可以存在多种形式的属性。在编程方面，它指的是创建一个可以与多个对象或实体一起使用的结构或方法。在Python中，多态性可以通过以下方式实现：
- en: Polymorphism with functions
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数多态性
- en: Polymorphism with classes (abstract classes)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类多态性（抽象类）
- en: Polymorphism with functions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数多态性
- en: 'Let''s think about two classes, `Ferrari` and `McLaren`. Let''s assume that
    both have a `Speed()` method that returns the top speed of the cars. Let''s think
    about how can we use function polymorphism in this scenario. Let''s create a file
    called `Poly_functions.py`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个类，`Ferrari`和`McLaren`。假设两者都有一个返回汽车最高速度的`Speed()`方法。让我们思考在这种情况下如何使用函数多态性。让我们创建一个名为`Poly_functions.py`的文件：
- en: '![](img/d69fa450-747f-44ce-9130-f010f91b2cea.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d69fa450-747f-44ce-9130-f010f91b2cea.png)'
- en: We can see that we have two classes, `Ferrari` and `McLaren`. Both have a common
    speed method that prints the speed of the two cars. One approach would be to create
    instances of both the classes and invoke the print speed method with each instance.
    Another approach could be to create a common method that takes the instance of
    the classes and that invokes the speed method on the instances it receives. This
    is the polymorphic `printSpeed(carType)` function that we defined at line 10.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有两个类，`Ferrari`和`McLaren`。两者都有一个打印两辆车速度的共同速度方法。一种方法是创建两个类的实例，并使用每个实例调用打印速度方法。另一种方法是创建一个接受类实例并在接收到的实例上调用速度方法的公共方法。这就是我们在第10行定义的多态`printSpeed(carType)`函数。
- en: Polymorphism with classes (abstract classes)
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类多态性（抽象类）
- en: 'There may be occasions in which we would want to define a template of a class
    in terms of what that class must do, but not in terms of how it should do it –
    we would want to leave that to the implementation of the class. This is where
    we can make use of abstract classes. Let''s create a script called `Poly_class.py`
    and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有时我们希望根据类必须做什么来定义类的模板，而不是如何做到这一点 - 我们希望将这留给类的实现。这就是我们可以使用抽象类的地方。让我们创建一个名为`Poly_class.py`的脚本，并添加以下代码：
- en: '![](img/ced77fe9-81c9-462f-bd46-c25fc2873fdb.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ced77fe9-81c9-462f-bd46-c25fc2873fdb.png)'
- en: It can be seen that we have an abstract class called `Shape`, which has an `area`
    method. The `area` method is not implemented in this class, but it would be implemented
    in the child class. The `Square` and `Circle` child classes override the `area`
    method. The `area` method is polymorphic, which means that if a square overrides
    it, it implements the area of a square and when a `Circle` class overrides it,
    it implements the area of a circle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到我们有一个名为`Shape`的抽象类，它有一个`area`方法。`area`方法在这个类中没有实现，但会在子类中实现。`Square`和`Circle`子类重写了`area`方法。`area`方法是多态的，这意味着如果一个正方形重写它，它实现了正方形的面积，当`Circle`类重写它时，它实现了圆的面积。
- en: Static, instance, and class methods in Python
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的静态、实例和类方法
- en: 'There are three kinds of methods that can be defined within a Python class.
    Up until now, we have mostly been dealing with instance methods, which we have
    invoked with our Python class instances:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python类中可以定义三种方法。到目前为止，我们大部分时间都在处理实例方法，我们已经使用我们的Python类实例调用了它们：
- en: '**Instance methods and variables:** Any method defined within a Python class
    that is invoked with the instance of the class, taking the self as its first positional
    argument, is said to be instance method. An instance method is able to access
    the  instance variables and the other instance methods of the class. With the
    `self.__class__` construct, it is also able to access the class level variables
    and the methods as well. An instance variable, on the other hand, is any variable
    that is declared within the Python class with the `self` keyword.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例方法和变量：** 在Python类中定义的任何方法，使用类的实例调用，以self作为其第一个位置参数，被称为实例方法。实例方法能够访问类的实例变量和其他实例方法。使用`self.__class__`构造，它也能够访问类级别的变量和方法。另一方面，实例变量是在Python类中使用`self`关键字声明的任何变量。'
- en: '**Class methods and variables:** Any method that is declared with the `@classmethod`
    Python decorator invoked with the class name is said to be a class method. A class
    method may also be declared without the `@classmethod` decorator. If this is the
    case, it must be invoked with the class name. A class method will have access
    only to the variables that are marked or declared at the class level and will
    not have access to object or instance level class variables. A class variable,
    on the other hand, can be declared outside any method. Within the class, we have
    to declare the variable without using the self keyword. For this reason, class
    variables and methods to some extent resemble static methods and variables that
    we studied in Java, but there is a catch, as mentioned here:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类方法和变量：** 使用`@classmethod` Python装饰器声明的任何方法都被称为类方法。类方法也可以在没有`@classmethod`装饰器的情况下声明。如果是这种情况，必须使用类名调用它。类方法只能访问在类级别标记或声明的变量，并且不能访问对象或实例级别的类变量。另一方面，类变量可以在任何方法之外声明。在类内部，我们必须在不使用self关键字的情况下声明变量。因此，类变量和方法在某种程度上类似于我们在Java中学习的静态方法和变量，但有一个陷阱，如下所述：'
- en: In Java and C#, we know that a static variable cannot be accessed with an instance
    of the class. In Python, static variables are class-level variables and they can
    actually be accessed by the instance of the class. But the access is read-only
    access, such that whenever a class-level variable is accessed with an instance
    of the class and the instance tries to modify or update it, Python automatically
    creates a new copy of the variable with the same name and assigns it to this instance
    of the class. This means that the next time the variable is accessed with the
    same instance, it will hide the class-level variable and it will provide access
    to the newly created instance-level copy of it instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和C#中，我们知道静态变量不能通过类的实例访问。在Python中，静态变量是类级变量，实际上可以通过类的实例访问。但是访问是只读访问，这意味着每当使用类的实例访问类级变量并且实例尝试修改或更新它时，Python会自动创建一个同名的变量副本并将其分配给类的这个实例。这意味着下次使用相同实例访问变量时，它将隐藏类级变量，并提供对新创建的实例级副本的访问。
- en: '**Static methods:** Any method in a Python class that is declared with the `@staticmethod` decorator is
    said to be a static method. Static methods in Python are different from what we
    saw in Java and C#. A static level method doesn''t have access to the instance 
    or the object-level variables, nor to the class-level variables of the class.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态方法：** 在Python类中使用`@staticmethod`装饰器声明的任何方法都被称为静态方法。Python中的静态方法与我们在Java和C#中看到的不同。静态级别的方法无法访问实例或对象级别的变量，也无法访问类级别的变量。'
- en: 'Let''s take an example called `Class_methods.py` to explain this further:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个名为`Class_methods.py`的示例来进一步解释：
- en: '![](img/c8c50950-2aae-4a6e-be1c-75f27fbe8e39.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8c50950-2aae-4a6e-be1c-75f27fbe8e39.png)'
- en: 'A continuation of the preceding code is shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的延续：
- en: '![](img/b8a6e8d2-3dbd-44e0-85c0-8c6346735d93.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8a6e8d2-3dbd-44e0-85c0-8c6346735d93.png)'
- en: The preceding code snippet explains the use of static, instance, and class methods.
    Whenever a class method is invoked by the instance of the class, Python automatically
    translates the instance type to class type internally, which can be seen in line
    42.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段解释了静态、实例和类方法的用法。每当类方法由类的实例调用时，Python会在内部自动将实例类型转换为类类型，这可以在第42行看到。
- en: 'The output is as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示：
- en: '![](img/d0b7fefc-0f6d-44e8-8bf2-6c63bb93ff62.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0b7fefc-0f6d-44e8-8bf2-6c63bb93ff62.png)'
- en: Files, directories, and I/O access
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件、目录和I/O访问
- en: Like any other programming language, Python provides a strong and easy interface
    to work with I/O, files, and directories. We will explore these in more detail
    in the following sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言一样，Python提供了一个强大且易于使用的接口来处理I/O、文件和目录。我们将在接下来的章节中更详细地探讨这些内容。
- en: File access and manipulation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件访问和操作
- en: 'We can read, write, and update files in Python. Python has got an open construct
    that can be used to provide file manipulation operations. When we open a file,
    there are various modes in which that file can be opened, as shown follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中读取、写入和更新文件。Python有一个`open`结构，可以用来提供文件操作。当我们打开一个文件时，可以以各种模式打开该文件，如下所示：
- en: '`r`: Read mode, this reads the file in text mode (Default).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：读取模式，这以文本模式读取文件（默认）。'
- en: '`rb`: This reads the file in binary mode.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rb`：这以二进制模式读取文件。'
- en: '`r+`: This reads the file in both read and write mode.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r+`：这以读取和写入模式读取文件。'
- en: '`rb`: This opens the file for reading and writing in binary mode.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rb`：这以二进制模式打开文件进行读取和写入。'
- en: '`w`: This opens the file in write mode only. It overwrites the existing file.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：这仅以写入模式打开文件。它会覆盖现有文件。'
- en: '`wb`: This opens the file for writing in binary mode. It overwrites the existing
    file.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wb`：这以二进制模式打开文件进行写入。它会覆盖现有文件。'
- en: '`w+`: This opens the file in both write and read mode. It overwrites the existing
    file.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w+`：这以写入和读取模式打开文件。它会覆盖现有文件。'
- en: '`wb+`: This opens the file for both reading and writing in binary mode. It
    overwrites the existing file.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wb+`：这以二进制模式打开文件进行读取和写入。它会覆盖现有文件。'
- en: '`a`: This opens the file in append mode and creates a file if it doesn''t exist.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：这以追加模式打开文件，并在文件不存在时创建文件。'
- en: '`ab`: This opens the file in append binary mode and creates a file if it doesn''t
    exist.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ab`：这以追加二进制模式打开文件，并在文件不存在时创建文件。'
- en: '`a+`: This opens the file in both append and read mode and creates a file if
    it doesn''t exist.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：这以追加和读取模式打开文件，并在文件不存在时创建文件。'
- en: '`ab+`: This opens the file in append read binary mode and creates a file if
    it doesn''t exist.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ab+`：这以追加读取二进制模式打开文件，并在文件不存在时创建文件。'
- en: In the following code block, the first argument to the `open` method call is
    the path of the file to be opened. The second is the `mode` in which the file
    has to be opened, and the third is the optional buffering argument that specifies
    the file's desired `buffer` size: `0` means unbuffered, `1` means line-buffered,
    and any other positive value means use a buffer of (approximately) that size (in
    bytes). A negative buffering means that the system default should be used. This
    is usually line-buffered for tty devices and fully buffered for other files. If
    omitted, the system default is used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，`open`方法调用的第一个参数是要打开的文件的路径。第二个参数是文件打开的`mode`，第三个是可选的缓冲参数，指定文件的期望`buffer`大小：`0`表示无缓冲，`1`表示行缓冲，任何其他正值表示使用大约该大小的缓冲（以字节为单位）。负缓冲表示应使用系统默认值。对于tty设备，通常是行缓冲，对于其他文件，通常是完全缓冲。如果省略，将使用系统默认值。
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With buffering, instead of reading directly from the operating system representation
    of the raw file (which would have high latency), the file is instead read into
    a OS buffer and read from there from then on. The advantage of this is that if
    we have a file present on the shared network and our objective is to read the
    file every 10 ms. We can load it once in the buffer and then read it from there,
    instead of reading it from the network each time, which would be expensive.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过缓冲，我们不是直接从操作系统的原始文件表示中读取（这样会有很高的延迟），而是将文件读入操作系统缓冲区，然后从那里读取。这样做的好处是，如果我们有一个文件存在于共享网络上，并且我们的目标是每10毫秒读取一次文件。我们可以将其加载到缓冲区中，然后从那里读取，而不是每次都从网络中读取，这将是昂贵的。
- en: 'Take a look at the following snippet from the `File_access.py` file to understand
    more:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`File_access.py`文件中的以下片段以了解更多：
- en: '![](img/72c27a66-405c-4bff-8007-6fce75c0dea8.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72c27a66-405c-4bff-8007-6fce75c0dea8.png)'
- en: The code snippet in the preceding screenshots from the `File_access.py` file
    explains how to use files in Python. The `read()` method of the `File` class takes
    the file path and if the whole path is not given, then the current working directory
    is assumed to be the starting path. The `read()` method invoked on the file instance
    reads the whole file into the program variable. `read(20)` will load 20 bytes
    from the file in the current file pointer position. This is very handy when we
    are dealing with large files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中的代码片段来自`File_access.py`文件，解释了如何在Python中使用文件。`File`类的`read()`方法接受文件路径，如果没有给出整个路径，则假定当前工作目录是起始路径。在文件实例上调用的`read()`方法将整个文件读入程序变量。`read(20)`将从当前文件指针位置加载20个字节的文件。当我们处理大文件时，这非常方便。
- en: 'The `readlines()` method returns a list, with each entry referring to each
    line of the file. The `readline()` method returns the current line from the file.
    The `seek()` method will take the file pointer to the position specified in the
    argument. Therefore, whenever we execute `seek(0)`, the file pointer points towards
    the beginning of the file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`readlines()`方法返回一个列表，每个条目都指向文件的一行。`readline()`方法返回文件的当前行。`seek()`方法将文件指针移到参数中指定的位置。因此，每当我们执行`seek(0)`时，文件指针都会指向文件的开头：'
- en: '![](img/d982737e-10d6-4d76-9cf5-750bcf84a5c1.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d982737e-10d6-4d76-9cf5-750bcf84a5c1.png)'
- en: Renaming and deleting files and accessing directories
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名和删除文件以及访问目录
- en: 'In Python, system-level access to file directories and various other operating
    system commands is provided by the `os` module. The `os` module is a very powerful
    utility. In this section, we will see a few of its uses with respect to renaming,
    deleting, creating, and accessing directories with the help of the following snippet
    from the `os_directories.py` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对文件目录和各种其他操作系统命令的系统级访问是由`os`模块提供的。`os`模块是一个非常强大的实用程序。在本节中，我们将看到它在重命名、删除、创建和访问目录方面的一些用法，借助`os_directories.py`文件中的以下片段：
- en: '![](img/510246cb-685b-46a6-8e83-c58199e98da4.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/510246cb-685b-46a6-8e83-c58199e98da4.png)'
- en: 'The code snippet in the preceding screenshot shows the various ways in which
    the `os` module is used with files and directories in Python, in order to rename
    and delete files and create and change directories. It also showed us how we can
    rename and traverse all the files (including nested files) from a subfolder. It
    should be noted that if we wish to delete a folder, we can use the `os.rmdir()` method,
    but all the files of the folder should be explicitly deleted in order for this
    to work:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中的代码片段展示了在Python中使用`os`模块与文件和目录一起使用的各种方式，以重命名和删除文件以及创建和更改目录。它还向我们展示了如何重命名和遍历所有文件（包括嵌套文件）从一个子文件夹。需要注意的是，如果我们想要删除一个文件夹，我们可以使用`os.rmdir()`方法，但是文件夹中的所有文件都应该被显式删除才能使其工作：
- en: 'The following output shows what happens with the file before and after its
    creation:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下输出显示了文件在创建前后的变化：
- en: '![](img/d27dec94-d550-47f0-a800-82356b636b19.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d27dec94-d550-47f0-a800-82356b636b19.png)'
- en: 'The following output shows the change in the file name:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下输出显示了文件名的更改：
- en: '![](img/d00304ad-2c46-4020-908e-aeaf748b38af.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d00304ad-2c46-4020-908e-aeaf748b38af.png)'
- en: 'The following output shows the change after the file is removed:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下输出显示了文件被删除后的变化：
- en: '![](img/ac7c3bda-3308-4ea5-8b4f-2da84ba8b947.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac7c3bda-3308-4ea5-8b4f-2da84ba8b947.png)'
- en: Console I/O
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台I/O
- en: 'So far, we have dealt with Python programs that mostly have hardcoded data
    as an input. Let''s see how can we take input from the user in Python and use
    that in our code instead. We will create a file called `user_input.py`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了大部分以硬编码数据作为输入的Python程序。让我们看看如何在Python中从用户那里获取输入并在我们的代码中使用。我们将创建一个名为`user_input.py`的文件：
- en: '![](img/2737bd23-9fff-48d2-a9ef-9f03d0d1a749.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2737bd23-9fff-48d2-a9ef-9f03d0d1a749.png)'
- en: 'This is fairly self-explanatory. In order to take the user input, we use the
    `input()` method, which halts the screen until the user provides an input. It
    always returns a string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当不言自明的。为了获取用户输入，我们使用`input()`方法，它会暂停屏幕，直到用户提供输入。它总是返回一个字符串：
- en: '![](img/ee4a3968-eabd-4d31-a6aa-36744383f1ea.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee4a3968-eabd-4d31-a6aa-36744383f1ea.png)'
- en: Regular expressions in Python
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的正则表达式
- en: '**Regular expressions** are very powerful and are widely used for pattern matching
    in the cyber security domain, be it dealing with parsing log files, Qualys or
    Nessus reports, or outputs produced by Metasploit, NSE or any other service scanning
    or exploit script. The module that provides support for regular expressions in
    Python is `re`. There are a few important methods that we will be using with Python
    regular expressions (the `re` module), which are explained as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**非常强大，在网络安全领域被广泛用于模式匹配，无论是处理解析日志文件、Qualys或Nessus报告，还是Metasploit、NSE或任何其他服务扫描或利用脚本生成的输出。Python中提供对正则表达式支持的模块是`re`。我们将使用Python正则表达式（`re`模块）的一些重要方法，如下所述：'
- en: '| `match()` | This determines if the regular expression finds a match at the
    beginning of the string `re.match(pattern,string,Flag=0)`. The flags can be specified
    with the `&#124;` or operator. The most commonly used flags are `re.Ignore-Case`,
    `re.Multiline`, and `re.DOTALL`. These flags can be specified with the or operator
    as (`re.M&#124; re.I`). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `match()` | 这确定正则表达式是否在字符串开头找到匹配项`re.match(pattern,string,Flag=0)`。标志可以用`&#124;`或操作符指定。最常用的标志是`re.Ignore-Case`，`re.Multiline`和`re.DOTALL`。这些标志可以用或操作符指定为(`re.M&#124;
    re.I`)。 |'
- en: '| `search()` | Unlike match, search doesn''t look for a match just at the beginning
    of the string, but instead searches or traverses throughout the string to look
    for the given search string/regex that can be specified as `re.search(pattern,string,Flag=0)`.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `search()` | 与match不同，search不仅在字符串开头寻找匹配项，而是在整个字符串中搜索或遍历以寻找给定的搜索字符串/正则表达式，可以指定为`re.search(pattern,string,Flag=0)`。
    |'
- en: '| `findall()` | This searches the string for the regex matches and returns
    all the substrings as a list wherever it finds a match. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `findall()` | 这在字符串中搜索正则表达式匹配项，并返回所有子字符串作为列表，无论它在哪里找到匹配项。 |'
- en: '| `group()` | If a match is found, then `group()` returns the string matched
    by the RE. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `group()` | 如果找到匹配项，则`group()`返回正则表达式匹配的字符串。 |'
- en: '| `start()` | If a match is found, then `start()` returns the starting position
    of the match. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `start()` | 如果找到匹配项，则`start()`返回匹配项的起始位置。 |'
- en: '| `end()` | If a match is found, then `end()` returns the end position of the
    match. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `end()` | 如果找到匹配项，则`end()`返回匹配项的结束位置。 |'
- en: '| `span()` | If a match is found, then `span()` returns a tuple containing
    the start and end positions of the match. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `span()` | 如果找到匹配项，则`span()`返回一个包含匹配项的起始和结束位置的元组。 |'
- en: '| `split()` | This splits a string on the basis of a regex match and returns
    us a list. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `split()` | 这根据正则表达式匹配来拆分字符串，并返回一个列表。 |'
- en: '| `sub()` | This is used for string replacement. It replaces all the substrings
    wherever it finds a match. It returns a new string if the match is not found.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `sub()` | 这用于字符串替换。它会替换所有子字符串的匹配项。如果找不到匹配项，则返回一个新字符串。 |'
- en: '| `subn()` | This is used for string replacement. It replaces all the substrings
    wherever it finds a match. The return type is a tuple with the new string at index
    0 and the number of replacements at index 1. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `subn()` | 这用于字符串替换。它会替换所有子字符串的匹配项。返回类型是一个元组，新字符串在索引0处，替换的数量在索引1处。 |'
- en: 'We will now try to understand regular expressions with the help of the following
    snippet from the `regular_expressions.py` script:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试通过`regular_expressions.py`脚本中的以下片段来理解正则表达式：
- en: '![](img/e8004fd3-a4ef-4d0e-900a-174774490875.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8004fd3-a4ef-4d0e-900a-174774490875.png)'
- en: 'The difference between `match` and `search` is that `match` only searches for
    the pattern at the beginning of the string, whereas `search` looks throughout
    the entire input string. The output produced with code lines 42 and 50 will illustrate
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`和`search`之间的区别在于，`match`只在字符串开头搜索模式，而`search`则在整个输入字符串中搜索。代码行42和50产生的输出将说明这一点：'
- en: '![](img/5febd3bf-641a-4918-9857-f09a0961ee8f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5febd3bf-641a-4918-9857-f09a0961ee8f.png)'
- en: In the preceding screen, it can be seen that when the `Hello` input is passed,
    both `match` and `search` were able to locate the string. However, when the input
    passed was `\d`, which means any decimal, `match` was not able to locate it but
    `search` was. This is because the `search` method searches throughout the string
    and not just the beginning.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，可以看到当输入`Hello`时，`match`和`search`都能够定位到字符串。然而，当输入为`\d`时，表示任何十进制数，`match`无法定位，但`search`可以。这是因为`search`方法在整个字符串中搜索，而不仅仅是开头。
- en: 'Again, it can be seen from the following screenshot that `match` did not return
    the grouping of digits and non-digits, but `search` did:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以从以下截图中看到，`match`没有返回数字和非数字的分组，但`search`有。
- en: '![](img/103f9502-7e14-446b-9540-612b790ee6d0.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/103f9502-7e14-446b-9540-612b790ee6d0.png)'
- en: 'In the following output, the `Reg` keyword is searched, so both `match` and
    `search` return results:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，搜索了`Reg`关键字，因此`match`和`search`都返回了结果：
- en: '![](img/d53c255f-370b-4e6a-bba4-133b4012e11c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d53c255f-370b-4e6a-bba4-133b4012e11c.png)'
- en: 'Notice how `findall()`, in the following screenshot, is different from `match`
    and `search`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在下面的截图中，`findall()`与`match`和`search`不同：
- en: '![](img/bcb6ea48-da84-4f3c-9bfe-ed19b1fdbca4.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcb6ea48-da84-4f3c-9bfe-ed19b1fdbca4.png)'
- en: 'These examples have shown how `match()` and `search()` operate differently
    and how `search()` is more powerful for carrying out search operations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子已经展示了`match()`和`search()`的不同操作方式，以及`search()`在执行搜索操作时更加强大：
- en: '![](img/4fac2b11-551e-472e-af98-da7102068a6a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fac2b11-551e-472e-af98-da7102068a6a.png)'
- en: 'Let''s take a look at a few important regular expressions in Python:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下Python中一些重要的正则表达式：
- en: '| **Regex expression** | **Description** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **描述** |'
- en: '| `\d` | This matches digits from zero to nine to a string. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 这匹配字符串中的零到九的数字。 |'
- en: '| `(\D\d)` | This matches the `\D` non-digits and the `\d`  digits that are
    grouped together. Parentheses (`()`) are used for grouping. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `(\D\d)` | 这匹配了`\D`非数字和`\d`数字，它们被分组在一起。括号(`()`)用于分组。 |'
- en: '| `.*string.*` | This returns a match if a word is found in the string, irrespective
    of what is before and after it. The `.*` notation means anything and everything.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `.*string.*` | 如果在字符串中找到一个单词，不管它前面和后面是什么，都会返回一个匹配项。`.*`符号表示任何东西。 |'
- en: '| `^` | The cap symbol means it matches a pattern at the start of the string.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 尖号符号表示它匹配字符串的开头。 |'
- en: '| `[a-zA-Z0-9]` | `[...]` is used to match anything that is placed inside the
    braces. `[12345]`, for example, means that a match should be found for any number
    between one and five. `[a-zA-Z0-9]` means that all alphanumeric characters should
    be considered matches. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `[a-zA-Z0-9]` | `[...]`用于匹配放在大括号内的任何内容。例如，`[12345]`表示应该找到介于一和五之间的任何数字的匹配项。`[a-zA-Z0-9]`表示应该将所有字母数字字符视为匹配项。
    |'
- en: '| `\w` | `\w` is identical to `[a-zA-Z0-9_]` and matches all the alphanumeric characters.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | `\w`与`[a-zA-Z0-9_]`相同，匹配所有字母数字字符。 |'
- en: '| `\W` | `\W` is the negation of `\w` and matches all non-alphanumeric characters.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | `\W`是`\w`的否定形式，匹配所有非字母数字字符。 |'
- en: '| `\D` | `\D` is the negation of `\d` and matches all characters that aren''t
    digits. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | `\D`是`\d`的否定形式，匹配所有不是数字的字符。 |'
- en: '| `[^a-z]` | `^`, when placed inside `[]`, acts as a negation. In this case,
    it means match anything besides letters from `a` to `z`.  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `[^a-z]` | `^`，当放置在`[]`内时，作为否定形式。在这种情况下，它意味着匹配除了`a`到`z`之间的字母以外的任何内容。 |'
- en: '| `re{n}` | This means match exactly `n` occurrences of the preceding expression.
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `re{n}` | 这意味着精确匹配前面表达式的`n`次出现。 |'
- en: '| `re{n ,}` | This means match `n` or more  occurrences of the preceding expression.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `re{n ,}` | 这意味着匹配前面表达式的`n`次或更多次出现。 |'
- en: '| `re {n,m}` | This means match a minimum of `n` and a maximum of `m` occurrences
    of the preceding expression. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `re {n,m}` | 这意味着匹配前面表达式的最少`n`次和最多`m`次出现。 |'
- en: '| `\s` | This means match the space characters. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 这意味着匹配空格字符。 |'
- en: '| `[T&#124;t]est` | This means match both `Test` and `test`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `[T&#124;t]est` | 这意味着匹配`Test`和`test`。 |'
- en: '| `re*` | This means match any occurrence of the expression following `*`.
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `re*` | 这意味着匹配`*`后面的表达式的任何出现。 |'
- en: '| `re?` | This means match any occurrence of the expression following `?`.
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `re?` | 这意味着匹配`?`后面的表达式的任何出现。 |'
- en: '| `re+` | This means match any occurrence of the expression following `+`.
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `re+` | 这意味着匹配`+`后面的表达式的任何出现。 |'
- en: Data manipulation and parsing with XML, JSON, and CSV data
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XML、JSON和CSV数据进行数据操作和解析
- en: In this section, we will first look at how we can manipulate XML data in Python
    followed by how we can manipulate JSON data. After that, we will look at the pandas
    Python utility with a focus on CSV.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先看看如何在Python中操作XML数据，然后看看如何操作JSON数据。之后，我们将重点介绍CSV的pandas Python实用程序。
- en: XML data manipulation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML数据操作
- en: 'In this section, we will look at how can we manipulate XML data in Python.
    While there are many ways to parse XML documents in Python, the simple and the
    most widely used method is using the `XML.etree` module. Let''s see the following
    example, which will illustrate how easy and simple it is to parse XML documents
    and strings in Python. Create a script called `xml_parser.py`. We will use an
    XML document called `exmployees.xml`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何在Python中操作XML数据。虽然有许多方法可以解析Python中的XML文档，但简单且最常用的方法是使用`XML.etree`模块。让我们看看以下示例，它将说明在Python中解析XML文档和字符串是多么简单和容易。创建一个名为`xml_parser.py`的脚本。我们将使用一个名为`exmployees.xml`的XML文档：
- en: '![](img/2af0e0e4-8682-4da6-bbda-ce278188c0b1.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2af0e0e4-8682-4da6-bbda-ce278188c0b1.png)'
- en: As can be seen in the preceding example, we simply use the `xml.etree.ElementTree`
    module and alias it as ET. In the parse method of the class, we extract the root
    of the XML document or the XML string by invoking the `parse` method, in the former
    case, and the `fromstring` method, in the latter case. This will return us an
    instance of the `<class 'xml.etree.ElementTree.Element'>` ET element class. We
    can iterate over this to get all the child nodes, as seen from line 21 to line
    26\. If we do not know the names of the attributes of a node, the `attrib` property
    of the class returns a dictionary that has a key value mapping for the attribute
    names and their values. If we do know the name of the subnodes, we can follow
    a second method, which is shown from line 29 to line 36, where we specify the
    names of the nodes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子中所示，我们简单地使用`xml.etree.ElementTree`模块，并将其别名为ET。在类的解析方法中，我们通过调用`parse`方法（在前一种情况下）或`fromstring`方法（在后一种情况下）来提取XML文档或XML字符串的根。这将返回`<class
    'xml.etree.ElementTree.Element'>` ET元素类的实例。我们可以遍历它以获取所有子节点，如从第21行到第26行所示。如果我们不知道节点的属性名称，类的`attrib`属性返回一个字典，其中包含属性名称和其值的键值映射。如果我们知道子节点的名称，我们可以遵循第二种方法，如从第29行到第36行所示，其中我们指定节点的名称。
- en: 'If we pass an XML string instead of a file, the only change is in the way we
    initialize the root element; the rest remains the same. Another thing to note
    about this script is that we are using command-line arguments. `sys.argv[]` is
    used to access these command-line arguments, with the 0^(th) index of the file having
    the name of the script itself and the arguments from index 1 onwards. In our example,
    the name of the XML file is passed as a command-line argument to the script and
    is accessed with the `sys.argv[1]` property. This is shown in the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递的是XML字符串而不是文件，则唯一的变化在于初始化根元素的方式；其余部分保持不变。关于此脚本的另一点要注意的是，我们使用了命令行参数。`sys.argv[]`用于访问这些命令行参数，文件的0索引具有脚本本身的名称，从索引1开始是参数。在我们的示例中，XML文件的名称作为命令行参数传递给脚本，并使用`sys.argv[1]`属性进行访问。如下所示：
- en: '![](img/c1c97fa6-d348-4d0b-ae92-e7cedbf8724a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1c97fa6-d348-4d0b-ae92-e7cedbf8724a.png)'
- en: JSON data manipulation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON数据操作
- en: Let's now look at how to use Python to manipulate JSON data. JSON (Java Script
    Object Notation) is a very widely used data storage and exchange format. It gained
    popularity as the internet matured, and it became the standard for information
    exchange in REST-based APIs or services.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Python操作JSON数据。 JSON（JavaScript对象表示）是一种非常广泛使用的数据存储和交换格式。随着互联网的成熟，它变得越来越受欢迎，并成为基于REST的API或服务中信息交换的标准。
- en: 'Python provides us with a JSON module for JSON data manipulation. Let''s create
    a JSON file called `employees.json` and look at how we can use the JSON module
    to access the JSON content. Let''s say that our objective is to read the employees''
    data, then to find the employees whose salary is over 30,000, and mark them with
    slab `A`. We''ll then mark those whose salary is less than 30,000 with slab `B`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了一个用于JSON数据操作的JSON模块。让我们创建一个名为`employees.json`的JSON文件，并查看如何使用JSON模块访问JSON内容。假设我们的目标是读取员工数据，然后找出工资超过30,000的员工，并用`A`级标记他们。然后我们将那些工资低于30,000的员工标记为`B`级：
- en: '![](img/4eaf8647-2b2b-441e-8317-7bc715e5cce7.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4eaf8647-2b2b-441e-8317-7bc715e5cce7.png)'
- en: 'The obtained output is shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的输出如下截图所示：
- en: '![](img/b699e6c9-04e1-45ef-b33e-598ac06ead4d.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b699e6c9-04e1-45ef-b33e-598ac06ead4d.png)'
- en: 'As can be deduced from the previous code, the JSON file is loaded as a Python
    dictionary, which can be achieved with the help of the `json.load()` command.  The
    `load ()` method expects the JSON file path to be provided as an argument. If
    the JSON data is not present as an external file but as a Python string instead,
    we can use the `json.loads()` method and pass the JSON string as an argument.
    This will again convert the string into a Python native type, which would either
    be a list or a dictionary. This can be seen as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码可以推断出，JSON文件被加载为Python字典，可以通过`json.load()`命令实现。`load()`方法期望提供JSON文件路径作为参数。如果JSON数据不是作为外部文件而是作为Python字符串存在，我们可以使用`json.loads()`方法，并将JSON字符串作为参数传递。这将再次将字符串转换为Python本机类型，可能是列表或字典。如下所示：
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `json_parse.py` file, lines 10 to 20 simply iterate over the Python
    dictionaries and inner lists and display the employee details. This is something
    we have seen before. The objective of the script was actually to update the employee
    slab, which is achieved in the `process()` method. We open and load the JSON file again in
    the Python native type (line 23). Then, we iterate over the Python dictionary.
    In line 27, we check if the salary of the employee is greater than or equal to
    30,000\. If it is, we modify the employee''s slab, by modifying the original `json_data`
    object that loaded all details. The `json_data["employees"]["data"][index]["slab"]` statement
    will point towards the slab of the current employee, decide whether their salary
    is more or less than 30,000 and set it to `A` or `B` as appropriate. Finally,
    we will have the modified details of the employees in the `json_data` object and
    we will overwrite the contents of the original JSON file using the file object
    with `json.dump() method.json.dump()`. This will take a Python native object (list,
    dictionary, or tuple) and convert it to its JSON equivalent. It takes the `file_object`
    as its second argument to indicate where the JSON data must go. It also takes
    formatting options such as `indent`, `sort_keys`, and so on. Likewise, we also
    have a `json.dumps()` method, which translates a Python native type to its JSON
    string equivalent. This is shown as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`json_parse.py`文件中，第10到20行简单地迭代Python字典和内部列表，并显示员工详细信息。这是我们之前见过的。脚本的目标实际上是更新员工的工资档次，这是在`process()`方法中实现的。我们再次打开并加载JSON文件到Python本机类型（第23行）。然后，我们迭代Python字典。在第27行，我们检查员工的工资是否大于或等于30,000。如果是，我们修改员工的档次，通过修改加载所有详细信息的原始`json_data`对象。`json_data["employees"]["data"][index]["slab"]`语句将指向当前员工的档次，确定他们的工资是多还是少于30,000，并将其设置为`A`或`B`。最后，我们将在`json_data`对象中得到修改后的员工详细信息，并使用`json.dump()方法`覆盖原始JSON文件的内容。这将把Python本机对象（列表、字典或元组）转换为其JSON等效形式。它将`file_object`作为第二个参数，指示JSON数据必须放在哪里。它还接受格式选项，如`indent`、`sort_keys`等。同样，我们还有一个`json.dumps()`方法，它将Python本机类型转换为其JSON字符串等效形式。如下所示：
- en: '[PRE2]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It should be remembered that external JSON files can not be modified in place.
    In other words, we cannot modify a part of the external JSON file and keep the
    rest the same. In this case, we need to overwrite the whole file with the new
    content.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 应该记住，外部JSON文件不能在原地修改。换句话说，我们不能修改外部JSON文件的一部分，然后保持其余部分不变。在这种情况下，我们需要用新内容覆盖整个文件。
- en: CSV
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: '**CSV data** is very widely used in the cyber security and data science domain,
    whether in the form of log files, as an output of Nessus or Qualys reports (in
    Excel format), or large datasets for machine learning. Python provides excellent
    support for CSV files with the built-in CSV module. In this section, we shall
    explore this module and look at the pandas Python utility with a focus on CSV.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSV数据**在网络安全和数据科学领域被广泛使用，无论是作为日志文件的形式，作为Nessus或Qualys报告的输出（以Excel格式），还是用于机器学习的大型数据集。Python提供了内置的CSV模块对CSV文件提供了出色的支持。在本节中，我们将探讨这个模块，并关注CSV的pandas
    Python实用程序。'
- en: 'Let''s first look at the built-in CSV module offered by Python. The following
    code snippet, called `csv_parser.py`, demonstrates this module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下Python提供的内置CSV模块。下面的代码片段，名为`csv_parser.py`，演示了这个模块：
- en: '![](img/4749f061-9e48-4237-bae7-4b9f61412218.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4749f061-9e48-4237-bae7-4b9f61412218.png)'
- en: The preceding code helps us understand how we can use the CSV module to read
    CSV files in Python. It's always recommended to use the CSV module, as this takes
    care of delimiters, new lines, and characters internally. There are two ways of
    reading from a CSV file, the first of which is to use the `csv.reader()` method
    (lines 10-25), which returns us a list of CSV strings. Each row or item of the
    list will be a string list representing a row of the CSV file, where each item
    can be accessed with the index. The other way to read CSV files is with the help
    of `csv.DictReader()` (lines 29-38), which returns a list of dictionaries. Each
    dictionary will have a key value pair with a key that represents the CSV column
    and a value, which is the actual row value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码帮助我们了解如何使用CSV模块在Python中读取CSV文件。建议始终使用CSV模块，因为它内部处理分隔符、换行符和字符。有两种从CSV文件中读取数据的方法，第一种是使用`csv.reader()`方法（第10-25行），它返回一个CSV字符串列表。列表的每一行或项将是表示CSV文件一行的字符串列表，可以通过索引访问每个项。另一种读取CSV文件的方法是使用`csv.DictReader()`（第29-38行），它返回一个字典列表。每个字典将具有一个键值对，键表示CSV列，值是实际的行值。
- en: 'The output produced is shown as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出如下所示：
- en: '![](img/6b9cd6c3-59ac-4e64-b0a5-91f72d0db0c2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b9cd6c3-59ac-4e64-b0a5-91f72d0db0c2.png)'
- en: 'In order to write to a CSV file, there are again two different ways. One way
    is to make use of the `csv.DictWriter()` directive, which returns a writer object
    and has the capability to push a Python list or dictionary directly to a CSV file.
    This would transform a Python list or dictionary to CSV format internally, when
    we invoke the `writerows()` method on the list or dictionary. This is shown from
    lines (40-53): we check the salary of an employee, associate the appropriate slab
    to it, and finally use the `writerows()` method to overwrite the modified CSV
    file. The `csv.DictWriter()` supports both `writerows()` and the `write row()`
    method. The `writerows()` method would simply take a dictionary and write it to
    the CSV file.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写入CSV文件，有两种不同的方法。一种方法是使用`csv.DictWriter()`指令，它返回一个writer对象，并且具有将Python列表或字典直接推送到CSV文件的能力。当我们在列表或字典上调用`writerows()`方法时，这将在内部将Python列表或字典转换为CSV格式。这在第40-53行中展示：我们检查员工的薪水，将适当的分级与之关联，最后使用`writerows()`方法覆盖修改后的CSV文件。`csv.DictWriter()`支持`writerows()`和`write
    row()`方法。`writerows()`方法将简单地获取一个字典并将其写入CSV文件。
- en: 'The second way to write to a CSV file is by using the `csv.Writer()` method.
    This returns a writer object, which takes a list of lists (strings) as an argument on
    the `writerows()` method and writes the structure to the external CSV file. The
    examples for both of these methods as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 写入CSV文件的第二种方法是使用`csv.Writer()`方法。这将返回一个writer对象，该对象将以列表的形式作为`writerows()`方法的参数，并将结构写入外部CSV文件。这两种方法的示例如下屏幕截图所示：
- en: '![](img/fcffdd28-fda0-48fa-ad18-cc52eb3bf1e6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcffdd28-fda0-48fa-ad18-cc52eb3bf1e6.png)'
- en: While the preceding ways of accessing and dealing with CSV files are good, they
    won't help if the CSV file is very large. If the CSV file is 10 GB and the RAM
    of the system is just 4 GB, neither `csv.reader()` or `csv.DictReader()` will
    work well. This is because both `reader()` and `DictReader()` read the external
    CSV file completely in the variable program memory, which is the RAM. For a huge
    file, it's not advisable to use the CSV module directly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面介绍的访问和处理CSV文件的方法很好，但如果CSV文件非常大，这些方法就不适用了。如果CSV文件大小为10GB，系统的RAM只有4GB，那么`csv.reader()`或`csv.DictReader()`都无法很好地工作。这是因为`reader()`和`DictReader()`都会将外部CSV文件完全读入变量程序内存中，也就是RAM。对于一个巨大的文件，直接使用CSV模块是不可取的。
- en: 'An alternative approach could be to read the file with the help of iterator,
    or in byte chunks, as shown in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用迭代器或按字节块读取文件，如下面的屏幕截图所示：
- en: '![](img/422f0beb-263e-4baa-b4bf-36c2b024054b.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/422f0beb-263e-4baa-b4bf-36c2b024054b.png)'
- en: The preceding code snippet will not load the entire file in the memory but would
    read one line at a time. This way, we can process and store that line in the database
    or carry out any relevant action. Because the file is read line by line, this
    would cause trouble if we have multiline CSV data. As we can see in the preceding
    example, the first record for `Emp1` is not read completely; it is split across
    two lines with the second line containing only part of the `Description` field.
    This means the previous approach would not work for large or multiline CSV files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段不会将整个文件加载到内存中，而是一次读取一行。这样，我们可以处理和存储该行到数据库中，或执行任何相关操作。由于文件是逐行读取的，如果我们有多行的CSV数据，这将会造成麻烦。正如我们在前面的示例中看到的，`Emp1`的第一条记录没有完全读取；它被分成两行，第二行只包含`Description`字段的一部分。这意味着以前的方法对于大型或多行的CSV文件是行不通的。
- en: If we try to read in terms of chunks or bytes, as we saw earlier, we would not
    know how many chunks or bytes would correspond to one row, so this would also
    give inconsistent results. To get around this issue, we will use Pandas, a powerful
    Python data analysis toolkit.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图按块或字节来读取，就像我们之前看到的那样，我们将不知道多少块或字节对应于一行，因此这也会导致不一致的结果。为了解决这个问题，我们将使用Pandas，这是一个强大的Python数据分析工具包。
- en: For detailed information on Pandas, please go through the following: [http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Pandas的详细信息，请参阅以下链接：[http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/)。
- en: 'First, we need to install pandas, which can be done as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装pandas，可以按照以下步骤进行：
- en: '[PRE3]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code snippet explains how to use pandas to read a huge CSV file
    in small chunks and thus reduce the memory usage:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段解释了如何使用pandas以小块读取巨大的CSV文件，从而减少内存使用：
- en: '![](img/29a040bd-0403-468a-929c-b1b11e816f89.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29a040bd-0403-468a-929c-b1b11e816f89.png)'
- en: As seen in the preceding code snippet, we declare the chunk size to be 100,000
    records, assuming we have a very large CSV file to process. The chunk size is
    the upper limit; if the actual records are less than the chunk size, the program
    will just fetch the lowest of the two. Then, we load the CSV file with `pd.read_csv()`,
    specifying the chunk size as one of the arguments. The `chunk.rename()` methods
    would actually remove the newline characters from the column names (if there are
    any) and `chunk.fillna('')` will take up the empty values returned by the CSV
    file. Instead of NA, it will fill them with empty string. Finally, we iterate
    over the rows with the `iterrows()` method, which returns a tuple, and we print
    the values as shown. It should be noted that `pd.read_csv()` returns a pandas
    DataFrame, which can be thought of as an in-memory relational table.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们声明块大小为100,000条记录，假设我们有一个非常大的CSV文件要处理。块大小是上限；如果实际记录少于块大小，程序将只获取两者中较小的值。然后，我们使用`pd.read_csv()`加载CSV文件，指定块大小作为参数。`chunk.rename()`方法实际上会从列名中删除换行符（如果有的话），`chunk.fillna('')`将填充CSV文件返回的空值。最后，我们使用`iterrows()`方法迭代行，该方法返回一个元组，然后按照所示打印值。应该注意的是，`pd.read_csv()`返回一个pandas
    DataFrame，可以被视为内存中的关系表。
- en: Exception handling
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exceptions, as we are all aware, are conditions that are unforeseen. They may
    arise at run time and cause a program to crash. For this reason, it is recommended
    to put suspect code (that may lead to an exception) in an exception handling code
    block. Then, even if an exception occurs, our code will handle it appropriately
    and take the required actions. Like Java and C#, Python also supports the legacy
    try and catch blocks for handling exceptions. There is a slight change, however,
    which is that the catch block in Python is called except.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 异常，我们都知道，是意想不到的条件。它们可能在运行时出现并导致程序崩溃。因此，建议将可疑代码（可能导致异常）放在异常处理代码块中。然后，即使发生异常，我们的代码也会适当地处理它并采取所需的操作。与Java和C#一样，Python也支持用于处理异常的传统try和catch块。然而，有一个小改变，就是Python中的catch块被称为except。
- en: 'The following code snippet shows how we can do basic exception handling in
    Python:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何在Python中进行基本的异常处理：
- en: '![](img/a860a901-891c-44c5-949d-287fa7267489.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a860a901-891c-44c5-949d-287fa7267489.png)'
- en: The preceding code is self explanatory. Instead of `try` and `catch`, Python
    uses `try` and `except`. We use the `raise` command in order to manually throw
    the exceptions. The final block works as it does in every other language with
    the core condition that irrespective of whether the exception occurs or not, the
    final block should be executed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是不言自明的。Python使用`try`和`except`，而不是`try`和`catch`。我们使用`raise`命令来手动抛出异常。最终块的工作方式与其他语言相同，核心条件是无论异常是否发生，最终块都应该被执行。
- en: It should be noted that in the previous example, we used a general Exception
    class when handling exceptions in the except block. If we are sure what kind of
    exception the code may raise, we can use specific exception handlers such as `IOError`,
    `ImportError`, `ValueError`,`KeyboardINterupt`, and `EOFError`. Finally, it should
    also be remembered that in Python we can use an else block alongside a `try` block
    .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在前面的例子中，我们在except块中处理异常时使用了一个通用的Exception类。如果我们确定代码可能引发什么样的异常，我们可以使用特定的异常处理程序，比如`IOError`、`ImportError`、`ValueError`、`KeyboardINterupt`和`EOFError`。最后，还应该记住，在Python中，我们可以在`try`块旁边使用一个else块。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed OOP, Files, directories, IO, XML, JSON, CSV, and
    exception handling with respect to Python. These are the core constructs of Python
    and are very widely used. We will be using all these structures and concepts frequently
    when we move on to the section on implementing penetration testing and cyber security
    with Python, so it's important that we have a good understanding of them all.
    In the next chapter, we will discuss more advanced concepts such as multithreading,
    multiprocessing, sub processes in Python, and socket programming. With that chapter,
    we will finish exploring the prerequisites of Python, which will in turn lead
    us onto learning about penetration testing and cyber security ecosystems with
    regard to Python.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Python的OOP、文件、目录、IO、XML、JSON、CSV和异常处理。这些是Python的核心构造，被广泛使用。当我们转向使用Python实现渗透测试和网络安全时，我们将经常使用所有这些结构和概念，因此我们对它们有很好的理解是很重要的。在下一章中，我们将讨论更高级的概念，如Python中的多线程、多进程、子进程和套接字编程。通过那一章，我们将完成对Python先决条件的探索，这将进而引导我们学习有关Python的渗透测试和网络安全生态系统。
- en: Questions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: We often hear of Python as a scripting language. What is the typical advantage
    of using it as an object-oriented language? Can you think of any particular products
    or use cases?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们经常听说Python是一种脚本语言。将其用作面向对象的语言的典型优势是什么？你能想到任何特定的产品或用例吗？
- en: Name some ways in which can we parse XML and CSV files.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些解析XML和CSV文件的方法。
- en: Can we detect all the attributes of a class without seeing the class structure?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不看类结构的情况下检测到类的所有属性？
- en: What are method decorators?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是方法装饰器？
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'pandas: [https://pandas.pydata.org/](https://pandas.pydata.org/)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pandas: [https://pandas.pydata.org/](https://pandas.pydata.org/)'
- en: 'NumPy: [http://www.numpy.org/](http://www.numpy.org/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NumPy: [http://www.numpy.org/](http://www.numpy.org/)'
- en: 'Python GUI programming: [https://www.python-course.eu/python_tkinter.php](https://www.python-course.eu/python_tkinter.php)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python GUI编程：[https://www.python-course.eu/python_tkinter.php](https://www.python-course.eu/python_tkinter.php)
