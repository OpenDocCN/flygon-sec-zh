# 第一章：Python 简介

本章将介绍 Python，主要关注 Python 编程语言遵循的数据类型，变量，表达式和程序结构。本章的目标是使读者熟悉 Python 的基础知识，以便他们可以在接下来的章节中使用它。本章将涵盖 Python 的安装及其依赖管理器。我们还将开始研究 Python 脚本。

在本章中，我们将涵盖以下主题：

+   Python 简介（包括安装和设置）

+   基本数据类型

+   序列数据类型 - 列表，字典，元组

+   变量和关键字

+   操作和表达式

# 技术要求

在继续本章之前，请确保您已准备好以下设置：

+   一台工作的计算机或笔记本电脑

+   Ubuntu 操作系统，最好是 16.04 版本

+   Python 3.x

+   一个可用的互联网连接

# 为什么选择 Python？

当我们考虑探索一种新的编程语言或技术时，我们经常会想到新技术的范围以及它可能给我们带来的好处。让我们从思考为什么我们可能想要使用 Python 以及它可能给我们带来的优势开始这一章。

为了回答这个问题，我们将考虑当前的技术趋势，而不会涉及更多的语言特定功能，比如它是面向对象的，功能性的，可移植的和解释性的。我们以前听过这些术语。让我们试着思考为什么我们可能会从严格的工业角度使用 Python，这种语言的现在和未来的景观可能是什么样的，以及这种语言如何为我们服务。我们将首先提到一些计算机科学相关人员可能选择的职业选项：

+   程序员或软件开发人员

+   Web 开发人员

+   数据库工程师

+   网络安全专业人员（渗透测试员，事件响应者，SOC 分析师，恶意软件分析师，安全研究员等）

+   数据科学家

+   网络工程师

还有许多其他角色，但我们暂时只关注最通用的选项，看看 Python 如何适用于它们。让我们从程序员或软件开发人员的角色开始。截至 2018 年，Python 被记录为招聘广告中列出的第二受欢迎的语言（[`www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/`](https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/)）。程序员的角色可能因公司而异，但作为 Python 程序员，您可能会编写 Python 软件产品，开发用 Python 编写的网络安全工具（已经存在大量这样的工具可以在 GitHub 和网络安全社区的其他地方找到），原型设计一个可以模仿人类的机器人，设计智能家居自动化产品或实用工具等。Python 的范围涵盖了软件开发的各个方面，从典型的软件应用到强大的硬件产品。这是因为这种语言易于理解，具有出色的库支持，由庞大的社区支持，并且当然，它是开源的美丽之处。

让我们转向网络。近年来，Python 在成熟作为 Web 开发语言方面表现出色。最受欢迎的全栈基于 Web 的框架，如 Django、Flask 和 CherryPy，使得使用 Python 进行 Web 开发成为一种无缝和清晰的体验，学习、定制和灵活性都很强。我个人最喜欢 Django，因为它提供了非常清晰的 MVC 架构，业务逻辑和表示层完全隔离，使得开发代码更加清晰和易于管理。Django 装备齐全，支持 ORM 和使用 celery 进行后台任务处理，实现了其他任何 Web 框架能够做到的一切，同时保持了 Python 的本地代码。Flask 和 CherryPy 也是 Web 开发的绝佳选择，可以对数据流和定制性进行大量控制。

**网络安全**是一个离开 Python 就不完整的领域。网络安全领域的每个行业都与 Python 有一定的关联，大多数网络安全工具都是用 Python 编写的。从渗透测试到监控安全运营中心，Python 被广泛使用和需要。Python 通过为渗透测试人员提供出色的工具和自动化支持，使他们能够为各种渗透测试活动编写快速而强大的脚本，从侦察到利用都可以。我们将在本书的课程中详细学习这一点。

**机器学习**（**ML**）和**人工智能**（**AI**）是科技行业中我们经常遇到的热门词汇。Python 对所有 ML 和 AI 模型都有出色的支持。在大多数情况下，Python 是任何想学习 ML 和 AI 的人的首选。这个领域中另一个著名的语言是 R，但由于 Python 在其他技术和软件开发领域的出色覆盖，将用 Python 编写的机器学习解决方案与现有或新产品结合起来比用 R 编写的解决方案更容易。Python 拥有惊人的机器学习库和 API，如 sciket-learn、NumPy、Pandas、matplotlib、NLTK 和 TensorFlow。Pandas 和 NumPy 使得科学计算变得非常容易，给用户提供了在内存中处理大型数据集的灵活性，具有出色的抽象层，使开发人员可以忘记背景细节，干净高效地完成工作。

几年前，一个典型的数据库工程师可能会被期望了解关系型数据库，比如**MySQL**、**SQL Server**、**Oracle**、**PostgreSQL**等等。然而，在过去的几年里，技术领域已经完全改变。虽然一个典型的数据库工程师仍然应该了解并熟练掌握这些数据库技术栈，但这已经不够了。随着数据量的增加，当我们进入大数据时代时，传统数据库必须与 Hadoop 或 Spark 等大数据解决方案配合工作。话虽如此，数据库工程师的角色已经演变成包括数据分析师的技能集。现在，数据不再需要从本地数据库服务器中获取和处理 - 它需要从异构来源收集，预处理，跨分布式集群或并行核心进行处理，然后再存储回分布式节点集群中。我们在这里谈论的是大数据分析和分布式计算。我们之前提到了 Hadoop 这个词。如果你对它不熟悉，Hadoop 是一个引擎，能够通过在计算机集群中生成文件块来处理大文件，然后对处理结果集进行聚合，这在业界被称为 map-reduce 操作。Apache Spark 是分析领域的一个新热词，它声称比 Hadoop 生态系统快 100 倍。Apache Spark 有一个名为`pyspark`的 Python API，使用它我们可以用本地 Python 代码运行 Apache Spark。它非常强大，熟悉 Python 使得设置变得简单和无缝。

提到前面的几点的目的是为了突出 Python 在当前技术领域和未来的重要性。机器学习和人工智能很可能会成为主导产业，而这两者都主要由 Python 驱动。因此，现在开始阅读和探索 Python 和机器学习的网络安全将是一个更好的时机。让我们通过了解一些基础知识来开始我们的 Python 之旅。

# 关于 Python - 编译还是解释

编译器通过将用高级编程语言编写的人类可读的代码转换为机器代码，然后由底层架构或机器运行。如果你不想运行代码，编译后的版本可以保存并以后执行。值得注意的是，编译器首先检查语法错误，只有在没有发现错误的情况下才会创建程序的编译版本。如果你使用过 C 语言，你可能会遇到`.out`文件，这些是编译后的文件的例子。

然而，在解释器的情况下，程序的每一行都是在运行时从源代码中解释并转换为机器代码进行执行。Python 属于解释的字节码类别。这意味着 Python 代码首先被翻译成中间字节码（一个`.pyc`文件）。然后，这个字节码由解释器逐行解释并在底层架构上执行。

# 安装 Python

在本书的过程中，所有的练习都将在 Linux 操作系统上展示。在我的情况下，我使用的是 Ubuntu 16.04。你可以选择任何你喜欢的变种。我们将使用`python3`来进行练习，可以按照以下方式安装：

```py
sudo apt-get install python3
sudo apt-get install python3-pip
```

第二个命令安装了**pip**，它是 Python 的包管理器。所有不包括在标准安装中的开源 Python 库都可以通过`pip`来安装。我们将在接下来的部分中探讨如何使用 pip。

# 开始

在本书的过程中，我们将致力于涵盖 Python、网络安全、渗透测试和数据科学领域的先进和著名的行业标准。然而，正如他们所说，每段非凡的旅程都始于小步。让我们开始我们的旅程，先了解 Python 的基础知识。

# 变量和关键字

**变量**，顾名思义，是保存值的占位符。Python 变量只是在 Python 程序或脚本的范围内保存用户定义值的名称。如果我们将 Python 变量与其他传统语言（如 C、C++、Java 等）进行比较，我们会发现它们有些不同。在其他语言中，我们必须将数据类型与变量的名称关联起来。例如，在 C 或 Java 中声明整数，我们必须声明为`int a=2`，编译器将立即在 C 中保留两个字节的内存，在 Java 中保留四个字节。然后将内存位置命名为`a`，程序将引用其中存储的值`2`。然而，Python 是一种动态类型语言，这意味着我们不需要将数据类型与我们在程序中声明或使用的变量关联起来。

整数的典型 Python 声明可能如`a=20`。这只是创建一个名为`a`的变量，并将值`20`放入其中。即使我们在下一行将值更改为`a="hello world"`，它也会将字符串`hello world`与变量`a`关联起来。让我们在 Python 终端上看看它的运行情况：

![](img/c64e1eab-6ced-40a7-afd9-f52a540dabe8.png)

使用 Python 终端，只需在终端提示符中键入`python3`命令。让我们思考一下这是如何工作的。看一下下面的图表，比较静态类型语言和动态类型语言：

![](img/0d42b878-542f-4972-a1d6-a5650b1921bc.png)

![](img/36132ef2-42f9-4f37-8d0c-18089f559fd2.png)

正如您在前面的图表中看到的，在 Python 的情况下，变量实际上保存对实际对象的引用。每次更改值时，都会在内存中创建一个新对象，并且变量指向这个新对象。以前的对象由垃圾收集器声明。

在讨论 Python 是一种动态类型语言之后，我们不应该将其与弱类型语言混淆。尽管 Python 是动态类型的，但它也是一种强类型语言，就像 Java、C 或 C++一样。

在下面的示例中，我们声明一个字符串类型的变量`a`和一个整数类型的变量`b`：

![](img/991cd824-ffd9-4193-8d3e-31654ea761e5.png)

当我们执行操作`c=a+b`时，在弱类型语言中可能发生的是将`b`的整数值转换为字符串，并将存储在变量`c`中的结果为`hello world22`。然而，由于 Python 是强类型的，该函数遵循与变量关联的类型。我们需要显式进行转换才能执行这种操作。

让我们看看下面的示例，以了解强类型语言的含义；我们在运行时明确更改变量`b`的类型并将其转换为字符串类型：

![](img/5b8991ee-cd92-44ad-abfe-d0534491ef7e.png)

# 变量命名约定

在了解了如何声明和使用变量的基础知识之后，让我们尝试了解它们遵循的命名约定。变量，也称为标识符，可以以 A-Z、a-z 或下划线之间的任何字母开头命名。然后可以跟随任意数量的数字或字母数字字符。

必须注意的是，某些特殊字符，如%，@，#，-和!在 Python 中是保留的，不能与变量一起使用。

# Python 关键字

**关键字**，顾名思义，是某种语言实现中具有预定义含义的特定保留字。在其他语言中，我们通常不能使用与关键字相同的名称来命名我们的变量，但 Python 是一个略有不同的情况。尽管我们不应该使用与关键字保留相同的名称来命名变量或标识符，即使我们这样做，程序也不会抛出任何错误，我们仍然会得到一个输出。让我们尝试通过传统的 C 程序和等效的 Python 脚本来理解这一点：

![](img/e3862155-a723-4571-abb9-4c60f2a57f5c.png)

应该注意的是，这是一个简单的 C 程序，我们在其中声明了一个整数，并使用`int`标识符来标识它，随后我们简单地打印`hello world`。

然而，当我们尝试编译程序时，它会抛出编译错误，如下面的屏幕截图所示：

![](img/334cc30b-eb1a-4cb2-a891-6614441abc6a.png)

让我们尝试在 Python shell 中做同样的事情，看看会发生什么：

![](img/975e7b89-e7e4-4874-89ea-4c1768baf01c.png)

可以看到，当我们用名称`int`和`str`声明变量时，程序没有抛出任何错误。尽管`int`和`str`都是 Python 关键字，在前面的情况下，我们看到用名称`int`声明的变量保存了一个字符串值，而用`str`类型声明的变量保存了一个`int`值。我们还看到了一个普通变量`a`，它是从`int`类型转换为`string`类型。由此可以确定，我们可以在 Python 中使用保留字作为变量。这样做的缺点是，如果我们要使用关键字作为变量或标识符，我们将覆盖这些保留字所具有的实际功能。当我们在程序范围内覆盖它们的实际行为时，它们将遵循更新或覆盖的功能，这是非常危险的，因为这将使我们的代码违反 Python 的约定。这应该始终被避免。

让我们扩展前面的例子。我们知道`str()`是一个内置的 Python 函数，其目的是将数值数据类型转换为字符串类型，就像我们对变量`a`所看到的那样。然而，后来我们重写了它的功能，并且在我们的程序范围内，我们将其分配给了一个整数类型。现在，在程序范围内的任何时间点，如果我们尝试使用`str`函数将数值类型转换为`string`，解释器将抛出一个错误，说`int`类型变量不能用作方法，或者它们不可调用，如下面的屏幕截图所示：

![](img/88a7a2cd-885c-4dc5-ae8e-0865c9ca544b.png)

对于`int`方法也是如此，我们将不再能够使用它将字符串转换为其等效的整数。

现在，让我们看看 Python 中还有哪些类型的关键字，我们应该尽量避免将它们用作我们的变量名。有一种很酷的方法可以通过 Python 代码本身来做到这一点，这让我们可以在终端窗口中打印 Python 关键字：

![](img/6e6f151e-b64d-4871-a95a-ab0b78b4869c.png)

`import`语句用于在 Python 中导入库，就像我们在 Java 中导入包时一样。我们将在以后的章节中详细介绍使用导入和循环。现在，我们将看看不同的 Python 关键字的含义：

+   `false`: 布尔`false`运算符。

+   `none`: 这相当于其他语言中的`Null`。

+   `true`: 布尔`true`运算符。

+   `and`: 逻辑`and`，可以与条件和循环一起使用。

+   `as`: 这用于为我们导入的模块分配别名。

+   `assert`: 这用于调试代码的目的。

+   `break`: 这会退出循环。

+   `class`: 这用于声明一个类。

+   `continue`: 这是传统的`continue`语句，用于循环，可以用于继续执行循环。

+   `def`：用于定义函数。每个 Python 函数都需要在`def`关键字之前。

+   `del`：用于删除对象

+   `elif`：条件`else...if`语句。

+   `else`：条件`else`语句。

+   `except`：用于捕获异常。

+   `finally`：与异常处理一起使用，作为我们清理资源的最终代码块的一部分。

+   `for`：传统的 for 循环声明关键字。

+   `global`：用于声明和使用全局变量。

+   `if`：条件`if`语句。

+   `import`：用于导入 Python 库、包和模块。

+   `in`：用于在 Python 字符串、列表和其他对象之间进行搜索。

+   `is`：用于测试对象的标识。

+   `lambda`：与 Lambda 函数一起使用。

+   `nonlocal`：用于声明嵌套函数中不是其本地变量的变量。

+   `not`：条件运算符。

+   `or`：另一个条件运算符。

+   `pass`：在 Python 中用作占位符。

+   `raise`：用于在 Python 中引发异常。

+   `return`：用于从函数返回。

+   `try`：与异常处理一起使用的传统`try`关键字。

+   `while`：与`while`循环一起使用。

+   `with`：用于文件打开等。

+   `yield`：与生成器一起使用。

+   `from`：与相对导入一起使用。

在本书中，我们将学习此列表中提到的所有关键字。

# Python 数据类型

像任何其他编程语言一样，Python 也有标准数据类型。在本节中，我们将探讨 Python 提供给我们使用的各种强大的数据类型。

# 数字

**数字**，顾名思义，涵盖了所有数字数据类型，包括整数和浮点数据类型。在本章的前面，我们看到要使用整数或浮点数，我们可以简单地声明变量并赋予整数或浮点值。现在，让我们编写一个适当的 Python 脚本，并探索如何使用数字。将脚本命名为`numbers.py`，如下所示：

![](img/8126ea5f-c958-432d-a21e-e104ab71827f.png)

前面的屏幕截图显示了一个简单的 Python 脚本，该脚本将整数与浮点数相加，然后打印总和。要运行脚本，我们可以输入`python3 numbers.py`命令，如下所示：

![](img/050cfa73-4361-4b66-9354-5975f58a6faa.png)

您可能已经注意到脚本开头的命令是`#! /usr/bin/python`。这行的作用是使您的代码可执行。在脚本的权限已更改并且已被设置为可执行之后，命令表示如果尝试执行此脚本，则我们应该继续使用`/usr/bin/python3`路径中放置的`python3`来执行它。可以在以下示例中看到这一点：

![](img/56bba27d-5bf8-4bab-a6e5-cefbbbc32293.png)

如果我们观察`print`命令，我们可以看到字符串格式化程序是`%s`。要用实际值填充它，需要将第二个参数传递给`print`函数：

![](img/c97aee4e-553c-4f0a-a5ca-adfad91fdb6d.png)

要将字符串转换为其等效的整数或浮点值，我们可以使用内置的`int()`和`float()`函数。

# 字符串类型

我们知道字符串是字符的集合。在 Python 中，字符串类型属于序列类别。字符串非常强大，有许多方法可用于执行字符串操作。让我们看一下下面的代码片段，它向我们介绍了 Python 中的字符串。在 Python 中，字符串可以在单引号和双引号中声明：

![](img/22c427ea-efbe-4418-9cff-bc1b0a78118e.png)

在上面的代码中，我们只是声明了一个名为`my_str`的字符串，并将其打印在控制台窗口上。

# 字符串索引

必须注意的是，在 Python 中可以将字符串视为字符序列。字符串可以被视为字符列表。让我们尝试打印字符串的各个索引处的字符，如下面的屏幕截图所示：

![](img/d5ec70ee-4290-461e-b965-01c74a3164cc.png)

在索引 `0` 处，字符 `0` 被打印。在索引 `10` 处，我们有一个空格，而在索引 `5` 处，我们有字母 `m`。需要注意的是，序列在 Python 中以起始索引 `0` 存储，字符串类型也是如此。

# 通过方法和内置函数进行字符串操作

在本节中，我们将看看如何比较两个字符串，连接字符串，将一个字符串复制到另一个字符串，并使用一些方法执行各种字符串操作。

# replace( ) 方法

`replace` 方法用于执行字符串替换。它返回一个带有适当替换的新字符串。`replace` 方法的第一个参数是要在字符串中替换的字符串或字符，而第二个参数是要替换的字符串或字符：

![](img/1fc71b45-8d4d-4b3f-a0a5-3457356c2a6c.png)

在前面的例子中，我们可以看到原始字符串中的 `!` 被 `@` 替换，并返回一个带有替换的新字符串。需要注意的是，这些更改实际上并没有应用到原始字符串上，而是返回了一个带有适当更改的新字符串。这可以在下一行中验证，我们打印原始字符串，旧的未更改值 `Welcome to python strings !` 被打印出来。这背后的原因是 Python 中的字符串是不可变的，就像在 Java 中一样。这意味着一旦声明了一个字符串，通常就不能修改。然而，并非总是如此。让我们尝试更改字符串，并这次尝试捕获最初声明的字符串 `my_str` 中的修改，如下所示：

![](img/149b832c-b606-4089-8a7d-eec5ae01da93.png)

在前面的代码中，我们能够修改原始字符串，因为我们从我们之前声明的字符串 `my_str` 中的 `replace` 方法中得到了新返回的字符串。这可能与我们之前说的相矛盾。让我们看看在调用 `replace` 方法之前和之后发生了什么：

![](img/b3244b6c-200a-4d48-951b-4fda8b1b2d53.png)

将 `!` 替换为 `@` 后，结果如下：

![](img/35b0c002-e5b1-4fd5-9ed7-bfc0ae446d32.png)

在前面的两个示例中可以看到，在调用 `replace` 方法之前，`my_str` 字符串引用指向包含 `!` 的实际对象。一旦 `replace()` 方法返回一个新字符串，并且我们用新返回的对象更新了现有的字符串变量，旧的内存对象并没有被覆盖，而是创建了一个新的对象。程序引用现在指向新创建的对象。早期的对象在内存中，并没有任何引用指向它。这将在以后的阶段由垃圾收集器清理。

另一件我们可以做的事情是尝试改变原始字符串中任何位置的任何字符。我们已经看到字符串字符可以通过它们的索引访问，但是如果我们尝试在任何特定索引处更新或更改字符，就会抛出异常，并且不允许进行操作，如下面的屏幕截图所示：

![](img/13e222d0-bd51-47f4-92e8-e8c83e701e31.png)

默认情况下，`replace()` 方法会替换目标字符串中替换字符串的所有出现。然而，如果我们只想替换目标字符串中的一个或两个出现，我们可以向 `replace()` 方法传递第三个参数，并指定我们想要进行的替换次数。假设我们有以下字符串：

![](img/f75a0ce4-c66a-4cce-b046-9fdf34154f94.png)

如果我们只想要`!`字符的第一个出现变成`@`，并且我们希望其余部分保持不变，可以按照以下方式实现：

![](img/c3588b54-8a51-4fd7-aef9-019c3524b426.png)

# 子字符串或字符串切片

获取字符串的一部分是我们在日常字符串操作中经常遇到的常见练习。诸如 C 或 Java 之类的语言为我们提供了专用方法，如`substr(st_index,end_index)`或`subString(st_index,end_index)`。在 Python 中执行子字符串操作时，没有专用方法，但我们可以使用切片。例如，如果我们希望获得原始`my_str`字符串的前四个字符，我们可以通过使用`my_str[0:4]`等操作来实现，如下面的屏幕截图所示：

![](img/c6aeed0e-02f3-469e-b7ce-9294498e9ca3.png)

同样，切片操作返回一个新的字符串，而不会对原始字符串进行更改。此外，值得在这里理解的是，切片发生在 n-1 个字符上，其中`n`是作为第二个参数指定的上限，即在我们的例子中是四。因此，实际的子字符串操作将从索引`0`开始，到索引`3`结束，从而返回字符串`Welc`。

让我们看一些切片的更多例子：

+   要从索引`4`获取整个字符串，按照以下方式操作：

![](img/265fb596-8570-4a43-a5bd-ac71c3cede1c.png)

+   要从开头获取到索引`4`的字符串，请执行以下操作：

![](img/e980939e-4bac-4535-80d2-61117ec28703.png)

+   要使用切片打印整个字符串，请执行以下操作：

![](img/8663fe94-e20c-4356-bed8-c2368b4f43f3.png)

+   要打印步长为`2`的字符，按照以下方式操作：

![](img/6f045c64-fcec-4fac-a464-6b0d2851675d.png)

+   要打印字符串的反向，请执行以下操作：

![](img/8320ea2f-87aa-493d-90df-6ca0ac460748.png)

+   打印字符串的一部分以相反的顺序，如下所示：

![](img/a9f35a75-da29-4ce9-88b6-d2abb5ab707f.png)

# 字符串连接和复制

`+`是 Python 中用于连接两个字符串的连接运算符。与往常一样，连接的结果是一个新的字符串，除非我们获得更新后的字符串，否则更新将不会反映在原始字符串对象上。`+`运算符在用于字符串类型时内部被重载以执行对象的连接。当它用于数值数据类型时，也用于两个数字的加法，如下所示：

![](img/9bbe9d09-0f6f-4be5-8b84-293154494d00.png)

有趣的是，Python 还支持另一个操作符，当与字符串数据类型一起使用时会被重载。它不是执行常规操作，而是执行原始操作的变体，以便可以在字符串数据类型之间复制功能。在这里，我们谈论的是乘法操作符`*`。它通常用于执行数值数据类型的乘法，但当它用于字符串数据类型时，它执行的是复制操作。这在以下代码片段中显示：

![](img/0dc12321-1ec0-449b-b40e-d18c32ed580e.png)

在前面的情况下，乘法运算符实际上将存储在变量`c`中的`Hello world`字符串复制了五次，正如我们在表达式中指定的那样。这是一个非常方便的操作，可以用来生成模糊负载，我们将在本书的后面章节中看到。

# strip()，lstrip()和 rstrip()方法

`strip`方法实际上是用于从输入字符串中去除空格。默认情况下，`strip`方法将从字符串的左右两侧去除空格，并返回一个新的字符串，其中前导和尾随两侧都没有空格，如下面的屏幕截图所示：

![](img/521462f8-9528-4dd3-8432-3c961ce9e0b1.png)

然而，如果我们只想去掉左边的空格，我们可以使用`lstrip()`方法。同样，如果我们只想去掉右边的空格，我们可以使用`rstrip()`方法。如下所示：

![](img/48b30334-a5c3-422f-a28e-dddd1dc5e34a.png)

# split()方法

`split`方法，顾名思义，用于在特定分隔符上拆分输入字符串，并返回包含已拆分单词的列表。我们将很快更详细地了解列表。现在，让我们看一下以下示例，其中我们有员工的姓名、年龄和工资，用逗号分隔在一个字符串中。如果我们希望分别获取这些信息，我们可以在`,`上执行拆分。`split`函数将第一个参数作为要执行`split`操作的分隔符：

![](img/54ee7d41-e315-4acf-9ef5-30f8a364999c.png)

默认情况下，`split`操作是在空格上执行的，即，如果未指定分隔符。可以如下所示：

![](img/3b721965-73f1-443e-ad86-80eb51ad3af0.png)

# find()、index()、upper()、lower()、len()和 count()方法

`find()`函数用于在目标字符串中搜索字符或字符串。如果找到匹配，此函数返回字符串的第一个索引。如果找不到匹配，则返回`-1`：

![](img/ac610f73-f88d-4f46-bd14-e0e7ca7c9db6.png)

`index()`方法与`find()`方法相同。如果找到匹配，它返回字符串的第一个索引，并在找不到匹配时引发异常：

![](img/bacda854-0567-4485-b282-0fdab63f915a.png)

`upper()`方法用于将输入字符串转换为大写字母，`lower()`方法用于将给定字符串转换为小写字母：

![](img/1d9cd7e7-9c5c-46da-8404-ced350f2a170.png)

`len()`方法返回给定字符串的长度：

![](img/76a2b0cf-b6c7-4672-ae1a-eb1414843544.png)

`count()`方法返回我们希望在目标字符串中计算的任何字符或字符串的出现次数：

![](img/6d5e9730-57b1-4b13-b8dd-4ab28b9a0255.png)

# `in`和`not in`方法

`in`和`not in`方法非常方便，因为它们让我们可以快速在序列上进行搜索。如果我们希望检查目标字符串中是否存在或不存在某个字符或单词，我们可以使用`in`和`not in`方法。这将返回`True`（如果单词存在）和`False`（如果不存在）：

![](img/13b72441-6e6c-4f4e-8558-7a125dfe3a87.png)

# endswith()、isdigit()、isalpha()、islower()、isupper()和 capitalize()方法

`endswith()`方法检查给定字符串是否以我们传递的特定字符或单词结尾：

![](img/3c680da9-5f9b-4341-8687-c510267c9191.png)

`isdigit()`方法检查给定的字符串是否为数字类型：

![](img/a1b64dd8-ef60-4a1a-bdc3-3b060d1a3fc4.png)

`isalpha()`方法检查给定的字符串是否为字母字符类型：

![](img/588ee101-e6b4-4c46-8893-7fb5184b26e6.png)

`islower()`方法检查字符串是否为小写，而`isupper()`方法检查字符串是否为大写。`capitalize()`方法将给定字符串转换为句子大小写：

![](img/4b918755-df2c-4319-ba79-94af07d7cd07.png)

# 列表类型

Python 没有数组类型，而是提供了列表数据类型。Python 列表也属于序列类，并提供了广泛的功能。如果你来自 Java、C 或 C++背景，你可能会发现 Python 列表与这些语言提供的数组和列表类型略有不同。在 C、C++或 Java 中，数组是相似数据类型的元素集合，Java 数组列表也是如此。但在 Python 中情况不同。在 Python 中，列表是可以是同质和异质数据类型的元素集合。这是使 Python 列表强大、健壮且易于使用的特点之一。在声明时，我们也不需要指定 Python 列表的大小。它可以动态增长以匹配它包含的元素数量。让我们看一个使用列表的基本示例：

![](img/80849a5f-d291-4d12-baf5-f3968064f41f.png)

Python 中的列表从索引`0`开始，可以根据索引访问任何项，如前面的屏幕截图所示。前面的列表是同质的，因为所有元素都是字符串类型。我们也可以有一个异质列表，如下所示：

![](img/98d236da-817a-4518-803a-e59395b2c770.png)

目前，我们正在手动打印列表元素。我们可以很容易地用循环迭代它们，稍后我们将探讨这一点。现在，让我们试着理解 Python 中可以对列表结构执行哪些操作。

# 切片列表

**切片**是一种允许我们从序列和列表中提取元素的操作。我们可以对列表进行切片，以提取我们感兴趣的部分。需要再次注意的是，切片的索引是基于 0 的，并且最后一个索引始终被视为`n-1`，其中 n 是指定的最后一个索引值。要从列表中切片出前五个和后五个元素，我们可以执行以下操作：

![](img/f71326a4-1b4c-4fe4-a8a6-2ffabe019d33.png)

让我们看一些列表切片的示例及其结果：

+   要获取从索引`4`开始的列表，请执行以下操作：

![](img/46a125ca-dab4-473c-8796-8b0fe756da1c.png)

+   要获取从开头到索引`4`的列表元素，请执行以下操作：

![](img/3c3ea6df-f4f2-4278-b6ea-6b775b7969bf.png)

+   要使用切片打印整个列表，请执行以下操作：

![](img/d7bf51a3-9ed3-4f24-a1a0-8890dfba879d.png)

+   要打印步长为`2`的列表元素，请执行以下操作：

![](img/8fd8c671-7792-46f7-93e6-b3a979605b0f.png)

+   要打印列表的反向，请执行以下操作：

![](img/69c36743-6554-4c54-91b7-395d2a5d1e10.png)

+   要以相反的顺序打印列表的一部分，请执行以下操作：

![](img/b490c167-0ab4-4ed5-bb00-1751307d7b46.png)

+   向`list-append()`添加新元素：`append()`方法用于向列表添加元素，要添加的元素作为参数传递给`append()`方法。要添加的这些元素可以是任何类型。除了数字或字符串之外，元素本身可以是一个列表：

![](img/6cf0eaa7-81d0-43f2-b4e6-bd9c147ac5f0.png)

我们可以看到在前面的例子中，我们使用`append()`方法向原始列表添加了三个元素`6`、`7`和`8`。然后，我们实际上添加了另一个包含三个字符的列表，这个列表会完整地存储在原始列表中。可以通过指定`my_list[8]`索引来访问它们。在前面的例子中，新列表完整地添加到原始列表中，但没有合并。

# 合并和更新列表

在 Python 中，可以通过两种方式进行列表合并。首先，我们可以使用传统的`+`运算符，之前我们用来连接两个字符串。当用于列表对象类型时，它也是一样的。另一种方法是使用`extend`方法，它将新列表作为要与现有列表合并的参数。这在以下示例中显示：

![](img/6bc7138d-5445-493a-b429-ad348042890f.png)

要更新列表中的元素，我们可以访问其索引，并为我们希望更新的任何元素添加更新后的值。例如，如果我们希望将字符串`Hello`作为列表的第 0 个元素，可以通过将第 0 个元素分配给`Hello`值来实现`merged[0]="hello"`：

![](img/81dc9bf3-7d05-4dc5-a2fe-7669da40f460.png)

# 复制列表

我们已经看到 Python 变量只是对实际对象的引用。对于列表也是如此。因此，操作列表会有点棘手。默认情况下，如果我们通过简单地使用`=`运算符将一个列表变量复制到另一个列表变量，它实际上不会创建列表的副本或本地副本 - 相反，它只会创建另一个引用，并将新创建的引用指向相同的内存位置。因此，当我们对复制的变量进行更改时，原始列表中也会反映相同的更改。在下面的示例中，我们将创建新的隔离副本，其中对复制的变量的更改不会反映在原始列表中：

![](img/a0c195ed-49bc-4dec-9772-0f94c573644a.png)

现在，让我们看看如何创建现有列表的新副本，以便对新列表的更改不会对现有列表造成任何更改：

![](img/fd4396e7-54fa-4227-b771-f9708b988c64.png)

创建原始列表的隔离副本的另一种方法是利用 Python 中提供的`copy`和`deepcopy`函数。浅复制构造一个新对象，然后将该对象的*引用*插入到原始列表中找到的对象中。另一方面，*深复制*构造一个新的复合对象，然后递归地插入到原始列表中找到的对象的*副本*：

![](img/cfa57b95-bd7f-4fdd-8f97-37431ba47755.png)

# 从列表中删除元素

我们可以使用`del`命令删除列表中的元素或整个列表。`del`命令不返回任何内容。我们也可以使用`pop`方法从列表中删除元素。`pop`方法将要删除的元素的索引作为参数：

![](img/41be39ab-2b4f-4483-acdd-7e1a929a6dae.png)

整个列表结构可以被删除如下：

![](img/52929047-d566-4cd2-b9de-96626a871fa0.png)

# 使用 len()、max()和 min()进行复制

乘法运算符`*`，当应用于列表时，会导致列表元素的复制效果。列表的内容将根据传递给复制运算符的数字重复多次：

![](img/aa5f4c95-bef4-46f8-b4c7-d54df712d39f.png)

`len()`方法给出了 Python 列表的长度。`max()`方法返回列表的最大元素，而`min()`方法返回列表的最小元素：

![](img/cb322b31-3b37-4f10-a95c-49e17ea5ce9c.png)

我们也可以在字符类型上使用`max`和`min`方法，但是不能在包含混合或异构类型的列表上使用它们。如果这样做，将会得到一个异常，说明我们正在尝试比较数字和字符：

![](img/edea29fb-7ba5-4650-918a-97c0eaf37001.png)

# in 和 not in

`in`和`not in`方法是 Python 中的基本操作，可以用于任何序列类型。我们之前看到了它们如何与字符串一起使用，我们用它们来搜索目标字符串中的字符串或字符。`in`方法返回`true`，如果搜索成功则返回`false`。`not in`方法则相反。执行如下所示：

![](img/50142294-3c9d-4e79-b4f8-70ca12912977.png)

# Python 中的元组

Python 元组与 Python 列表非常相似。不同之处在于它是一个只读结构，因此一旦声明，就不能对元组的元素进行修改。Python 元组可以用如下方式使用：

![](img/deb53b7e-f5fc-4639-9413-03355effa0d6.png)

在前面的代码中，我们可以看到我们可以像访问列表一样访问元组，但是当我们尝试更改元组的任何元素时，它会抛出一个异常，因为元组是只读结构。如果我们执行我们在列表上执行的操作，我们会发现它们与元组的工作方式完全相同：

![](img/f4f04740-11d2-47d7-b642-86bded48a6b3.png)

如果元组中只有一个元素，则必须使用尾随逗号声明。如果在声明时不添加逗号，则将根据元组的元素将其解释为数字或字符串数据类型。以下示例更好地解释了这一点：

![](img/aadff71a-28ef-4377-803c-3790e9c065a0.png)

元组可以转换为列表，然后可以进行如下操作：

![](img/d2a752cc-1c18-412a-9de8-483ee1ba9b8e.png)

# Python 中的字典

**字典**是非常强大的结构，在 Python 中被广泛使用。字典是一种键值对结构。字典键可以是唯一的数字或字符串，值可以是任何 Python 对象。字典是可变的，可以就地更改。以下示例演示了 Python 中字典的基础知识：

![](img/026f5772-da80-4c06-b866-5ffa45f665af.png)

Python 字典可以在花括号内声明。每个键值对之间用逗号分隔。应该注意，键必须是唯一的；如果我们尝试重复键，旧的键值对将被新的键值对覆盖。从前面的例子中，我们可以确定字典键可以是字符串或数字类型。让我们尝试在 Python 中对字典进行各种操作：

+   **使用键检索字典值**：可以通过字典键的名称访问字典值。如果不知道键的名称，可以使用循环来遍历整个字典结构。我们将在本书的下一章中介绍这一点： 

![](img/3800b1fd-c087-4497-9eb2-70d32b55f8b2.png)

这是打印字典值的许多方法之一。但是，如果我们要打印值的键在字典中不存在，我们将收到一个找不到键的异常，如下截图所示：

![](img/9be2648e-13c9-4097-b0ce-04c7dcbf929d.png)

有一种更好的方法来处理这个问题，避免这种类型的异常。我们可以使用字典类提供的`get()`方法。`get()`方法将键名作为第一个参数，如果键不存在，则将默认值作为第二个参数。然后，如果找不到键，将返回默认值，而不是抛出异常。如下截图所示：

![](img/5884c24f-f3c4-44dc-9b79-ca9f0e412392.png)

在前面的例子中，当实际字典`dict1`中存在`k1`键时，将返回`k1`键的值，即`v1`。然后，搜索了`k0`键，但最初不存在。在这种情况下，不会引发异常，而是返回`False`值，表明实际上不存在这样的键`K0`。请记住，我们可以将任何占位符作为`get()`方法的第二个参数，以指示我们要搜索的键的缺失。

+   **向字典添加键和值**：一旦声明了字典，在代码的过程中可能会有许多情况，我们希望修改字典键或添加新的字典键和值。可以通过以下方式实现。如前所述，字典值可以是任何 Python 对象，因此我们可以在字典中的值中有元组、列表和字典类型：

![](img/425afb59-cd2f-4d18-966d-8fa9b01a11a8.png)

现在，让我们将更复杂的类型添加为值：

![](img/228b2391-23bd-460f-85e0-6e045e2b03ed.png)

可以通过它们的键正常检索这些值，如下所示：

![](img/a68a6a98-a518-4c70-a02f-c8d7171aa4f4.png)

+   **扩展字典内容**: 在前面的例子中，我们将一个字典添加为现有字典的值。我们现在将看到如何将两个字典合并为一个公共或新字典。可以使用`update()`方法来实现这一点：

![](img/7474e4c8-1dc5-4086-a8df-f911e871d9c0.png)

+   **`Keys()`**：要获取所有字典键，我们可以使用`keys()`方法。这将返回字典键的类实例：

![](img/85740215-8770-4e17-b499-4f91cae8fbb8.png)

我们可以看到，keys 方法返回一个`dict_keys`类的实例，它保存了字典键的列表。我们可以将其强制转换为列表类型，如下所示：

![](img/86da945a-0ecb-44f2-a367-d6e6fe617918.png)

+   **`values()`**：`values()`方法返回字典中存在的所有值：

![](img/3c4ba243-4241-4d6c-b0c8-9bccbe80de5d.png)

+   **`Items()`**：这个方法实际上是用来遍历字典键值对的，因为它返回一个包含元组列表的列表类实例。每个元组有两个条目，第一个是键，第二个是值：

![](img/6c4ee05b-2d21-4c19-b018-492110271041.png)

我们也可以将返回的类实例转换为元组、列表元组或列表类型。这样做的理想方式是遍历项目，我们稍后将在循环时看到：

![](img/b526057b-5f0d-471b-9256-da3477b45944.png)

+   **`in`**和**`not in`**：`in`和`not in`方法用于查看字典中是否存在键。默认情况下，`in`和`not in`子句将搜索字典键，而不是值。看下面的例子：

![](img/8423b4f3-adbc-448d-a657-4ba3d67e5264.png)

+   **存储顺序**：默认情况下，Python 字典是无序的，这意味着它们在内部存储的顺序与我们定义的顺序不同。这是因为字典存储在称为**哈希表**的动态表中。由于这些表是动态的，它们的大小可以增加和缩小。内部发生的情况是计算键的哈希值并将其存储在表中。键进入第一列，而第二列保存实际值。让我们看下面的例子来更好地解释这一点：

![](img/5df607af-fdcd-462d-bfe9-23375ad29fd9.png)

在前面的例子中，我们声明了一个名为`a`的字典，第一个键为`abc`，第二个键为`abcd`。然而，当我们打印值时，我们可以看到`abcd`在`abc`之前存储。为了解释这一点，让我们假设字典内部存储的动态表或哈希表的大小为`8`。

正如我们之前提到的，键将被存储为哈希值。当我们计算`abc`字符串的哈希并以模 8 的方式进行除法时，即表大小为`8`，我们得到结果`7`。如果我们对`abcd`做同样的操作，我们得到结果`4`。这意味着哈希`abcd`将被存储在索引`4`，而哈希`abc`将被存储在索引`7`。因此，在列表中，我们得到`abcd`在`abc`之前列出的原因是这样的：

![](img/e5c7a7d8-19a0-47de-85ee-17aa4f778632.png)

在`hash(key)%table_size`操作后，可能会出现两个键到达相同值的情况，这称为**冲突**。在这种情况下，首先插槽的键是先存储的键。

+   **`sorted()`**：如果我们希望字典根据键排序，可以使用内置的 sorted 方法。这可以调整为返回一个元组列表，每个元组在第 0 个索引处有一个键，第 1 个索引处有一个值：

![](img/ccb9d9fc-f6fc-4fe5-98d0-95e24576990c.png)

+   **删除元素**：我们可以使用传统的`del`语句来删除任何字典项。当我们说删除时，我们指的是删除键和值。字典项成对工作，因此删除键也会删除值。删除条目的另一种方法是使用`pop()`方法并将键作为参数传递。这在以下代码片段中显示：

![](img/b723bc4c-f7de-45c6-87d3-8bc7252f83b7.png)

# Python 运算符

Python 中的运算符是可以对表达式进行算术或逻辑操作的东西。运算符操作的变量称为**操作数**。让我们试着了解 Python 中提供的各种运算符： 

+   **算术**：

| **函数** | **示例** |
| --- | --- |
| 加法 | `a + b` |
| 减法 | `a - b` |
| 否定 | `-a` |
| 乘法 | `a * b` |
| 除法 | `a / b` |
| 取模 | `a % b` |
| 指数 | `a ** b` |
| 地板除法 | `a // b` |

+   **赋值**：

+   `a = 0`评估为`a=0`

+   `a +=1`评估为`a = a + 1`

+   `a -= 1`评估为`a = a + 1`

+   `a *= 2`评估为`a = a * 2`

+   `a /= 5`评估为`a = a / 5`

+   `a **= 3`评估为`a = a ** 3`

+   `a //= 2`评估为`a= a // 2`（地板除法 2）

+   `a %= 5`评估为`a= a % 5`

+   **逻辑运算符**：

+   **`and`**：`True`：如果两个操作数都为`true`，则条件变为`true`。例如，`(a and b)`为`true`。

+   **`or`**：`True`：如果两个操作数中有任何一个非零，则条件变为`true`。例如，`(a or b)`为`true`。

+   **`not`**：`True`：用于颠倒其操作数的逻辑状态。例如，`not (a and b)`为`false`。

+   **位运算符**：

| **函数** | **示例** |
| --- | --- |
| `and` | `a & b` |
| `or` | `a &#124; b` |
| `xor` | `a ^ b` |
| `反转` | `~ a` |
| `右移` | `a >> b` |
| `左移` | `a << b` |

# 总结

在本章中，我们讨论了 Python 的基础知识，并探索了该语言的语法。这与您以往可能学过的语言并没有太大不同，例如 C、C++或 Java。但是，与同行相比，它更容易使用，并且在网络安全领域非常强大。本章阐述了 Python 的基础知识，并将帮助我们进步，因为一些数据类型，如列表、字典、元组和字符串在本书的整个过程中都被大量使用。

在下一章中，我们将学习条件和循环，并看看循环如何与我们迄今为止学习的数据类型一起使用。

# 问题

1.  Python 是开源的吗？如果是，它与其他开源语言有何不同？

1.  谁管理 Python 并致力于进一步的功能增强？

1.  Python 比 Java 快吗？

1.  Python 是面向对象的还是函数式的？

1.  如果我对任何编程语言几乎没有经验，我能快速学会 Python 吗？

1.  Python 对我有什么好处，作为一名网络安全工程师？

1.  我是一名渗透测试员-为什么我需要了解人工智能和机器学习？
