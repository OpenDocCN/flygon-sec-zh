- en: Vulnerability Scanner Python - Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞扫描器Python - 第1部分
- en: kWhen we talk of port scanning, the tool that automatically comes to mind is
    Nmap. Nmap has a good reputation and it is arguably the best open source port
    scanner available. It has tons of features that allow you to carry out a wide
    variety of scans over the network to discover what hosts are alive, what ports
    are open, and also which services and service versions are running on the host.
    It also has an engine (the Nmap scanning engine) that can scan NSE scripts, that
    is used to discover common vulnerabilities with the running services. In this
    chapter, we will make use of Python in order to automate the process of port scanning.
    This chapter will form the basis for our automated vulnerability scanner, and
    will supplement the subsequent chapter, which will focus on automating service
    scanning and enumeration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论端口扫描时，自动想到的工具就是Nmap。Nmap有良好的声誉，可以说是最好的开源端口扫描器。它具有大量功能，允许您在网络上执行各种扫描，以发现哪些主机是活动的，哪些端口是开放的，以及主机上运行的服务和服务版本。它还有一个引擎（Nmap扫描引擎），可以扫描用于发现运行服务的常见漏洞的NSE脚本。在本章中，我们将使用Python来自动执行端口扫描的过程。本章将为我们的自动化漏洞扫描器奠定基础，并将补充下一章，该章将专注于自动化服务扫描和枚举。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing Nmap
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Nmap
- en: Building a network scanner with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python构建网络扫描器
- en: Introducing Nmap
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Nmap
- en: Our  port scanner will be made on top of Nmap, with additional features and
    capabilities, such as parallel port scanning a target and pausing and resuming
    a scan. It will also have a web GUI that we can use to conduct our scans.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的端口扫描器将基于Nmap构建，具有额外的功能和能力，例如并行端口扫描目标，暂停和恢复扫描。它还将具有一个Web GUI，我们可以用来进行扫描。
- en: 'Let''s take a look at the various properties of Nmap:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Nmap的各种属性：
- en: 'The following screenshot shows the different scan techniques that are available
    with Nmap:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了Nmap可用的不同扫描技术：
- en: '![](img/bc202233-ec7a-4cf2-9f45-f460cbf1989f.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc202233-ec7a-4cf2-9f45-f460cbf1989f.png)'
- en: 'The following screenshot shows host discovery and port specification, along
    with some examples:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了主机发现和端口规范，以及一些示例：
- en: '![](img/6d0cc2a1-1a99-4b91-a955-7c716b98e2b4.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d0cc2a1-1a99-4b91-a955-7c716b98e2b4.png)'
- en: 'The following screenshot shows service and version detection and OS detection,
    along with some examples:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了服务和版本检测以及操作系统检测，以及一些示例：
- en: '![](img/0916b622-58df-43d6-8352-47abde235a89.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0916b622-58df-43d6-8352-47abde235a89.png)'
- en: 'The following screenshot shows the timing and performance, along with some
    examples:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了时间和性能，以及一些示例：
- en: '![](img/2c977b22-4f6f-4759-a377-2f524a871ce2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c977b22-4f6f-4759-a377-2f524a871ce2.png)'
- en: 'The following screenshot shows NSE scripts, along with some examples:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了NSE脚本以及一些示例：
- en: '![](img/65ff3c58-e849-4150-adf9-d23d42e34175.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65ff3c58-e849-4150-adf9-d23d42e34175.png)'
- en: 'The following screenshot shows Firewall/IDS evasion and spoofing, along with
    some examples:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了防火墙/IDS回避和欺骗，以及一些示例：
- en: '![](img/73d765cb-3e08-4f16-8897-5b8e5440adb1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73d765cb-3e08-4f16-8897-5b8e5440adb1.png)'
- en: 'The following screenshot shows some helpful Nmap output examples:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了一些有用的Nmap输出示例：
- en: '![](img/d133fd74-18da-4b31-931c-965053f0e6fb.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d133fd74-18da-4b31-931c-965053f0e6fb.png)'
- en: The preceding screenshots provide a comprehensive list of the Nmap commands
    that we frequently use in our day-to-day operations. We will not be covering how
    to run Nmap commands on the Terminal, as it is assumed that this is straightforward.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图提供了我们在日常操作中经常使用的Nmap命令的全面列表。我们将不会涵盖如何在终端上运行Nmap命令，因为这被认为是直接的。
- en: It should be noted that, from now on, we will be using Kali Linux as our pen-test
    lab OS. All the Python automation that we will see will therefore be implemented
    on the Kali Linux box. To install a Kali Linux VM/VirtualBox image, please refer
    to [https://www.osboxes.org/Kali-linux/](https://www.osboxes.org/Kali-linux/).
    To download VirtualBox, refer to [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    Once downloaded, perform the steps shown in the following screenshots.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，从现在开始，我们将使用Kali Linux作为我们的渗透测试实验室操作系统。因此，我们将在Kali Linux上实施所有Python自动化。要安装Kali
    Linux VM/VirtualBox镜像，请参考[https://www.osboxes.org/Kali-linux/](https://www.osboxes.org/Kali-linux/)。要下载VirtualBox，请参考[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。下载后，执行以下截图中显示的步骤。
- en: 'First, enter a Name for the new virtual machine along with the Type and Version;
    in our case, this is Linux and Debian (64-bit). After that, allocate the memory
    size:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入新虚拟机的名称，类型和版本；在我们的案例中，这是Linux和Debian（64位）。之后，分配内存大小：
- en: '![](img/8660a60c-33a3-4bbd-a4ae-89f264016990.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8660a60c-33a3-4bbd-a4ae-89f264016990.png)'
- en: 'Next, choose the virtual hard disk file, as shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择虚拟硬盘文件，如下截图所示：
- en: '![](img/fb56c950-1a2e-40aa-b206-c3316e593f3e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb56c950-1a2e-40aa-b206-c3316e593f3e.png)'
- en: Building a network scanner with Python
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python构建网络扫描器
- en: 'Now that we are all set up with our VirtualBox image, let''s have a look at
    a simple Python script that will help us to call Nmap and initiate a scan. Later
    on, we will optimize this script to make it better. We will finish by making it
    a full-fledged port scanning Python engine with pause, resume, and multiprocessing
    abilities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了VirtualBox镜像，让我们来看一个简单的Python脚本，它将帮助我们调用Nmap并启动扫描。稍后，我们将优化此脚本以使其更好。最后，我们将使其成为一个功能齐全的端口扫描Python引擎，具有暂停，恢复和多进程能力：
- en: '![](img/f39d287f-fe41-46e2-9472-e1905e658275.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f39d287f-fe41-46e2-9472-e1905e658275.png)'
- en: The information produced by the preceding script is hard for the Python code
    to filter and store. If we want to store all the open ports and services in a
    dictionary, it would be hard to do that with the preceding method. Let's think
    about another way in which the information produced can be parsed and processed
    by the script. We know that the `oX` flag is used to produce output in XML format.
    We will use the `oX` flag to convert the XML string to a Python dictionary as
    shown in the following sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面脚本产生的信息对Python代码来说很难过滤和存储。如果我们想要将所有打开的端口和服务存储在字典中，使用前面的方法会很困难。让我们考虑另一种方法，可以解析并处理脚本产生的信息。我们知道`oX`标志用于以XML格式生成输出。我们将使用`oX`标志将XML字符串转换为Python字典，如下节所示。
- en: Controlling the Nmap output with the script
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本控制Nmap输出
- en: 'In the following example, we reused the same concepts that we studied earlier.
    We redirected the Nmap output in XML format to the screen. We then collected the
    output produced as a string and used the `import xml.Etree.elementTree` Python
    module as `ET` in order to convert the XML output to Python dictionaries. Using
    the following code, we can control Nmap using our program and filter out all the
    useful information:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们重复使用了之前学习的相同概念。我们将Nmap输出重定向为XML格式显示在屏幕上。然后，我们将产生的输出作为字符串收集起来，并使用`import
    xml.Etree.elementTree` Python模块作为`ET`，以将XML输出转换为Python字典。使用以下代码，我们可以使用我们的程序控制Nmap并过滤出所有有用的信息：
- en: '![](img/642b97d5-7cb5-4089-aaa2-186d75977dbc.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/642b97d5-7cb5-4089-aaa2-186d75977dbc.png)'
- en: 'We can then store that information in database tables:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这些信息存储在数据库表中：
- en: '![](img/18f9a7f3-34e3-4fe4-a586-cca99832a8a4.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18f9a7f3-34e3-4fe4-a586-cca99832a8a4.png)'
- en: 'Next, run the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although the preceding method is good, and gives us granular control over Nmap
    output, it involves processing and parsing code that we may not want to write
    every time we conduct a scan with Nmap. An alternative and better approach is
    to use Python's built-in Nmap wrapper module. We can install Python's Nmap module
    with `pip install`, and it does pretty much the same as what we did before, but
    allows us to avoid writing all the processing and subprocessing logic. It keeps
    the code clean and more readable. Whenever we wish to have more granular control,
    we can always fall back to the preceding approach.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的方法很好，并且让我们对Nmap输出有细粒度的控制，但它涉及处理和解析代码，这可能是我们每次使用Nmap进行扫描时都不想编写的。另一种更好的方法是使用Python内置的Nmap包装模块。我们可以使用`pip
    install`安装Python的Nmap模块，它几乎与我们之前做的事情一样，但允许我们避免编写所有处理和子处理逻辑。这使得代码更清晰、更可读。每当我们希望有更细粒度的控制时，我们总是可以回到前面的方法。
- en: Using the Nmap module to conduct Nmap port scanning
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nmap模块进行Nmap端口扫描
- en: 'Let''s now go ahead and install the Python Nmap module as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续安装Python Nmap模块，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command will install the `Nmap` utility. The following section
    provides an overview as to how the library can be used:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将安装`Nmap`实用程序。以下部分提供了有关如何使用该库的概述：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This gives a quick start to an excellent utility written by Alexandre Norman.
    More details of this module can be found at [https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-nmap/).
    We will be using the same module in order to conduct parallel port scanning with
    Nmap with the additional capabilities of pausing and resuming the scans.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这为Alexandre Norman编写的出色实用程序提供了一个快速入门。有关此模块的更多详细信息，请访问[https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-nmap/)。我们将使用相同的模块来进行Nmap的并行端口扫描，并具有暂停和恢复扫描的附加功能。
- en: Objective and architectural overview
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标和架构概述
- en: Before we get into granular code details, its important for us to understand
    what are we doing and why are we doing it. Nmap, by default, is very powerful
    and has tons of capabilities. In a typical network pen test using OS tools, the
    methodology adapted is to employ Nmap for port scanning to get open ports, the
    services running, and the service versions. Based on the port scanning results,
    a tester usually uses various service scanning scripts to get the service versions
    and the CVE IDs associated (if there are any) and then, in turn, based on these,
    a tester can use Metasploit to exploit the vulnerabilities. For service scanning,
    a tester uses various open source technologies, such as NSE, Ruby, Python, Java,
    bash scripts, or tools such as Metasploit, w3af, nikto, Wireshark, and so on.
    The whole cycle forms a process that needs to be followed every time, but it is
    very disintegrated. The idea we are trying to present here is that, in the following
    section, we will orchestrate all the activities a pen tester needs to perform
    and automate all of them with the help of Python, such that all the tools and
    scripts required to be run can be preconfigured and run all in one go. Not only
    are we just orchestrating and automating the activities, but we are also making
    the code optimized to make use of multiprocessing and multithreading to reduce
    the scan time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码细节之前，重要的是我们理解我们在做什么以及为什么这样做。默认情况下，Nmap非常强大并且具有大量功能。在使用操作系统工具进行典型的网络渗透测试时，采用的方法是使用Nmap进行端口扫描以获取打开的端口、运行的服务和服务版本。根据端口扫描结果，测试人员通常使用各种服务扫描脚本来获取服务版本和相关的CVE
    ID（如果有的话），然后再根据这些，测试人员可以使用Metasploit来利用这些漏洞。对于服务扫描，测试人员使用各种开源技术，如NSE、Ruby、Python、Java、bash脚本，或者诸如Metasploit、w3af、nikto、Wireshark等工具。整个周期形成了一个需要每次遵循的流程，但它非常分散。我们在这里尝试提出的想法是，在接下来的部分中，我们将编排渗透测试人员需要执行的所有活动，并使用Python自动化所有这些活动，以便所有需要运行的工具和脚本都可以预先配置并一次性运行。我们不仅仅是编排和自动化活动，还使代码优化以利用多进程和多线程来减少扫描时间。
- en: 'The architecture of the code can be bifurcated into the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的架构可以分为以下几部分：
- en: Port scanning (service/port discovery)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口扫描（服务/端口发现）
- en: Service scanning
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务扫描
- en: Port scanning
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口扫描
- en: 'The port scanning part refers to how we are going to implement it in our Python
    code. The idea is to use a combination of threading and multiprocessing. If we
    want 10 hosts to be scanned, we will break it into 5 batches. Each batch has two
    hosts (the batch size can be increased depending upon the RAM and processor capabilities
    of your lab machine). For a four-core processor and 2 GB RAM, the batch size should
    be 2. At any one time, we will process one batch and dedicate a single thread
    to each host. For this reason, two threads will be running in parallel to scan
    two hosts. Once a host is dedicated to a thread, the thread will pick the port
    range for that host to be scanned (let''s say it''s between 1 and 65535). Instead
    of scanning the ports sequentially, the logic is to break the whole range into
    three chunks, each of a size of 21,845\. Now, the three chunks of a single host
    are scanned in parallel. If the number of processor cores is higher, the chunk
    size can be increased. For a four-core processor and 2 GB RAM, three chunks are
    recommended:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描部分是指我们将如何在Python代码中实现它。想法是使用线程和多进程的组合。如果我们想要扫描10个主机，我们将把它分成5个批次。每个批次有两个主机（批次大小可以根据实验室机器的RAM和处理器能力增加）。对于四核处理器和2GB
    RAM，批次大小应为2。在任何时候，我们将处理一个批次，并为每个主机分配一个单独的线程。因此，将有两个线程并行运行，扫描两个主机。一旦一个主机被分配给一个线程，线程将选择要扫描该主机的端口范围（假设在1到65535之间）。逻辑不是顺序扫描端口，而是将整个范围分成三个大小为21,845的块。现在，单个主机的三个块并行扫描。如果处理器核心数量更多，块大小可以增加。对于四核处理器和2GB
    RAM，建议使用三个块：
- en: '![](img/43439e13-237b-41cd-9532-19de6878b022.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43439e13-237b-41cd-9532-19de6878b022.png)'
- en: To summarize, hosts are broken into batches with a batch size of 2 and are dedicated
    to a single host. Further ports are broken into chunks and a multiprocessing process
    is dedicated to scan each chunk such that port scanning happens in parallel. Thus,
    at any one time, two threads and six processes will be running for a port scanning
    activity. If the user wants to pause the scan, they can use *Ctrl* + *C *at the
    Terminal window to pause. When they rerun the code, they will be prompted with
    the option of launching a new scan or resuming an earlier paused scan.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，主机被分成大小为2的批次，并专门用于单个主机。进一步的端口被分成块，并且一个多进程过程被专门用于扫描每个块，使得端口扫描可以并行进行。因此，在任何时候，将有两个线程和六个进程用于端口扫描活动。如果用户想要暂停扫描，他们可以在终端窗口使用*Ctrl*
    + *C*来暂停。当他们重新运行代码时，他们将被提示选择启动新的扫描或恢复先前暂停的扫描。
- en: Service scanning
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务扫描
- en: When the port scanning activity is over, we save all the results in our MySQL
    database table. Depending on the service discovered, we have a configured list
    of scripts that we need to execute if a specific service is found. We use a JSON
    file to map the service and the corresponding scripts to execute. A user is prompted
    with the port scanning results and is given the option to reconfigure or change
    the results if needed, to reduce false positives. Once the final configuration
    is set, service scanning is started. We pick one host at a time from the database
    and, based on the services discovered, read the appropriate scripts from the JSON
    file, execute them for this particular host, and save the results in the database.
    This continues until all the hosts are scanned for their services. Finally, an
    HTML report is produced that contains the formatted results and screenshots to
    attach to **proof of concept (POC)** reports.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当端口扫描活动结束时，我们将所有结果保存在我们的MySQL数据库表中。根据发现的服务，我们有一个配置好的脚本列表，如果找到特定的服务，我们需要执行这些脚本。我们使用JSON文件来映射服务和相应的脚本以执行。用户将得到端口扫描结果，并有选择重新配置或更改结果的选项，以减少误报。一旦最终配置完成，服务扫描就开始了。我们从数据库中逐个选择一个主机，并根据发现的服务，从JSON文件中读取适当的脚本，为这个特定的主机执行它们，并将结果保存在数据库中。这将持续到所有主机的服务都被扫描。最后，生成一个包含格式化结果和屏幕截图的HTML报告，以附加到概念验证（POC）报告中。
- en: 'The following is an architectural diagram of service scanning:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 服务扫描的架构图如下：
- en: '![](img/d773d881-a6d1-49a6-8553-07c81a5aed82.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d773d881-a6d1-49a6-8553-07c81a5aed82.png)'
- en: 'The following screenshot depicts how the JSON file is configured to execute
    the scripts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了JSON文件如何配置以执行脚本：
- en: '![](img/0c8f1abe-7e5b-4057-a877-13af911e8717.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8f1abe-7e5b-4057-a877-13af911e8717.png)'
- en: 'As can be seen in the preceding screenshot, there are various categories of
    commands that are placed in the JSON file. The Metasploit template shows the commands
    that are used to execute the Metasploit modules. Single-line commands are used
    to execute NSE scripts and all modules or scripts that are not interactive. The
    other categories include `interactive_commands` and `single_line_sniffing`, which
    is where we need to sniff the traffic along with executing the scripts. The general
    template of the JSON file is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，JSON文件中有各种类别的命令。Metasploit模板显示了用于执行Metasploit模块的命令。单行命令用于执行NSE脚本和所有非交互式的模块或脚本。其他类别包括`interactive_commands`和`single_line_sniffing`，在这里我们需要嗅探流量并执行脚本。JSON文件的一般模板如下：
- en: '![](img/705fd705-0c7b-48aa-b505-cf34c0fb0b9d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/705fd705-0c7b-48aa-b505-cf34c0fb0b9d.png)'
- en: The key is the name of the service. The title has the file description. The `method_id`
    is the actual Python method that should be invoked to call the external script
    that is to be executed. Note that for single-line commands, we also specify a
    timeout parameter in seconds as the first argument under the `args` parameter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 键是服务的名称。标题有文件描述。`method_id`是应调用的实际Python方法，以调用要执行的外部脚本。请注意，对于单行命令，我们还在`args`参数下的第一个参数中指定了以秒为单位的超时参数。
- en: A closer look at the code
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的更详细查看
- en: 'Let''s take a look at an overview of the essential files and methods that we
    will use to build our network scanner using Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们将使用Python构建网络扫描器所需的基本文件和方法的概述：
- en: '`Driver_main_class.py`: This is the Python class, file, or module that prompts
    the user for input information such as the project name, the IP addresses to scan,
    the port range to scan, the scan switch to use, and the scan type.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver_main_class.py`：这是提示用户输入信息的Python类、文件或模块，例如项目名称、要扫描的IP地址、要扫描的端口范围、要使用的扫描开关和扫描类型。'
- en: '`main_class_based_backup.py`: This is the Python class, file, or module that
    contains all the main logic for port scanning that we discussed previously. It
    takes an input from `Driver_main_class.py` and stores the input in the database.
    Finally, it starts port scanning on our targets using threading and multiprocessing.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_class_based_backup.py`：这是包含我们之前讨论的所有端口扫描主要逻辑的Python类、文件或模块。它从`Driver_main_class.py`获取输入并将输入存储在数据库中。最后，它使用线程和多进程在我们的目标上启动端口扫描。'
- en: '`Driver_scanner.py`: After port scanning is over, the next step is to perform
    service scanning and this Python class invokes another class, `driver_meta.py`,
    which takes the project name or ID for which service scanning is to be performed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver_scanner.py`：端口扫描结束后，下一步是执行服务扫描，这个Python类调用另一个类`driver_meta.py`，该类获取要执行服务扫描的项目名称或ID。'
- en: '`driver_meta.py`: This class displays the default result of the port scanning
    and gives the user the option to reconfigure the results if needed. After reconfiguration,
    this class reads the hosts from the database table for the current project for
    which service scanning is to be done. For each host, it then reads the JSON file
    to get the commands to be executed, and for each command to be executed, it passes
    on the control to another file, `auto_comamnds.py`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_meta.py`：这个类显示端口扫描的默认结果，并给用户重新配置结果的选项。重新配置后，该类从数据库表中读取当前项目的主机，为其执行服务扫描。对于每个主机，它然后读取JSON文件以获取要执行的命令，并对于要执行的每个命令，它将控制传递给另一个文件`auto_comamnds.py`。'
- en: '`auto_commands.py`: This is the file that takes arguments from `driver_meta.py`
    and calls the external technologies such as NSE, Ruby, Python, Java, bash scripts,
    or tools such as Metasploit, Wireshark, and Nikto. These are then used to perform
    service scanning for a chosen service, host, and port. After the command execution
    is over, it returns the results to `driver_meta.py` to be saved in the database.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto_commands.py`：这个文件从`driver_meta.py`获取参数，并调用外部技术，如NSE、Ruby、Python、Java、bash脚本，或者工具，如Metasploit、Wireshark和Nikto。然后用于执行所选服务、主机和端口的服务扫描。命令执行结束后，它将结果返回给`driver_meta.py`以保存在数据库中。'
- en: '`IPtable.py`: This is the class that stores the port scanning results in the
    database table. It represents the data layer of our vulnerability scanner.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPtable.py`：这是将端口扫描结果存储在数据库表中的类。它代表了我们的漏洞扫描器的数据层。'
- en: '`IPexploits.py`: This is the class that stores the service scanning results
    in the database table. It also represents the data layer of our vulnerability
    scanner.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPexploits.py`：这是将服务扫描结果存储在数据库表中的类。它还代表了我们的漏洞扫描器的数据层。'
- en: Getting started
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The whole code base can be found at the following GitHub repository. The installation
    instructions are specified on the home page. We will take a look at the sections
    of the code and that files that have the central logic to implement the scanner.
    Feel free to download the code from the repository and execute it as specified
    in the execution section. Alternatively, I have created a plug and play Kali VM
    image, which has got all the prerequisite installations and the code base out
    of the box. This can be downloaded and executed hassle-free from the URL [<https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing>](http://%3Chttps://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing%3E).
    The default username is: `PTO_root` and the password is: `PTO_root`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码库可以在以下GitHub存储库中找到。安装说明在主页上指定。我们将查看代码部分和具有实现扫描器的中心逻辑的文件。请随时从存储库下载代码并按照执行部分中指定的方式执行。或者，我创建了一个即插即用的Kali
    VM映像，其中包含所有先决条件安装和开箱即用的代码库。可以从URL[<https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing>](http://%3Chttps://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing%3E)下载并无忧地执行。默认用户名为：`PTO_root`，密码为：`PTO_root`
- en: 'As mentioned earlier, we will be discussing the central logic of the code,
    which is represented by the following code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将讨论代码的中心逻辑，该逻辑由以下代码片段表示：
- en: '![](img/906ee2de-700c-48dc-aa75-c98131399c4e.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/906ee2de-700c-48dc-aa75-c98131399c4e.png)'
- en: 'The whole class can be found at the URL [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py%3E)
    for `Driver_main_class.py`. The constructor of the class declares an object for
    the `NmapScan` class found in `main_class_based_backup.py`. The lines highlighted
    as **(1)** and **(2)** are the places where the actual logic is triggered after
    collecting all inputs, including the project name, the IPs, the port range, the
    scan switch and the scan type. Scan type 1 signifies a new scan, while scan type
    2 signifies resuming an existing scan, which would have been paused earlier. The
    `self.scanbanner()` method prompts the user to enter the Nmap scan switch that
    the user wishes to use. There are seven switch types that are most frequently
    used in day-to-day scans. The following screenshot shows the configuration file, `Nmap.cfg`,
    that has the scan switches configured:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类可以在URL[<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py%3E)找到`Driver_main_class.py`。该类的构造函数声明了在`main_class_based_backup.py`中找到的`NmapScan`类的对象。**（1）**和**（2）**标记的行是在收集所有输入后触发实际逻辑的地方，包括项目名称、IP、端口范围、扫描开关和扫描类型。扫描类型1表示新扫描，而扫描类型2表示恢复先前暂停的现有扫描。`self.scanbanner()`方法提示用户输入用户希望使用的Nmap扫描开关。有七种开关类型在日常扫描中最常用。以下截图显示了配置文件`Nmap.cfg`中配置的扫描开关：
- en: '![](img/db825a7f-52ec-40d7-a2d2-76923a5600b8.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db825a7f-52ec-40d7-a2d2-76923a5600b8.png)'
- en: 'The following code snippet represents the flow of the `main_class_based_backup.py` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段代表了`main_class_based_backup.py`类的流程：
- en: '![](img/4f7219c0-f153-451e-aa10-0381f5441da9.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f7219c0-f153-451e-aa10-0381f5441da9.png)'
- en: This screenshot represents the main `NmapScan` class. The constructor of the
    class contains various variables that we will be using throughout the execution
    flow of the class. As mentioned earlier, `IPtable` is a python class that is written
    to push the data in the backend database. The structure of the database will be
    discussed in the `db_structure` section. For now, we should understand that by
    using the MySQLdb db connector / Python module, we will push all the port scanning
    details in the backend tables via the `IPtable` class. Furthermore, `textable`
    is a Python module that is used to draw tables on the Terminal windows to represent
    data. `Simple_Logger` is a Python module that is required to log the debug and
    error messages in files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图代表了主要的`NmapScan`类。该类的构造函数包含了我们将在整个类的执行流程中使用的各种变量。如前所述，`IPtable`是一个用于将数据推送到后端数据库的Python类。数据库的结构将在`db_structure`部分讨论。目前，我们应该理解，通过使用MySQLdb
    db连接器/Python模块，我们将通过`IPtable`类将所有端口扫描的详细信息推送到后端表中。此外，`textable`是一个用于在终端窗口上绘制表格以表示数据的Python模块。`Simple_Logger`是一个用于在文件中记录调试和错误消息的Python模块。
- en: 'As we saw previously, when we looked at `Driver_main_class.py`, the actual
    execution flow starts with the `driver_main` method of the `NmapScan` class (highlighted
    in code snippets **(1)** and **(2)** of the `Driver_main_class.py` class). The
    following screenshot shows this method in more detail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，当我们查看`Driver_main_class.py`时，实际执行流程始于`NmapScan`类的`driver_main`方法（在`Driver_main_class.py`类的代码片段**(1)**和**(2)**中突出显示）。以下截图更详细地显示了这个方法：
- en: '![](img/5bfc3fe2-0ae7-4311-9419-1ed0006c3c4a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bfc3fe2-0ae7-4311-9419-1ed0006c3c4a.png)'
- en: 'The preceding code snippet is straightforward. The method receives all the
    arguments from the caller. We save the start time of the scan in a variable called start.
    The highlighted code snippet **(1)** invokes another `main` method of the same
    class and passes all the received parameters to it. This is the method where the
    port scanning for all the hosts is initiated. Once the invoked `self.main` method finishes
    its execution, as highlighted by code snippet (2), we need to check whether all
    the hosts were successfully scanned. This can be deduced from a backhand table,
    which maintains a `status_code` for all the hosts that are being scanned, referenced
    by the current project ID. If the hosts are successfully scanned, the status would
    be complete, otherwise it would be processing or incomplete. If the current project
    is not under the paused status and there are still a few hosts that have a status
    of incomplete or processing, we need to process those hosts again, which is something
    that is highlighted by code snippet (3). If the processing status is complete
    for all the hosts, we update the final project status as complete, as specified
    by the `self.IPtable.clearLogs` method. Finally, we display the execution time
    in seconds. In the next code snippet, we will take a look at the main method of
    the `NmapScan` class, which gets things running:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段很简单。该方法接收来自调用者的所有参数。我们将扫描的开始时间保存在一个名为`start`的变量中。突出显示的代码片段**(1)**调用了同一类的另一个`main`方法，并将所有接收到的参数传递给它。这是启动所有主机的端口扫描的方法。一旦调用的`self.main`方法完成执行，如代码片段(2)所示，我们需要检查所有主机是否成功扫描。这可以从一个后台表中推断出，该表维护了所有正在扫描的主机的`status_code`，由当前项目ID引用。如果主机成功扫描，状态将是complete，否则将是processing或incomplete。如果当前项目不处于暂停状态，并且仍有一些主机的状态是incomplete或processing，我们需要再次处理这些主机，这是代码片段(3)所突出显示的内容。如果所有主机的处理状态都是complete，我们将最终项目状态更新为complete，由`self.IPtable.clearLogs`方法指定。最后，我们显示执行时间（以秒为单位）。在下一个代码片段中，我们将看一下`NmapScan`类的`main`方法，让事情开始运行：
- en: '![](img/e985decc-f655-423b-a6ae-6099dce2091b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e985decc-f655-423b-a6ae-6099dce2091b.png)'
- en: The `main` method begins by checking the `scan_type`. It must be noted that
    `scan_type ="1"` means a new scan and `scan_type="2"` stands for resuming an earlier
    paused scan. The code also checks the scan mode. Note that c stands for command-line
    mode. The vulnerability scanner we are making operates in both GUI mode, which
    we will discuss later, and command-line mode. We can ignore the `g-init` and `g-start` modes
    for now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法开始检查`scan_type`。必须注意`scan_type="1"`表示新扫描，`scan_type="2"`表示恢复先前暂停的扫描。代码还检查扫描模式。注意`c`代表命令行模式。我们正在制作的漏洞扫描器在GUI模式和命令行模式下都可以操作，我们稍后会讨论。我们现在可以忽略`g-init`和`g-start`模式。'
- en: 'In line 6, the code stores the current project name in the backend database.
    The logic of the code is handled by the `self.db_projectname` method. The method
    takes the project name, stores it in a database table, returns a unique project
    ID, and stores it in class variable called `self.CURRENT_PROJECT_ID`. It also
    creates a folder called `Results_project_id` under the `Results` folder, which
    lies under the root of the parent project folder. The complete details of the
    method can be found at the following path: [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py%3E).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，代码将当前项目名称存储在后端数据库中。代码的逻辑由`self.db_projectname`方法处理。该方法接受项目名称，将其存储在数据库表中，返回一个唯一的项目ID，并将其存储在名为`self.CURRENT_PROJECT_ID`的类变量中。它还在父项目文件夹的根目录下的`Results`文件夹下创建一个名为`Results_project_id`的文件夹。该方法的完整细节可以在以下路径找到：[<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py%3E)。
- en: The code snippet highlighted as **(2)** invokes a method called `self.numofips(targethosts)`,
    which returns the length of the hosts to be scanned. If there are multiple hosts,
    they are expected to be inputted as either comma-separated (such as `192.168.250.143`,
    `192.168.250.144`) or in CIDR notation (such as `192.168.250.140/16`). If they
    are comma-separated, then `targethosts.split(',')` will split the input and return
    the list of IPs to the `listip `variable. If the notation is CIDR, code snippet
    **(3)** will translate the CIDR IP list into a native Python list of IPs and return
    the result, which will again be stored in the `listip `variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码片段**(2)**调用了一个名为`self.numofips(targethosts)`的方法，该方法返回要扫描的主机数量。如果有多个主机，它们应该被输入为逗号分隔（例如`192.168.250.143`，`192.168.250.144`）或CIDR表示法（例如`192.168.250.140/16`）。如果它们是逗号分隔的，那么`targethosts.split(',')`将分割输入并返回IP列表给`listip`变量。如果是CIDR表示法，代码片段**(3)**将把CIDR
    IP列表转换为本机Python IP列表并返回结果，结果将再次存储在`listip`变量中。
- en: 'The code snippet highlighted as **(4)** is responsible for breaking the ports
    into small chunks and storing them in the database against the current project
    ID, as we discussed previously. Let''s assume that we have two hosts to scan,
    `192.168.250.143` and `192.168.250.136`, and we want to scan the entire port range
    (from 1 to 65,535) for the hosts. In this case, the invocation of method would
    be `self.makeBulkEntries([192.168.250.143,192.168.250.136], "1-65535")`. The method
    processes the input and converts it to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码片段**(4)**负责将端口分成小块并将它们存储在数据库中，与之前讨论的当前项目ID相关。假设我们有两个要扫描的主机，`192.168.250.143`和`192.168.250.136`，并且我们想要扫描主机的整个端口范围（从1到65,535）。在这种情况下，方法的调用将是`self.makeBulkEntries([192.168.250.143,192.168.250.136],
    "1-65535")`。该方法处理输入并将其转换为以下内容：
- en: '`[[192.168.250.143,"1-21845"],[192.168.250.143,"21845-43690"],[192.168.250.143,"43690-65535"],[192.168.250.144,"1-21845"],[192.168.250.144,"21845-43690"],[192.168.250.144,"43690-65535"]].`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[192.168.250.143,"1-21845"],[192.168.250.143,"21845-43690"],[192.168.250.143,"43690-65535"],[192.168.250.144,"1-21845"],[192.168.250.144,"21845-43690"],[192.168.250.144,"43690-65535"]]`。'
- en: The preceding list is inserted in the database table as six rows, each having
    a scan status of incomplete.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表被插入到数据库表中，共有六行，每行的扫描状态为不完整。
- en: In the next line, `threading.enumurate()` returns the current number of running
    threads. It should return us a value of 1, as just the main thread is running.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，`threading.enumurate()`返回当前运行线程的数量。它应该返回一个值为1，因为只有主线程在运行。
- en: The code snippet highlighted as **(5)** calls the `startProcessing` method.
    This is the method that reads a batch of distinct hosts from the backend database
    table, where the status is incomplete. It further allocates a thread to scan these
    hosts. It must be noted that `self.N` signifies the batch size, which we have
    already discussed is 2, and is initialized in constructor of class. We can increase
    the number for a higher processor count.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码片段**(5)**调用了`startProcessing`方法。这个方法从后端数据库表中读取一批不完整状态的不同主机，然后为这些主机分配一个线程进行扫描。必须注意的是，`self.N`表示批处理大小，我们已经讨论过它是2，并且在类的构造函数中初始化。我们可以增加这个数字以获得更高的处理器数量。
- en: While the `startProcessing` method spawns threads and allocates one thread per
    unscanned host, there has to be some logic that checks when the host is scanned
    completely, such that if batch size is `2`, and 1 host is scanned, it pulls out
    another unscanned host and allocates a thread to it. The method is also required
    to check whether all the hosts are completely scanned. If this is the case, the
    scan must end. This piece of logic is handled by the `start_Polling()` method,
    as shown in the code snippet marked as **(6)**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`startProcessing`方法会生成线程并为每个未扫描的主机分配一个线程，但必须有一些逻辑来检查主机何时完全扫描，例如，如果批处理大小为`2`，并且扫描了1个主机，它会提取另一个未扫描的主机并为其分配一个线程。该方法还需要检查所有主机是否完全扫描。如果是这种情况，扫描必须结束。这段逻辑由`start_Polling()`方法处理，如标有**(6)**的代码片段所示。'
- en: The code snippet highlighted as **(7)** will invoke a method that will resume
    paused scans. It will therefore load all the project IDs of the scans that have
    a paused status. A user can select any valid project ID to resume the scan.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码片段**(7)**将调用一个方法来恢复暂停的扫描。因此，它将加载所有处于暂停状态的扫描的项目ID。用户可以选择任何有效的项目ID来恢复扫描。
- en: Finally, snippet **(8)** mentions` Start_Polling()`, which has the same function
    as discussed previously, but in this case for scans that are resumed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码片段**(8)**提到了`Start_Polling()`，它具有与之前讨论的相同功能，但在这种情况下是为恢复的扫描。
- en: 'The `startProcessing()` method shown in the following snippet simply pulls
    all the different hosts from the database table where the status is incomplete and
    places them in the native Python list `All_hosts`. For the current example, it
    will return the following list: [`192.168.250.143`, `192.168.250.144`].  After
    that, the snippet highlighted as (1) will invoke the `startThreads `method, where
    one thread will be allocated to a host:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`startProcessing()`方法简单地从数据库表中提取所有不完整状态的不同主机，并将它们放入本机Python列表`All_hosts`中。对于当前示例，它将返回以下列表：[`192.168.250.143`,
    `192.168.250.144`]。之后，高亮显示的代码片段**(1)**将调用`startThreads`方法，其中一个线程将被分配给一个主机：
- en: '![](img/9c9a7de3-73d9-40fe-b127-81948237195c.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c9a7de3-73d9-40fe-b127-81948237195c.png)'
- en: The `startThreads()` method is straightforward. We iterate over the list hosts
    and allocate a thread to each host, by invoking the `obj.simplescanner` method and
    passing the current IP list to it. The `simplescanner `method will be invoked
    two times for our current example. First, it will be invoked for Thread 1, which
    has an IP address of `192.168.250.143` and then it will be invoked for Thread
    2, which has an IP address of `192.168.250.144`. This is highlighted by snippet
    **(1)**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`startThreads()`方法很简单。我们遍历主机列表并为每个主机分配一个线程，通过调用`obj.simplescanner`方法并将当前IP列表传递给它。对于我们当前的示例，`simplescanner`方法将被调用两次。首先，它将为线程1调用，该线程具有IP地址`192.168.250.143`，然后它将为线程2调用，该线程具有IP地址`192.168.250.144`。这由代码片段**(1)**突出显示。'
- en: 'The `simpleScanner()` method is also straightforward and uses the concept of
    multiprocessing that we studied earlier. First, it  reads all the records or port
    chunks for the current host for which it is invoked. For example, when its invoked
    against host `192.168.250.143`, it reads the database rows [`[192.168.250.143,"1-21845"],
    [192.168.250.143,"21845-43690"], and [192.168.250.143,"43690-65535"]`]. After
    that, it will update the status for all of them and mark them as: processing,
    as we are about to dedicate processes that would process the port chunks. Finally,
    we iterate over the port list and invoke a multiprocessing process for the current
    IP and current port chunk, which is highlighted by section **(1)**. Going by the
    current example, we would have three parallel processes running for Thread 1 and
    three for Thread 2 as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleScanner（）`方法也很简单，使用了我们之前学习的多进程概念。首先，它读取调用它的当前主机的所有记录或端口块。例如，当它针对主机`192.168.250.143`调用时，它会读取数据库行[`[192.168.250.143，"1-21845"]，[192.168.250.143，"21845-43690"]和[192.168.250.143，"43690-65535"]`]。之后，它将更新所有这些记录的状态，并将它们标记为：处理中，因为我们将要专门处理端口块的进程。最后，我们遍历端口列表，并为当前IP和当前端口块调用多进程进程，如**（1）**部分所示。根据当前示例，我们将为Thread
    1运行三个并行进程，为Thread 2运行三个并行进程：'
- en: '`Process 1 (method = portscanner(), IP = 192.168.250.143, portx = 1-21845,
    rec_id = 100)`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程1（方法=端口扫描器（），IP=192.168.250.143，portx=1-21845，rec_id=100）
- en: '`Process 2 (method = portscanner(), IP = 192.168.250.143, portx = 21845-43690,
    rec_id = 101)`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程2（方法=端口扫描器（），IP=192.168.250.143，portx=21845-43690，rec_id=101）
- en: '`Process 3 (method = portscanner(), IP=  192.168.250.143, portx = 43690-65535,
    rec_id = 102)`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程3（方法=端口扫描器（），IP=192.168.250.143，portx=43690-65535，rec_id=102）
- en: '`Process 4 (method = portscanner(), IP = 192.168.250.144, portx = 1-21845,
    rec_id = 103)`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程4（方法=端口扫描器（），IP=192.168.250.144，portx=1-21845，rec_id=103）
- en: '`Process 5 (method = portscanner(), IP = 192.168.250.144, portx = 21845-43690,
    rec_id = 104)`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程5（方法=端口扫描器（），IP=192.168.250.144，portx=21845-43690，rec_id=104）
- en: '`Process 6 (method = portscanner(), IP = 192.168.250.144, portx = 43690-65535,
    rec_id = 105)`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程6（方法=端口扫描器（），IP=192.168.250.144，portx=43690-65535，rec_id=105）
- en: Ideally, each process would be executed on a processor core. It would be great
    to have a seven-core processor. In that case, the main program would be utilizing
    one core and the other six cores would have been distributed in parallel among
    the preceding six processes. In our case, however, we have a four-core processor,
    where one core is used by the main thread and the remaining three are shared between
    the six processes that are spawned. This will involve certain delay due to context
    switching. Also note that we are using the mp.Process utility of the multiprocessing
    library. Feel free to use the batch processing module, as we discussed in the
    previous chapters, with a batch size of 3 and see if there is any difference in
    the scan time. Finally, we want the Thread 1 thread to stay alive until all the
    host chunks are scanned, as our polling logic indicates that if a thread is finished
    then host scan is over. We therefore invoke the `join()` method on the current
    thread. This ensures that Thread 1 and Thread 2 both stay alive until all the
    processes are finished; in other words, all chunks are scanned.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个进程将在处理器核心上执行。拥有七个核心的处理器将是很棒的。在这种情况下，主程序将利用一个核心，其余六个核心将在前面的六个进程之间并行分配。然而，在我们的情况下，我们有一个四核处理器，其中一个核心被主线程使用，其余三个核心被生成的六个进程共享。这将涉及由于上下文切换而产生一定的延迟。还要注意，我们正在使用多进程库的mp.Process实用程序。请随时使用批处理模块，如我们在前几章中讨论的，批处理大小为3，看看扫描时间是否有任何差异。最后，我们希望Thread
    1线程保持活动状态，直到所有主机块都被扫描，因为我们的轮询逻辑表明，如果一个线程完成，那么主机扫描就结束了。因此，我们在当前线程上调用`join（）`方法。这确保了Thread
    1和Thread 2在所有进程完成之前都保持活动状态；换句话说，所有块都被扫描。
- en: 'The following code is self-explanatory. We are using Python''s built-in Nmap
    utility to scan a host and port chunk. If the scan is successful, we simply parse
    the results and extract the TCP and UDP results separately. After extracting the
    results, we simply save the results in the backend database table using the `self.IPtable
    .Update ()` method. We mark the status as complete and save the results for the
    ports and services which were found to be open. On the other hand, if the port
    scanning results for the port chunks and IPs returned any exceptions, we make
    three repeated attempts to carry out a scan:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是不言自明的。我们使用Python的内置Nmap实用程序来扫描主机和端口块。如果扫描成功，我们只需解析结果并分别提取TCP和UDP结果。提取结果后，我们只需使用`self.IPtable
    .Update（）`方法将结果保存在后端数据库表中。我们将状态标记为完成，并保存发现为开放的端口和服务的结果。另一方面，如果端口扫描结果和IP返回任何异常，我们将尝试进行三次重复扫描：
- en: '![](img/6c69fb2c-a863-4c03-9951-d6587f0e30d8.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c69fb2c-a863-4c03-9951-d6587f0e30d8.png)'
- en: 'After three retries, if the scan is unsuccessful, then for that record (`I`,
    `port-chunk`, `project_id`) we update the status as error-complete as shown in
    the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 经过三次重试，如果扫描不成功，那么对于该记录（`I`，`port-chunk`，`project_id`），我们将更新状态为错误完成，如下截图所示：
- en: '![](img/07daa4ad-28c8-4ce9-ab0e-368f1d2b1577.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07daa4ad-28c8-4ce9-ab0e-368f1d2b1577.png)'
- en: 'The `start_Polling` method continuously monitors the number of active threads, as
    shown in lines **(1)** and **(2)**. If it finds only one running thread, then
    it checks the backend table to see whether all hosts are marked with a status
    of complete. If there is only one running thread (`main`) and all hosts are marked
    as complete, it breaks out of the infinite polling loop. On the other hand, if
    it finds that the current number of threads running is less than the maximum permitted
    batch size, and there are few unscanned hosts left in the database table, it picks
    an unscanned host and allocates a thread to it by invoking the `startProcessing()` method.
    This is highlighted by sections **(3)** and **(4)** of the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_Polling`方法不断监视活动线程的数量，如**(1)**和**(2)**所示。如果发现只有一个正在运行的线程，然后它检查后端表，看是否所有主机都标记为`complete`状态。如果只有一个正在运行的线程（`main`）并且所有主机都标记为complete，则它会跳出无限轮询循环。另一方面，如果发现当前运行的线程数量小于最大允许的批处理大小，并且数据库表中还有一些未扫描的主机，它会选择一个未扫描的主机，并通过调用`startProcessing()`方法为其分配一个线程。这在以下代码片段的**(3)**和**(4)**部分中得到了突出显示：'
- en: '![](img/474536d9-0239-4bd0-b419-d93f3e97063f.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/474536d9-0239-4bd0-b419-d93f3e97063f.png)'
- en: 'The following code handles how to resume a paused scan. The `self.IPtable.MakeUpdate` method
    updates the status of the unscanned hosts to `incomplete`. It returns 1 when there
    were hosts that have a status of processing that are now marked as `incomplete`.
    If the scan was paused before the hosts were placed in the database table, then
    it returns a status of `2`. In this case, we are required to make the bulk entries
    again. The rest of the code is straightforward; we invoke the `startProcessing()` method
    to delegate a thread for a host to be scanned:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了如何恢复暂停的扫描。`self.IPtable.MakeUpdate`方法将未扫描主机的状态更新为`incomplete`。当有主机的状态从`processing`更改为`incomplete`时，返回1。如果在将主机放入数据库表之前扫描被暂停，则返回状态`2`。在这种情况下，我们需要重新进行批量输入。其余代码很简单；我们调用`startProcessing()`方法来委派一个线程来扫描主机：
- en: '![](img/d998a5dc-be7b-4796-a2a5-4b3f0a3a9275.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d998a5dc-be7b-4796-a2a5-4b3f0a3a9275.png)'
- en: It must be noted that in order to pause the scan we simply need to press *Ctrl*
    + *C* on the console or Terminal window. The current scan would be paused, updating
    the status appropriately in the backend database against the current project ID. It
    should also be noted that, as mentioned earlier, the methods discussed above form
    the central logic of the port scanner (portion) of our vulnerability scanner.
    The exact code has a few other functions and the details can be found at the GitHub
    repository [<https://github.com/FurqanKhan1/Dictator>](http://%3Chttps://github.com/FurqanKhan1/Dictator%3E).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，为了暂停扫描，我们只需在控制台或终端窗口上按下*Ctrl* + *C*。当前扫描将被暂停，并在后端数据库中针对当前项目ID适当地更新状态。还应该注意，正如前面提到的，上述方法构成了我们漏洞扫描器的端口扫描部分的核心逻辑。确切的代码还有一些其他功能，详细信息可以在GitHub存储库[<https://github.com/FurqanKhan1/Dictator>](http://%3Chttps://github.com/FurqanKhan1/Dictator%3E)中找到。
- en: Executing the code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行代码
- en: Before executing the code, refer to the installation and setup instructions
    at the GitHub URL [<https://github.com/FurqanKhan1/Dictator/wiki>](http://%3Chttps://github.com/FurqanKhan1/Dictator/wiki%3E).
    The installation guide also talks about how to set up the backend database and
    tables. Alternatively, you can download the plug and play VM that has everything
    installed and preconfigured.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码之前，请参考GitHub URL [<https://github.com/FurqanKhan1/Dictator/wiki>](http://%3Chttps://github.com/FurqanKhan1/Dictator/wiki%3E)上的安装和设置说明。安装指南还介绍了如何设置后端数据库和表。或者，您可以下载预先安装和预配置了所有内容的即插即用的虚拟机。
- en: 'To run the code, go to `/root/Django_project/Dictator/Dictator_Servicepath` and
    run the `driver_main_class.py` code file as `python Driver_main_class.py`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请转到`/root/Django_project/Dictator/Dictator_Servicepath`并运行`driver_main_class.py`代码文件，命令为`python
    Driver_main_class.py`：
- en: '![](img/0ef89bf7-bfcd-495b-814e-a5402aff164e.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ef89bf7-bfcd-495b-814e-a5402aff164e.png)'
- en: 'The following screenshot shows the program in the process of scanning:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了程序正在进行扫描的过程：
- en: '![](img/7db4c409-3d62-48d3-aec5-1bdeb4057460.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7db4c409-3d62-48d3-aec5-1bdeb4057460.png)'
- en: 'The following screenshot shows the log details:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了日志详情：
- en: '![](img/4feca97b-57a3-40ba-8ee2-04c02ff0ead0.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4feca97b-57a3-40ba-8ee2-04c02ff0ead0.png)'
- en: It can be seen in the preceding screenshots that for one host, three subprocesses
    were spawned and one thread was created.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到在前面的屏幕截图中，为一个主机生成了三个子进程并创建了一个线程。
- en: Database schema for the port scanning portion of the vulnerability scanner
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漏洞扫描器端口扫描部分的数据库架构
- en: 'Let''s try to understand the backend database and the structure of the various
    tables within the database that we are using. The `show databases` command is
    used to list all the databases present in MySQL:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着了解我们正在使用的后端数据库以及数据库中各种表的结构。使用`show databases`命令列出MySQL中存在的所有数据库：
- en: '![](img/33fbdd85-907e-4b6c-81b8-3713c8e0c79c.png)      ![](img/6b682cfd-471e-4e60-ba2e-16e9734fd478.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33fbdd85-907e-4b6c-81b8-3713c8e0c79c.png) ![](img/6b682cfd-471e-4e60-ba2e-16e9734fd478.png)'
- en: 'In order to use the current database, which is relevant for our vulnerability
    scanner, we use the use `nmapscan` command. Furthermore, to see all the tables
    within the current database, we use the `show tables` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用当前数据库，也就是我们的漏洞扫描器相关的数据库，我们使用`nmapscan`命令。此外，要查看当前数据库中的所有表，我们使用`show tables`命令：
- en: '![](img/34d0290a-b420-42ed-8d8e-db7f49cd82a2.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34d0290a-b420-42ed-8d8e-db7f49cd82a2.png)'
- en: 'In order for us to see the structure or schema of the table that will hold
    all the scan projects, we use the `desc project` command. To see the data of the
    project we scanned, we issue the following SQL query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看将保存所有扫描项目的表的结构或模式，我们使用`desc project`命令。要查看我们扫描的项目的数据，我们发出以下SQL查询：
- en: '![](img/bf85b82b-b7bb-41c8-ac59-d63bb1a430e7.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf85b82b-b7bb-41c8-ac59-d63bb1a430e7.png)'
- en: '`IPtable` is the table that holds the results for the port scanning results
    of our target. The following command, `desc IPtable`, shows us the schema of the
    table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPtable` 是保存我们目标端口扫描结果的表。以下命令 `desc IPtable` 显示了表的模式：'
- en: '![](img/f4848d35-8c04-4c37-8534-a8d613ca6661.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4848d35-8c04-4c37-8534-a8d613ca6661.png)'
- en: 'The following screenshot shows the data present in the `IPtable` for the current
    project, `744`. We can see that all the service scan results are placed in the
    table in CSV format:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当前项目`744`中`IPtable`中的数据。我们可以看到所有的服务扫描结果都以CSV格式放在表中：
- en: '![](img/19ce5118-42ad-4cdb-b976-1d46ee553d09.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19ce5118-42ad-4cdb-b976-1d46ee553d09.png)'
- en: 'Once the port scanning of the project is successfully finished, all the details
    of the project are moved from `IPtable` to `IPtable_history`. This is to make
    the lookup operation fast on `IPtable`. As a result, the schema of `IPtable_history`
    table would be exactly the same as IPtable. This can be verified in the following
    screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目的端口扫描成功完成，项目的所有细节都将从 `IPtable` 移动到 `IPtable_history`。这是为了在 `IPtable` 上快速进行查找操作。因此，`IPtable_history`
    表的模式将与IPtable完全相同。这可以在以下截图中验证：
- en: '![](img/ee50a4d2-fe36-4dcd-85d8-978e85dd336f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee50a4d2-fe36-4dcd-85d8-978e85dd336f.png)'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how to use Python's built-in Nmap utility to conduct
    and automate port scanning with the additional capabilities of pausing and resuming
    the scans and adding a layer of optimization using threads and multiprocessing.
    In the next chapter, we will be continuing with our vulnerability scanner, to
    understand how we can now use the port scanning results to further automate and
    orchestrate service scanning. We will also discuss a GUI version of our vulnerability
    scanner, which has tons of features and a very intuitive dashboard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用Python内置的Nmap实用程序来进行和自动化端口扫描，同时具有暂停和恢复扫描的附加功能，并使用线程和多进程添加了优化层。在下一章中，我们将继续使用我们的漏洞扫描程序，了解如何现在可以使用端口扫描结果来进一步自动化和编排服务扫描。我们还将讨论我们的漏洞扫描程序的GUI版本，它具有大量功能和非常直观的仪表板。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why are we using a combination of threads and multiprocessing to automate port
    scanning?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用线程和多进程的组合来自动化端口扫描？
- en: What can we possibly do to further optimize the throughput?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能如何进一步优化吞吐量？
- en: Is there any other Python module or library that we can use to automate Nmap?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有其他Python模块或库可以用来自动化Nmap？
- en: Can we use other scanners such as Angry-IP or Mass Scan using the same methodology?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用其他扫描程序，如Angry-IP或Mass Scan，使用相同的方法吗？
- en: Further reading
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A Python class on how to use Nmap and access scan results from `python3`: [https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-Nmap/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何使用Nmap和从`python3`访问扫描结果的Python课程：[https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-Nmap/)
- en: An Nmap tutorial:[ https://hackertarget.com/Nmap-tutorial/](https://hackertarget.com/Nmap-tutorial/)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap教程：[ https://hackertarget.com/Nmap-tutorial/](https://hackertarget.com/Nmap-tutorial/)
- en: 'Python MySQL: [https://www.w3schools.com/python/python_mysql_getstarted.asp](https://www.w3schools.com/python/python_mysql_getstarted.asp)
    and [https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python MySQL：[https://www.w3schools.com/python/python_mysql_getstarted.asp](https://www.w3schools.com/python/python_mysql_getstarted.asp)
    和 [https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/)
