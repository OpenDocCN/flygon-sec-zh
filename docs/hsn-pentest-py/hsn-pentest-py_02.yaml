- en: Building Python Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Python脚本
- en: 'This chapter will cover the core concepts of all programming languages. This
    includes conditional statements, loops, functions, and packages. We will see that
    these concepts are pretty much the same in Python as they are in other programming
    languages, except for some syntactical differences. But syntax just requires practice;
    everything else will fall into line automatically. The topics that we are going
    to cover in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖所有编程语言的核心概念。这包括条件语句、循环、函数和包。我们将看到这些概念在Python中与其他编程语言中基本相同，只是在一些语法上有所不同。但语法只需要练习；其他一切都会自动顺利进行。本章我们将要涵盖的主题如下：
- en: Conditional statements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: Loops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Modules and packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和包
- en: Comprehensions and generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和生成器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Make sure you have the following pre-requisites needed to proceed further:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你具备以下继续学习所需的先决条件：
- en: A working computer or laptop
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台工作的计算机或笔记本电脑
- en: Ubuntu OS (preferably 16.04)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu操作系统（最好是16.04）
- en: Python 3.x
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.x
- en: A working internet connection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作的互联网连接
- en: Indentation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩进
- en: If you come from a background of a language such as Java, C, or C++, you might
    be familiar with the concept of grouping logically connected statements using
    curly braces. This is not the case, however, in Python. Instead, the logically
    connected statements, including classes, functions, conditional statements, and
    loops, are grouped using indentation. Indentation keeps the code clean and easy
    to read. We shall explore this in more detail in the coming sections. For now,
    however, let's say goodbye to braces. I recommend that you use tabs for indentation,
    as typing an equal number of spaces in every line becomes very time-consuming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java、C或C++等语言的背景，你可能熟悉使用花括号来分组逻辑连接语句的概念。然而，在Python中情况并非如此。相反，逻辑连接的语句，包括类、函数、条件语句和循环，都是使用缩进来分组的。缩进可以使代码保持清晰易读。我们将在接下来的部分中更详细地探讨这一点。但现在，让我们和花括号说再见。我建议你使用制表符进行缩进，因为在每一行输入相同数量的空格会非常耗时。
- en: Conditional statements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Just like all other languages, to carry out the conditional operations, Python
    makes use of conditional statements. The conditional statements supported by Python
    are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他语言一样，Python使用条件语句来执行条件操作。Python支持的条件语句如下：
- en: '`if` condition'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`条件'
- en: '`if...else` condition'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if...else`条件'
- en: '`else...if` conditional ladder, known as `elif` in Python'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else...if`条件梯，在Python中称为`elif`'
- en: Python doesn't support the `switch` statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python不支持`switch`语句。
- en: The if condition
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if条件
- en: The `if` condition or the `if` statement takes a statement and returns either a
    Boolean `True` or a Boolean `False` value after evaluating the statement. If the
    condition returns `True`, the code proceeding the `if` statement (equally indented)
    is executed. If the statement/condition evaluates to `False`, then either the
    `else` block of code gets executed if there is one, or the block of code following
    the `if` block is executed, so the `if` block is effectively skipped. Let's take
    a look at the `if` code in action.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件或`if`语句接受一个语句，并在评估该语句后返回布尔值`True`或`False`。如果条件返回`True`，则执行`if`语句后面的代码（同样缩进）。如果语句/条件评估为`False`，那么如果有`else`代码块，则执行`else`代码块，否则执行`if`块后面的代码，因此`if`块实际上被跳过。让我们看看`if`代码的运行情况。'
- en: 'From now on, we are going to look at how scripting works. We will either be
    creating script files or carrying out exercises. For this reason, go ahead and
    create a file on gedit or any editor of your choice and name it `if_condition.py`.
    Alternatively, we can type `gedit if_condition.py` in the Terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将看一下脚本是如何工作的。我们将要么创建脚本文件，要么进行练习。因此，请继续在gedit或你选择的任何编辑器上创建一个名为`if_condition.py`的文件。或者，我们可以在终端中输入`gedit
    if_condition.py`：
- en: '![](img/aa9f2b2d-6c1e-4a9c-9f32-6256eeea1e66.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa9f2b2d-6c1e-4a9c-9f32-6256eeea1e66.png)'
- en: 'We then type the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们输入以下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in order to run this script, we can simply type `python3.5 if_condition.py`
    in the Terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了运行这个脚本，我们可以在终端中简单地输入`python3.5 if_condition.py`：
- en: '![](img/1312d095-dbf5-4364-b1b7-5b7579c8056e.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1312d095-dbf5-4364-b1b7-5b7579c8056e.png)'
- en: 'The Python `print` method by default adds `\n` to the string to be printed,
    using which we can see two outputs in different lines. Note that the syntax of
    the `if` statement is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`print`方法默认会在要打印的字符串后添加`\n`，这样我们可以看到两个不同行的输出。请注意`if`语句的语法如下：
- en: '`if <condition> : and then indented code`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`if <条件>：然后缩进的代码`'
- en: Whether or not we use brackets with the conditions is up to us. As you can see,
    the condition evaluated to `True`, so the line `a is greater` was printed. For
    `if` conditions in Python, anything that does not evaluate to zero (`0`), `False`,
    `None`, or `empty` would be treated as `True` and the code proceeding the `if`
    statement will get executed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否使用括号与条件是由我们决定的。正如你所看到的，条件评估为`True`，所以打印了`a is greater`。对于Python中的`if`条件，任何不评估为零（`0`）、`False`、`None`或`空`的东西都会被视为`True`，并且执行`if`语句后面的代码。
- en: Let's see another example of the `if` condition in conjunction with the `and...or` and `and...not`logical
    operators.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`if`条件与`and...or`和`and...not`逻辑运算符结合的另一个例子。
- en: 'Let''s create another file called `if_detailed.py` and type the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`if_detailed.py`的文件，并输入以下代码：
- en: '![](img/7c54677b-14e2-455c-9d44-5ca468c56ff8.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c54677b-14e2-455c-9d44-5ca468c56ff8.png)'
- en: 'You might have noticed that at the beginning of the file, we have a statement
    that reads `#! /usr/bin/python3.5`. This means we don''t have to type `python3.5`
    every time we execute the code. It directs the code to use the program placed
    at `/usr/bin/python3.5` to execute it every time it''s executed as an executable.
    We need to change the permissions of the file to make it executable. Do this,
    and then execute the code as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在文件的开头，我们有一个语句，写着`#! /usr/bin/python3.5`。这意味着我们不必每次执行代码时都输入`python3.5`。它指示代码使用位于`/usr/bin/python3.5`的程序来执行它，每次作为可执行文件执行时。我们需要改变文件的权限使其可执行。这样做，然后按照以下方式执行代码：
- en: '![](img/7e5e11fc-3482-487e-bb75-e91fda5623a7.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e5e11fc-3482-487e-bb75-e91fda5623a7.png)'
- en: The output produced is self-explanatory. As I mentioned before, anything that
    doesn't evaluate to `0`, `False`, `None`, or `empty` is taken as `True` and the `if`
    block is executed. This explains why the first three `if` conditions were evaluated
    to `True` and the message was printed, but the fourth message was not printed.
    From line 19 onwards, we have made use of logical operators. In Python, the conjunction
    operation is carried by the `and` operator, which is the same as `&&`, which we
    use with C, C++, and Java.  For the short circuit Boolean operator, we have the
    `or` keyword in Python, which is the same as `||` in C, C++, and Java. Finally,
    the `not` keyword provides negation in Python, as `!` does in other languages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出是不言自明的。正如我之前提到的，任何不等于`0`、`False`、`None`或`empty`的东西都被视为`True`，并且执行`if`块。这解释了为什么前三个`if`条件被评估为`True`并且消息被打印出来，但第四个消息没有被打印。从第19行开始，我们使用了逻辑运算符。在Python中，合取操作由`and`运算符执行，这与我们在C、C++和Java中使用的`&&`相同。对于短路布尔运算符，在Python中我们有`or`关键字，它与C、C++和Java中的`||`相同。最后，`not`关键字在Python中提供否定，就像其他语言中的`!`一样。
- en: It should be noted that in Python, `null` byte characters are represented by
    a reserved keyword, `None`, which is the same as `null` in languages such as Java
    or C#.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在Python中，`null`字节字符由保留关键字`None`表示，这与Java或C#等语言中的`null`相同。
- en: The if...else condition
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if...else`条件'
- en: 'The `if...else` condition is pretty much the same as in any other language.
    If the `if` condition evaluates to a `True` value, the code block indented under
    `if` is executed. Otherwise, the code block indented under the `else` block is
    executed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`条件在任何其他语言中基本上是一样的。如果`if`条件评估为`True`值，那么缩进在`if`下面的代码块将被执行。否则，缩进在`else`块下面的代码块将被执行：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create a file called `if_else.py` and see how to use it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`if_else.py`的文件，并看看如何使用它：
- en: '![](img/5599335c-aa75-4ca0-84cb-e3fc8080ee70.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5599335c-aa75-4ca0-84cb-e3fc8080ee70.png)'
- en: 'Again, the output here is self-explanatory. In this section of code, we explored
    the usage of some bitwise operators alongside the `if...else` code structure.
    We also used variables, which are to be printed with the print method. `%s` is
    a placeholder, and specifies that the value of `%s` should be replaced by a string
    variable whose value would come immaterially after the string ends. If we have
    multiple values to substitute, they can be passed as a tuple such as `%(val1,val2,val3)`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出也是不言自明的。在这段代码中，我们探讨了一些位运算符与`if...else`代码结构一起使用的情况。我们还使用了变量，这些变量将被打印出来。`%s`是一个占位符，并指定`%s`的值应该被字符串变量替换，其值将在字符串结束后立即出现。如果我们有多个值要替换，它们可以作为一个元组传递，如`%(val1,val2,val3)`：
- en: '![](img/adaa4be6-332d-470f-8ae1-b6d99a3a6bac.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adaa4be6-332d-470f-8ae1-b6d99a3a6bac.png)'
- en: The if...elif condition
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if...elif`条件'
- en: 'The `if...elif` ladder, popularly known as **if...else if** in other programming
    languages such as C, C ++, and Java, has the same function in Python. An `if`
    condition let''s us specify a condition alongside the `else` part of the code.
    Only if the condition is `true` is the section proceeding the conditional statement
    executed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...elif`梯，在其他编程语言中如C、C++和Java中被称为**if...else if**，在Python中具有相同的功能。`if`条件让我们在代码的`else`部分旁边指定一个条件。只有条件为`true`时，才会执行条件语句后面的部分：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It must be noted that the third `else` in the preceding code snippet is optional.
    Even if we don''t specify it, the code works just fine:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，前面代码片段中的第三个`else`是可选的。即使我们不指定它，代码也能正常工作：
- en: '![](img/ee775bc5-f579-4818-b1b7-e52d557c3560.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee775bc5-f579-4818-b1b7-e52d557c3560.png)'
- en: 'Let''s create a file named `if_el_if.py`, and see how this can be used:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`if_el_if.py`的文件，并看看它如何使用：
- en: '![](img/2676e133-5cb3-4a20-85c9-3a22b38122d7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2676e133-5cb3-4a20-85c9-3a22b38122d7.png)'
- en: Loops
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: '**Loops** are utilities that every programming language has. With the help
    of loops, we execute tasks or statements that are repetitive in nature, which,
    without loops, would take up lots of lines of code. This, in a way, defeats the
    purpose of having a programming language in the first place. If you are familiar
    with Java, C, or C ++, you might have already come across `while`, `for`, and
    `do...while` loops. Python is pretty much the same, except that it doesn''t support
    `do...while` loops. Thus, the loops that we are going to study in the following
    section in Python are the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**是每种编程语言都具有的实用工具。借助循环，我们可以执行重复性的任务或语句，如果没有循环，将需要大量的代码行。这在某种程度上违背了首先拥有编程语言的目的。如果你熟悉Java、C或C++，你可能已经遇到了`while`、`for`和`do...while`循环。Python基本上是一样的，只是它不支持`do...while`循环。因此，我们将在下一节中学习的Python中的循环是以下的：'
- en: '`while` loop'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: '`for` loop'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: The while loop
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'Remember that when we discussed lists in the first chapter of the book, we
    mentioned that lists can actually hold heterogeneous data types in Python. A list
    may contain integers, strings, dictionaries, tuples, or even nested lists. This
    feature makes lists very powerful and exceptionally easy and intuitive to use.
    Let''s take a look at the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们在书的第一章讨论列表时，我们提到在Python中列表实际上可以包含异构数据类型。列表可以包含整数、字符串、字典、元组，甚至是嵌套列表。这个特性使得列表非常强大，非常容易和直观地使用。让我们看下面的例子：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s take a closer look at `while` loops with the help of the following code,
    which we will call `while_loops.py`. We will also see how we can iterate over
    lists using `while` loops:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码更仔细地了解`while`循环，我们将其称为`while_loops.py`。我们还将看到如何使用`while`循环迭代列表：
- en: '![](img/0e68bc32-414c-496d-adc4-3b226d86b136.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e68bc32-414c-496d-adc4-3b226d86b136.png)'
- en: The first portion of the code, lines 2 to 6, depicts a simple usage of the `while`
    loop, where we are printing a statement five times. Note that the condition that
    is specified for the loop to be executed can be placed with or without braces,
    as shown from lines 7 to 10.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分，第2到6行，描述了`while`循环的简单用法，我们在其中打印了一个语句五次。请注意，为了执行循环指定的条件可以放在括号内或括号外，如第7到10行所示。
- en: 'In line 12, we declared a list containing numbers, strings, a float, and a
    nested list as well. Then, in the final `while` loop starting at line 14, we iterate
    over the elements of the list by setting the loop control variable to be less
    than the length of the list. Within the loop, we check for the type of the list
    variable. The `if` type (`1`) returns an integer class, type (`a`) returns a string
    class, and type (`[]`) returns a list class. When the type is a list, we iterate
    over its elements again in a nested `while` loop, and print each one, as shown
    from lines 19 to 24:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行，我们声明了一个包含数字、字符串、浮点数和嵌套列表的列表。然后，在从第14行开始的最后一个`while`循环中，我们通过将循环控制变量设置为小于列表长度来迭代列表的元素。在循环中，我们检查列表变量的类型。`if`类型(`1`)返回一个整数类，类型(`a`)返回一个字符串类，类型(`[]`)返回一个列表类。当类型是列表时，我们再次在嵌套的`while`循环中迭代它的元素，并打印每一个，如第19到24行所示：
- en: '![](img/10ea76e3-b448-4f3b-83b1-94ab2fb0b198.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10ea76e3-b448-4f3b-83b1-94ab2fb0b198.png)'
- en: The for loop
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: The `for` loop is very widely used in Python, and it's the default choice whenever
    we have to iterate over an inalterable list. Before moving forward with the `for`
    loop, let's take a closer look at what the terms **iteration**, **iterable**,
    and **iterator** mean in Python.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在Python中被广泛使用，每当我们需要迭代不可改变的列表时，它都是默认选择。在继续使用`for`循环之前，让我们更仔细地了解Python中的**迭代**、**可迭代**和**迭代器**这些术语的含义。'
- en: Iteration, iterable, and iterator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代、可迭代和迭代器
- en: '**Iteration**: An iteration is a process wherein a set of instructions or structures
    are repeated in a sequence a specified number of times or until a condition is
    met. Each time the body of a loop executes, it''s said to complete one iteration.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代**：迭代是一个过程，其中一组指令或结构按顺序重复指定次数，或直到满足条件。每次循环体执行时，都称为完成一次迭代。'
- en: '**Iterable**: An iterable is an object that has an `__iter__` method, which
    returns an iterator. An iterator is any object that contains a sequence of elements
    that can be iterated over, and then an operation can be performed. Python strings,
    lists, tuples, dictionaries, and sets are all iterables as they implement the
    `__iter__` method. Take a look at the following snippet to see an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代**：可迭代是一个具有`__iter__`方法的对象，它返回一个迭代器。迭代器是任何包含可以迭代的元素序列的对象，然后可以执行操作。Python字符串、列表、元组、字典和集合都是可迭代的，因为它们实现了`__iter__`方法。看下面的代码片段，看一个例子：'
- en: '![](img/519d23b0-3a68-4990-8bdc-a9ab679251bb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/519d23b0-3a68-4990-8bdc-a9ab679251bb.png)'
- en: 'In the preceding code snippet, we declare a string `a` and place the value
    `hello` value in it. To see all the built-in methods of any object in Python,
    we can use the `dir(<object>)` method. For strings, this returns us all the operations
    and methods that can be carried out on the string type. In the second row, the
    5th operation is the `iter` method we mentioned previously. It can be seen that `iter(a)`
    returns a string iterator:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了一个字符串`a`，并将值`hello`放入其中。要查看Python中任何对象的所有内置方法，我们可以使用`dir(<object>)`方法。对于字符串，这将返回可以在字符串类型上执行的所有操作和方法。在第二行，第5个操作是我们之前提到的`iter`方法。可以看到`iter(a)`返回一个字符串迭代器。
- en: '![](img/a0a1f01f-e979-4f87-978e-bad863fc3fa3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0a1f01f-e979-4f87-978e-bad863fc3fa3.png)'
- en: Likewise, a list object's `iter` method would return a list iterator, as previously
    shown.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，列表对象的`iter`方法将返回一个列表迭代器，如前所示。
- en: '**Iterator**: An iterator is an object with a `__next__` method. The next method
    always returns the `next` element of the sequence over which the original `iter()`
    method is called, starting from index 0\. This is shown in the following code
    snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**：迭代器是一个具有`__next__`方法的对象。`next`方法始终返回调用原始`iter()`方法的序列的`next`元素，从索引0开始。下面的代码片段中展示了这一点：'
- en: '![](img/56b3b03d-3e4d-46ed-9c14-5e7635670261.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56b3b03d-3e4d-46ed-9c14-5e7635670261.png)'
- en: 'As can be seen in the examples for both string and list, the `next` method
    over the iterator will always return us the `next` element in the sequence or
    the object that we are iterating over. It must be noted that the iterator only
    moves forwards, and if we want `iter_a` or `list_itr` to go back to any element,
    we must reinitialize the iterator to the original object or sequence:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在字符串和列表的示例中所看到的，迭代器上的`next`方法总是返回我们迭代的序列或对象中的`next`元素。必须注意的是，迭代器只能向前移动，如果我们想让`iter_a`或`list_itr`返回到任何元素，我们必须重新将迭代器初始化为原始对象或序列：
- en: '![](img/debc073b-944c-415d-8025-4aad8c31828f.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/debc073b-944c-415d-8025-4aad8c31828f.png)'
- en: A closer look at for loops
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更仔细地看一下for循环
- en: 'The `for` loops in Python exceed the capabilities of `for` loops in other programming
    languages. When calling upon iterables such as strings, tuples, lists, sets, or
    dictionaries, the `for` loop internally calls the `iter` to get an iterator. Then,
    it calls the `next` method over that iterator to get the actual element in the
    iterable. It then calls next repeatedly until a `StopIteration` exception is raised,
    which it would internally handle and get us out of the loop. The syntax of the `for`
    loop is given as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`for`循环超出了其他编程语言中`for`循环的能力。当调用诸如字符串、元组、列表、集合或字典等可迭代对象时，`for`循环内部调用`iter`来获取迭代器。然后，它调用`next`方法来获取可迭代对象中的实际元素。然后，它重复调用next直到引发`StopIteration`异常，然后它会在内部处理并将我们从循环中取出。`for`循环的语法如下所示：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s create a file called `for_loops.py`, which will explain the basic use
    of `for` loops:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`for_loops.py`的文件，它将解释`for`循环的基本用法：
- en: '![](img/21f3c53c-8026-4eb0-89c2-584610aaf3bd.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21f3c53c-8026-4eb0-89c2-584610aaf3bd.png)'
- en: 'In the preceding example, we used the Python range function/method, which helps
    us implement the traditional `for` loop that we learnt in other programming languages
    such as C, C ++, or Java. This might look like `for i =0 ;i < 5 ;i ++`. The range
    function in Python takes one mandatory argument and two default ones. The mandatory
    argument specifies the limit of the iteration and, starting from index `0`, returns
    numbers until it reaches the limit, as seen in lines 3 and 4 of the code. When
    invoked with two arguments, the first one serves as the starting point of the
    range and the last one serves as the end point, as is depicted in lines 7 and
    8 of our code. Finally, when the `range` function is invoked with three arguments,
    the third one serves as the step size, which is equal to one by default. This
    is depicted in the following output and lines 12 and 13 of the sample code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了Python的range函数/方法，它帮助我们实现了传统的`for`循环，我们在其他编程语言（如C、C++或Java）中学到的。这可能看起来像`for
    i =0 ;i < 5 ;i ++`。Python中的range函数需要一个必需参数和两个默认参数。必需参数指定迭代的限制，并且从索引`0`开始，返回数字，直到达到限制，就像代码的第3和第4行所示的那样。当使用两个参数调用时，第一个参数作为范围的起点，最后一个作为终点，就像我们代码的第7和第8行所示的那样。最后，当使用三个参数调用`range`函数时，第三个参数作为步长，默认为1。这在下面的输出和示例代码的第12和第13行中显示：
- en: '![](img/52eaf92b-b027-400f-ad61-adc8931dae46.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52eaf92b-b027-400f-ad61-adc8931dae46.png)'
- en: 'Let''s take a look at another example of a `for` loop, which we shall use to
    iterate over all the iterables that Python defines. This will allow us to explore
    the real power of `for` loops. Let''s create a file called `for_loops_ad.py`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个`for`循环的例子，我们将用它来迭代Python定义的所有可迭代对象。这将使我们能够探索`for`循环的真正威力。让我们创建一个名为`for_loops_ad.py`的文件：
- en: '![](img/5899a34e-3c43-477a-b13b-b2fe50d1e557.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5899a34e-3c43-477a-b13b-b2fe50d1e557.png)'
- en: 'Earlier, we saw how we can read the values from lists, strings, and tuples.
    In the preceding example, we use the `for` loop to enumerate over strings, lists,
    and dictionaries. We learned earlier that the `for` loop actually invokes the
    `iter` method of iterables and then calls the `next` method for each iteration.
    This is shown in the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何从列表、字符串和元组中读取值。在前面的示例中，我们使用`for`循环枚举字符串、列表和字典。我们之前了解到，`for`循环实际上调用可迭代对象的`iter`方法，然后为每次迭代调用`next`方法。这在下面的示例中显示：
- en: '![](img/c6c41da0-de0e-4976-9ac5-55a9dea1ab52.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6c41da0-de0e-4976-9ac5-55a9dea1ab52.png)'
- en: When we iterate over Python dictionaries using a `for` loop, by default, the
    dictionary keys are returned to us. When we use `.items()` over dictionaries,
    it returns us a tuple each time we iterate over it, with the key at 0^(th) index
    of the tuple and the value at the first index.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`for`循环迭代Python字典时，默认情况下会将字典键返回给我们。当我们在字典上使用`.items()`时，每次迭代都会返回一个元组，其中键在元组的第0个索引处，值在第一个索引处。
- en: Functions and methods in Python
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的函数和方法
- en: Functions and methods are used to design or make a logical unit of code that
    can be reused throughout the course of your script or other scripts. Functions
    actually form the basis of code reuse and bring modularity to the code structure.
    They keep the code clean and easier to modify.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法用于设计或制作可以在脚本或其他脚本的整个过程中重复使用的逻辑代码单元。函数实际上构成了代码重用的基础，并为代码结构带来了模块化。它们使代码更清晰，更容易修改。
- en: It is advisable to always try to break our logic into small units of code, each
    of which is a function. We should try to keep the size of the method small in
    terms of the lines of code whenever possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们总是尝试将逻辑分解为小的代码单元，每个单元都是一个函数。我们应该尽量保持方法的大小在代码行方面尽可能小。
- en: 'The following code represents the basic syntax of defining methods in Python:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码代表了在Python中定义方法的基本语法：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Python methods do not have a return type in their definition as you might have
    seen in C, C++, or Java, such as `void`, `in`, `float`, and so on. A Python method
    may or may not return a value, but we do not explicitly need to specify that.
    Methods are very powerful and flexible in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python方法在其定义中没有返回类型，就像您在C、C++或Java中看到的那样，例如`void`、`in`、`float`等。Python方法可能返回值，也可能不返回值，但我们不需要明确指定。方法在Python中非常强大和灵活。
- en: It should be noted that the default name of every Python script is `main` and
    that this is placed inside a global variable that is accessible throughout the
    Python context called `__name__`. We shall use this in the coming example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到每个Python脚本的默认名称是`main`，并且它被放置在一个全局变量中，可以在整个Python上下文中访问，称为`__name__`。我们将在接下来的示例中使用它。
- en: 'Let''s explore the various ways of invoking methods using our `method_basics.py` script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用我们的`method_basics.py`脚本调用方法的各种方式：
- en: '![](img/6433781e-b3c0-4444-ac77-972cb6a9b54e.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6433781e-b3c0-4444-ac77-972cb6a9b54e.png)'
- en: 'Let''s now break this down into smaller pieces and try to understand what has
    happened:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其分解成更小的部分，并尝试理解发生了什么：
- en: '`print_msg1()`: This is a basic method that just prints a string on the console.
    It is defined at line 2 and invoked at line 19.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg1()`: 这是一个基本的方法，只是在控制台上打印一个字符串。它在第2行定义，在第19行调用。'
- en: '`print_msg2()`: This is a method that takes an argument in the variable message
    and then prints that variable value on the screen. Remember that Python variables
    do not require a type to be specified, so we can pass any data to the `message` variable.
    This is a Pythonic example of a method that takes a single argument. Remember
    that the type of the argument is a Python object and it can take any value passed
    to it. The output can be seen in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg2()`: 这是一个方法，接受变量消息作为参数，然后在屏幕上打印该变量的值。请记住，Python变量不需要指定类型，因此我们可以将任何数据传递给`message`变量。这是一个接受单个参数的Python方法的示例。请记住，参数的类型是Python对象，它可以接受传递给它的任何值。输出可以在以下截图中看到：'
- en: '![](img/f707b6e8-aff7-4cf9-99f6-05cf4084806f.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f707b6e8-aff7-4cf9-99f6-05cf4084806f.png)'
- en: '`print_msg3()`: This is a Python method that takes two arguments. It is similar
    to the `print_msg2()` method that we saw previously. The difference is that it
    may sometimes return a value. It is also invoked differently. Note that in line
    22, we invoke this method by passing the second parameter as `True`. This means
    it has a return value of `True`, but we do not invoke it with `True` as a second
    parameter in line 26, so it therefore returns nothing. For this reason, we get
    `None` printed on the screen. In other programming languages, such as C, C++,
    or Java, the order of parameters while invoking the method is very important.
    This is because the sequence with which we passed the argument should be the same
    sequence that is passed to the method. In Python, however, we can invoke the methods
    and pass the named parameters during invocation. This means that the order or
    sequence doesn''t matter, as long as the name matches the name of the method parameter.
    This is depicted in line 29, where we are passing a message as a second parameter,
    even though it is the first parameter in the method definition. This works perfectly,
    as shown in the output.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg3()`: 这是一个Python方法，接受两个参数。它类似于我们之前看到的`print_msg2()`方法。不同之处在于它有时可能会返回一个值。它的调用方式也不同。请注意，在第22行，我们通过将第二个参数传递为`True`来调用此方法。这意味着它返回一个值为`True`，但是我们在第26行不使用`True`作为第二个参数调用它，因此它不返回任何值。因此，我们在屏幕上得到`None`。在其他编程语言中，如C、C++或Java，调用方法时参数的顺序非常重要。这是因为我们传递参数的顺序应该与传递给方法的顺序相同。然而，在Python中，我们可以调用方法并在调用过程中传递命名参数。这意味着顺序并不重要，只要名称与方法参数的名称匹配即可。这在第29行中得到了体现，我们将消息作为第二个参数传递，即使它在方法定义中是第一个参数。这样做完全有效，如输出所示。'
- en: '`print_msg4()`: This is where we get familiar with Python default parameters
    and how they can be used with methods. A default parameter is a variable that
    is assigned a default value while a method is declared. If the caller passes on
    a value for this parameter or variable, then the default value is overwritten
    by the value passed by the caller. If no value is passed for the default parameter
    during invocation, then the variable persists the default value to which it was
    initialized. The `print_msg4()` method has got one mandatory argument, `m`, and
    two optional  arguments, `op1` and `op2`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4()`: 这是我们熟悉Python默认参数以及它们如何与方法一起使用的地方。默认参数是在声明方法时分配默认值的变量。如果调用者为此参数或变量传递了一个值，则默认值将被调用者传递的值覆盖。如果在调用过程中没有为默认参数传递值，则变量将保持其初始化的默认值。`print_msg4()`方法有一个必填参数`m`，和两个可选参数`op1`和`op2`。'
- en: '`print_msg4(''Test Mandatory'')`: This is invoked at line 31\. This indicates
    that the `Test mandatory` string should be passed for the mandatory parameter
    and the other two `op1` and `op2` variables will be initialized to the default
    values, as seen in the output.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4(''Test Mandatory'')`: 这在第31行被调用。这表示必填参数应传递`Test mandatory`字符串，另外两个`op1`和`op2`变量将被初始化为默认值，如输出所示。'
- en: '`print_msg4(1,2)`: This is invoked at line 32\. This indicates that an integer
    with `value=1` should be passed for the mandatory parameter and another integer
    with `value=2` should be passed for `op1`. The default value will therefore be
    overwritten for `op1`. `op2` will retain the default value, as no value is passed.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4(1,2)`: 这在第32行被调用。这表示必填参数应传递一个带有`value=1`的整数，另一个带有`value=2`的整数应传递给`op1`。因此，`op1`的默认值将被覆盖。`op2`将保留默认值，因为没有传递值。'
- en: '`print_msg4(2,3,2)`: This is invoked at line 33\. This indicates that an integer
    with `value=2` should be passed for the mandatory parameter and another integer
    with `value=3` should be passed for `op1 ` so the default values for `op1` and
    `op2` are overwritten.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4(2,3,2)`: 这在第33行被调用。这表示必填参数应传递一个带有`value=2`的整数，另一个带有`value=3`的整数应传递给`op1`，因此`op1`和`op2`的默认值将被覆盖。'
- en: '`print_msg4(1,op2=''Test'')`: This is invoked at line 34\. The mandatory parameter
    receives an integer with `value=1`. For the second parameter, we are specifying
    a named parameter during invocation, so the sequence does not matter for `Test`,
    which will get copied to `op2` of the caller.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4(1,op2=''Test'')`: 这在第34行被调用。必填参数接收一个带有`value=1`的整数。对于第二个参数，在调用过程中我们指定了一个命名参数，因此`Test`的顺序对`op2`不重要，它将被复制到调用者的`op2`。'
- en: '`print_msg4(1,op2=33,op1=44)`: This is invoked at line 35\. The mandatory parameter
    receives `value=1`. For the second parameter, we specify a named parameter, `op2`,
    and for the third parameter, we pass `op1`. Again, we can see in the output that
    the sequence does not matter.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg4(1,op2=33,op1=44)`: 这在第35行被调用。必填参数接收`value=1`。对于第二个参数，我们指定了一个命名参数`op2`，对于第三个参数，我们传递了`op1`。同样，我们可以在输出中看到顺序并不重要。'
- en: '`print_msg5()`: Usually, in other programming languages, a function or method
    can always return one value. If it needs to return multiple values, it must put
    the values in an array or another structure and then return them. Python handles
    this situation abstractly for us. If you read the code, you might think that the
    method is returning multiple values, whereas in reality it''s returning a tuple
    with each value multiplied by two. This can be validated from the output.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_msg5()`: 通常，在其他编程语言中，函数或方法总是可以返回一个值。如果需要返回多个值，必须将这些值放入数组或另一个结构中，然后返回它们。Python为我们抽象地处理了这种情况。如果你阅读代码，你可能会认为该方法返回了多个值，而实际上它返回的是一个元组，其中每个值都乘以了二。这可以从输出中验证。'
- en: Let's now explore some further methods and ways to pass arguments, using the
    following example, `methods_adv.py`. The following code snippet represents variable-argument
    type methods in Python. As can be verified from the output, `method_1` takes a
    normal sequence of any size as an input, meaning we can pass any number of arguments
    to the method. When the method is declared with a parameter preceded by the `*`
    sign, all the passed arguments are translated into a sequence and a tuple object
    is placed inside `args`. On the other hand, when `*` is used with a parameter
    while invoking the method, the parameter type from the sequence is changed and
    internally each element `if` sequence is passed as a single parameter to the caller,
    as seen in `method_1_rev`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在探索一些更进一步的方法和传递参数的方式，使用以下示例`methods_adv.py`。以下代码片段表示Python中的可变参数类型方法。从输出中可以验证，`method_1`接受任意大小的普通序列作为输入，这意味着我们可以向方法传递任意数量的参数。当方法声明为由`*`符号前缀的参数时，所有传递的参数都被转换为序列，并且一个元组对象被放置在`args`中。另一方面，当在调用方法时使用`*`与参数一起使用时，参数类型从序列中更改，内部将每个元素`if`序列作为单个参数传递给调用者，如`method_1_rev`中所示。
- en: 'Furthermore, when `if` is used with a parameter in the method declaration,
    it internally transforms all the maned parameters into a Python dictionary, with
    the key as the name and the value being the same as the value after the `=` operator.
    This can be seen in `method_2`. Finally, when `**` is used with the caller parameter,
    that parameter is internally transformed from a Python dictionary to named parameters.
    This can be validated with `method_2_rev`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当在方法声明中使用`if`与参数一起使用时，它会将所有命名参数内部转换为Python字典，键为名称，值为`=`运算符后的值。这可以在`method_2`中看到。最后，当`**`与调用者参数一起使用时，该参数会从Python字典内部转换为命名参数。这可以通过`method_2_rev`进行验证：
- en: '![](img/a143bc5f-0fdd-4a93-a9ff-650b65748d8b.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a143bc5f-0fdd-4a93-a9ff-650b65748d8b.png)'
- en: Modules and packages
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: 'Every Python script is called a module. Python has been designed with reusability
    and ease of code in mind. For this reason, every Python file we create becomes
    a Python module and is eligible to be invoked or used within any other file or
    script. You might have learned in Java how to import classes and reuse them with
    other classes. The idea is pretty much the same here, except that we are importing
    the whole file as a module and we can reuse any method, class, or variable of
    the imported file. Let''s take a look at an example. We will create two files, `child.py`
    and `parent.py`, and put the following code in each, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python脚本都被称为一个模块。Python被设计为可重用和易于编码。因此，我们创建的每个Python文件都成为Python模块，并有资格在任何其他文件或脚本中被调用或使用。你可能已经学过在Java中如何导入类并与其他类一起重用。这里的想法基本上是一样的，只是我们将整个文件作为模块导入，我们可以重用导入文件的任何方法、类或变量。让我们看一个例子。我们将创建两个文件`child.py`和`parent.py`，并在每个文件中放置以下代码：
- en: '![](img/4978a91f-a963-4631-9d09-6704e427d4f0.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4978a91f-a963-4631-9d09-6704e427d4f0.png)'
- en: The first five lines belong to `child.py`, and the last eight lines belong to
    `parent.py`. We will run the parent, as shown in the output. It should be noted
    that the imported file can be given an alias. In our case, we imported the child
    and gave it the alias C. Finally, we called `child_method()` class of that module
    from the parent Python script.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前五行属于`child.py`，最后八行属于`parent.py`。我们将运行父文件，如输出所示。应该注意的是，导入的文件可以被赋予别名。在我们的例子中，我们导入了child并给它起了别名C。最后，我们从父Python脚本中调用了该模块的`child_method()`类。
- en: Let's now try to explore Python packages and how they can be used. In Java,
    a package is nothing but a folder or directory that collects logically connected
    class files in Java. Packages do the same in Python; they collect logically connected
    Python modules. It is always recommended to use packages, as this keeps the code
    clean and makes it reusable and modular.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试探索Python包以及它们如何被使用。在Java中，包只是收集Java中逻辑连接的类文件的文件夹或目录。包在Python中也是如此；它们收集逻辑连接的Python模块。始终建议使用包，因为这样可以保持代码整洁，使其可重用和模块化。
- en: 'As mentioned earlier, a Python package is a normal directory. The only difference
    is that in order to make a normal directory behave like a Python package, we must
    place an empty `__init__.py` file inside the directory. This indicates to Python
    which directories it should use as packages. Let''s go ahead and create a package
    called `shapes`. We will place an empty Python file called `__init__.py` and another
    file called `area_finder.py` inside it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python包是一个普通的目录。唯一的区别是，为了使普通目录像Python包一样运行，我们必须在目录中放置一个空的`__init__.py`文件。这告诉Python应该使用哪些目录作为包。让我们继续创建一个名为`shapes`的包。我们将放置一个空的Python文件`__init__.py`和另一个名为`area_finder.py`的文件在其中：
- en: '![](img/3f51903f-9f5e-4c09-a2d4-51e0ab61bd4c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f51903f-9f5e-4c09-a2d4-51e0ab61bd4c.png)'
- en: 'Let''s now put the following code in the `area_finder.py` file. Let''s also
    create another file called `invoker.py` and place it **outside the shapes** folder
    that we created. The code of the invoker is given on the right-hand side of the
    following image, while the code of the `area_finder` is given on the left-hand
    side:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在把以下代码放在`area_finder.py`文件中。我们还要创建另一个名为`invoker.py`的文件，并将其放在我们创建的shapes文件夹之外。调用者的代码在下图的右侧，而`area_finder`的代码在左侧：
- en: '![](img/d04e78e6-484e-4d8b-a142-751caf7ca5ce.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d04e78e6-484e-4d8b-a142-751caf7ca5ce.png)'
- en: The preceding code is a straightforward example of how to use packages in Python.We
    created a package called `shapes` and placed a file called `area_finder` in it,
    which will compute the area of a shape. Then, we went ahead and created a file
    called `invoker.py` outside the `shapes` folder, and imported the `area_finder`
    script from the package in multiple ways (for demonstration purposes). Finally,
    we used one of the aliases to invoke the `find_area()` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是Python中如何使用包的一个简单示例。我们创建了一个名为`shapes`的包，并在其中放置了一个名为`area_finder`的文件，用于计算形状的面积。然后，我们继续创建了一个名为`invoker.py`的文件，放在`shapes`文件夹外，并以多种方式导入了包中的`area_finder`脚本（仅用于演示目的）。最后，我们使用其中一个别名来调用`find_area()`方法。
- en: Generators and comprehensions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器和推导式
- en: 'A **generator** is a special kind of iterator in Python. In other words, a
    Python generator is a function that returns us a generator iterator by issuing
    the `yield` command, which can be iterated upon. There might be occasions in which
    we would want a method or function to return us a series of values, instead of
    just one. We might, for example, want our method to partially carry out a task,
    return the partial results to the caller, and then resume the work right from
    the place where it returned the last value. Usually, when a method terminates
    or returns a value, its execution begins again from the start. This is what generators
    try to address. A generator method returns a value and a control to the caller
    and then continues its execution right from where it left off. A generator method
    is a normal Python method with a yield statement. The following code snippet, `generators.py`,
    explains how generators can be used:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是Python中一种特殊的迭代器。换句话说，Python生成器是通过发出`yield`命令返回生成器迭代器的函数，可以进行迭代。可能会有一些情况，我们希望一个方法或函数返回一系列值，而不仅仅是一个值。例如，我们可能希望我们的方法部分执行任务，将部分结果返回给调用者，然后从上次返回最后一个值的地方恢复工作。通常，当方法终止或返回一个值时，它的执行会从头开始。这就是生成器试图解决的问题。生成器方法返回一个值和一个控制给调用者，然后从离开的地方继续执行。生成器方法是一个带有yield语句的普通Python方法。以下代码片段`generators.py`解释了如何使用生成器：'
- en: '![](img/602efafc-01fe-4ce4-99db-0d946dea3d9e.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/602efafc-01fe-4ce4-99db-0d946dea3d9e.png)'
- en: Note that since `genMethod` has a yield statement in it, it becomes a generator.
    Every time the yield statement is executed, the value of "a" is returned to the
    caller as well as the control (remember that generators return series of values).
    Every time the `next()` call is made to the generator method, it resumes its execution
    from where it left off previously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`genMethod`中有一个yield语句，它变成了一个生成器。每次执行yield语句时，"a"的值都会作为控制返回给调用者（记住生成器返回一系列值）。每次对生成器方法进行`next()`调用时，它都会从之前离开的地方恢复执行。
- en: 'We know that every time a yield is executed, the generator method returns a
    generator iterator. Thus, as with any iterator, we can use a `for` loop to iterate
    over the generator method. This `for` loop will continue until it reaches the
    yield operation in the method. The same example with a `for` loop would look as
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，每次执行yield时，生成器方法都会返回一个生成器迭代器。因此，与任何迭代器一样，我们可以使用`for`循环来迭代生成器方法。这个`for`循环会一直持续，直到它到达方法中的yield操作。使用`for`循环的相同示例如下：
- en: '![](img/8f445fb5-837c-4f90-af71-da0d2bebab28.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f445fb5-837c-4f90-af71-da0d2bebab28.png)'
- en: You might be wondering why we would use generators when the same result can
    be achieved with lists. Generators are very memory- and space-efficient. If a
    lot of processing is required to generate values, it makes sense to use generators,
    because then we only generate values according to our requirements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们要使用生成器，当相同的结果可以通过列表实现。生成器非常节省内存和空间。如果需要大量处理来生成值，使用生成器是有意义的，因为我们只根据需求生成值。
- en: 'Generator expressions are one-line expressions that can produce generator objects,
    which can be iterated over. This means that the same optimization in terms of
    memory and processing can be achieved. The following code snippet shows how generator
    expressions can be used:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是可以产生生成器对象的一行表达式，可以进行迭代。这意味着可以实现相同的内存和处理优化。以下代码片段显示了如何使用生成器表达式：
- en: '![](img/2d06b188-024e-4928-b650-aa02d5d0f302.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d06b188-024e-4928-b650-aa02d5d0f302.png)'
- en: Comprehensions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导式
- en: '**Python comprehensions**, commonly known as **list comprehensions**, are a
    very powerful Python utility that comes in handy if we need to perform some manipulation
    operations over all or some of the elements of a list. A list comprehension would
    return a new list with the modifications applied. Let''s say that we have a  list
    of numbers and we want to square each number in the list.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python推导式**，通常称为**列表推导式**，是Python中非常强大的实用工具，如果我们需要对列表的所有或部分元素执行一些操作，它会很方便。列表推导式将返回一个带有应用修改的新列表。假设我们有一个数字列表，我们想要对列表中的每个数字进行平方。'
- en: 'Let''s take a look at two different approaches to this problem:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解决这个问题的两种不同方法：
- en: '![](img/eaed9af8-43f0-40e1-86df-0076c101d8d4.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaed9af8-43f0-40e1-86df-0076c101d8d4.png)'
- en: 'The code snippet on the left, the more traditional approach, took nine lines.
    The same code using comprehensions took us just three lines. A list comprehension
    is declared within square brackets and it performs any operation on each element
    of a list. It then returns a new list with the modifications. Let''s take a look
    at another example of comprehensions. This time, we will use an `if` condition
    (known as a comprehension filter), and nested loops with comprehensions. We will
    name the file `list_comp_adv.py` and enter the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的代码片段是更传统的方法，需要九行。使用推导式的相同代码只需要三行。列表推导式在方括号内声明，并对列表的每个元素执行任何操作。然后返回带有修改的新列表。让我们看另一个推导式的例子。这次，我们将使用一个`if`条件（称为推导式过滤器），以及带有推导式的嵌套循环。我们将命名文件为`list_comp_adv.py`，并输入以下代码：
- en: '![](img/5a1a5b89-0434-4f19-b6c6-60d05a1c1ca1.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a1a5b89-0434-4f19-b6c6-60d05a1c1ca1.png)'
- en: The preceding snippet is self-explanatory. It shows us how to use `if` conditions
    with comprehensions (line 4). It also shows us how to use nested loops to add
    up two lists (line 5). Finally, it shows us how to use dictionaries with comprehensions
    (line 6).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是不言自明的。它向我们展示了如何在推导式中使用`if`条件（第4行）。它还向我们展示了如何使用嵌套循环来累加两个列表（第5行）。最后，它向我们展示了如何在推导式中使用字典（第6行）。
- en: Map, Lambda, zip, and filters
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map、Lambda、zip和filters
- en: In this section, we are going to understand some very handy Python functions.
    These allow us to carry out quick processing operations on Python iterables such
    as lists.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解一些非常方便的Python函数。这些函数允许我们对Python可迭代对象（如列表）进行快速处理操作。
- en: '`Map()`: As we saw earlier, list comprehensions come in very handy when we
    have to perform an operation on all or some of the elements in a list. The same
    can be achieved with the help of the `map` function. This takes two arguments,
    the first being the function that will perform the manipulation on the elements
    of the list, and the second being the list itself. The following example, `map_usage.py`,
    demonstrates this:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map()`: 正如我们之前看到的，当我们需要对列表中的所有或部分元素执行操作时，列表推导式非常方便。同样的操作也可以通过`map`函数实现。它接受两个参数，第一个是将对列表元素执行操作的函数，第二个是列表本身。以下示例`map_usage.py`演示了这一点：'
- en: '![](img/77878f15-4172-4891-8b59-225dce87a415.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77878f15-4172-4891-8b59-225dce87a415.png)'
- en: '`Lambda()`: Lambda functions are small but powerful in-line functions that
    can be used for manipulation of data. They can be very useful for small manipulations,
    as very little code is required to implement them. Let''s look at the same example
    again, but this time we will use a Lambda function in place of a normal Python
    function:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lambda()`: Lambda函数是小巧但功能强大的内联函数，可用于数据操作。它们对于小的操作非常有用，因为实现它们所需的代码很少。让我们再次看同一个示例，但这次我们将使用Lambda函数代替普通的Python函数：'
- en: '![](img/cb16e80b-43d7-4c23-bfef-9aebe43b2889.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb16e80b-43d7-4c23-bfef-9aebe43b2889.png)'
- en: '`Zip()`: The `zip` method takes two lists or iterables and aggregates the elements
    across multiple iterables. Finally, it returns us a tuple iterator that contains
    the aggregation. Let''s make use of a simple code, `zip_.py`, to demonstrate this
    function:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zip()`: `zip`方法接受两个列表或可迭代对象，并在多个可迭代对象之间聚合元素。最后，它返回一个包含聚合的元组迭代器。让我们使用一个简单的代码`zip_.py`来演示这个函数：'
- en: '![](img/3b2d1050-84aa-4988-8977-1da910a5f0f7.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b2d1050-84aa-4988-8977-1da910a5f0f7.png)'
- en: '`Filter()` :The `filter` method is used to filter out the elements of the list
    that return true for a particular condition. The `filter` method takes two arguments,
    the first being the method or Lambda function that either returns `true` or `false`
    for a particular element, and the second being the list or iterable to which that
    element belongs. It returns a list that contains the elements for which the condition
    evaluated as `true`. Let''s create a file called `filter_usage.py`, and add the
    following content:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filter()`: `filter`方法用于过滤出列表中满足特定条件的元素。`filter`方法接受两个参数，第一个是返回特定元素为`true`或`false`的方法或Lambda函数，第二个是该元素所属的列表或可迭代对象。它返回一个包含条件评估为`true`的元素的列表。让我们创建一个名为`filter_usage.py`的文件，并添加以下内容：'
- en: '![](img/5281cba6-6154-46fd-a92d-b7b1edbd98ad.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5281cba6-6154-46fd-a92d-b7b1edbd98ad.png)'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed abut conditions, loops, methods, iterators, packages,
    generators, and comprehensions. All of these are widely used in Python. The reason
    why we covered these topics is because when we get into automating penetration
    testing and cyber security test cases later on, we will see these concepts widely
    used within our code files. In the next chapter, we will explore the object-oriented
    nature of Python. We will explore how to deal with XML, CSV, and JSON data in
    Python. We will also read about files, IO, and regular expressions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了条件、循环、方法、迭代器、包、生成器和推导式。所有这些在Python中被广泛使用。我们之所以涵盖这些主题，是因为当我们进入后面的自动化渗透测试和网络安全测试用例时，我们将看到这些概念在我们的代码文件中被广泛使用。在下一章中，我们将探讨Python的面向对象特性。我们将探讨如何在Python中处理XML、CSV和JSON数据。我们还将了解有关文件、IO和正则表达式的内容。
- en: Questions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name a real-world use case in which generators are used.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '举一个现实生活中使用生成器的用例。 '
- en: Can we store a function name in a variable and then invoke it via a variable?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将函数名称存储在变量中，然后通过变量调用它吗？
- en: Can we store a module name in a variable?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将模块名称存储在变量中吗？
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Generators and Comprehensions: [http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html](http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和推导式：[http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html](http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html)
- en: 'Modules: [https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块：[https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)
