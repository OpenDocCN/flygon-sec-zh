- en: Introduction to Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python简介
- en: This chapter will provide an introduction to Python, focusing primarily on data
    types, variables, expressions, and program structures that the Python programming
    language follows. The objective of this chapter is to familiarize the reader with
    the basics of Python so that they can use it in the upcoming chapters. The chapter
    will cover the installation of Python and its dependency manager. We will also
    start taking a look at scripting in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Python，主要关注Python编程语言遵循的数据类型，变量，表达式和程序结构。本章的目标是使读者熟悉Python的基础知识，以便他们可以在接下来的章节中使用它。本章将涵盖Python的安装及其依赖管理器。我们还将开始研究Python脚本。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to Python (including its installation and setup)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python简介（包括安装和设置）
- en: Basic data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: Sequence data types – lists, dictionaries, tuples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列数据类型 - 列表，字典，元组
- en: Variables and keywords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和关键字
- en: Operations and expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和表达式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Make sure you have the following setup ready before proceeding with this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，请确保您已准备好以下设置：
- en: A working computer or laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台工作的计算机或笔记本电脑
- en: An Ubuntu operating system, preferably version 16.04
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu操作系统，最好是16.04版本
- en: Python 3.x
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.x
- en: A working internet connection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的互联网连接
- en: Why Python?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Python？
- en: When we think about exploring a new programming language or technology, we often
    wonder about the scope of the new technology and how it might benefit us. Let's
    start this chapter by thinking about why we might want to use Python and what
    advantages it might give us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑探索一种新的编程语言或技术时，我们经常会想到新技术的范围以及它可能给我们带来的好处。让我们从思考为什么我们可能想要使用Python以及它可能给我们带来的优势开始这一章。
- en: 'To answer this question, we are going to think about current technology trends
    and not get into more language-specific features, such as the fact that it is
    object-oriented, functional, portable, and interpreted. We have heard these terms
    before. Let''s try to think about why we might use Python from a strictly industrial
    standpoint, what the present and future landscapes of this language might look
    like, and how the language can serve us. We''ll start by mentioning a few career
    options that someone involved in computer science might opt for:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将考虑当前的技术趋势，而不会涉及更多的语言特定功能，比如它是面向对象的，功能性的，可移植的和解释性的。我们以前听过这些术语。让我们试着思考为什么我们可能会从严格的工业角度使用Python，这种语言的现在和未来的景观可能是什么样的，以及这种语言如何为我们服务。我们将首先提到一些计算机科学相关人员可能选择的职业选项：
- en: Programmer or software developer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员或软件开发人员
- en: Web developer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web开发人员
- en: Database engineer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库工程师
- en: Cyber security professional (penetration tester, incident responder, SOC analyst,
    malware analyst, security researcher, and so on)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全专业人员（渗透测试员，事件响应者，SOC分析师，恶意软件分析师，安全研究员等）
- en: Data scientist
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据科学家
- en: Network engineer
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工程师
- en: There are many other roles as well, but we'll just focus on the most generic
    options for the time being to see how Python fits into them. Let's start off with
    the role of programmer or software developer. As of 2018, Python was recorded
    as the second most popular language listed in job adverts ([https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/](https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/)).
    The role of programmer might vary from company to company, but as a Python programmer,
    you might be making a software product written in Python, developing a cyber security
    tool written in Python (there are tons of these already in existence that can
    be found on GitHub and elsewhere in the cyber security community), prototyping
    a robot that can mimic humans, engineering a smart home automation product or
    utility, and so on. The scope of Python covers every dimension of software development,
    from typical software applications to robust hardware products. The reason for
    this is the ease of the language to understand, the power of the language in terms
    of its excellent library support, which is backed by a huge community, and, of
    course, the beauty of it being open source.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他角色，但我们暂时只关注最通用的选项，看看Python如何适用于它们。让我们从程序员或软件开发人员的角色开始。截至2018年，Python被记录为招聘广告中列出的第二受欢迎的语言（[https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/](https://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/)）。程序员的角色可能因公司而异，但作为Python程序员，您可能会编写Python软件产品，开发用Python编写的网络安全工具（已经存在大量这样的工具可以在GitHub和网络安全社区的其他地方找到），原型设计一个可以模仿人类的机器人，设计智能家居自动化产品或实用工具等。Python的范围涵盖了软件开发的各个方面，从典型的软件应用到强大的硬件产品。这是因为这种语言易于理解，具有出色的库支持，由庞大的社区支持，并且当然，它是开源的美丽之处。
- en: Let's move on to the web. In recent years, Python has done remarkably well in
    terms of its maturity as a web development language. The most popular full stack
    web-based frameworks such as Django, Flask, and CherryPy have made web development
    with Python a seamless and clean experience, with lots of learning, customization,
    and flexibility on the way. My personal favorite is Django, as it provides a very
    clean MVC architecture, where business, logic, and presentation layers are completely
    isolated, making the development code much cleaner and easier to manage. With
    all batteries loaded and support for ORM and out-the-box support for background
    task processing with celery, Django does everything that any other web framework
    would be capable of doing, while keeping the native code in Python. Flask and
    CherryPy are also excellent choices for web development and come with lots of
    control over the data flow and customization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向网络。近年来，Python在成熟作为Web开发语言方面表现出色。最受欢迎的全栈基于Web的框架，如Django、Flask和CherryPy，使得使用Python进行Web开发成为一种无缝和清晰的体验，学习、定制和灵活性都很强。我个人最喜欢Django，因为它提供了非常清晰的MVC架构，业务逻辑和表示层完全隔离，使得开发代码更加清晰和易于管理。Django装备齐全，支持ORM和使用celery进行后台任务处理，实现了其他任何Web框架能够做到的一切，同时保持了Python的本地代码。Flask和CherryPy也是Web开发的绝佳选择，可以对数据流和定制性进行大量控制。
- en: '**Cyber security** is a field that would be incomplete without Python. Every
    industry within the cyber security domain is related to Python in one way or another
    and the majority of cyber security tools are written in Python. From penetration
    testing to monitoring security operations centers, Python is widely used and needed.
    Python aids penetration testers by providing them with excellent tools and automation
    support with which they can write quick and powerful scripts for a variety of
    penetration testing activities, from reconnaissance to exploitation. We will learn
    about this in great detail throughout the course of this book.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络安全**是一个离开Python就不完整的领域。网络安全领域的每个行业都与Python有一定的关联，大多数网络安全工具都是用Python编写的。从渗透测试到监控安全运营中心，Python被广泛使用和需要。Python通过为渗透测试人员提供出色的工具和自动化支持，使他们能够为各种渗透测试活动编写快速而强大的脚本，从侦察到利用都可以。我们将在本书的课程中详细学习这一点。'
- en: '**Machine learning** (**ML**) and **artificial intelligence** (**AI**) are
    buzz words in the tech industry that we come across frequently nowadays. Python
    has excellent support for all ML and AI models. Python, by default in most cases,
    is the first choice for anyone who wants to learn ML and AI. The other famous
    language in this domain is R, but because of Python''s excellent coverage across
    all the other technology and software development stacks, it is easier to combine
    machine learning solutions written in Python with existing or new products than
    it is to combine solutions written in R. Python has got amazing machine learning
    libraries and APIs such as sciket-learn, NumPy, Pandas, matplotlib, NLTK, and
    TensorFlow. Pandas and NumPy have made scientific computations a very easy task,
    giving users the flexibility to process huge datasets in memory with an excellent
    layer of abstraction, which allows developers and programmers to forget about
    the background details and get the job done neatly and efficiently.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器学习**（**ML**）和**人工智能**（**AI**）是科技行业中我们经常遇到的热门词汇。Python对所有ML和AI模型都有出色的支持。在大多数情况下，Python是任何想学习ML和AI的人的首选。这个领域中另一个著名的语言是R，但由于Python在其他技术和软件开发领域的出色覆盖，将用Python编写的机器学习解决方案与现有或新产品结合起来比用R编写的解决方案更容易。Python拥有惊人的机器学习库和API，如sciket-learn、NumPy、Pandas、matplotlib、NLTK和TensorFlow。Pandas和NumPy使得科学计算变得非常容易，给用户提供了在内存中处理大型数据集的灵活性，具有出色的抽象层，使开发人员可以忘记背景细节，干净高效地完成工作。'
- en: A few years ago, a typical database engineer would have been expected to know
    relational databases such as **MySQL**, **SQL Server**, **Oracle**, **PostgreSQL**,
    and so on. Over the past few years, however, the technology landscape has completely
    changed. While a typical database engineer is still supposed to know and be proficient
    with this database technology stack, this is no longer enough. With the increasing
    volume of data, as we enter the era of big data, traditional databases have to
    work in conjunction with big data solutions such as Hadoop or Spark. Having said
    that, the role of the database engineer has evolved to be one that includes the
    skill set of a data analyst. Now, data is not to be fetched and processed from
    local database servers—it is to be collected from heterogeneous sources, pre-processed,
    processed across a distributed cluster or parallel cores, and then stored back
    across the distributed cluster of nodes. What we are talking about here is big
    data analytics and distributed computing. We mentioned the word Hadoop previously.
    If you are not familiar with it, Hadoop is an engine that is capable of processing
    huge files by spawning chunks of files across a cluster of computers and then
    performing an aggregation on the processed result set, something which is popularly
    known as a map-reduce operation. Apache Spark is a new buzzword in the domain
    of analytics and it claims to be 100 times faster than the Hadoop ecosystem. Apache
    Spark has got a Python API for Python developers called `pyspark`, using which
    we can run Apache Spark with native Python code. It is extremely powerful and
    having familiarity with Python makes the setup easy and seamless.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，一个典型的数据库工程师可能会被期望了解关系型数据库，比如**MySQL**、**SQL Server**、**Oracle**、**PostgreSQL**等等。然而，在过去的几年里，技术领域已经完全改变。虽然一个典型的数据库工程师仍然应该了解并熟练掌握这些数据库技术栈，但这已经不够了。随着数据量的增加，当我们进入大数据时代时，传统数据库必须与Hadoop或Spark等大数据解决方案配合工作。话虽如此，数据库工程师的角色已经演变成包括数据分析师的技能集。现在，数据不再需要从本地数据库服务器中获取和处理
    - 它需要从异构来源收集，预处理，跨分布式集群或并行核心进行处理，然后再存储回分布式节点集群中。我们在这里谈论的是大数据分析和分布式计算。我们之前提到了Hadoop这个词。如果你对它不熟悉，Hadoop是一个引擎，能够通过在计算机集群中生成文件块来处理大文件，然后对处理结果集进行聚合，这在业界被称为map-reduce操作。Apache
    Spark是分析领域的一个新热词，它声称比Hadoop生态系统快100倍。Apache Spark有一个名为`pyspark`的Python API，使用它我们可以用本地Python代码运行Apache
    Spark。它非常强大，熟悉Python使得设置变得简单和无缝。
- en: The objective of mentioning the preceding points was to highlight the significance
    of Python in the current technological landscape and in the coming future. ML
    and AI are likely to be the dominating industries, both of which are primarily
    powered by Python. For this reason, there will not be a better time to start reading
    about and exploring Python and cyber security with machine learning than now.
    Let's start our journey into Python by looking at a few basics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提到前面的几点的目的是为了突出Python在当前技术领域和未来的重要性。机器学习和人工智能很可能会成为主导产业，而这两者都主要由Python驱动。因此，现在开始阅读和探索Python和机器学习的网络安全将是一个更好的时机。让我们通过了解一些基础知识来开始我们的Python之旅。
- en: About Python – compiled or interpreted
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Python - 编译还是解释
- en: Compilers work by converting human-readable code written in high-level programming
    languages into machine code, which is then run by the underlying architecture
    or machine. If you don't wish to run the code, the compiled version can be saved
    and executed later on. It should be noted that the compiler first checks for syntax
    errors and only creates the compiled version of the program if none are found.
    If you have used C, you might have come across `.out` files, which are examples
    of compiled files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过将用高级编程语言编写的人类可读的代码转换为机器代码，然后由底层架构或机器运行。如果你不想运行代码，编译后的版本可以保存并以后执行。值得注意的是，编译器首先检查语法错误，只有在没有发现错误的情况下才会创建程序的编译版本。如果你使用过C语言，你可能会遇到`.out`文件，这些是编译后的文件的例子。
- en: In the case of interpreters, however, each line of the program is taken and
    interpreted from the source code at runtime and then converted into machine code
    for execution. Python falls into the category of interpreted byte code. This means
    that the Python code is first translated to an intermediate byte code (a `.pyc`
    file). Then, this byte code is interpreted line by line by the interpreter and
    executed on the underlying architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在解释器的情况下，程序的每一行都是在运行时从源代码中解释并转换为机器代码进行执行。Python属于解释的字节码类别。这意味着Python代码首先被翻译成中间字节码（一个`.pyc`文件）。然后，这个字节码由解释器逐行解释并在底层架构上执行。
- en: Installing Python
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python
- en: 'Over the course of this book, all of the exercises will be shown on a Linux
    OS. In my case, I am using Ubuntu 16.04\. You can choose any variant you prefer.
    We will be using `python3` for our exercises, which can be installed as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，所有的练习都将在Linux操作系统上展示。在我的情况下，我使用的是Ubuntu 16.04。你可以选择任何你喜欢的变种。我们将使用`python3`来进行练习，可以按照以下方式安装：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second command installs **pip**, which is Python's package manager. All
    open source Python libraries that do not come as part of the standard installation
    can be installed with the help of `pip`. We will be exploring how to use pip in
    the upcoming sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令安装了**pip**，它是Python的包管理器。所有不包括在标准安装中的开源Python库都可以通过`pip`来安装。我们将在接下来的部分中探讨如何使用pip。
- en: Getting started
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: Throughout the course of this book, we will aim to cover advanced and well-known
    industry standards in Python, cyber security, penetration testing, and the data
    science space. However, as they say, every remarkable journey starts with small
    steps. Let's go ahead and start our journey by understanding the basics of Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们将致力于涵盖Python、网络安全、渗透测试和数据科学领域的先进和著名的行业标准。然而，正如他们所说，每段非凡的旅程都始于小步。让我们开始我们的旅程，先了解Python的基础知识。
- en: Variables and keywords
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和关键字
- en: '**Variables**, as the name suggests, are placeholders that hold a value. A
    Python variable is nothing but a name that can hold a user-defined value during
    the scope of a Python program or script. If we compare Python variables to other
    conventional languages, such as C, C++, Java, and so on, we will see that they
    are a little bit different. In the other languages, we have to associate a data
    type with the name of the variable. For example, to declare an integer in C or
    Java, we have to declare it as `int a=2`, and the compiler will immediately reserve
    two bytes of memory in C and four bytes in Java. It would then name the memory
    location as `a`, which is to be referenced from the program with the value `2`
    stored in it. Python, however, is a dynamically typed language, which means that
    we do not need to associate a data type with the variable that we will declare
    or use in our program.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**，顾名思义，是保存值的占位符。Python变量只是在Python程序或脚本的范围内保存用户定义值的名称。如果我们将Python变量与其他传统语言（如C、C++、Java等）进行比较，我们会发现它们有些不同。在其他语言中，我们必须将数据类型与变量的名称关联起来。例如，在C或Java中声明整数，我们必须声明为`int
    a=2`，编译器将立即在C中保留两个字节的内存，在Java中保留四个字节。然后将内存位置命名为`a`，程序将引用其中存储的值`2`。然而，Python是一种动态类型语言，这意味着我们不需要将数据类型与我们在程序中声明或使用的变量关联起来。'
- en: 'A typical Python declaration of an integer might look like `a=20`. This simply
    creates a variable named `a` and places the value `20` in it. Even if we change
    the value in the next line to be `a="hello world"`, it would associate the string
    `hello world` with the variable `a`. Let''s see that in action on the Python Terminal,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的典型Python声明可能如`a=20`。这只是创建一个名为`a`的变量，并将值`20`放入其中。即使我们在下一行将值更改为`a="hello world"`，它也会将字符串`hello
    world`与变量`a`关联起来。让我们在Python终端上看看它的运行情况：
- en: '![](img/c64e1eab-6ced-40a7-afd9-f52a540dabe8.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c64e1eab-6ced-40a7-afd9-f52a540dabe8.png)'
- en: 'To use the Python Terminal, simply type the `python3` command in your Terminal
    prompt. Let''s think about how this works. Take a look at the following diagram,
    which compares statically typed languages with dynamically typed languages:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python终端，只需在终端提示符中键入`python3`命令。让我们思考一下这是如何工作的。看一下下面的图表，比较静态类型语言和动态类型语言：
- en: '![](img/0d42b878-542f-4972-a1d6-a5650b1921bc.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d42b878-542f-4972-a1d6-a5650b1921bc.png)'
- en: '![](img/36132ef2-42f9-4f37-8d0c-18089f559fd2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36132ef2-42f9-4f37-8d0c-18089f559fd2.png)'
- en: As you can see in the preceding diagrams, in the case of Python, the variable
    actually holds a reference to the actual object. Every time the value is changed,
    a new object is created in memory and the variable points toward this new object.
    The previous object is claimed by the garbage collector.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中看到的，在Python的情况下，变量实际上保存对实际对象的引用。每次更改值时，都会在内存中创建一个新对象，并且变量指向这个新对象。以前的对象由垃圾收集器声明。
- en: Having discussed that Python is a dynamically typed language, we must not confuse
    it with a weakly typed one. Though Python is dynamically typed, it is also a strongly
    typed language, just like Java, C, or C++.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Python是一种动态类型语言之后，我们不应该将其与弱类型语言混淆。尽管Python是动态类型的，但它也是一种强类型语言，就像Java、C或C++一样。
- en: 'In the following example, we declare a variable, `a`, of string type and a
    variable, `b`, of integer type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们声明一个字符串类型的变量`a`和一个整数类型的变量`b`：
- en: '![](img/991cd824-ffd9-4193-8d3e-31654ea761e5.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/991cd824-ffd9-4193-8d3e-31654ea761e5.png)'
- en: When we carry out the operation `c=a+b`, what might happen in a weakly typed
    language is that the integer value of `b` would be typecasted to a string, and
    the result that was stored in variable `c` would have been `hello world22`. However,
    because Python is strongly typed, the function adheres to the type that is associated
    with the variable. We need to make the conversion explicitly to carry out any
    operations of this kind.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行操作`c=a+b`时，在弱类型语言中可能发生的是将`b`的整数值转换为字符串，并将存储在变量`c`中的结果为`hello world22`。然而，由于Python是强类型的，该函数遵循与变量关联的类型。我们需要显式进行转换才能执行这种操作。
- en: 'Let''s take a look at the following example to understand what it means to
    be a strongly typed language; we explicitly change the type of variable `b` and
    typecast it to a string type at runtime:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的示例，以了解强类型语言的含义；我们在运行时明确更改变量`b`的类型并将其转换为字符串类型：
- en: '![](img/5b8991ee-cd92-44ad-abfe-d0534491ef7e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b8991ee-cd92-44ad-abfe-d0534491ef7e.png)'
- en: Variable naming conventions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量命名约定
- en: Having understood the basics of how variables can be declared and used, let's
    try to understand the naming conventions they follow. A variable, also known as
    an identifier, can be named by anything that starts with any letter between A-Z,
    a-z, or an underscore. This can then be followed by any number of digits or alphanumeric
    characters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何声明和使用变量的基础知识之后，让我们尝试了解它们遵循的命名约定。变量，也称为标识符，可以以A-Z、a-z或下划线之间的任何字母开头命名。然后可以跟随任意数量的数字或字母数字字符。
- en: 'It must be noted that certain special characters, such as %, @, #, -, and !, are
    reserved in Python and can''t be used with variables.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，某些特殊字符，如%，@，#，-和!在Python中是保留的，不能与变量一起使用。
- en: Python keywords
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python关键字
- en: '**Keywords**, as the name implies, are certain reserved words that have a predefined
    meaning within a particular language implementation. In other languages, we cannot
    usually name our variables with the same name as that of the keywords, but Python
    is a slightly different case. Although we shouldn''t name the variables or identifiers
    with the same name as those reserved for keywords, even if we do, the program
    will not throw any errors and we will still get an output. Let''s try to understand
    this with the help of a conventional C program and an equivalent Python script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键字**，顾名思义，是某种语言实现中具有预定义含义的特定保留字。在其他语言中，我们通常不能使用与关键字相同的名称来命名我们的变量，但Python是一个略有不同的情况。尽管我们不应该使用与关键字保留相同的名称来命名变量或标识符，即使我们这样做，程序也不会抛出任何错误，我们仍然会得到一个输出。让我们尝试通过传统的C程序和等效的Python脚本来理解这一点：'
- en: '![](img/e3862155-a723-4571-abb9-4c60f2a57f5c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3862155-a723-4571-abb9-4c60f2a57f5c.png)'
- en: It should be noted that this is a simple C program in which we have declared
    an integer and used the `int` identifier to identify it, following which we simply
    print `hello world`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这是一个简单的C程序，我们在其中声明了一个整数，并使用`int`标识符来标识它，随后我们简单地打印`hello world`。
- en: 'When we try to compile the program, however, it throws a compilation error,
    as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试编译程序时，它会抛出编译错误，如下面的屏幕截图所示：
- en: '![](img/334cc30b-eb1a-4cb2-a891-6614441abc6a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/334cc30b-eb1a-4cb2-a891-6614441abc6a.png)'
- en: 'Let''s try to do the same in a Python shell and see what happens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Python shell中做同样的事情，看看会发生什么：
- en: '![](img/975e7b89-e7e4-4874-89ea-4c1768baf01c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/975e7b89-e7e4-4874-89ea-4c1768baf01c.png)'
- en: It can be seen that the program did not throw any errors when we declared our
    variable with the names `int` and `str`. Although both `int` and `str` are Python
    keywords, in the preceding case, we saw that a variable declared with name as
    `int` held a string value and a variable declared with `str` type held an `int`
    value. We also saw how a normal variable, `a`, was typecasted from `int` to `string`
    type. From this, it can be established that we can use reserved words as variables
    in Python. The downside of this is that if we are to make use of keywords as variables
    or identifiers, we are overriding the actual functionality that these reserved
    words possess. When we override their actual behavior within the scope of our
    program, they will follow the updated or overridden functionality, which is very
    dangerous as this would make our code fall out of Python's conventions. This should
    always be avoided.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，当我们用名称`int`和`str`声明变量时，程序没有抛出任何错误。尽管`int`和`str`都是Python关键字，在前面的情况下，我们看到用名称`int`声明的变量保存了一个字符串值，而用`str`类型声明的变量保存了一个`int`值。我们还看到了一个普通变量`a`，它是从`int`类型转换为`string`类型。由此可以确定，我们可以在Python中使用保留字作为变量。这样做的缺点是，如果我们要使用关键字作为变量或标识符，我们将覆盖这些保留字所具有的实际功能。当我们在程序范围内覆盖它们的实际行为时，它们将遵循更新或覆盖的功能，这是非常危险的，因为这将使我们的代码违反Python的约定。这应该始终被避免。
- en: 'Let''s extend the preceding example. We know that `str()` is a built-in Python
    function, the purpose of which is to convert a numeric data type into a string
    type, as we saw for variable `a`. Later on, however, we overwrote its functionality
    and, for the scope of our program, we assigned it to an integer type. Now, at
    any point in time during the scope of this program, if we try to use the `str`
    function to convert a numeric type into a `string`, the interpreter will throw
    an error, saying that the `int` type variables can''t be used as methods, or that
    they are not callable, as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前面的例子。我们知道`str()`是一个内置的Python函数，其目的是将数值数据类型转换为字符串类型，就像我们对变量`a`所看到的那样。然而，后来我们重写了它的功能，并且在我们的程序范围内，我们将其分配给了一个整数类型。现在，在程序范围内的任何时间点，如果我们尝试使用`str`函数将数值类型转换为`string`，解释器将抛出一个错误，说`int`类型变量不能用作方法，或者它们不可调用，如下面的屏幕截图所示：
- en: '![](img/88a7a2cd-885c-4dc5-ae8e-0865c9ca544b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88a7a2cd-885c-4dc5-ae8e-0865c9ca544b.png)'
- en: The same would hold true for the `int` method and we would no longer be able
    to use it to type cast a string to its equivalent integer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`int`方法也是如此，我们将不再能够使用它将字符串转换为其等效的整数。
- en: 'Now, let''s take a look at other types of keywords that are available in Python
    that we should try not to use as our variable names. There is a cool way to do
    this with the Python code itself, which lets us print the Python keywords in the
    Terminal window:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Python中还有哪些类型的关键字，我们应该尽量避免将它们用作我们的变量名。有一种很酷的方法可以通过Python代码本身来做到这一点，这让我们可以在终端窗口中打印Python关键字：
- en: '![](img/6e6f151e-b64d-4871-a95a-ab0b78b4869c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e6f151e-b64d-4871-a95a-ab0b78b4869c.png)'
- en: 'The `import` statement is used to import the libraries in Python, just as we
    use imports for importing packages in Java. We will get into the details of using
    imports and loops in future sections. For now, we will look at what the different
    Python keywords mean:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句用于在Python中导入库，就像我们在Java中导入包时一样。我们将在以后的章节中详细介绍使用导入和循环。现在，我们将看看不同的Python关键字的含义：'
- en: '`false`: The Boolean `false` operator.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`: 布尔`false`运算符。'
- en: '`none`: This is equivalent to `Null` in other languages.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 这相当于其他语言中的`Null`。'
- en: '`true`: The Boolean `true` operator.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`: 布尔`true`运算符。'
- en: '`and`: The logical `and` that can be used with conditions and loops.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`: 逻辑`and`，可以与条件和循环一起使用。'
- en: '`as`: This is used to assign an alias to a module that we import.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as`: 这用于为我们导入的模块分配别名。'
- en: '`assert`: This is used with the objective of debugging code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`: 这用于调试代码的目的。'
- en: '`break`: This exits the loop.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`: 这会退出循环。'
- en: '`class`: This is used to declare a class.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`: 这用于声明一个类。'
- en: '`continue`: This is the traditional `continue` statement used with loops that
    can be used to continue the execution of a loop.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`: 这是传统的`continue`语句，用于循环，可以用于继续执行循环。'
- en: '`def`: This is used to define a function. Every Python function needs to be
    preceded by the `def` keyword.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def`：用于定义函数。每个Python函数都需要在`def`关键字之前。'
- en: '`del`: This is used to delete objects'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del`：用于删除对象'
- en: '`elif`: The conditional `else...if` statement.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elif`：条件`else...if`语句。'
- en: '`else`: The conditional `else` statement.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`：条件`else`语句。'
- en: '`except`: This is used to catch exceptions.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except`：用于捕获异常。'
- en: '`finally`: This is used with exception handling as part of the final block
    of code in which we clean our resources.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`：与异常处理一起使用，作为我们清理资源的最终代码块的一部分。'
- en: '`for`: The traditional for loop declaration keyword.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`：传统的for循环声明关键字。'
- en: '`global`: This is used to declare and use global variables.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global`：用于声明和使用全局变量。'
- en: '`if`: The conditional `if` statement.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`：条件`if`语句。'
- en: '`import`: This is used to import Python libraries, packages, and modules.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`：用于导入Python库、包和模块。'
- en: '`in`: This is used to search between Python strings, lists, and other objects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`：用于在Python字符串、列表和其他对象之间进行搜索。'
- en: '`is`: This is used to test the identity of an object.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`：用于测试对象的标识。'
- en: '`lambda`: This is used with Lambda functions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda`：与Lambda函数一起使用。'
- en: '`nonlocal`: This is used to declare a variable inside a nested function that
    is not local to it.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nonlocal`：用于声明嵌套函数中不是其本地变量的变量。'
- en: '`not`: This is a conditional operator.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`：条件运算符。'
- en: '`or`: This is another conditional operator.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`：另一个条件运算符。'
- en: '`pass`: This is used as a placeholder in Python.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pass`：在Python中用作占位符。'
- en: '`raise`: This is used to raise an exception in Python.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raise`：用于在Python中引发异常。'
- en: '`return`: This is used to return from a function.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`：用于从函数返回。'
- en: '`try`: The traditional `try` keyword that''s used with exception handling.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`：与异常处理一起使用的传统`try`关键字。'
- en: '`while`: This is used with the `while` loop.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`：与`while`循环一起使用。'
- en: '`with`: This is used with file opening and so on.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`：用于文件打开等。'
- en: '`yield`: This is used with generators.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`：与生成器一起使用。'
- en: '`from`: This is used with relative imports.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`：与相对导入一起使用。'
- en: Throughout this book, we will learn about all the keywords mentioned in this
    list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习此列表中提到的所有关键字。
- en: Python data types
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数据类型
- en: Like any other programming language, Python also comes with standard data types.
    In this section, we will explore the various powerful data types that Python makes
    available for us to use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他编程语言一样，Python也有标准数据类型。在本节中，我们将探讨Python提供给我们使用的各种强大的数据类型。
- en: Numbers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: '**Numbers**, as the name suggests, covers all the numeric data types, including
    both integer and floating data types. Earlier in this chapter, we saw that to
    use an integer or a float, we can simply declare the variable and assign an integer
    or a float value. Now, let''s write a proper Python script and explore how to
    use numbers. Name the script `numbers.py` which is shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字**，顾名思义，涵盖了所有数字数据类型，包括整数和浮点数据类型。在本章的前面，我们看到要使用整数或浮点数，我们可以简单地声明变量并赋予整数或浮点值。现在，让我们编写一个适当的Python脚本，并探索如何使用数字。将脚本命名为`numbers.py`，如下所示：'
- en: '![](img/8126ea5f-c958-432d-a21e-e104ab71827f.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8126ea5f-c958-432d-a21e-e104ab71827f.png)'
- en: 'The preceding screenshot show a simple Python script that adds an integer with
    a float and then prints the sum. To run the script, we can type the `python3 numbers.py`
    command, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了一个简单的Python脚本，该脚本将整数与浮点数相加，然后打印总和。要运行脚本，我们可以输入`python3 numbers.py`命令，如下所示：
- en: '![](img/050cfa73-4361-4b66-9354-5975f58a6faa.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050cfa73-4361-4b66-9354-5975f58a6faa.png)'
- en: 'You might have noticed that the command at the beginning of the script says
    `#! /usr/bin/python`. What this line does is make your code executable. After
    the privileges of the script have changed and it has been made executable, the
    command says that if an attempt is made to execute this script, then we should
    go ahead and execute it with `python3`, which is placed in the `/usr/bin/python3`
    path. This can be seen in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到脚本开头的命令是`#! /usr/bin/python`。这行的作用是使您的代码可执行。在脚本的权限已更改并且已被设置为可执行之后，命令表示如果尝试执行此脚本，则我们应该继续使用`/usr/bin/python3`路径中放置的`python3`来执行它。可以在以下示例中看到这一点：
- en: '![](img/56bba27d-5bf8-4bab-a6e5-cefbbbc32293.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56bba27d-5bf8-4bab-a6e5-cefbbbc32293.png)'
- en: 'If we observe the `print` command, we can see that the string formatter is
    `%s`. To fill it in with the actual value, the second argument to the `print`
    function is passed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察`print`命令，我们可以看到字符串格式化程序是`%s`。要用实际值填充它，需要将第二个参数传递给`print`函数：
- en: '![](img/c97aee4e-553c-4f0a-a5ca-adfad91fdb6d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c97aee4e-553c-4f0a-a5ca-adfad91fdb6d.png)'
- en: To convert a string into its equivalent integer or float value, we can use the
    built-in `int()` and `float()` functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换为其等效的整数或浮点值，我们可以使用内置的`int()`和`float()`函数。
- en: String types
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'We know that a string is a collection of characters. In Python, string types
    come under the sequence category. Strings are really powerful and have many methods
    that can be used to perform string manipulation operations. Let''s look at the
    following piece of code, which introduces us to strings in Python. Strings can
    be declared within both single and double quotes in Python:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道字符串是字符的集合。在Python中，字符串类型属于序列类别。字符串非常强大，有许多方法可用于执行字符串操作。让我们看一下下面的代码片段，它向我们介绍了Python中的字符串。在Python中，字符串可以在单引号和双引号中声明：
- en: '![](img/22c427ea-efbe-4418-9cff-bc1b0a78118e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22c427ea-efbe-4418-9cff-bc1b0a78118e.png)'
- en: In the preceding code, we are simply declaring a string called `my_str` and
    printing it on the console window.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们只是声明了一个名为`my_str`的字符串，并将其打印在控制台窗口上。
- en: String indexes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串索引
- en: 'It must be noted that strings can be accessed as a sequence of characters in
    Python. Strings can be thought of as a list of characters. Let''s try to print
    the characters at various indices of the string, as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，在Python中可以将字符串视为字符序列。字符串可以被视为字符列表。让我们尝试打印字符串的各个索引处的字符，如下面的屏幕截图所示：
- en: '![](img/d5ec70ee-4290-461e-b965-01c74a3164cc.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5ec70ee-4290-461e-b965-01c74a3164cc.png)'
- en: At index `0`, the character `0` gets printed. At index `10`, we have an empty
    space, while at index `5`, we have the letter `m`. It should be noted that the
    sequences are stored in Python with a starting index of `0`, and the same holds
    true for the string type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引 `0` 处，字符 `0` 被打印。在索引 `10` 处，我们有一个空格，而在索引 `5` 处，我们有字母 `m`。需要注意的是，序列在Python中以起始索引
    `0` 存储，字符串类型也是如此。
- en: String operations through methods and built-in functions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过方法和内置函数进行字符串操作
- en: In this section, we will look at how to compare two strings, concatenate strings,
    copy one string to another, and perform various string manipulation operations
    with the help of some methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何比较两个字符串，连接字符串，将一个字符串复制到另一个字符串，并使用一些方法执行各种字符串操作。
- en: The replace( ) method
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: replace( ) 方法
- en: 'The `replace` method is used to perform string replacement. It returns a new
    string with the appropriate replacements. The first argument to the replace method
    is the string or character to be replaced within the string, while the second
    argument is the string or character with which it is to be replaced:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 方法用于执行字符串替换。它返回一个带有适当替换的新字符串。`replace` 方法的第一个参数是要在字符串中替换的字符串或字符，而第二个参数是要替换的字符串或字符：'
- en: '![](img/1fc71b45-8d4d-4b3f-a0a5-3457356c2a6c.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fc71b45-8d4d-4b3f-a0a5-3457356c2a6c.png)'
- en: 'In the preceding example, we can see that the `!` from the original string
    is replaced by `@` and a new string with the replacement is returned. It should
    be noted that these changes were not actually made to the original string, but
    instead a new string was returned with the appropriate changes. This can be verified
    in the following line, where we print the original string and the old unchanged
    value, `Welcome to python strings !`, is printed. The reason behind this is that
    strings in Python are immutable, just like they are in Java. This means that once
    a string is declared, it can''t usually be modified. This isn''t always the case,
    however. Let''s try to change the string and this time try and catch the modifications
    in the originally declared string, `my_str`, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到原始字符串中的 `!` 被 `@` 替换，并返回一个带有替换的新字符串。需要注意的是，这些更改实际上并没有应用到原始字符串上，而是返回了一个带有适当更改的新字符串。这可以在下一行中验证，我们打印原始字符串，旧的未更改值
    `Welcome to python strings !` 被打印出来。这背后的原因是Python中的字符串是不可变的，就像在Java中一样。这意味着一旦声明了一个字符串，通常就不能修改。然而，并非总是如此。让我们尝试更改字符串，并这次尝试捕获最初声明的字符串
    `my_str` 中的修改，如下所示：
- en: '![](img/149b832c-b606-4089-8a7d-eec5ae01da93.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/149b832c-b606-4089-8a7d-eec5ae01da93.png)'
- en: 'In the preceding code, we were able to modify the original string, as we got
    the newly returned string from the `replace` method in our earlier declared string,
    `my_str`. This might sound contradictory to what we said previously. Let''s take
    a look at how this works by looking at what happens behind the scenes before and
    after we call the `replace` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们能够修改原始字符串，因为我们从我们之前声明的字符串 `my_str` 中的 `replace` 方法中得到了新返回的字符串。这可能与我们之前说的相矛盾。让我们看看在调用
    `replace` 方法之前和之后发生了什么：
- en: '![](img/b3244b6c-200a-4d48-951b-4fda8b1b2d53.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3244b6c-200a-4d48-951b-4fda8b1b2d53.png)'
- en: 'After replacing the `!` with `@`, this will look as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `!` 替换为 `@` 后，结果如下：
- en: '![](img/35b0c002-e5b1-4fd5-9ed7-bfc0ae446d32.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35b0c002-e5b1-4fd5-9ed7-bfc0ae446d32.png)'
- en: It can be seen in the preceding two illustrations that before the `replace`
    method was called, the `my_str` string reference pointed toward the actual object
    that contained an `!`. Once the `replace()` method returned a new string and we
    updated the existing string variable with the newly returned object, the older
    memory object was not overwritten, but instead a new one was created. The program
    reference now points toward the newly created object. The earlier object is in
    memory and doesn't have any references pointing toward it. This will be cleaned
    up by the garbage collector at a later stage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个示例中可以看到，在调用 `replace` 方法之前，`my_str` 字符串引用指向包含 `!` 的实际对象。一旦 `replace()`
    方法返回一个新字符串，并且我们用新返回的对象更新了现有的字符串变量，旧的内存对象并没有被覆盖，而是创建了一个新的对象。程序引用现在指向新创建的对象。早期的对象在内存中，并没有任何引用指向它。这将在以后的阶段由垃圾收集器清理。
- en: 'Another thing we can do is try and change any character in any position of
    the original string. We have already seen that the string characters can be accessed
    by their index, but if we try to update or change a character at any specific
    index, an exception will be thrown and the operation will not be permitted, as
    shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我们可以做的事情是尝试改变原始字符串中任何位置的任何字符。我们已经看到字符串字符可以通过它们的索引访问，但是如果我们尝试在任何特定索引处更新或更改字符，就会抛出异常，并且不允许进行操作，如下面的屏幕截图所示：
- en: '![](img/13e222d0-bd51-47f4-92e8-e8c83e701e31.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13e222d0-bd51-47f4-92e8-e8c83e701e31.png)'
- en: 'By default, the `replace()` method replaces all the occurrences of the replacement
    string within the target string. If we only want to replace one or two occurrences
    of something within the target string, however, we can pass a third argument to
    the `replace()` method and specify the number of replacement occurrences that
    we want to have. Let''s say we have the following string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`replace()` 方法会替换目标字符串中替换字符串的所有出现。然而，如果我们只想替换目标字符串中的一个或两个出现，我们可以向 `replace()`
    方法传递第三个参数，并指定我们想要进行的替换次数。假设我们有以下字符串：
- en: '![](img/f75a0ce4-c66a-4cce-b046-9fdf34154f94.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f75a0ce4-c66a-4cce-b046-9fdf34154f94.png)'
- en: 'If we just want the first occurrence of the `!` character to be `@` and we
    want the rest to be the same, this can be achieved as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想要`!`字符的第一个出现变成`@`，并且我们希望其余部分保持不变，可以按照以下方式实现：
- en: '![](img/c3588b54-8a51-4fd7-aef9-019c3524b426.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3588b54-8a51-4fd7-aef9-019c3524b426.png)'
- en: Substrings or string slicing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子字符串或字符串切片
- en: 'Obtaining part of the string is a common exercise that we come across frequently
    in day-to-day string operations. Languages such as C or Java provide us with dedicated
    methods such as `substr(st_index,end_index)` or `subString(st_index,end_index)`.
    To perform the substring operation in Python, there is no dedicated method, but
    we can instead use slicing. For example, if we wish to get the first four characters
    of our original `my_str` string, we can achieve this by using operations such
    as `my_str[0:4]`, as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字符串的一部分是我们在日常字符串操作中经常遇到的常见练习。诸如C或Java之类的语言为我们提供了专用方法，如`substr(st_index,end_index)`或`subString(st_index,end_index)`。在Python中执行子字符串操作时，没有专用方法，但我们可以使用切片。例如，如果我们希望获得原始`my_str`字符串的前四个字符，我们可以通过使用`my_str[0:4]`等操作来实现，如下面的屏幕截图所示：
- en: '![](img/c6aeed0e-02f3-469e-b7ce-9294498e9ca3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6aeed0e-02f3-469e-b7ce-9294498e9ca3.png)'
- en: Again, the slice operation returns a new string and the changes are not applied
    to the original string. Furthermore, it is worth understanding here that the slicing
    happens over n-1 characters, where `n` is the upper limit, specified as the second
    parameter, which is four, in our case. Thus, the actual substring operation will
    be performed starting from index `0` and ending at index `3`, thus returning the
    string `Welc`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，切片操作返回一个新的字符串，而不会对原始字符串进行更改。此外，值得在这里理解的是，切片发生在n-1个字符上，其中`n`是作为第二个参数指定的上限，即在我们的例子中是四。因此，实际的子字符串操作将从索引`0`开始，到索引`3`结束，从而返回字符串`Welc`。
- en: 'Let''s take a look at some more examples of slicing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些切片的更多例子：
- en: 'To get the whole string from index `4`, do the following:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从索引`4`获取整个字符串，按照以下方式操作：
- en: '![](img/265fb596-8570-4a43-a5bd-ac71c3cede1c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/265fb596-8570-4a43-a5bd-ac71c3cede1c.png)'
- en: 'To get the string from the start up to index `4`, do the following:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从开头获取到索引`4`的字符串，请执行以下操作：
- en: '![](img/e980939e-4bac-4535-80d2-61117ec28703.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e980939e-4bac-4535-80d2-61117ec28703.png)'
- en: 'To print the whole string with slicing, do the following:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用切片打印整个字符串，请执行以下操作：
- en: '![](img/8663fe94-e20c-4356-bed8-c2368b4f43f3.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8663fe94-e20c-4356-bed8-c2368b4f43f3.png)'
- en: 'To print the characters with a step of `2`, do the following:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印步长为`2`的字符，按照以下方式操作：
- en: '![](img/6f045c64-fcec-4fac-a464-6b0d2851675d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f045c64-fcec-4fac-a464-6b0d2851675d.png)'
- en: 'To print the reverse of the string, do the following:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印字符串的反向，请执行以下操作：
- en: '![](img/8320ea2f-87aa-493d-90df-6ca0ac460748.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8320ea2f-87aa-493d-90df-6ca0ac460748.png)'
- en: 'To print a part of the string in reverse order, to the following:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字符串的一部分以相反的顺序，如下所示：
- en: '![](img/a9f35a75-da29-4ce9-88b6-d2abb5ab707f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9f35a75-da29-4ce9-88b6-d2abb5ab707f.png)'
- en: String concatenation and replication
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接和复制
- en: '`+` is the concatenation operator that''s used in Python to concatenate two
    strings. As always, the result of the concatenation is a new string and unless
    we get the updated string, the update will not be reflected with the original
    string object. The `+` operator is internally overloaded to perform concatenation
    of objects when it is used on string types. It is also used for the addition of
    two numbers when used on numeric data types, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`是Python中用于连接两个字符串的连接运算符。与往常一样，连接的结果是一个新的字符串，除非我们获得更新后的字符串，否则更新将不会反映在原始字符串对象上。`+`运算符在用于字符串类型时内部被重载以执行对象的连接。当它用于数值数据类型时，也用于两个数字的加法，如下所示：'
- en: '![](img/9bbe9d09-0f6f-4be5-8b84-293154494d00.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bbe9d09-0f6f-4be5-8b84-293154494d00.png)'
- en: 'Interestingly, Python also supports another operator that gets overloaded when
    used with string data types. Instead of performing a conventional operation, this
    operator performs a variation of the original operation so that the functionality
    can be replicated across string data types. Here, we are talking about the multiplication
    operator, `*`. This is conventionally supposed to perform the multiplication of
    numeric data types, but when it is used on string data types, it performs a replication
    operation instead. This is shown in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Python还支持另一个操作符，当与字符串数据类型一起使用时会被重载。它不是执行常规操作，而是执行原始操作的变体，以便可以在字符串数据类型之间复制功能。在这里，我们谈论的是乘法操作符`*`。它通常用于执行数值数据类型的乘法，但当它用于字符串数据类型时，它执行的是复制操作。这在以下代码片段中显示：
- en: '![](img/0dc12321-1ec0-449b-b40e-d18c32ed580e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc12321-1ec0-449b-b40e-d18c32ed580e.png)'
- en: In the preceding case, the multiplication operator actually replicates the `Hello
    world` string stored in the `c` variable five times, as we specified in the expression.
    This is a very handy operation and can be used to generate fuzzing payloads, which
    we will see in the later chapters of this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，乘法运算符实际上将存储在变量`c`中的`Hello world`字符串复制了五次，正如我们在表达式中指定的那样。这是一个非常方便的操作，可以用来生成模糊负载，我们将在本书的后面章节中看到。
- en: The strip(), lstrip(), and rstrip() methods
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: strip()，lstrip()和rstrip()方法
- en: 'The `strip` method is actually used to strip off the white spaces from the
    input string. By default, the `strip` method will strip off the spaces from both
    the left and right sides of the string and will return a new string without spaces
    on both the leading and trailing sides, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip`方法实际上是用于从输入字符串中去除空格。默认情况下，`strip`方法将从字符串的左右两侧去除空格，并返回一个新的字符串，其中前导和尾随两侧都没有空格，如下面的屏幕截图所示：'
- en: '![](img/521462f8-9528-4dd3-8432-3c961ce9e0b1.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/521462f8-9528-4dd3-8432-3c961ce9e0b1.png)'
- en: 'However, if we only wish to strip off the left spaces ,we can use the `lstrip()`
    method. Similarly, if we just wish to strip off the right spaces, we can use the
    `rstrip()` method. This is shown as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想去掉左边的空格，我们可以使用`lstrip()`方法。同样，如果我们只想去掉右边的空格，我们可以使用`rstrip()`方法。如下所示：
- en: '![](img/48b30334-a5c3-422f-a28e-dddd1dc5e34a.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48b30334-a5c3-422f-a28e-dddd1dc5e34a.png)'
- en: The split() method
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: split()方法
- en: 'The `split` method, as the name suggests, is used to split the input string
    over a particular delimiter and return a list that contains the words that have
    been split. We will be looking at lists in more detail shortly. For now, let''s
    take a look at the following example, where we have the name, the age, and the
    salary of an employee in a string separated by commas. If we wish to obtain this
    information separately, we can perform a split over `,`. The `split` function
    takes the first argument as the delimiter on which the `split` operation is to
    be performed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`方法，顾名思义，用于在特定分隔符上拆分输入字符串，并返回包含已拆分单词的列表。我们将很快更详细地了解列表。现在，让我们看一下以下示例，其中我们有员工的姓名、年龄和工资，用逗号分隔在一个字符串中。如果我们希望分别获取这些信息，我们可以在`,`上执行拆分。`split`函数将第一个参数作为要执行`split`操作的分隔符：'
- en: '![](img/54ee7d41-e315-4acf-9ef5-30f8a364999c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54ee7d41-e315-4acf-9ef5-30f8a364999c.png)'
- en: 'By default, the `split` operation is performed over a space, that is, if a
    delimiter is not specified. This can be seen as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`split`操作是在空格上执行的，即，如果未指定分隔符。可以如下所示：
- en: '![](img/3b721965-73f1-443e-ad86-80eb51ad3af0.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b721965-73f1-443e-ad86-80eb51ad3af0.png)'
- en: The find(), index(), upper(), lower(), len(), and count() methods
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: find()、index()、upper()、lower()、len()和count()方法
- en: 'The `find()` function is used to search for a character or string within our
    target string. This function returns the first index of the string if a match
    is found. It returns `-1` if it does not find the match:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`函数用于在目标字符串中搜索字符或字符串。如果找到匹配，此函数返回字符串的第一个索引。如果找不到匹配，则返回`-1`：'
- en: '![](img/ac610f73-f88d-4f46-bd14-e0e7ca7c9db6.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac610f73-f88d-4f46-bd14-e0e7ca7c9db6.png)'
- en: 'The `index()` method is identical to the `find()` method. It returns the first
    index of the string if it finds the match and raises an exception if it does not
    find a match:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`方法与`find()`方法相同。如果找到匹配，它返回字符串的第一个索引，并在找不到匹配时引发异常：'
- en: '![](img/bacda854-0567-4485-b282-0fdab63f915a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bacda854-0567-4485-b282-0fdab63f915a.png)'
- en: 'The `upper()` method is used to transform the input string to upper case letters
    and the `lower()` method is used to transform a given string to lowercase letters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()`方法用于将输入字符串转换为大写字母，`lower()`方法用于将给定字符串转换为小写字母：'
- en: '![](img/1d9cd7e7-9c5c-46da-8404-ced350f2a170.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d9cd7e7-9c5c-46da-8404-ced350f2a170.png)'
- en: 'The `len()` method returns the length of the given string:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`方法返回给定字符串的长度：'
- en: '![](img/76a2b0cf-b6c7-4672-ae1a-eb1414843544.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76a2b0cf-b6c7-4672-ae1a-eb1414843544.png)'
- en: 'The `count()` method returns the number of occurrences of any character or
    string that we wish to count within the target string:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`方法返回我们希望在目标字符串中计算的任何字符或字符串的出现次数：'
- en: '![](img/6d5e9730-57b1-4b13-b8dd-4ab28b9a0255.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d5e9730-57b1-4b13-b8dd-4ab28b9a0255.png)'
- en: The in and not in methods
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`in`和`not in`方法'
- en: 'The `in` and `not in` methods are very handy, as they let us perform a quick
    search on the sequences. If we wish to check if a certain character or word is
    present or not present in the target string, we can use the `in` and `not in` methods.
    These will return `True` if the word is present and `False` otherwise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`和`not in`方法非常方便，因为它们让我们可以快速在序列上进行搜索。如果我们希望检查目标字符串中是否存在或不存在某个字符或单词，我们可以使用`in`和`not
    in`方法。这将返回`True`（如果单词存在）和`False`（如果不存在）：'
- en: '![](img/13b72441-6e6c-4f4e-8558-7a125dfe3a87.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b72441-6e6c-4f4e-8558-7a125dfe3a87.png)'
- en: The endswith(), isdigit(), isalpha(), islower(), isupper(), and capitalize()
    methods
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: endswith()、isdigit()、isalpha()、islower()、isupper()和capitalize()方法
- en: 'The `endswith()` method checks whether the given string ends with a specific
    character or word that we pass as an argument:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`endswith()`方法检查给定字符串是否以我们传递的特定字符或单词结尾：'
- en: '![](img/3c680da9-5f9b-4341-8687-c510267c9191.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c680da9-5f9b-4341-8687-c510267c9191.png)'
- en: 'The `isdigit()` method checks whether the given string is of a digit type or
    not:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`isdigit()`方法检查给定的字符串是否为数字类型：'
- en: '![](img/a1b64dd8-ef60-4a1a-bdc3-3b060d1a3fc4.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1b64dd8-ef60-4a1a-bdc3-3b060d1a3fc4.png)'
- en: 'The `isalpha()` method checks whether the given string is of an alphabetic
    character type or not:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`isalpha()`方法检查给定的字符串是否为字母字符类型：'
- en: '![](img/588ee101-e6b4-4c46-8893-7fb5184b26e6.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/588ee101-e6b4-4c46-8893-7fb5184b26e6.png)'
- en: 'The `islower()` method checks whether the string is lowercase, while the `isupper()`
    method checks if the string is uppercase. The `capitalize()` method puts a given
    string into sentence case:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`islower()`方法检查字符串是否为小写，而`isupper()`方法检查字符串是否为大写。`capitalize()`方法将给定字符串转换为句子大小写：'
- en: '![](img/4b918755-df2c-4319-ba79-94af07d7cd07.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b918755-df2c-4319-ba79-94af07d7cd07.png)'
- en: List types
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表类型
- en: 'Python does not have array types, but instead offers the list data type. Python
    lists also fall under the category of sequences and offer a wide range of functionalities.
    Coming from a Java, C, or C++ background, you are likely to find that Python lists
    are slightly different from the arrays and list types offered by these languages.
    In C, C++, or Java, an array is a collection of elements of similar data types,
    and this is also the case for Java array lists. This is different in the case
    of Python. In Python, a list is a collection of elements that can be of either
    homogeneous and heterogeneous data types. This is one of the features that makes
    Python lists powerful, robust, and easy to use. We also don''t need to specify
    the size of a Python list when declaring it. It can grow dynamically to match
    the number of elements it contains. Let''s see a basic example of using lists:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有数组类型，而是提供了列表数据类型。Python列表也属于序列类，并提供了广泛的功能。如果你来自Java、C或C++背景，你可能会发现Python列表与这些语言提供的数组和列表类型略有不同。在C、C++或Java中，数组是相似数据类型的元素集合，Java数组列表也是如此。但在Python中情况不同。在Python中，列表是可以是同质和异质数据类型的元素集合。这是使Python列表强大、健壮且易于使用的特点之一。在声明时，我们也不需要指定Python列表的大小。它可以动态增长以匹配它包含的元素数量。让我们看一个使用列表的基本示例：
- en: '![](img/80849a5f-d291-4d12-baf5-f3968064f41f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80849a5f-d291-4d12-baf5-f3968064f41f.png)'
- en: 'Lists in Python start from index `0` and any item can be accessed on the basis
    of indices, as shown in the preceding screenshot. The preceding list is homogeneous,
    as all the elements are of string type. We can also have a heterogeneous list,
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的列表从索引`0`开始，可以根据索引访问任何项，如前面的屏幕截图所示。前面的列表是同质的，因为所有元素都是字符串类型。我们也可以有一个异质列表，如下所示：
- en: '![](img/98d236da-817a-4518-803a-e59395b2c770.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98d236da-817a-4518-803a-e59395b2c770.png)'
- en: For now, we are printing the list elements manually. We can very easily iterate
    over them with loops instead, and we will explore that later on. For now, let's
    try to understand which operations can be performed on list structures in Python.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在手动打印列表元素。我们可以很容易地用循环迭代它们，稍后我们将探讨这一点。现在，让我们试着理解Python中可以对列表结构执行哪些操作。
- en: Slicing the lists
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片列表
- en: '**Slicing** is an operation that allows us to extract elements from sequences
    and lists. We can slice lists to extract portions that we might be interested
    in. It must be noted again that the indexes of slicing are 0-based and that the
    last index is always considered to be `n-1`, where n is the specified last index
    value. To slice the first five and last five elements from the list, we can perform
    the following operation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片**是一种允许我们从序列和列表中提取元素的操作。我们可以对列表进行切片，以提取我们感兴趣的部分。需要再次注意的是，切片的索引是基于0的，并且最后一个索引始终被视为`n-1`，其中n是指定的最后一个索引值。要从列表中切片出前五个和后五个元素，我们可以执行以下操作：'
- en: '![](img/f71326a4-1b4c-4fe4-a8a6-2ffabe019d33.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71326a4-1b4c-4fe4-a8a6-2ffabe019d33.png)'
- en: 'Let''s see some examples of list slicing and their results:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些列表切片的示例及其结果：
- en: 'To get the list from index `4` onwards, do the following:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取从索引`4`开始的列表，请执行以下操作：
- en: '![](img/46a125ca-dab4-473c-8796-8b0fe756da1c.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46a125ca-dab4-473c-8796-8b0fe756da1c.png)'
- en: 'To get the list elements from the start up to index `4`, do the following:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取从开头到索引`4`的列表元素，请执行以下操作：
- en: '![](img/3c3ea6df-f4f2-4278-b6ea-6b775b7969bf.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c3ea6df-f4f2-4278-b6ea-6b775b7969bf.png)'
- en: 'To print the whole list with slicing, do the following:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用切片打印整个列表，请执行以下操作：
- en: '![](img/d7bf51a3-9ed3-4f24-a1a0-8890dfba879d.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7bf51a3-9ed3-4f24-a1a0-8890dfba879d.png)'
- en: 'To print the list elements with a step size of `2`, do the following:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印步长为`2`的列表元素，请执行以下操作：
- en: '![](img/8fd8c671-7792-46f7-93e6-b3a979605b0f.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd8c671-7792-46f7-93e6-b3a979605b0f.png)'
- en: 'To print the reverse of the list, do the following:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印列表的反向，请执行以下操作：
- en: '![](img/69c36743-6554-4c54-91b7-395d2a5d1e10.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c36743-6554-4c54-91b7-395d2a5d1e10.png)'
- en: 'To print a portion of the list in reverse order, do the following:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以相反的顺序打印列表的一部分，请执行以下操作：
- en: '![](img/b490c167-0ab4-4ed5-bb00-1751307d7b46.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b490c167-0ab4-4ed5-bb00-1751307d7b46.png)'
- en: 'Add new elements to `list-append()`: The `append()` method is used to add elements
    to the list, and the elements to be added are given as an argument to the `append()`
    method. These elements to be added can be of any type. As well as being a number
    or a string, the element can be a list in itself:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`list-append()`添加新元素：`append()`方法用于向列表添加元素，要添加的元素作为参数传递给`append()`方法。要添加的这些元素可以是任何类型。除了数字或字符串之外，元素本身可以是一个列表：
- en: '![](img/6cf0eaa7-81d0-43f2-b4e6-bd9c147ac5f0.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cf0eaa7-81d0-43f2-b4e6-bd9c147ac5f0.png)'
- en: We can see in the preceding example that we added three elements, `6`, `7`,
    and `8`, to our original list using the `append()` method. Then, we actually added
    another list containing three characters that would be stored intact as a list
    inside the original list. These can be accessed by specifying the `my_list[8]`
    index. In the preceding example, the new list is added intact to the original
    list, but is not merged.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的例子中，我们使用`append()`方法向原始列表添加了三个元素`6`、`7`和`8`。然后，我们实际上添加了另一个包含三个字符的列表，这个列表会完整地存储在原始列表中。可以通过指定`my_list[8]`索引来访问它们。在前面的例子中，新列表完整地添加到原始列表中，但没有合并。
- en: Merging and updating lists
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并和更新列表
- en: 'List merging can be done in two ways in Python. First, we can use the traditional
    `+` operator, which we used previously to concatenate two strings. It does the
    same when used on list object types. The other way to achieve this would be by
    using the `extend` method, which takes the new list as an argument to be merged
    with the existing list. This is shown in the following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以通过两种方式进行列表合并。首先，我们可以使用传统的`+`运算符，之前我们用来连接两个字符串。当用于列表对象类型时，它也是一样的。另一种方法是使用`extend`方法，它将新列表作为要与现有列表合并的参数。这在以下示例中显示：
- en: '![](img/6bc7138d-5445-493a-b429-ad348042890f.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc7138d-5445-493a-b429-ad348042890f.png)'
- en: 'To update an element in the list, we can access its index and add the updated
    value for any element that we wish to update. For example, if we want to have
    the string `Hello` as the 0^(th) element of the list, this can be achieved by
    assigning the 0^(th) element to the `Hello` value as `merged[0]="hello"`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新列表中的元素，我们可以访问其索引，并为我们希望更新的任何元素添加更新后的值。例如，如果我们希望将字符串`Hello`作为列表的第0个元素，可以通过将第0个元素分配给`Hello`值来实现`merged[0]="hello"`：
- en: '![](img/81dc9bf3-7d05-4dc5-a2fe-7669da40f460.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81dc9bf3-7d05-4dc5-a2fe-7669da40f460.png)'
- en: Copying lists
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制列表
- en: 'We have seen that Python variables are nothing but references to actual objects.
    The same holds true for lists. For this reason, manipulating lists gets a little
    tricky. By default, if we copy one list variable to another one by simply using
    the `=` operator, it won''t actually create a duplicate or local copy of the list
    for that variable – instead, it would just create another reference and point
    the newly created reference toward the same memory location. Thus, when we make
    a change to the copied variable, the same change will be reflected in the original
    list. In the following example, we will create new isolated copies, where a change
    in the copied variable will not be reflected in the original list:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Python变量只是对实际对象的引用。对于列表也是如此。因此，操作列表会有点棘手。默认情况下，如果我们通过简单地使用`=`运算符将一个列表变量复制到另一个列表变量，它实际上不会创建列表的副本或本地副本
    - 相反，它只会创建另一个引用，并将新创建的引用指向相同的内存位置。因此，当我们对复制的变量进行更改时，原始列表中也会反映相同的更改。在下面的示例中，我们将创建新的隔离副本，其中对复制的变量的更改不会反映在原始列表中：
- en: '![](img/a0c195ed-49bc-4dec-9772-0f94c573644a.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0c195ed-49bc-4dec-9772-0f94c573644a.png)'
- en: 'Now, let''s look at how can we create a new copy of an existing list so that
    the changes to the new one do not cause any changes to the existing one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建现有列表的新副本，以便对新列表的更改不会对现有列表造成任何更改：
- en: '![](img/fd4396e7-54fa-4227-b771-f9708b988c64.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd4396e7-54fa-4227-b771-f9708b988c64.png)'
- en: 'Another way to create the isolated copy of the original list is to make use
    of the `copy` and `deepcopy` functions that are available in Python. A shallow
    copy constructs a new object and then inserts *references* to that object to the
    objects found in the original list. A *deep copy*, on the other hand, constructs
    a new compound object and then recursively inserts *copies* of the objects found
    in the original list:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原始列表的隔离副本的另一种方法是利用Python中提供的`copy`和`deepcopy`函数。浅复制构造一个新对象，然后将该对象的*引用*插入到原始列表中找到的对象中。另一方面，*深复制*构造一个新的复合对象，然后递归地插入到原始列表中找到的对象的*副本*：
- en: '![](img/cfa57b95-bd7f-4fdd-8f97-37431ba47755.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa57b95-bd7f-4fdd-8f97-37431ba47755.png)'
- en: Removing elements from lists
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表中删除元素
- en: 'We can use the `del` command to delete either an element from the list or the
    whole list. The `del` command does not return anything. We can also use the `pop`
    method to remove elements from the list. The `pop` method takes the index of the
    element that we wish to remove as an argument:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`del`命令删除列表中的元素或整个列表。`del`命令不返回任何内容。我们也可以使用`pop`方法从列表中删除元素。`pop`方法将要删除的元素的索引作为参数：
- en: '![](img/41be39ab-2b4f-4483-acdd-7e1a929a6dae.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41be39ab-2b4f-4483-acdd-7e1a929a6dae.png)'
- en: 'The entire list structure can be deleted as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 整个列表结构可以被删除如下：
- en: '![](img/52929047-d566-4cd2-b9de-96626a871fa0.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52929047-d566-4cd2-b9de-96626a871fa0.png)'
- en: Replication with len(), max(), and min()
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用len()、max()和min()进行复制
- en: 'The multiplication operator `*`, when applied to lists, causes a replication
    effect of the list elements. The contents of the list are repeated as many times
    as indicated by the number passed to the replication operator:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符`*`，当应用于列表时，会导致列表元素的复制效果。列表的内容将根据传递给复制运算符的数字重复多次：
- en: '![](img/aa5f4c95-bef4-46f8-b4c7-d54df712d39f.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa5f4c95-bef4-46f8-b4c7-d54df712d39f.png)'
- en: 'The `len()` method gives the length of the Python lists. The `max()` method
    returns the maximum element of the list, while the `min()` method returns the
    minimum element of the list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`方法给出了Python列表的长度。`max()`方法返回列表的最大元素，而`min()`方法返回列表的最小元素：'
- en: '![](img/cb322b31-3b37-4f10-a95c-49e17ea5ce9c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb322b31-3b37-4f10-a95c-49e17ea5ce9c.png)'
- en: 'We can use the `max` and `min` methods on the character types as well, but
    we cannot use them on a list that has mixed or heterogeneous types. If we do this,
    we will get an exception stating that we are trying to compare numbers and characters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在字符类型上使用`max`和`min`方法，但是不能在包含混合或异构类型的列表上使用它们。如果这样做，将会得到一个异常，说明我们正在尝试比较数字和字符：
- en: '![](img/edea29fb-7ba5-4650-918a-97c0eaf37001.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edea29fb-7ba5-4650-918a-97c0eaf37001.png)'
- en: in and not in
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: in和not in
- en: 'The `in` and `not in` methods are essential Python operations that can be used
    against any sequence type. We saw how these were used previously with strings,
    where we used them to search for a string or character within the target string.
    The `in` method returns `true` if the search is successful and returns `false`
    if not. The opposite is the case for the `not in` method. The execution is shown
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`和`not in`方法是Python中的基本操作，可以用于任何序列类型。我们之前看到了它们如何与字符串一起使用，我们用它们来搜索目标字符串中的字符串或字符。`in`方法返回`true`，如果搜索成功则返回`false`。`not
    in`方法则相反。执行如下所示：'
- en: '![](img/50142294-3c9d-4e79-b4f8-70ca12912977.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50142294-3c9d-4e79-b4f8-70ca12912977.png)'
- en: Tuples in Python
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的元组
- en: 'A **Python tuple** is very similar to a Python list. The difference is that
    it''s a read-only structure, so once it is declared, no modification can be made
    to the elements of the tuple. Python tuples can be used as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python元组与Python列表非常相似。不同之处在于它是一个只读结构，因此一旦声明，就不能对元组的元素进行修改。Python元组可以用如下方式使用：
- en: '![](img/deb53b7e-f5fc-4639-9413-03355effa0d6.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb53b7e-f5fc-4639-9413-03355effa0d6.png)'
- en: 'In the preceding code, we can see that we can access tuples in the same way
    as we can access lists, but when we try to change any element of the tuple, it
    throws us an exception as a tuple is a read-only structure. If we perform the
    operations that we performed on lists, we will see that they work in exactly the
    same way as tuples:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们可以像访问列表一样访问元组，但是当我们尝试更改元组的任何元素时，它会抛出一个异常，因为元组是只读结构。如果我们执行我们在列表上执行的操作，我们会发现它们与元组的工作方式完全相同：
- en: '![](img/f4f04740-11d2-47d7-b642-86bded48a6b3.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4f04740-11d2-47d7-b642-86bded48a6b3.png)'
- en: 'If a tuple has only one element in it, it has to be declared with a trailing
    comma. If we do not add that comma while declaring it, it will be interpreted
    as a numeric or string data type, depending on the elements of the tuple. The
    following example explains this better:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组中只有一个元素，则必须使用尾随逗号声明。如果在声明时不添加逗号，则将根据元组的元素将其解释为数字或字符串数据类型。以下示例更好地解释了这一点：
- en: '![](img/aadff71a-28ef-4377-803c-3790e9c065a0.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aadff71a-28ef-4377-803c-3790e9c065a0.png)'
- en: 'A tuple can be converted into a list and can then be operated on as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以转换为列表，然后可以进行如下操作：
- en: '![](img/d2a752cc-1c18-412a-9de8-483ee1ba9b8e.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2a752cc-1c18-412a-9de8-483ee1ba9b8e.png)'
- en: Dictionaries in Python
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的字典
- en: '**Dictionaries** are very powerful structures and are widely used in Python.
    A dictionary is a key-value pair structure. A dictionary key can be a unique number
    or string, and the value can be any Python object. Dictionaries are mutable and
    can be changed in place. The following example demonstrates the basics of dictionaries
    in Python:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**是非常强大的结构，在Python中被广泛使用。字典是一种键值对结构。字典键可以是唯一的数字或字符串，值可以是任何Python对象。字典是可变的，可以就地更改。以下示例演示了Python中字典的基础知识：'
- en: '![](img/026f5772-da80-4c06-b866-5ffa45f665af.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/026f5772-da80-4c06-b866-5ffa45f665af.png)'
- en: 'A Python dictionary can be declared within curly braces. Each key value pair
    is separated by a comma. It should be noted that the keys have to be unique; if
    we try to repeat the keys, the old key value pair is overwritten by the new one.
    From the preceding example, we can establish that the dictionary keys can be either
    string or numeric types. Let''s try to perform various operations on dictionaries
    in Python:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典可以在花括号内声明。每个键值对之间用逗号分隔。应该注意，键必须是唯一的；如果我们尝试重复键，旧的键值对将被新的键值对覆盖。从前面的例子中，我们可以确定字典键可以是字符串或数字类型。让我们尝试在Python中对字典进行各种操作：
- en: '**Retrieving the dictionary values with the keys**: Dictionary values can be
    accessed through the name of the dictionary key. If the name of the key is not
    known, we can use loops to iterate through the whole dictionary structure. We
    will cover this in the next chapter of this book:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用键检索字典值**：可以通过字典键的名称访问字典值。如果不知道键的名称，可以使用循环来遍历整个字典结构。我们将在本书的下一章中介绍这一点： '
- en: '![](img/3800b1fd-c087-4497-9eb2-70d32b55f8b2.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3800b1fd-c087-4497-9eb2-70d32b55f8b2.png)'
- en: 'This is one of the many ways to print dictionary values. However, if the key
    for which the value we wish to print does not exist in the dictionary, we will
    get a key not found exception, as shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是打印字典值的许多方法之一。但是，如果我们要打印值的键在字典中不存在，我们将收到一个找不到键的异常，如下截图所示：
- en: '![](img/9be2648e-13c9-4097-b0ce-04c7dcbf929d.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9be2648e-13c9-4097-b0ce-04c7dcbf929d.png)'
- en: 'There is a better way to handle this and avoid these kinds of exceptions. We
    can use the `get()` method provided by the dictionary class. The `get()` method
    takes the key name as the first argument and the default value if the key is not
    present as the second argument. Then, instead of throwing an exception, the default
    value will be returned if the key is not found. This is shown in the following
    screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方法来处理这个问题，避免这种类型的异常。我们可以使用字典类提供的`get()`方法。`get()`方法将键名作为第一个参数，如果键不存在，则将默认值作为第二个参数。然后，如果找不到键，将返回默认值，而不是抛出异常。如下截图所示：
- en: '![](img/5884c24f-f3c4-44dc-9b79-ca9f0e412392.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5884c24f-f3c4-44dc-9b79-ca9f0e412392.png)'
- en: In the preceding example, when the `k1` key is present in the actual dictionary,
    `dict1`, the value for the `k1` key is returned, which is `v1`. Then, the `k0`
    key was searched, which was not present originally. In that case, no exception
    was raised, but instead the `False` value was returned, suggesting that no such
    key, `K0`, was actually present. Remember that we can specify any placeholder
    as the second argument to the `get()` method to indicate the absence of the key
    we are searching for.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当实际字典`dict1`中存在`k1`键时，将返回`k1`键的值，即`v1`。然后，搜索了`k0`键，但最初不存在。在这种情况下，不会引发异常，而是返回`False`值，表明实际上不存在这样的键`K0`。请记住，我们可以将任何占位符作为`get()`方法的第二个参数，以指示我们要搜索的键的缺失。
- en: '**Adding keys and values to the dictionary**: Once a dictionary has been declared,
    over the course of the code, there could be many occasions in which we want to
    modify a dictionary key or add a new dictionary key and value. This can be achieved
    as follows. As mentioned earlier, a dictionary value can be any Python object,
    so we can have tuples, lists, and dictionary types as values inside a dictionary:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向字典添加键和值**：一旦声明了字典，在代码的过程中可能会有许多情况，我们希望修改字典键或添加新的字典键和值。可以通过以下方式实现。如前所述，字典值可以是任何Python对象，因此我们可以在字典中的值中有元组、列表和字典类型：'
- en: '![](img/425afb59-cd2f-4d18-966d-8fa9b01a11a8.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/425afb59-cd2f-4d18-966d-8fa9b01a11a8.png)'
- en: 'Now, let''s add more complex types as values:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将更复杂的类型添加为值：
- en: '![](img/228b2391-23bd-460f-85e0-6e045e2b03ed.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/228b2391-23bd-460f-85e0-6e045e2b03ed.png)'
- en: 'These values can be retrieved as normal values by their keys as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过它们的键正常检索这些值，如下所示：
- en: '![](img/a68a6a98-a518-4c70-a02f-c8d7171aa4f4.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a68a6a98-a518-4c70-a02f-c8d7171aa4f4.png)'
- en: '**Expanding a dictionary with the contents of another dictionary**: In the
    preceding example,we added a dictionary as a value to an existing dictionary.
    We will now see how can we merge two dictionaries into one common or new dictionary.
    The `update()` method can be used to do this:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展字典内容**: 在前面的例子中，我们将一个字典添加为现有字典的值。我们现在将看到如何将两个字典合并为一个公共或新字典。可以使用`update()`方法来实现这一点：'
- en: '![](img/7474e4c8-1dc5-4086-a8df-f911e871d9c0.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7474e4c8-1dc5-4086-a8df-f911e871d9c0.png)'
- en: '**`Keys()`**: To get all the dictionary keys, we can use the `keys()` method.
    This returns the class instances of the dictionary keys:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Keys()`**：要获取所有字典键，我们可以使用`keys()`方法。这将返回字典键的类实例：'
- en: '![](img/85740215-8770-4e17-b499-4f91cae8fbb8.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85740215-8770-4e17-b499-4f91cae8fbb8.png)'
- en: 'We can see that the keys method returns an instance of the `dict_keys` class,
    which holds the list of dictionary keys. We can type cast this as a list type
    as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，keys方法返回一个`dict_keys`类的实例，它保存了字典键的列表。我们可以将其强制转换为列表类型，如下所示：
- en: '![](img/86da945a-0ecb-44f2-a367-d6e6fe617918.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86da945a-0ecb-44f2-a367-d6e6fe617918.png)'
- en: '**`values()`**: The `values()` method returns all the values that are present
    in the dictionary:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`values()`**：`values()`方法返回字典中存在的所有值：'
- en: '![](img/3c4ba243-4241-4d6c-b0c8-9bccbe80de5d.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c4ba243-4241-4d6c-b0c8-9bccbe80de5d.png)'
- en: '**`Items()`**: This method is actually used to iterate over the dictionary
    key value pairs, as it returns a list class instance that contains a list of tuples.
    Each tuple has two entries, the first one being the key and the second one being
    the value:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Items()`**：这个方法实际上是用来遍历字典键值对的，因为它返回一个包含元组列表的列表类实例。每个元组有两个条目，第一个是键，第二个是值：'
- en: '![](img/6c4ee05b-2d21-4c19-b018-492110271041.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c4ee05b-2d21-4c19-b018-492110271041.png)'
- en: 'We can convert the returned class instance into a tuple, list tuple, or list
    type as well. The ideal way to do this is to iterate over the items, which we
    will see later when we look at loops:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将返回的类实例转换为元组、列表元组或列表类型。这样做的理想方式是遍历项目，我们稍后将在循环时看到：
- en: '![](img/b526057b-5f0d-471b-9256-da3477b45944.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b526057b-5f0d-471b-9256-da3477b45944.png)'
- en: '**`in`** and **`not in`**: The `in` and `not in` methods are used to see whether
    a key is present in the dictionary or not. By default, the `in` and `not in` clauses
    will search the dictionary keys, not the values. Take a look at the following
    example:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`in`**和**`not in`**：`in`和`not in`方法用于查看字典中是否存在键。默认情况下，`in`和`not in`子句将搜索字典键，而不是值。看下面的例子：'
- en: '![](img/8423b4f3-adbc-448d-a657-4ba3d67e5264.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8423b4f3-adbc-448d-a657-4ba3d67e5264.png)'
- en: '**Order of storing**: By default, Python dictionaries are unordered, which
    means they are not stored internally in the same order as we define them. The
    reason for this is that the dictionaries are stored in dynamic tables called **hash
    tables**. As these tables are dynamic, they can increase and shrink in size. What
    happens internally is that a hash value of the key is computed and stored in the
    table. The key goes in the first column, while the second column holds the actual
    value. Let''s take a look at the following example to explain this better:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储顺序**：默认情况下，Python字典是无序的，这意味着它们在内部存储的顺序与我们定义的顺序不同。这是因为字典存储在称为**哈希表**的动态表中。由于这些表是动态的，它们的大小可以增加和缩小。内部发生的情况是计算键的哈希值并将其存储在表中。键进入第一列，而第二列保存实际值。让我们看下面的例子来更好地解释这一点：'
- en: '![](img/5df607af-fdcd-462d-bfe9-23375ad29fd9.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df607af-fdcd-462d-bfe9-23375ad29fd9.png)'
- en: In the preceding case, we declare a dictionary, `a`, with the first key as `abc`
    and the second key as `abcd`. When we print the values, however, we can see that
    `abcd` is stored internally before `abc`. To explain this, let's assume that the
    dynamic table or hash table in which the dictionary is internally stored is of
    size `8`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个名为`a`的字典，第一个键为`abc`，第二个键为`abcd`。然而，当我们打印值时，我们可以看到`abcd`在`abc`之前存储。为了解释这一点，让我们假设字典内部存储的动态表或哈希表的大小为`8`。
- en: 'As we mentioned earlier, the keys will be stored as hash values. When we compute
    the hash of the `abc` string and and divide it in a modular fashion by `8`, which
    is the table size, we get the result of `7`. If we do the same for `abcd`, we
    get a result of `4`. This means that the hash `abcd` will be stored at index `4`,
    while the hash `abc` will be stored at index `7`. For this reason, in the listing,
    we get `abcd` listed before `abc`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，键将被存储为哈希值。当我们计算`abc`字符串的哈希并以模8的方式进行除法时，即表大小为`8`，我们得到结果`7`。如果我们对`abcd`做同样的操作，我们得到结果`4`。这意味着哈希`abcd`将被存储在索引`4`，而哈希`abc`将被存储在索引`7`。因此，在列表中，我们得到`abcd`在`abc`之前列出的原因是这样的：
- en: '![](img/e5c7a7d8-19a0-47de-85ee-17aa4f778632.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5c7a7d8-19a0-47de-85ee-17aa4f778632.png)'
- en: There may be occasions in which two keys arrive at a common value after the
    `hash(key)%table_size` operation, which is called a **collision**. In this case,
    the key to be slotted first is the one that is stored first.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hash(key)%table_size`操作后，可能会出现两个键到达相同值的情况，这称为**冲突**。在这种情况下，首先插槽的键是先存储的键。
- en: '**`sorted()`**: If we want our dictionary to be sorted according to the keys,
    we can use the built-in sorted method. This can be tweaked to return a list of
    tuples, with each tuple having a key at the 0^(th) index and its value at the
    1^(st) index:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`sorted()`**：如果我们希望字典根据键排序，可以使用内置的sorted方法。这可以调整为返回一个元组列表，每个元组在第0个索引处有一个键，第1个索引处有一个值：'
- en: '![](img/ccb9d9fc-f6fc-4fe5-98d0-95e24576990c.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccb9d9fc-f6fc-4fe5-98d0-95e24576990c.png)'
- en: '**Removing elements**: We can use the conventional `del` statement to delete
    any dictionary item. When we say delete, we mean delete both the key and the value.
    Dictionary items work in pairs, so deleting the key would remove the value as
    well. Another way to delete an entry is to use the `pop()` method and pass the
    key as an argument. This is shown in the following code snippet:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除元素**：我们可以使用传统的`del`语句来删除任何字典项。当我们说删除时，我们指的是删除键和值。字典项成对工作，因此删除键也会删除值。删除条目的另一种方法是使用`pop()`方法并将键作为参数传递。这在以下代码片段中显示：'
- en: '![](img/b723bc4c-f7de-45c6-87d3-8bc7252f83b7.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b723bc4c-f7de-45c6-87d3-8bc7252f83b7.png)'
- en: Python operators
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python运算符
- en: 'An operator in Python is something that can carry out arithmetic or logical
    operations on an expression. The variable on which the operator operates is called
    the **operand**. Let''s try to understand the various operators that are available
    in Python:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python中的运算符是可以对表达式进行算术或逻辑操作的东西。运算符操作的变量称为**操作数**。让我们试着了解Python中提供的各种运算符： '
- en: '**Arithmetic**:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术**：'
- en: '| **Functions** | **Example** |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **示例** |'
- en: '| Addition | `a + b` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `a + b` |'
- en: '| Subtraction | `a - b` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | `a - b` |'
- en: '| Negation | `-a` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 否定 | `-a` |'
- en: '| Multiplication | `a * b` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `a * b` |'
- en: '| Division | `a / b` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | `a / b` |'
- en: '| Modulo | `a % b` |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 取模 | `a % b` |'
- en: '| Exponentiation | `a ** b` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | `a ** b` |'
- en: '| Floor Division | `a // b` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 地板除法 | `a // b` |'
- en: '**Assignment**:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值**：'
- en: '`a = 0` evaluates to `a=0`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a = 0`评估为`a=0`'
- en: '`a +=1` evaluates to `a = a + 1`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a +=1`评估为`a = a + 1`'
- en: '`a -= 1` evaluates to `a = a + 1`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a -= 1`评估为`a = a + 1`'
- en: '`a *= 2` evaluates to `a = a * 2`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a *= 2`评估为`a = a * 2`'
- en: '`a /= 5` evaluates to `a = a / 5`'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a /= 5`评估为`a = a / 5`'
- en: '`a **= 3` evaluates to `a = a ** 3`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a **= 3`评估为`a = a ** 3`'
- en: '`a //= 2` evaluates to `a= a // 2` (floor division 2)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a //= 2`评估为`a= a // 2`（地板除法2）'
- en: '`a %= 5` evaluates to `a= a % 5`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a %= 5`评估为`a= a % 5`'
- en: '**Logical operators**:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑运算符**：'
- en: '**`and`**: `True`: If both the operands are `true`, then the condition becomes
    `true`. For example, `(a and b)` is `true`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`and`**：`True`：如果两个操作数都为`true`，则条件变为`true`。例如，`(a and b)`为`true`。'
- en: '**`or`**: `True`: If any of the two operands are non-zero, then the condition
    becomes `true`. For example, `(a or b)` is `true`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`or`**：`True`：如果两个操作数中有任何一个非零，则条件变为`true`。例如，`(a or b)`为`true`。'
- en: '**`not`**: `True`: This is used to reverse the logical state of its operand.
    For example, `not (a and b)` is `false`.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`not`**：`True`：用于颠倒其操作数的逻辑状态。例如，`not (a and b)`为`false`。'
- en: '**Bitwise operators**:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算符**：'
- en: '| **Functions** | **Example** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **示例** |'
- en: '| `and` | `a & b` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `and` | `a & b` |'
- en: '| `or` | `a &#124; b` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `or` | `a &#124; b` |'
- en: '| `xor` | `a ^ b` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `xor` | `a ^ b` |'
- en: '| `invert` | `~ a` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `反转` | `~ a` |'
- en: '| `Right Shift` | `a >> b` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `右移` | `a >> b` |'
- en: '| `Left Shift` | `a << b` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `左移` | `a << b` |'
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the basics of Python and explored the syntax of
    the language. This isn't very different from the languages that you may have studied
    in the past, such as C, C ++, or Java. However, it's much easier to use and is
    really powerful in the cyber security domain compared to its peers. This chapter
    formulates the basics of Python and will help us progress, as some data types
    such as lists, dictionaries, tuples, and strings are used heavily throughout the
    course of this book.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Python的基础知识，并探索了该语言的语法。这与您以往可能学过的语言并没有太大不同，例如C、C++或Java。但是，与同行相比，它更容易使用，并且在网络安全领域非常强大。本章阐述了Python的基础知识，并将帮助我们进步，因为一些数据类型，如列表、字典、元组和字符串在本书的整个过程中都被大量使用。
- en: In the next chapter, we will learn about conditions and loops and see how loops
    can be used with the data types that we have studied so far.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习条件和循环，并看看循环如何与我们迄今为止学习的数据类型一起使用。
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is Python open source? If so, how is it different from other open source languages?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python是开源的吗？如果是，它与其他开源语言有何不同？
- en: Who manages Python and works on further feature enhancements?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁管理Python并致力于进一步的功能增强？
- en: Is Python faster than Java?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python比Java快吗？
- en: Is Python object-oriented or functional?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python是面向对象的还是函数式的？
- en: Can I learn Python quickly if I have little to no experience with any programming
    language?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我对任何编程语言几乎没有经验，我能快速学会Python吗？
- en: How is Python beneficial to me, being a cyber security engineer?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python对我有什么好处，作为一名网络安全工程师？
- en: I am a penetration tester – why do I need to understand AI and machine learning?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我是一名渗透测试员-为什么我需要了解人工智能和机器学习？
