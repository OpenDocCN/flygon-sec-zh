- en: Assembly Language in Linux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的汇编语言
- en: In this chapter, we are going to talk about assembly language programming in
    Linux. We will go through how to build our own code. An assembly language is a
    low-level programming language. Low-level programming languages are machine-dependent
    programming and are the simplest form that a computer understands. In assembly,
    you will be dealing with computer architecture components such as registers and
    stack, unlike most high-level programming languages such as Python or Java. Also,
    assembly is not a portable language, which means each assembly programming language
    is specific to one hardware or one computer architecture; for example, Intel has
    its own specific assembly language. We are learning assembly not to build a sophisticated
    software but to build our own customized shellcodes, so we will be going to make
    it very easy and simple.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在Linux中的汇编语言编程。我们将学习如何构建我们自己的代码。汇编语言是一种低级编程语言。低级编程语言是机器相关的编程，是计算机理解的最简单形式。在汇编中，你将处理计算机架构组件，如寄存器和堆栈，不像大多数高级编程语言，如Python或Java。此外，汇编不是一种可移植的语言，这意味着每种汇编编程语言都特定于一种硬件或一种计算机架构；例如，英特尔有自己特定的汇编语言。我们学习汇编不是为了构建复杂的软件，而是为了构建我们自己定制的shellcode，所以我们将使它非常简单和简单。
- en: I promise that, after this chapter, you will look at each program and process
    differently, and you will be able to understand how computers really execute your
    instructions. Let's start!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我保证，完成本章后，你将以不同的方式看待每个程序和进程，并且你将能够理解计算机是如何真正执行你的指令的。让我们开始吧！
- en: Assembly language code structure
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编语言代码结构
- en: Here, we are not going to talk about the language structure but the code structure.
    Do you remember memory layout?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会讨论语言结构，而是代码结构。你还记得内存布局吗？
- en: 'Let''s take another look at it:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一下：
- en: '![](img/00052.gif)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.gif)'
- en: 'We are going to put our **executable code** in the `.text` section and our
    **variables** in the `.data` section:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的**可执行代码**放在`.text`部分，我们的**变量**放在`.data`部分：
- en: '![](img/00053.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: 'Let''s also have a closer look at the stack. The stack is **LIFO**, which means
    **Last Input First Output**, so it''s not random access, rather it uses push and
    pop operations. Push is to push something into the top of the stack. Let''s look
    at an example. Suppose that we have a stack and it contains only **0x1234**:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更仔细地看一下堆栈。堆栈是**LIFO**，这意味着**后进先出**，所以它不是随机访问，而是使用推入和弹出操作。推入是将某物推入堆栈顶部。让我们看一个例子。假设我们有一个堆栈，它只包含**0x1234**：
- en: '![](img/00054.gif)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.gif)'
- en: 'Now, let''s push something into the stack using the assembly `push 0x5678`.
    This instruction will push the value **0x5678** into the stack, and that will
    change the **stack pointer** to point to **0x5678**:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用汇编`push 0x5678`将某物推入堆栈。这条指令将值**0x5678**推入堆栈，并将**堆栈指针**指向**0x5678**：
- en: '![](img/00055.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: 'Now, if we want to get data out of the stack, we use a `pop` instruction, and
    it will extract the last element pushed into the stack. So, taking the same stack
    layout, let''s extract the last element using `pop rax`, which will extract the
    value **0x5678** and move it to the **RAX** register:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要从堆栈中取出数据，我们使用`pop`指令，它将提取推入堆栈的最后一个元素。因此，以相同的堆栈布局，让我们使用`pop rax`来提取最后一个元素，它将提取值**0x5678**并将其移动到**RAX**寄存器：
- en: '![](img/00056.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: It's very simple!!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！
- en: How are we going to code assembly on Linux x64? Actually, it's quite simple;
    do you remember syscalls? This is how we are going to execute what we want by
    invoking system commands. For example, if I want to exit a program then I have
    to use the `exit` syscall.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何在Linux x64上编写汇编代码？实际上，这很简单；你还记得系统调用吗？这就是我们通过调用系统命令来执行我们想要的方式。例如，如果我想要退出一个程序，那么我必须使用`exit`系统调用。
- en: 'Firstly, this file, `/usr/include/x86_64-linux-gnu/asm/unistd_64.h`, contains
    all the syscalls for Linux x64\. Let''s search for the `exit` syscall:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个文件`/usr/include/x86_64-linux-gnu/asm/unistd_64.h`包含了Linux x64的所有系统调用。让我们搜索`exit`系统调用：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `exit` syscall has a syscall number `60`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`系统调用有一个系统调用号`60`。'
- en: 'Now, let''s look at its arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下它的参数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/00057.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: 'There is only one argument, that is, `status`, and it has the `int` data type
    to define the exit status, such as zero status for no error:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个参数，即`status`，它具有`int`数据类型来定义退出状态，例如零状态表示没有错误：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s see how we are going to use registers to invoke Linux x64 syscalls:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用寄存器来调用Linux x64系统调用：
- en: '![](img/00058.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: We just put the **syscall number** in **RAX**, then the **first argument** in
    **RDI**, **second argument** in **RSI**, and so on, as shown in the preceding
    screenshot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将**系统调用号**放入**RAX**，然后将**第一个参数**放入**RDI**，**第二个参数**放入**RSI**，依此类推，就像前面的截图所示。
- en: 'Let''s look at how we are going to invoke the `exit` syscall:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一看我们将如何调用`exit`系统调用：
- en: '![](img/00059.gif)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.gif)'
- en: We just put **60**, which is the `exit` syscall number in **RAX**, then we put
    **0** in **RDI**, which is the exit status; yes, it's that simple!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将**60**，即`exit`系统调用号放入**RAX**，然后将**0**放入**RDI**，这就是退出状态；是的，就是这么简单！
- en: 'Let''s take a deeper look at the assembly code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看一下汇编代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line tells the processor to move the value `60` into `rax`, and in
    the second line it tells the processor to move the value `0` into `rdi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉处理器将值`60`移动到`rax`中，第二行告诉处理器将值`0`移动到`rdi`中。
- en: As you can see, the general structure of one instruction is `{Operation} {Destination},
    {Source}`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一条指令的一般结构是`{操作} {目的地}，{来源}`。
- en: Data types
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: Data types are important in assembly. We can use them to define a variable or
    when we want to perform any operation on just a small portion of register or memory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型在汇编中很重要。我们可以用它们来定义变量，或者当我们想要对寄存器或内存的一小部分执行任何操作时使用它们。
- en: 'The following table explains the data types in assembly based on length:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了汇编中基于长度的数据类型：
- en: '| **Name** | **Directive** | **Bytes** | **Bits** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **指令** | **字节** | **位** |'
- en: '| Byte | `db` | 1 | 8 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | `db` | 1 | 8 |'
- en: '| Word | `dw` | 2 | 16 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 字 | `dw` | 2 | 16 |'
- en: '| Doubleword | `dd` | 4 | 32 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 双字 | `dd` | 4 | 32 |'
- en: '| Quadword | `dq` | 8 | 64 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 四字 | `dq` | 8 | 64 |'
- en: To fully understand, we are going to build a hello world program in assembly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解，我们将在汇编中构建一个hello world程序。
- en: Hello world
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world
- en: OK, let's start to go deeper. We are going to build a hello world, which is
    undoubtedly the basic building block for any programmer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始深入了解。我们将构建一个hello world，这无疑是任何程序员的基本构建块。
- en: 'First, we need to understand what we really need, which is a syscall to print
    `hello world` on the screen. To do this, let''s search for the `write` syscall:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解我们真正需要的是一个系统调用来在屏幕上打印`hello world`。为此，让我们搜索`write`系统调用：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that the `write` syscall is number `1`; now let''s look at its arguments:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`write`系统调用的编号是`1`；现在让我们看看它的参数：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/00060.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: 'The `write` syscall has three arguments; the first one is the file descriptor:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`系统调用有三个参数；第一个是文件描述符：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The file descriptor has three modes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符有三种模式：
- en: '| **Integer value** | **Name** | **Alias for** `stdio.h` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **整数值** | **名称** | **`stdio.h`的别名** |'
- en: '| `0` | Standard input | `stdin` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 标准输入 | `stdin` |'
- en: '| `1` | Standard output | `stdout` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 标准输出 | `stdout` |'
- en: '| `2` | Standard error | `stderr` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 标准错误 | `stderr` |'
- en: As we are going to print `hello world` on the screen, we are going to choose
    standard output `1`, the second argument, which is a pointer to the string we
    want to print; the third argument is the count of the string, including spaces.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要在屏幕上打印`hello world`，所以我们将选择标准输出`1`，作为第二个参数，它是指向我们要打印的字符串的指针；第三个参数是字符串的计数，包括空格。
- en: 'The following diagram explains what is going to be inside the registers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了寄存器中将要包含的内容：
- en: '![](img/00061.gif)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.gif)'
- en: 'And now, let''s jump to the full code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到完整的代码：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `.data` section, which contains all the variables, the first variable
    in the code is the `hello_world` variable with data type byte (`db`), and it contains
    a `hello world` string along with `0xa`, which means a new line, like in `\n`
    in C. The second variable is `length`, that contains the length of `hello_world`
    string with `equ`, which means equal, and `$-`, which means evaluate the current
    line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.data`部分，其中包含所有变量，代码中的第一个变量是`hello_world`变量，数据类型为字节（`db`），它包含一个`hello world`字符串以及`0xa`，表示换行，就像C语言中的`\n`一样。第二个变量是`length`，它包含`hello_world`字符串的长度，使用`equ`表示相等，`$-`表示评估当前行。
- en: In the `.text` section, as we previously explained, we move `1` to `rax`, which
    indicates the `write` syscall number, then we move `1` to `rdi` as an indicator
    that the file descriptor is set to standard output, then we move the address of
    the `hello_world` string to `rsi`, and we move the length of the `hello_world`
    string to `rdx`, and finally, we invoke `syscall`, which means execute.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.text`部分，正如我们之前解释的，我们将`1`移动到`rax`，表示`write`系统调用编号，然后我们将`1`移动到`rdi`，表示文件描述符设置为标准输出，然后我们将`hello_world`字符串的地址移动到`rsi`，将`hello_world`字符串的长度移动到`rdx`，最后，我们调用`syscall`，表示执行。
- en: 'Now, let''s assemble and link the object code, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们汇编和链接目标代码，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding commands is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '![](img/00062.gif)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.gif)'
- en: 'It printed the `hello world` string but exited with `Segmentation fault` because
    the program doesn''t know where to go next. We can fix it by adding the `exit`
    syscall:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了`hello world`字符串，但因为程序不知道接下来要去哪里，所以以`Segmentation fault`退出。我们可以通过添加`exit`系统调用来修复它：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We just added the `exit` syscall by moving `60` to `rax`, then we moved `1`
    to `rdi`, which indicates the exit status, and finally we invoked `syscall` to
    execute the `exit` syscall:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`60`移动到`rax`来添加了`exit`系统调用，然后我们将`1`移动到`rdi`，表示退出状态，最后我们调用`syscall`来执行`exit`系统调用：
- en: '![](img/00063.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: 'Let''s assemble the link and try again:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们汇编链接并再次尝试：
- en: '![](img/00064.gif)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.gif)'
- en: 'Now it''s exited normally; let''s also confirm the exit status using `echo
    $?`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它正常退出了；让我们也使用`echo $?`确认退出状态：
- en: '![](img/00065.gif)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.gif)'
- en: Exit status is `1`, as we selected!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态是`1`，正如我们选择的！
- en: Stack
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: As we discussed in the previous chapter, a **stack** is a space allocated for
    each running application and is used to store variables and data. A stack supports
    two operations (push and pop); a **push** operation is used to push an element
    to the stack, and that will cause the stack pointer to move to a lower memory
    address (a stack grows from high memory to low memory) and point to the top of
    the stack, whereas **pop** takes the first element at the top of the stack and
    extracts it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中讨论的，**堆栈**是为每个运行的应用程序分配的空间，用于存储变量和数据。堆栈支持两种操作（推入和弹出）；**推入**操作用于将元素推入堆栈，这将导致堆栈指针移动到较低的内存地址（堆栈从高内存向低内存增长），并指向堆栈顶部，而**弹出**则取出堆栈顶部的第一个元素。
- en: 'Let''s take a look at a simple example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is very simple; let''s compile and link it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单；让我们编译和链接它：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, I will run the application in a debugger (debuggers will be explained
    in the next chapter) just to show you how the stack really works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将在调试器中运行应用程序（调试器将在下一章中解释），只是为了向您展示堆栈的真正工作原理。
- en: 'First, before we run the program, all registers are empty except the RSP register, which
    is now pointing at the top of the stack `00007ffdb3f53950`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在运行程序之前，所有寄存器都是空的，除了RSP寄存器，它现在指向堆栈顶部`00007ffdb3f53950`：
- en: '![](img/00066.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: 'Then, the first instruction is executed, which moves `0x1234` to `rdx`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行第一条指令，将`0x1234`移动到`rdx`：
- en: '![](img/00067.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: 'As we can see, the `rdx` register now holds `0x1234` and there are no changes
    in the stack yet. The second instruction pushes the value of `rdx` into the Stack,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`rdx` 寄存器现在保存着 `0x1234`，而堆栈中还没有发生任何变化。第二条指令将 `rdx` 的值推送到堆栈中，如下所示：
- en: '![](img/00068.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: 'Look at the Stack section; it moved to the lower address (from `50` to `48`),
    and now it contains `0x1234`. The third instruction is to push `0x5678` directly
    to the Stack:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下堆栈部分；它移动到了较低的地址（从 `50` 到 `48`），现在包含 `0x1234`。第三条指令是直接将 `0x5678` 推送到堆栈中：
- en: '![](img/00069.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: 'The fourth instruction will extract the last element in the Stack to `rdi`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第四条指令将把堆栈中的最后一个元素提取到 `rdi` 中：
- en: '![](img/00070.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: 'As you can see, the Stack now doesn''t contain `0x5678` anymore, and it moved
    to `rdi`. The last instruction will be to extract the last element in the Stack
    to `rsi`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，堆栈中不再包含 `0x5678`，而是移动到了 `rdi`。最后一条指令是将堆栈中的最后一个元素提取到 `rsi` 中：
- en: '![](img/00071.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: Now the stack is back to normal and `0x1234` moved to `rsi`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在堆栈恢复正常，`0x1234` 移动到了 `rsi`。
- en: Well, so far, we have covered two basic examples on how to build a hello world
    program and also a push/pop operation in the stack, wherein we saw some basic
    instructions, such as `mov`, `push`, `pop`, and there is much more to come. Now,
    you might be wondering why I haven't explained any of those instructions and took
    you through the examples first. My strategy takes you to the next section; here,
    we will go through all the basic instructions required for an assembly language.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何构建一个 hello world 程序以及堆栈中的推送/弹出操作的两个基本示例，我们看到了一些基本指令，比如 `mov`、`push`、`pop`，还有更多内容等待我们去学习。现在，你可能会想为什么我没有解释这些指令，而是先带你看了这些示例。我的策略是带你进入下一节；在这里，我们将学习汇编语言所需的所有基本指令。
- en: Data manipulation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据操作
- en: '**Data manipulation** is moving data in assembly, and it is a very important
    topic because most of our operations will be moving data to execute instructions,
    so we have to really understand how to use them, such as the `mov` instruction,
    and how to move data between registers and between register and memory, copying
    addresses to registers, and how to swap the contents of two registers or between
    register and memory using the `xchg` instruction, then how to load the effective
    address of the source into the destination using the `lea` instruction.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据操作** 是在汇编中移动数据，这是一个非常重要的主题，因为我们的大部分操作都将是移动数据来执行指令，所以我们必须真正理解如何使用它们，比如 `mov`
    指令，以及如何在寄存器之间和寄存器与内存之间移动数据，复制地址到寄存器，以及如何使用 `xchg` 指令在两个寄存器或寄存器和内存之间交换内容，然后如何使用
    `lea` 指令将源的有效地址加载到目的地。'
- en: The mov instruction
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mov 指令
- en: The `mov` instruction is the most important instruction used in assembly in
    Linux, and we used it in all the previous examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令是在 Linux 中汇编中使用最重要的指令，我们在所有之前的示例中都使用了它。'
- en: The `mov` instruction is used to move data between registers, and between registers
    and memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令用于在寄存器之间、寄存器和内存之间移动数据。'
- en: 'Let''s look at some examples. First, let''s begin with moving data directly
    to registers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。首先，让我们从直接将数据移动到寄存器开始：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code will just copy `0x1234` to `rax` and `0x56789` to `rbx`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将会把 `0x1234` 复制到 `rax`，并且把 `0x56789` 复制到 `rbx`：
- en: '![](img/00072.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: 'Let''s go further and add some moving data between registers to the previous
    example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步添加一些在寄存器之间移动数据到之前的示例中：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What we added just moved the contents of both `rax` and `rbx` to `rdi` and
    `rsi` respectively:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的内容将 `rax` 和 `rbx` 的内容分别移动到 `rdi` 和 `rsi`：
- en: '![](img/00073.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: 'Let''s try to move data between registers and memory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在寄存器和内存之间移动数据：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `mov al, [mem1]`, the brackets mean move the contents of `mem1` to `al`.
    If we use `mov al, mem1` without brackets, it will move the pointer of `mem1`
    to `al`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mov al, [mem1]` 中，方括号表示将 `mem1` 的内容移动到 `al`。如果我们使用 `mov al, mem1` 而不带方括号，它将会把
    `mem1` 的指针移动到 `al`。
- en: In the first line, we moved `0x12` to the RAX register and, because we are moving
    only 8 bits, we used AL (the lower part of RAX register that can hold 8 bits)
    because we don't need to use all 64 bits. Also note that we defined the `mem1`
    memory section as `db`, which is byte, or it can hold 8 bits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将 `0x12` 移动到 RAX 寄存器中，因为我们只移动了 8 位，所以我们使用了 AL（RAX 寄存器的低部分，可以容纳 8 位），因为我们不需要使用所有
    64 位。还要注意的是，我们将 `mem1` 内存部分定义为 `db`，即字节，或者它可以容纳 8 位。
- en: 'Take a look at the following table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的表格：
- en: '| **64-bit register** | **32-bit register** | **16-bit register** | **8-bit
    register** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **64 位寄存器** | **32 位寄存器** | **16 位寄存器** | **8 位寄存器** |'
- en: '| RAX | EAX | AX | AH, AL |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| RAX | EAX | AX | AH, AL |'
- en: '| RBX | EBX | BX | BH, BL |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| RBX | EBX | BX | BH, BL |'
- en: '| RCX | ECX | CX | CH, CL |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| RCX | ECX | CX | CH, CL |'
- en: '| RDX | EDX | DX | DH, DL |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| RDX | EDX | DX | DH, DL |'
- en: '| RSI | ESI | SI | SIL |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| RSI | ESI | SI | SIL |'
- en: '| RDI | EDI | DI | DIL |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| RDI | EDI | DI | DIL |'
- en: '| RSP | ESP | SP | SPL |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| RSP | ESP | SP | SPL |'
- en: '| RBP | EBP | BP | BPL |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| RBP | EBP | BP | BPL |'
- en: '| R8 | R8D | R8W | R8B |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| R8 | R8D | R8W | R8B |'
- en: '| R9 | R9D | R9W | R9B |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| R9 | R9D | R9W | R9B |'
- en: '| R10 | R10D | R10W | R10B |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| R10 | R10D | R10W | R10B |'
- en: '| R11 | R11D | R11W | R11B |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| R11 | R11D | R11W | R11B |'
- en: '| R12 | R12D | R12W | R12B |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| R12 | R12D | R12W | R12B |'
- en: '| R13 | R13D | R13W | R13B |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| R13 | R13D | R13W | R13B |'
- en: '| R14 | R14D | R14W | R14B |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| R14 | R14D | R14W | R14B |'
- en: '| R15 | R15D | R15W | R15B |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| R15 | R15D | R15W | R15B |'
- en: Then, we moved value `0x1234`, which is defined as `dw`, to the `rbx` register,
    and then we moved 2 bytes (16 bits) in BX, which can hold 16 bits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义为 `dw` 的值 `0x1234` 移动到 `rbx` 寄存器，然后我们在 BX 中移动了 2 个字节（16 位），它可以容纳 16
    位。
- en: Then, we moved the value `0x12345678`, which is defined as `dd`, to the RCX
    register, and it's 4 bytes (32 bits), to ECX.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义为 `dd` 的值 `0x12345678` 移动到 RCX 寄存器，它是 4 个字节（32 位），移动到 ECX。
- en: 'And finally, we moved `0x1234567891234567`, which is defined as `dq`, to the
    RDX register, and it''s 8 bytes (64 bits), so we moved it to RDX:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义为 `dq` 的值 `0x1234567891234567` 移动到 RDX 寄存器，它是 8 个字节（64 位），所以我们将它移动到
    RDX 中：
- en: '![](img/00074.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: This is what it looks like in the registers after executing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行后，寄存器中的情况如下。
- en: 'Now, let''s talk about moving data from register to memory. Take a look at
    the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈从寄存器到内存的数据移动。看看下面的代码：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At the first and second instructions, we moved values directly to registers,
    and, in the third instruction, we moved the contents of register RAX (AL) to `mem1`
    and specified the length with byte. Then, in the fourth instruction, we moved
    the contents of register RBX (RX) to `mem2` and specified the length with word.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一和第二条指令中，我们直接将值移动到寄存器中，在第三条指令中，我们将寄存器RAX（AL）的内容移动到`mem1`中，并用字节指定了长度。然后，在第四条指令中，我们将寄存器RBX（RX）的内容移动到`mem2`中，并用字指定了长度。
- en: 'This is the contents of `mem1` and `mem2` before moving any values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在移动任何值之前`mem1`和`mem2`的内容：
- en: '![](img/00075.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: 'The next screenshot is after moving values to `mem1` and `mem2`, which has
    changed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图是在将值移动到`mem1`和`mem2`之后的情况：
- en: '![](img/00076.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: Data swapping
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据交换
- en: '**Data swapping** is really easy too; it is used to exchange the contents of
    two registers or between register and memory using the `xchg` instruction:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据交换**也很容易；它用于交换两个寄存器或寄存器和内存之间的内容，使用`xchg`指令：'
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the previous code, we moved `0x1234` to the `rax` register, then we moved
    `0x5678` to the `rbx` register:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`0x1234`移动到`rax`寄存器，然后将`0x5678`移动到`rbx`寄存器：
- en: '![](img/00077.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'Then, in the third instruction, we swapped the contents of both `rax` and `rbx`
    with the `xchg` instruction:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第三条指令中，我们使用`xchg`指令交换了`rax`和`rbx`的内容：
- en: '![](img/00078.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: 'Then, we pushed `0x9876` to the `rcx` register and `mem1` holds `0x1234`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x9876`推送到`rcx`寄存器，`mem1`保存`0x1234`：
- en: '![](img/00079.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: 'And now, swap both `rcx` and `mem1`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，交换`rcx`和`mem1`的内容：
- en: '![](img/00080.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: Load effective address
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载有效地址
- en: 'The **load effective address** (**lea**) instruction loads the address of the
    source into the destination:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载有效地址**（**lea**）指令将源的地址加载到目的地：'
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we moved the address of `mem1` to `rax`, then we moved the address inside
    `rax` to `rbx`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`mem1`的地址移动到`rax`，然后将`rax`中的地址移动到`rbx`：
- en: '![](img/00081.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: Both are now pointing at `mem1`, which contains `0x1234`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两者都指向`mem1`，其中包含`0x1234`。
- en: Arithmetic operations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算
- en: 'Now, we are going to talk about arithmetic operations (addition and subtraction).
    Let''s begin:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论算术运算（加法和减法）。让我们开始：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we move `0x1` to the `rax` register, then we add `0x2`, and the result
    will be stored in the `rax` register.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`0x1`移动到`rax`寄存器，然后加上`0x2`，结果将存储在`rax`寄存器中。
- en: Then, we move `0x3` to the `rbx` register and add the contents of `mem1`, which
    contains `0x2` with the contents of `rbx`, and the result will be stored in `rbx`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x3`移动到`rbx`寄存器，并将包含`0x2`的`mem1`的内容与`rbx`的内容相加，结果将存储在`rbx`中。
- en: Then, we move `0x9` to the `rcx` register, then we subtract `0x1`, and the result
    will be stored in `rcx`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x9`移动到`rcx`寄存器，然后减去`0x1`，结果将存储在`rcx`中。
- en: 'Then, we move `0x5` to the `rdx` register, subtract the contents of `mem2`
    from `rdx`, and the result will be stored in the `mem2` memory portion:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x5`移动到`rdx`寄存器，从`mem2`中减去`rdx`的内容，并将结果存储在`mem2`的内存部分中：
- en: '![](img/00082.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'And the contents of `mem2` after subtraction is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 减法后`mem2`的内容如下：
- en: '![](img/00083.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: 'Now, let''s talk about addition with carry and subtraction with borrow:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈带进位加法和借位减法：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we move `0x5` to the `rax` register, then we set the carry flag, which
    will be carrying `1`. After this, we add the contents of the `rax` register to
    `0x1`, and to the carry flag, which is `1`. This will give us `0x7` *(5+1+1)*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`0x5`移动到`rax`寄存器，然后设置进位标志，它将携带`1`。之后，我们将`rax`寄存器的内容加上`0x1`，并加到进位标志中，得到`0x7`
    *(5+1+1)*。
- en: 'Then, we move `0x5` to the `rbx` register and set the carry flag, then we subtract
    `0x1` from the `rbx` register and also another `1` in the carry flag; that will
    give us `0x3` *(5-1-1)*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x5`移动到`rbx`寄存器并设置进位标志，然后从`rbx`寄存器中减去`0x1`，并且在进位标志中再减去`1`；这将给我们`0x3`
    *(5-1-1)*：
- en: '![](img/00084.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: 'Now, the final part here is the increment and decrement operations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里的最后部分是增量和减量操作：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we move `0x5` to the `rax` register, increment the value of `rax` with
    `1`, then we increment again, which gives us `0x7`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`0x5`移动到`rax`寄存器，将`rax`的值增加`1`，然后再次增加，得到`0x7`。
- en: 'Then, we move `0x6` to the `rbx` register, decrement the value of `rbx` with
    `1`, then we decrement again, which gives us `0x4`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`0x6`移动到`rbx`寄存器，将`rbx`的值减去`1`，然后再次减去，得到`0x4`：
- en: '![](img/00085.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Loops
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Now, we are going to talk about loops in assembly. Like in any other high-level
    language (Python, Java, and so on), we can use loops for iteration using the RCX
    register as a counter, then the `loop` keyword. Let''s see the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论汇编中的循环。就像在任何其他高级语言（Python、Java等）中一样，我们可以使用循环来使用RCX寄存器作为计数器进行迭代，然后使用`loop`关键字。让我们看下面的例子：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the previous code, we wanted to increment the contents of RAX five times,
    so we moved `0x5` to the `rcx` register, then moved `0x1` to the `rbx` register:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们想要增加RAX的内容五次，所以我们将`0x5`移动到`rcx`寄存器，然后将`0x1`移动到`rbx`寄存器：
- en: '![](img/00086.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'Then, we added the `increment` tag as an indication of the start of the block
    we wanted to repeat, then we added the increment instruction to the contents of
    the `rbx` register:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`increment`标签添加为我们想要重复的块的开始指示，然后我们添加了增量指令到`rbx`寄存器的内容：
- en: '![](img/00087.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'Then, we called `loop increment`, which will decrement the contents of the
    RCX register and then go to start again from the `increment` tag:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`loop increment`，它将递减RCX寄存器的内容，然后再次从`increment`标签开始：
- en: '![](img/00088.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: 'Now it will go until the RCX register hits zero, then the flow will go out
    of that loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将一直执行，直到RCX寄存器为零，然后流程将离开该循环：
- en: '![](img/00089.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: 'Now, what if the program is rewritten with a value on RCX? Let''s see an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果程序在RCX上重写了一个值会怎样？让我们看一个例子：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After executing this code, the program will be stuck in an infinite loop, and
    if we look closer, we will see that the code overwrites the value in the RCX register
    after executing syscall:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，程序将陷入无限循环，如果我们仔细观察，我们将看到代码在执行系统调用后覆盖了RCX寄存器中的值：
- en: '![](img/00090.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: 'So, we have to find a way to save the RCX register, such as saving it in the
    stack. First, we push the current value in the stack before executing syscall,
    and, after executing syscall, we overwrite whatever is in RCX with our value again
    and then decrement the value and push it again in the stack to save it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须找到一种方法来保存RCX寄存器，比如将其保存在堆栈中。首先，在执行系统调用之前，我们将当前值推送到堆栈中，然后在执行系统调用后，我们再次用我们的值覆盖RCX中的任何内容，然后递减该值并再次将其推送到堆栈中以保存它：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This way, we save our value in the RCX register and then pop it in RCX again
    to use it. Look at the `pop rcx` instruction in the preceding code. RCX got back
    to `0x5` again, as expected:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们保存了RCX寄存器中的值，然后再次将其弹出到RCX中以使用它。请看上述代码中的`pop rcx`指令。RCX再次回到`0x5`，正如预期的那样：
- en: '![](img/00091.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: Controlling the flow
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程
- en: 'Here, we are going to talk about controlling the flow of execution. The normal
    flow of execution is to execute step 1, then 2, and so on until the code exits
    normally. What if we decide we want something to happen in step 2, then the code
    skips 3, and goes to execute 4 directly, or we just want to skip step 3 without
    waiting for something to happen? There are two types of jumping:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论控制执行流程。执行流程的正常流程是执行步骤1，然后2，依此类推，直到代码正常退出。如果我们决定在步骤2中发生某些事情，然后跳过3，直接执行4，或者我们只是想跳过步骤3而不等待发生某些事情，有两种跳转类型：
- en: Changing the flow unconditionally
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无条件改变流程
- en: Changing the flow based on changes in flags
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据标志的更改改变流程
- en: 'Now, let''s start with the unconditional jump:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从无条件跳转开始：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The previous code contains four `exit` syscalls but with different exit statuses
    (`12`, `0`, `10`, `1`), and we started with `jmp exit_ten`, which means jump to
    the `exit_ten` location, and it will jump to this section of code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码包含四个`exit`系统调用，但具有不同的退出状态（`12`，`0`，`10`，`1`），并且我们从`jmp exit_ten`开始，这意味着跳转到`exit_ten`位置，它将跳转到代码的这一部分：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Execute it and exit normally with exit status `10`. Note that the next section will
    never be executed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 执行并正常退出，退出状态为`10`。请注意，下一部分将永远不会被执行：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s confirm:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认一下：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output for the preceding commands can be seen in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 先前命令的输出可以在以下截图中看到：
- en: '![](img/00092.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: As we can see, the code exited with exit status `10`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，代码以退出状态`10`退出。
- en: 'Let''s look at another example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the earlier code, it starts by printing `hello_one`. Then, it will hit `jmp
    print_three`, and the flow of execution will be changed to the `print_three` location
    and start printing `hello_three`. The following section will never be executed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，它开始打印`hello_one`。然后，它将到达`jmp print_three`，执行流程将更改到`print_three`位置，并开始打印`hello_three`。以下部分将永远不会被执行：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s confirm that:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认一下：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output for the preceding commands can be seen in the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 先前命令的输出可以在以下截图中看到：
- en: '![](img/00093.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: Now, let's move on to jumping with the condition, and, to be honest, we can't
    cover all conditions here because the list is very long, but we will see some
    examples so that you can understand the concept.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论带条件的跳转，老实说，我们无法在这里涵盖所有条件，因为列表非常长，但我们将看到一些例子，以便您理解概念。
- en: The jump if below (`jb`) instruction means it will execute the jump if a **carry
    flag** (**CF**) is set (CF is equal to `1`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`jb`指令表示如果**进位标志**（**CF**）被设置（CF等于`1`）则执行跳转。'
- en: As we said earlier, we can set a CF manually using the `stc` instruction.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们可以使用`stc`指令手动设置CF。
- en: 'Let''s modify the previous example, but using the `jb` instruction, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改先前的例子，但使用`jb`指令，如下所示：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we executed `stc` to set a carry flag (that is, CF is equal
    to `1`), then we test that using `jb` instruction that means jump to `print_three`
    if CF is equal to `1`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们执行了`stc`来设置进位标志（即CF等于`1`），然后我们使用`jb`指令进行测试，这意味着如果CF等于`1`，则跳转到`print_three`。
- en: 'Here is another example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个例子：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, the add operation will set the carry flag, then we
    make the test using the `jb` instruction; if CF is equal to `1`, then jump to
    `exit_ten`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，加法操作将设置进位标志，然后我们使用`jb`指令进行测试；如果CF等于`1`，则跳转到`exit_ten`。
- en: 'Now, let''s look at a different method, that is, the jump if below or equal
    (`jbe`) instruction, which means CF is equal to `1` or **zero flag (ZF**) is equal
    to `1`. The previous example will work too, but let''s try something else to set
    ZF is equal to `1`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个不同的方法，即如果小于或等于（`jbe`）指令，这意味着CF等于`1`或**零标志（ZF）**等于`1`。先前的例子也可以工作，但让我们尝试其他方法来设置ZF等于`1`：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the previous code, the subtraction operation will set ZF and then we will
    use the `jbe` instruction to test whether CF is equal to `1` or ZF is equal to
    `1`; if true, then it will jump to execute `exit_ten`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，减法操作将设置ZF，然后我们将使用`jbe`指令来测试CF等于`1`或ZF等于`1`；如果为真，则会跳转执行`exit_ten`。
- en: 'Another type is jump if not sign (`jns`), which means SF is equal to `0`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型是如果不是符号（`jns`），这意味着SF等于`0`：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the previous code, the subtraction operation will set the **sign flag**
    (**SF**) equal to `1`. After that, we will test whether SF is equal to `0`, which
    will fail, and it won''t jump to execute `exit_ten` and will continue with the
    normal exit with exit status `0`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，减法操作将设置**符号标志**（**SF**）等于`1`。之后，我们将测试SF是否等于`0`，这将失败，它不会跳转执行`exit_ten`，而是继续以退出状态`0`正常退出：
- en: '![](img/00094.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: Procedures
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程
- en: Procedures in assembly can act as functions in high-level language, which means
    that you can write a block of code, then you can call it to execute.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编中的过程可以像高级语言中的函数一样，这意味着你可以编写一段代码块，然后调用它来执行。
- en: For example, we can build a procedure that can take two numbers and add them.
    Also, we can use it many times during execution using the `call` instruction.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以构建一个过程，可以接受两个数字并将它们相加。而且，我们可以在执行过程中多次使用`call`指令。
- en: Building procedures is easy. First, define your procedure before `_start`, then
    add your instructions and end your procedure with the `ret` instruction.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程很容易。首先，在`_start`之前定义你的过程，然后添加你的指令，并用`ret`指令结束你的过程。
- en: 'Let''s try to build a procedure that can take two numbers and add them:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着构建一个过程，可以接受两个数字并将它们相加：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we added an `addition` section, before the `_start` section. Then, in
    the `addition` section, we used the `add` instruction to add what's inside the `R8`
    and `R9` registers and put the result in the `R8` register, then we ended the
    `addition` procedure with `ret`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`_start`部分之前添加了一个`addition`部分。然后，在`addition`部分中，我们使用`add`指令来将`R8`和`R9`寄存器中的内容相加，并将结果放入`R8`寄存器，然后我们用`ret`结束了`addition`过程。
- en: 'Then, we moved `1` to the `R8` register and `3` to the `R9` register:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`1`移动到`R8`寄存器，将`3`移动到`R9`寄存器：
- en: '![](img/00095.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: 'Then, we called the `addition` procedure, which will push the next instruction
    address into the stack, which is `mov r8,0x4`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用了`addition`过程，它将把下一条指令地址推入堆栈，即`mov r8,0x4`：
- en: '![](img/00096.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: 'Note that `RSP` is now pointing to the next operation, and we are inside the
    `addition` procedure, and then the code will add both numbers and store the result
    in the `R8` register:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`RSP`现在指向下一个操作，我们在`addition`过程中，然后代码将会将两个数相加并将结果存储在`R8`寄存器中：
- en: '![](img/00097.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: After this, it will hit the `ret` instruction, which will set the flow of executing
    back to `mov r8,0x4`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它将执行`ret`指令，这将把执行流程返回到`mov r8,0x4`。
- en: 'This will move `4` to the `R8` register, then move `2` to the `R8` register:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`4`移动到`R8`寄存器，然后将`2`移动到`R8`寄存器：
- en: '![](img/00098.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'Then, call the `addition` procedure, and it will push the next instruction
    into the stack, which is `mov rax, 60`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`addition`过程，它将把下一条指令推入堆栈，即`mov rax, 60`：
- en: '![](img/00099.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: 'Then, add both numbers and store the result in the `R8` register:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将这两个数相加并将结果存储在`R8`寄存器中：
- en: '![](img/00100.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'Then, we hit the `ret` instruction again, which will pop the next instruction
    from the stack and put it in the `RIP` register, which is equivalent to `pop rip`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次执行`ret`指令，这将从堆栈中弹出下一条指令，并将其放入`RIP`寄存器中，相当于`pop rip`：
- en: '![](img/00101.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: Then, the code will continue with executing the `exit` syscall.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将继续执行`exit`系统调用。
- en: Logical operations
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑操作
- en: Now, we are going to talk about logical operations such as bitwise operations
    and bit-shifting operations.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要讨论逻辑操作，比如位运算和位移操作。
- en: Bitwise operations
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算
- en: 'There are four types of bitwise operations in logical operations: AND, OR,
    XOR, and NOT.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑操作中有四种位运算：AND、OR、XOR和NOT。
- en: 'Let''s start with the AND bitwise operation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从AND位运算开始：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we moved `0x10111011` to the `rax` register, then we moved `0x11010110`
    to the `rbx` register:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`0x10111011`移动到`rax`寄存器，然后将`0x11010110`移动到`rbx`寄存器：
- en: '![](img/00102.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: 'Then, we performed the **AND** bitwise operation on both sides and stored the
    result in RAX:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对两边执行了**AND**位运算，并将结果存储在RAX中：
- en: '![](img/00103.gif)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: 'Let''s see the result inside the `RAX` register:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`RAX`寄存器中的结果：
- en: '![](img/00104.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Now, let''s move to the OR bitwise operation and modify the previous code to
    perform the operation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到OR位运算，并修改之前的代码来执行这个操作：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We moved both values to the `rax` and `rbx` registers:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个值移动到`rax`和`rbx`寄存器中：
- en: '![](img/00105.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: 'Then, we executed the OR operation on those values:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对这些数值执行了OR操作：
- en: '![](img/00106.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'Now, let''s confirm the result in the `RAX` register:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确认一下`RAX`寄存器中的结果：
- en: '![](img/00107.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'Let''s now look at the XOR bitwise operation with the same values:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看相同数值的XOR位运算：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Move the same values to the `rax` and `rbx` registers:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的数值移动到`rax`和`rbx`寄存器中：
- en: '![](img/00108.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: 'Then, execute the XOR operation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行XOR操作：
- en: '![](img/00109.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: 'Let''s see what is inside the `RAX` register:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`RAX`寄存器里面是什么：
- en: '![](img/00110.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: You can use the XOR instruction on a register with itself to clear the content
    of that register. For instance, `xor rax` and `rax` will fill the RAX register
    with zeros.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用XOR指令对一个寄存器自身进行操作，以清除该寄存器的内容。例如，`xor rax`和`rax`将用0填充RAX寄存器。
- en: 'Now, let''s see the final one, which is the NOT bitwise operation, which will
    change ones to zeros and zeros to ones:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看最后一个，即NOT位运算，它将把1变为0，0变为1：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding code can be seen in the following screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出可以在以下截图中看到：
- en: '![](img/00111.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: What happened is that the NOT instruction changed zeros to ones (`ff`) and vice
    versa.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是NOT指令将0变为1（`ff`），1变为0。
- en: Bit-shifting operations
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位移操作
- en: 'Bit-shifting operations is an easy topic if you follow what each diagram says.
    Mainly, there are two types of bit-shifting operations: arithmetic shift operation
    and logic operation. However, we will also see the rotate operation.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照每个图表所说的去做，位移操作就是一个简单的话题。主要有两种类型的位移操作：算术位移操作和逻辑操作。然而，我们也会看到旋转操作。
- en: Let's start with the arithmetic shift operation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从算术位移操作开始。
- en: Arithmetic shift operation
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术位移操作
- en: 'Let''s make this as simple as possible. There are two types of arithmetic shift:
    **shift arithmetic left** (**SAL**) and **shift arithmetic right** (**SAR**).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尽可能简单地解释。有两种类型的算术移位：**算术左移**（**SAL**）和**算术右移**（**SAR**）。
- en: 'In SAL, we push **0** at the **least significant bit** side, and the extra
    bit from the **most significant bit** side may affect **CF** if it''s a **1**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在SAL中，我们在**最低有效位**侧推送**0**，并且来自**最高有效位**侧的额外位可能会影响**CF**，如果它是**1**：
- en: '![](img/00112.gif)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.gif)'
- en: 'So, the result of this shift will not affect on **CF**, and it will look like
    this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种移位的结果不会影响**CF**，它会是这样的：
- en: '![](img/00113.gif)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.gif)'
- en: 'Let''s take an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We moved `0x0fffffffffffffff` to the `rax` register, and this is how it looks
    now:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`0x0fffffffffffffff`移动到`rax`寄存器中，现在它看起来是这样的：
- en: '![](img/00114.gif)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.gif)'
- en: 'Now, we want to perform SAL with 4 bits one time:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要进行一次SAL移位4位：
- en: '![](img/00115.gif)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.gif)'
- en: 'Because the most significant bit was zero, so CF will not be set:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最高有效位为零，所以CF不会被设置：
- en: '![](img/00116.jpeg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: 'Now, let''s try another round: we push another zero, and the most significant
    bit is one:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试另一轮：我们再推送一个零，最高有效位为1：
- en: '![](img/00117.gif)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.gif)'
- en: 'A carry flag will be set:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将设置进位标志：
- en: '![](img/00118.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: 'Now, let''s look at the SAR instruction. In SAR, a value will be pushed based
    on the **most significant bit** if it is **0**, then **0** will be pushed, and
    if it is **1**, then **1** will be pushed to keep the sign from changing:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下SAR指令。在SAR中，如果**最高有效位**为**0**，则将推送一个基于该位的值，那么将推送**0**，如果为**1**，则将推送**1**以保持符号不变：
- en: '![](img/00119.gif)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.gif)'
- en: The most significant bit is used as an indication for the sign, **0** for the
    positive number and **1** for the negative number.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**最高有效位**用作符号的指示，**0**表示正数，**1**表示负数。'
- en: So, in SAR, it will shift with whatever is in the most significant bit.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在SAR中，它将根据**最高有效位**进行移位。
- en: 'Let''s look at the example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE42]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, the input will look like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输入将如下所示：
- en: '![](img/00120.gif)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.gif)'
- en: 'So, SAR four times will push **0** four times as the most significant bit is
    zero:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SAR四次将在最高有效位为零时推送**0**四次：
- en: '![](img/00121.gif)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.gif)'
- en: 'Also, CF is set because the least significant bit is 1:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于最低有效位为1，所以CF被设置：
- en: '![](img/00122.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: Logical shift
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑移位
- en: The logical shift also contains two types of shifting:logical **shift left**
    (**SHL**) and logical**shift right** (**SHR**). SHL is exactly like SAL.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑移位还包括两种类型的移位：逻辑**左移**（**SHL**）和逻辑**右移**（**SHR**）。SHL与SAL完全相同。
- en: 'Let''s look at the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, it will push zero from the least significant bit side four times:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，它将从最低有效位侧再次推送零四次：
- en: '![](img/00123.gif)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00123.gif)'
- en: 'This will not have any effect on the carry flag:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会对进位标志产生任何影响：
- en: '![](img/00124.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00124.jpeg)'
- en: 'At the second round, it will push zero again four times:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二轮中，它将再次推送四次零：
- en: '![](img/00125.gif)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00125.gif)'
- en: 'The most significant bit is 1, so this will set the carry flag:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最高有效位为1，因此这将设置进位标志：
- en: '![](img/00126.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00126.jpeg)'
- en: 'Let''s now move to SHR. It simply pushes a 0 from the **most significant bit**
    side without keeping the sign from changing:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向SHR。它只是在**最高有效位**侧推送一个0，而不改变符号：
- en: '![](img/00127.gif)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.gif)'
- en: 'Now, try the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试以下代码：
- en: '[PRE44]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, first, we move 64 bits of ones:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们移动64位的1：
- en: '![](img/00128.gif)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.gif)'
- en: 'After this, we will perform SHR 32 times, which will push 32 zeros to the most
    significant bit side:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将进行32次SHR，这将在最高有效位侧推送32个零：
- en: '![](img/00129.gif)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00129.gif)'
- en: 'Also, as the least significant bits are ones, this will set the carry flag:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，由于最低有效位为1，这将设置进位标志：
- en: '![](img/00130.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: Rotate operation
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转操作
- en: 'The rotate operation is simple: we will rotate the contents of a register to
    the right or to the left. Here, we are only going to discuss **rotate right**
    (**ROR**) and **rotate left** (**ROL**).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转操作很简单：我们将寄存器的内容向右或向左旋转。在这里，我们只讨论**向右旋转**（**ROR**）和**向左旋转**（**ROL**）。
- en: 'Let''s start with ROR:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从ROR开始：
- en: '![](img/00131.gif)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.gif)'
- en: 'In ROR, we just rotate the bits from right to left without adding any bits;
    let''s look at the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROR中，我们只是将位从右向左旋转而不添加任何位；让我们看一下以下代码：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We move `0xffffffff00000000` to the `rax` register:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`0xffffffff00000000`移动到`rax`寄存器中：
- en: '![](img/00132.gif)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00132.gif)'
- en: 'Then, we will start moving bits from right to left 32 times:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始从右向左移动32次：
- en: '![](img/00133.gif)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.gif)'
- en: 'There is no shifting with ones, so the carry flag will not be set:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对1进行移位，因此不会设置进位标志：
- en: '![](img/00134.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: 'Let''s move the ROL, which is the opposite of ROR, which rotates bits from
    left to right without adding any bits:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移动ROL，这是ROR的相反，它将位从左向右旋转而不添加任何位：
- en: '![](img/00135.gif)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.gif)'
- en: 'Let''s look at the previous example but ROL:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下之前的例子，但是使用ROL：
- en: '[PRE46]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'First, we also move `0xffffffff00000000` to the `rax` register:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`0xffffffff00000000`移动到`rax`寄存器中：
- en: '![](img/00136.gif)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.gif)'
- en: 'Then, we will start rotating bits from left to right 32 times:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从左向右旋转32次：
- en: '![](img/00137.gif)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00137.gif)'
- en: 'We are rotating ones, so this will set the carry flag:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在旋转1，因此这将设置进位标志：
- en: '![](img/00138.jpeg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00138.jpeg)'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the Intel x64 assembly language in Linux and how
    to deal with stacks, data manipulation, arithmetic and logical operations, how
    to control the flow of execution, and also how we can invoke system calls in an
    assembly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Linux中的Intel x64汇编语言以及如何处理堆栈、数据操作、算术和逻辑操作，如何控制执行流程，以及如何在汇编中调用系统调用。
- en: Now we are ready to make our own customized shellcodes, but before that, you
    need to learn some basics in debugging and reverse engineering, which will be
    our next chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备制作我们自己定制的shellcode，但在此之前，您需要学习一些调试和逆向工程的基础知识，这将是我们的下一章。
