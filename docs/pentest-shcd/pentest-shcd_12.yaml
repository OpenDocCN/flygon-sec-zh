- en: Detection and Prevention
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和预防
- en: 'Finally, to the last chapter of the book. Here, we will talk about security
    mechanisms to prevent buffer overflow attacks. Let''s divide these mechanisms
    into three parts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到了本书的最后一章。在这里，我们将讨论防止缓冲区溢出攻击的安全机制。让我们将这些机制分为三部分：
- en: System approach
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统方法
- en: Compiler approach
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器方法
- en: Developer approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者方法
- en: System approach
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统方法
- en: In this part, we will talk about built-in mechanisms inside some system kernels
    to prevent techniques, such as ASLR, in buffer overflow attacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将讨论一些系统内核内置的机制，以防止缓冲区溢出攻击中的ASLR等技术。
- en: '**Address Space Layout Randomization** (**ASLR**) is a mitigation technique
    against overflow attacks that randomizes memory segments, which prevents hardcoded
    exploits. For example, if I want to use the return-to-lib technique, I have to
    get the address of the function, which will be used in the attack. However, since
    the addresses of memory segments are randomized, the only way to do it is to guess
    that location, and yes, we use this technique to bypass NX protection, but not
    bypass ASLR.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址空间布局随机化**（**ASLR**）是一种针对溢出攻击的缓解技术，它随机化内存段，从而防止硬编码的利用。例如，如果我想使用返回到库的技术，我必须获取将在攻击中使用的函数的地址。然而，由于内存段的地址是随机化的，唯一的方法就是猜测那个位置，是的，我们使用这种技术来规避NX保护，但不能规避ASLR。'
- en: 'For security geeks out there, don''t worry; there are many ways to get around
    ASLR. Let''s take a look at how ASLR really works. Open your Linux victim machine
    and make sure that ASLR is disabled:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全极客们，不用担心；有许多方法可以规避ASLR。让我们看看ASLR是如何真正工作的。打开你的Linux受害机器，并确保ASLR已禁用：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00404.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00404.jpeg)'
- en: 'ASLR is disabled since the value of `randomize_va_space` is `0`. If it is enabled,
    set it to `0`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`randomize_va_space`的值为`0`，ASLR已禁用。如果已启用，请将其设置为`0`：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s take a look at the addressing layout for any application, for example,
    `cat`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看任何应用程序的寻址布局，例如`cat`：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, open another Terminal. Now, we need to get the PID of this process using
    the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开另一个终端。现在，我们需要使用以下命令获取该进程的PID：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00405.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00405.jpeg)'
- en: 'The PID of `cat` is `5029`. Let''s get the memory layout for this process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`的PID是`5029`。让我们获取此进程的内存布局：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00406.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00406.jpeg)'
- en: 'Now, let''s stop the `cat` process using *Ctrl* + *C*, and then start it again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，停止`cat`进程使用*Ctrl* + *C*，然后再次启动它：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, from another Terminal window, run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从另一个终端窗口运行以下命令：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00407.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00407.jpeg)'
- en: 'Now, the PID of `cat` is `5164`. Let''s get the memory layout for this PID:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`cat`的PID是`5164`。让我们获取此PID的内存布局：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00408.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00408.jpeg)'
- en: Take a look at the memory layout of both PIDs; they are exactly the same. Everything
    is statically allocated in memory, such as libraries, stack, and heap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看看两个PID的内存布局；它们完全相同。所有东西都是静态分配在内存中的，比如库、堆栈和堆。
- en: 'Now, let''s enable ASLR to see the difference:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启用ASLR来看看区别：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make sure that ASLR is enabled:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保ASLR已启用：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00409.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00409.jpeg)'
- en: 'Then, let''s start any process, for example, `cat`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们启动任何进程，例如`cat`：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, from another Terminal window, run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从另一个终端窗口运行以下命令：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00410.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00410.jpeg)'
- en: 'The PID of `cat` is `5271`. Now, read its memory layout:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`的PID是`5271`。现在，阅读它的内存布局：'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00411.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00411.jpeg)'
- en: 'Now, let''s stop `cat` and re-run it again:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们停止`cat`，然后再次运行它：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, let''s catch the PID of `cat`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们捕获`cat`的PID：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00412.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00412.jpeg)'
- en: 'Now, read its memory layout:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，阅读它的内存布局：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00413.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00413.jpeg)'
- en: Let's compare both addresses. They are totally different. Stack, heap, and libraries
    are all now dynamically allocated, and all addresses will become unique for every
    execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两个地址。它们完全不同。堆栈、堆和库现在都是动态分配的，所有地址将对每次执行都变得唯一。
- en: Now to the next section, which is the compiler approach, such as executable-space
    protection and canary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到下一部分，即编译器方法，比如可执行空间保护和canary。
- en: Compiler approach
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器方法
- en: Executable-space protection is a technique used to mark some segments in memory
    as non-executable, such as stack and heap. So, if we even succeeded to inject
    a shellcode, then it would be impossible to make that shellcode run.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行空间保护是一种技术，用于将内存中的某些段标记为不可执行，比如堆栈和堆。因此，即使我们成功注入了shellcode，也不可能使该shellcode运行。
- en: Executable-space protection in Linux is called **non-executable** (**NX**), and
    in Windows it is called **Data Execution Prevention** (**DEP**).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，可执行空间保护被称为**不可执行**（**NX**），在Windows中被称为**数据执行防护**（**DEP**）。
- en: 'Let''s try to use our example from [Chapter 6](part0081.html#2D7TI0-5bf3e26315164e77bbeecc4f75207114),
    *Buffer Overflow Attacks*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们在[第6章](part0081.html#2D7TI0-5bf3e26315164e77bbeecc4f75207114)中的例子，*缓冲区溢出攻击*：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, compile it with NX disabled:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，禁用NX编译它：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open it in GDB:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中打开它：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, let''s run this exploit:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们运行这个利用：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the exploit:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行利用：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside GDB, run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中，运行以下命令：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00414.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00414.jpeg)'
- en: 'Now, let''s try the same exploit but with NX enabled:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试启用NX的相同利用：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, open it in GDB and run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在GDB中打开它并运行以下命令：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00415.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00415.jpeg)'
- en: So, why did the code get stuck at this address?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么代码会卡在这个地址？
- en: '![](img/00416.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00416.jpeg)'
- en: Because it refuses to even execute our No Operation (`nop`) from the stack,
    as the stack is now non-executable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它甚至拒绝执行我们从栈中的No Operation (`nop`)，因为栈现在是不可执行的。
- en: Let's talk about another technique, which is stack canary or stack protector.
    Stack canary is used to detect any attempt to smash the stack.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈另一种技术，即栈canary或栈保护器。栈canary用于检测任何企图破坏栈的行为。
- en: 'When a return value is stored in a stack, a value called **canary** value is
    written before storing the **return address**. So, any attempt to perform a stack
    overflow attack will overwrite the **canary** value, which will cause a flag to
    be raised to stop the execution because there is an attempt to smash the stack:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个返回值存储在栈中时，在存储返回地址之前会写入一个称为**canary**值的值。因此，任何尝试执行栈溢出攻击的行为都会覆盖**canary**值，这将导致引发一个标志来停止执行，因为有企图破坏栈的行为：
- en: '![](img/00417.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00417.jpeg)'
- en: 'Now, try to use our previous example, but let''s enable the stack `canary`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用我们之前的例子，但让我们启用栈`canary`：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, let''s re-run it inside GDB and try our exploit:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在GDB中重新运行它并尝试我们的利用：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00418.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00418.jpeg)'
- en: 'Let''s take a look at why it failed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么它失败了：
- en: '![](img/00419.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00419.jpeg)'
- en: 'It tried to compare the original canary value with the stored value, and it
    failed because we did overwrite the original value with whatever was there in
    our exploit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图将原始canary值与存储的值进行比较，但失败了，因为我们用我们的攻击覆盖了原始值：
- en: '![](img/00420.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00420.jpeg)'
- en: And as you can see, stack smashing was detected!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，栈破坏已被检测到！
- en: Developer approach
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者方法
- en: Now to the final part, which is the developer approach, where any developer
    should do all they can to protect their code against overflow attacks. I'll talk
    about C/C++, but the concept still remains the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到最后一部分，即开发者方法，任何开发者都应该尽其所能保护他们的代码免受溢出攻击。我会谈论C/C++，但概念仍然是一样的。
- en: 'First, when using any string handling function, you should use safe functions.
    The next table shows unsafe functions and what to use instead:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在使用任何字符串处理函数时，你应该使用安全函数。下表显示了不安全的函数以及应该使用的替代函数：
- en: '| **Unsafe functions** | **Safe functions** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **不安全函数** | **安全函数** |'
- en: '| `strcpy` | `strlcpy` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `strcpy` | `strlcpy` |'
- en: '| `strncpy` | `strlcpy` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `strncpy` | `strlcpy` |'
- en: '| `strcat` | `strlcat` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `strcat` | `strlcat` |'
- en: '| `strncat` | `strlcat` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `strncat` | `strlcat` |'
- en: '| `vsprintf` | `vsnprintf` or `vasprintf` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `vsprintf` | `vsnprintf` 或 `vasprintf` |'
- en: '| `sprintf` | `snprintf` or `asprintf` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf` | `snprintf` 或 `asprintf` |'
- en: Also, you should always use the `sizeof` function to calculate the size of a
    buffer in your code. Try to be precise when it comes to the buffer size by mixing
    it with a safe function; then, your code is much safer now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该始终使用`sizeof`函数来计算代码中缓冲区的大小。尝试通过将其与安全函数混合使用来精确计算缓冲区大小；然后，你的代码现在更安全了。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the final chapter of the book, we discussed some protection techniques in
    operating systems and also some techniques in the C compiler, such as GCC. Then,
    we moved on to how to make your code safer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们讨论了操作系统中的一些保护技术，还有一些C编译器中的技术，比如GCC。然后，我们继续讨论如何使你的代码更安全。
- en: This is not the end. There are more ways to work around each protection technique.
    With this book, you have been provided with strong basics to continue your journey.
    Keep going and I promise you that you will master this domain!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是结束。有更多的方法来规避每种保护技术。通过本书，你已经获得了坚实的基础，可以继续你的学习之旅。继续前进，我保证你会掌握这个领域！
