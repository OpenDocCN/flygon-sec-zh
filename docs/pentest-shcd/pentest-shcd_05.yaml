- en: Creating Shellcode
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Shellcode
- en: Let's get ready to dive deep into this topic where we will be using what we
    have learned so far to create simple, fully customized shellcodes. This will get
    even more adventurous when we face the obstacles that are bad characters and find
    ways of removing them. Moving on, we will see how to create advanced shellcodes
    and also create our shellcodes using the Metasploit Framework automatically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好深入研究这个话题，我们将利用到目前为止学到的知识来创建简单的、完全定制的shellcode。当我们面对坏字符并找到去除它们的方法时，这将变得更加有趣。接下来，我们将看到如何创建高级的shellcode，并使用Metasploit
    Framework自动创建我们的shellcode。
- en: 'The following are the topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题：
- en: The basics and bad characters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础知识和坏字符
- en: The relative address technique
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对地址技术
- en: The execve syscall
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: execve系统调用
- en: Bind TCP shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定TCP shell
- en: Reverse TCP shell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向TCP shell
- en: Generating shellcode using Metasploit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Metasploit生成shellcode
- en: The basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Firstly, let's begin with what a shellcode is. As we have already seen earlier,
    the shellcode is a machine code that can be used as a payload to be injected in
    stack overflow attacks, which can be obtained from the assembly language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从shellcode是什么开始。正如我们之前已经看到的，shellcode是一种可以作为有效载荷注入到堆栈溢出攻击中的机器码，可以从汇编语言中获得。
- en: 'So what we have to do is simple: write what we want the shellcode to do as
    assembly, then perform some modifications, and convert it to a machine code.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要做的很简单：将我们希望shellcode执行的操作以汇编形式写下来，然后进行一些修改，并将其转换为机器码。
- en: 'Let''s try to make a hello world shellcode and convert an executable form to
    machine code. We need to use the `objdump` command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试制作一个hello world的shellcode，并将可执行形式转换为机器码。我们需要使用`objdump`命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output for the preceding command is shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](img/00179.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00179.jpeg)'
- en: 'Do you see what''s inside that red rectangular box? This is the machine code
    of our hello world example. But we need to convert it to this form: `\xff\xff\xff\xff`,
    where `ff` represents the operation code. You can do that manually line by line,
    but it would be somewhat tedious. We can do that automatically using just one
    line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到红色矩形框里面的是什么？这是我们hello world示例的机器码。但是我们需要将它转换成这种形式：`\xff\xff\xff\xff`，其中`ff`代表操作码。你可以手动逐行进行转换，但这可能有点乏味。我们可以使用一行代码自动完成：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s try that with our code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用我们的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](img/00180.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00180.jpeg)'
- en: 'This is our machine language:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的机器语言：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we can use the following code for testing our machine:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下代码来测试我们的机器：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s compile it and run it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](img/00181.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00181.jpeg)'
- en: You can see from the preceding output that our shellcode didn't work. The reason
    was the bad characters in it. This takes us to the next section, which discusses
    ways to remove them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上面的输出中看到，我们的shellcode没有起作用。原因是其中有坏字符。这让我们进入下一节，讨论如何去除它们。
- en: Bad characters
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坏字符
- en: Bad characters are characters that can break the execution of a shellcode because
    they can be interpreted as something else.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 坏字符是指可以破坏shellcode执行的字符，因为它们可能被解释为其他东西。
- en: 'For example, consider `\x00`, which means zero value, but it will be interpreted
    as a null terminator and will be used to terminate a string. Now, to prove that,
    let''s take another look at the previous code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`\x00`，它表示零值，但它将被解释为空终止符，并用于终止一个字符串。现在，为了证明这一点，让我们再看一下之前的代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we tried to execute it, we got an error, `Shellcode Length: 14`. If you
    look at the 15^(th) operation code, you will see `\x00`, which is interpreted
    as a null terminator.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们尝试执行它时，我们得到一个错误，`Shellcode Length: 14`。如果你看第15个操作码，你会看到`\x00`，它被解释为空终止符。'
- en: 'Here is the list of bad characters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是坏字符的列表：
- en: '`00`: This is the zero value or null terminator (`\0`)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`：这是零值或空终止符（`\0`）'
- en: '`0A`: This is the line feed (`\n`)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0A`：这是换行符（`\n`）'
- en: '`FF`: This is the form feed (`\f`)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FF`：这是换页符（`\f`）'
- en: '`0D`: This is the carriage return (`\r`)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0D`：这是回车符（`\r`）'
- en: 'Now, how to remove these bad characters from our shellcode? Actually, we can
    remove them using what we know so far in assembly, such as choosing which part
    of one register should depend on the size of the moved data. For example, if I
    want to move a small value such as `15` to RAX, we should use the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何从我们的shellcode中删除这些坏字符呢？实际上，我们可以使用我们在汇编中已经知道的知识来删除它们，比如选择一个寄存器的哪一部分应该取决于移动数据的大小。例如，如果我想将一个小值（比如`15`）移动到RAX，我们应该使用以下代码：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can use arithmetic operations, for example, to move `15`
    to the RAX register:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用算术运算，例如将`15`移动到RAX寄存器：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s take a look at our machine code, one instruction at a time:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐条查看我们的机器码：
- en: '![](img/00182.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00182.jpeg)'
- en: 'The first instruction is `mov rax, 1`, and it contains `0` because we were
    trying to move `1` byte (8 bits) to a 64-bit register. So it would fill the rest
    with zeros, which we can fix using `mov al, 1`,  so we moved `1` byte (8 bits)
    to an 8-bit part of the RAX register; let''s confirm that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令是`mov rax, 1`，它包含`0`，因为我们试图将`1`字节（8位）移动到64位寄存器。所以它会用零填充剩下的部分，我们可以使用`mov
    al, 1`来修复这个问题，这样我们就将`1`字节（8位）移动到了RAX寄存器的8位部分；让我们确认一下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the following commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](img/00183.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00183.jpeg)'
- en: We managed to remove all the bad characters from the first instruction. Let's
    try another method with the second instruction, which is using arithmetic operations
    such as adding or subtracting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功从第一条指令中删除了所有的坏字符。让我们尝试另一种方法，使用算术运算，比如加法或减法。
- en: 'First, we need to clear the register using the `xor` instruction, `xor rdi,
    rdi`. Now, the RDI register contains zeros; we add `1` to its value, `add rdi,
    1`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`xor`指令清除寄存器，`xor rdi, rdi`。现在RDI寄存器包含零；我们将其值加`1`，`add rdi, 1`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, run the following commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00184.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00184.jpeg)'
- en: 'We fixed that too. Let''s fix all that and leave moving the `hello world` string
    to the next section:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也修复了这个。让我们修复所有这些，把移动`hello world`字符串留到下一节：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, run the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00185.gif)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00185.gif)'
- en: We managed to remove all the bad characters from our shellcode, which leaves
    us with how to deal with addresses when copying strings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设法从我们的shellcode中删除了所有的坏字符，这让我们需要处理在复制字符串时的地址。
- en: The relative address technique
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对地址技术
- en: The relative address is the current location relative to the RIP register, and
    relative value is a very good technique to avoid using hardcoded addresses in
    assembly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相对地址是相对于RIP寄存器的当前位置，相对值是一种非常好的技术，可以避免在汇编中使用硬编码地址。
- en: How can we do that? Actually, it's made so simple by using `lea <destination>,
    [rel <source>]`, where the  `rel` instruction will compute the address of the
    source relative to the RIP register.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么做到的？实际上，通过使用`lea <destination>, [rel <source>]`，这个`rel`指令将计算相对于RIP寄存器的源地址，这样做变得非常简单。
- en: 'We need to define our variable before the code itself, which in turn has to
    be defined before the RIP current location; otherwise, it will be a short value
    and the rest of the register will be filled with zeros like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码本身之前定义我们的变量，这样就必须在RIP当前位置之前定义它；否则，它将是一个短值，寄存器的其余部分将填充为零，就像这样：
- en: '![](img/00186.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00186.jpeg)'
- en: 'Now, let''s modify our shellcode with this technique to fix the location of
    the `hello world` string:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这种技术修改我们的shellcode来修复`hello world`字符串的位置：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, run the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00187.gif)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00187.gif)'
- en: 'No bad characters at all! Let''s try it as a shellcode:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一点坏字符都没有！让我们尝试它作为一个shellcode：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00188.gif)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00188.gif)'
- en: 'Let''s now try to compile this shellcode and run it using our C code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用我们的C代码编译并运行这个shellcode：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, run the following commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00189.gif)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00189.gif)'
- en: It worked! Now, this is our first shellcode.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！现在，这是我们的第一个shellcode。
- en: Let's move to see more techniques on how to deal with addresses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何处理地址的更多技巧。
- en: The jmp-call technique
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jmp-call技术
- en: Now, we will talk about a new technique on how to deal with the string's address,
    which is the **jmp-call** technique.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论如何处理字符串地址的新技术，即**jmp-call**技术。
- en: 'This technique is simply to first make the `jmp` instruction to the string
    we want to move to a specific register. After that, we call the actual code using
    the `call` instruction, which pushes the string''s address to the stack, then
    we pop the address into that register. Take a look at the next example to fully
    understand this technique:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术简单地首先使`jmp`指令到我们想要移动到特定寄存器的字符串。之后，我们使用`call`指令调用实际的代码，将字符串的地址推入堆栈，然后我们将地址弹出到那个寄存器中。看看下一个例子，完全理解这种技术：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, run the following commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00190.gif)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00190.gif)'
- en: 'No bad characters; let''s now review what we did. First, we executed a `jmp`
    instruction to the string, then we called the actual code using the `call` instruction,
    which will cause the next instruction to be pushed into the stack; let''s see
    that code inside GDB:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有坏字符；现在让我们回顾一下我们做了什么。首先，我们执行了一个`jmp`指令到字符串，然后我们使用`call`指令调用了实际的代码，这将导致下一条指令被推入堆栈；让我们在GDB中看看这段代码：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00191.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00191.jpeg)'
- en: 'The next instruction is calling the code using the `call code` instruction.
    Notice what is going to happen in the stack:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是使用`call code`指令调用代码。注意堆栈中将会发生什么：
- en: '![](img/00192.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00192.jpeg)'
- en: The address of the `hello world` string is pushed into the stack and the next
    instruction is pop `rsi`, which moves the address of the `hello world` string
    from the stack to the RSI register.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello world`字符串的地址被推入堆栈，下一条指令是`pop rsi`，它将`hello world`字符串的地址从堆栈移动到RSI寄存器。'
- en: 'Let''s try to use it as a shellcode:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将其作为一个shellcode：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00193.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00193.jpeg)'
- en: 'Implementing the same in C code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在C代码中实现相同的操作：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s compile and run it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00194.gif)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00194.gif)'
- en: The stack technique
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈技术
- en: Here, we are going to learn another technique to deal with addresses using the
    stack. It's very simple, but we have two obstacles. First, we only allow 4 bytes
    to push into the stack in one operation—we will use registers to help us in this.
    Second, we have to push out strings into the stack in reverse—we will use Python
    to do that for us.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习另一种使用堆栈处理地址的技术。这很简单，但我们有两个障碍。首先，我们只允许一次将4个字节推入堆栈的操作——我们将使用寄存器来帮助我们。其次，我们必须以相反的顺序将字符串推入堆栈——我们将使用Python来为我们做这件事。
- en: 'Let''s try to solve the second obstacle. Using Python, I''m going to define
    `string = ''hello world\n''`, then I will reverse my string and encode it to `hex`
    in one line using `string[::-1].encode(''hex'')`. Next, we will have our string
    in reverse and encoded:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决第二个障碍。使用Python，我将定义`string = 'hello world\n'`，然后我将反转我的字符串，并使用`string[::-1].encode('hex')`一行将其编码为`hex`。接下来，我们将得到我们的反向编码字符串：
- en: '![](img/00195.gif)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00195.gif)'
- en: 'Done! Now, let''s try to solve the first obstacle:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，让我们尝试解决第一个障碍：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, we push 8 bytes to the stack. We could push the rest into the stack
    divided by 4 bytes at each operation, but we also can use registers to move 8
    bytes in one operation and then push the content of that register into the stack:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将8个字节推入堆栈。我们可以将其余的内容分成4字节推入堆栈的每个操作，但我们也可以使用寄存器一次移动8个字节，然后将该寄存器的内容推入堆栈：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00196.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00196.jpeg)'
- en: 'Let''s try to use it as a shellcode:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将其用作shellcode：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, run the following commands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00197.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00197.jpeg)'
- en: That was easy too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很容易。
- en: In the next section, we will discuss how to make a useful shellcode using the `execve`
    syscall.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用`execve`系统调用制作有用的shellcode。
- en: The execve syscall
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: execve系统调用
- en: Now, we will learn how to make a useful shellcode using `execve`. Before we
    continue, we must understand what the `execve` syscall is. It's a syscall used
    to execute a program or a script. Let's take an example of how to use `execve`
    to read the `/etc/issue` file using the C language.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用`execve`制作有用的shellcode。在继续之前，我们必须了解`execve`系统调用是什么。它是一个用于执行程序或脚本的系统调用。让我们以使用C语言读取`/etc/issue`文件的`execve`的示例来说明。
- en: 'First, let''s take a look at the `execve` requirements:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`execve`的要求：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00198.gif)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00198.gif)'
- en: As it says, the first argument is the program we want to execute.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它所说，第一个参数是我们要执行的程序。
- en: The second argument, `argv`, is a pointer to an array of arguments related to
    the program we want to execute. Also, `argv` should contain the program's name.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`argv`是指向与我们要执行的程序相关的参数数组的指针。此外，`argv`应该包含程序的名称。
- en: The third argument is `envp`, which contains whatever arguments we want to pass
    to the environment, but we can set this argument to `NULL`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是`envp`，其中包含我们想要传递给环境的任何参数，但我们可以将此参数设置为`NULL`。
- en: 'Now, let''s build C code to execute the `cat /etc/issue` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建C代码来执行`cat /etc/issue`命令：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s compile and run it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00199.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00199.jpeg)'
- en: It gave us the content of the `/etc/issue` file, which is `Kali GNU/Linux Rolling
    \n \l`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它给了我们`/etc/issue`文件的内容，即`Kali GNU/Linux Rolling \n \l`。
- en: 'Now, let''s try to execute `/bin/sh` in assembly using the `execve` syscall.
    Here, I''m going to use the stack technique; let''s do this code step by step:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`execve`系统调用在汇编中执行`/bin/sh`。在这里，我将使用堆栈技术；让我们一步一步地完成这段代码：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, we need to use `NULL` as a sign of separation in the stack. Then, we
    move the stack pointer to RDX register to get our third argument:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在堆栈中使用`NULL`作为分隔符。然后，我们将堆栈指针移动到RDX寄存器，以获取我们的第三个参数：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we need to push our path, which is `/bin/sh`, into the stack, and since
    we only have seven bytes and we don''t want any zeros in our code, let''s push
    `//bin/sh` or `/bin//sh`. Let''s reverse this string and encode it to `hex` using
    Python:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将我们的路径`/bin/sh`推入堆栈中，由于我们只有七个字节，而且我们不希望我们的代码中有任何零，让我们推入`//bin/sh`或`/bin//sh`。让我们反转这个字符串，并使用Python将其编码为`hex`：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00200.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00200.jpeg)'
- en: 'Now that we have our string ready, let''s push it into the stack using any
    register, since it contains 8 bytes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的字符串准备好了，让我们使用任何寄存器将其推入堆栈，因为它包含8个字节：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s move RSP to the RDI register to get our first argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将RSP移动到RDI寄存器，以获取我们的第一个参数：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we need to push another `NULL` as a string separation, then we need a
    pointer to our string by pushing RDI content, which is the address of our string
    to the stack. Then, we move the stack pointer to the RDI register to get the second
    argument:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要推入另一个`NULL`作为字符串分隔符，然后我们需要通过推入RDI内容（即我们字符串的地址）将一个指针推入堆栈。然后，我们将堆栈指针移动到RDI寄存器，以获取第二个参数：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, all our arguments are ready; let''s get the `execve` syscall number:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有我们的参数都准备好了；让我们获取`execve`系统调用号：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00201.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00201.jpeg)'
- en: 'The `execve` syscall number is `59`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`execve`系统调用号是`59`：'
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s put our code together:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的代码放在一起：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, run the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00202.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00202.jpeg)'
- en: 'Let''s convert it to a shellcode:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换为shellcode：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00203.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00203.jpeg)'
- en: 'We will use C code to inject our shellcode:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用C代码来注入我们的shellcode：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, run the following commands:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出显示在以下截图中：
- en: '![](img/00204.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00204.jpeg)'
- en: TCP bind shell
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP绑定shell
- en: Now, let's move further to do something really useful, which is building a TCP
    bind shell.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步做一些真正有用的事情，即构建一个TCP绑定shell。
- en: The TCP bind shell is used to set up a server on a machine (victim), and that
    server is waiting for a connection from another machine (attacker), which allows
    the other machine (attacker) to execute commands on the server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TCP绑定shell用于在一台机器（受害者）上设置服务器，并且该服务器正在等待来自另一台机器（攻击者）的连接，这允许另一台机器（攻击者）在服务器上执行命令。
- en: 'First, let''s take a look at a bind shell in C language to understand how it
    really works:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下C语言中的绑定shell，以了解它是如何工作的：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s break it down into pieces to understand how it works:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它分解成几部分来理解它是如何工作的：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Firstly, we created a socket, which takes three arguments. The first argument
    is to define the protocol family, which is `AF_INET`, which represents IPv4 and
    can be represented in numeric form by `2`. The second argument is to specify the
    type of connection, and here, `SOCK_STREAM` represents TCP and can represented
    in numeric form by `1`. The third argument is the protocol and it''s set to `0`,
    which tells the operating system to choose the most appropriate protocol to use.
    Now let''s find the `socket` syscall number:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个套接字，它需要三个参数。第一个参数是定义协议族，即`AF_INET`，代表IPv4，可以用`2`来表示。第二个参数是指定连接的类型，在这里，`SOCK_STREAM`代表TCP，可以用`1`来表示。第三个参数是协议，设置为`0`，告诉操作系统选择最合适的协议来使用。现在让我们找到`socket`系统调用号：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00205.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00205.jpeg)'
- en: From the obtained output, the `socket` syscall number is `41`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从获得的输出中，`socket`系统调用号是`41`。
- en: 'Let''s create the first part in assembly:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在汇编中创建第一部分：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output value, which is `sockfd`, will be stored in the RAX register; let''s
    move it to the RDI register:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出值，即`sockfd`，将被存储在RAX寄存器中；让我们将其移到RDI寄存器中：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now to the next part, which is filling the structure, `mysockaddr`, to be an
    input to the `bind` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到下一部分，即填充`mysockaddr`结构以作为`bind`函数的输入：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We need it in the form of a pointer; also, we have to push to the stack in reverse
    order.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以指针的形式；而且，我们必须以相反的顺序推送到堆栈。
- en: First, we push `0` to represent to bind to all interfaces (4 bytes).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们推送`0`来表示绑定到所有接口（4字节）。
- en: 'Second, we push the port in the form of `htons` (2 bytes). To convert our port
    to `htons`, we could use Python:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们以`htons`形式推送端口（2字节）。要将我们的端口转换为`htons`，我们可以使用Python：
- en: '![](img/00206.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00206.jpeg)'
- en: Here is our port (`1234`) in `htons` form (`0xd204`).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的端口（`1234`）以`htons`形式（`0xd204`）。
- en: 'Third, we push the value `2`, which represents `AF_INET` (2 bytes):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们推送值`2`，表示`AF_INET`（2字节）：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Having our structure set, let''s prepare the `bind` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的结构设置，让我们准备`bind`函数：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `bind` function takes three arguments. The first one is `sockfd`, which
    is already stored in the RDI register; the second is our structure in the form
    of a reference; and the third is the length of our structure, which is `16`. Now
    what''s left is to get the `bind` syscall number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数需要三个参数。第一个是`sockfd`，已经存储在RDI寄存器中；第二个是我们的结构以引用的形式；第三个是我们结构的长度，即`16`。现在剩下的是获取`bind`系统调用号：'
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00207.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00207.jpeg)'
- en: 'From the preceding screenshot, we can see that the `bind` syscall number is
    `49`; let''s create the `bind` syscall:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，我们可以看到`bind`系统调用号是`49`；让我们创建`bind`系统调用：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s set the `listen` function, which takes two arguments:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置`listen`函数，它需要两个参数：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first argument is `sockfd`, which we have stored already in the RDI register.
    The second argument is a number, which represents the maximum number of connections
    the server can accept, and here, it allows only one.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`sockfd`，我们已经将其存储在RDI寄存器中。第二个参数是一个数字，表示服务器可以接受的最大连接数，在这里，它只允许一个。
- en: 'Now, let''s get the `listen` syscall number:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取`listen`系统调用号：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00208.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00208.jpeg)'
- en: 'Now, let''s build the `bind` syscall:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建`bind`系统调用：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''ll move on to next function, which is `accept`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续下一个函数，即`accept`：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `accept` function takes three arguments. The first is `sockfd`, and again,
    it is already stored in the RDI register; we can set the second and the third
    arguments to zero. Let''s get the `accept` syscall number:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept`函数需要三个参数。第一个是`sockfd`，同样，它已经存储在RDI寄存器中；我们可以将第二个和第三个参数设置为零。让我们获取`accept`系统调用号：'
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00209.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00209.jpeg)'
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the `accept` function, which is ; `clientfd`, will be stored
    in the RAX register, so let''s move that to a safer place:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept`函数的输出，即`clientfd`，将被存储在RAX寄存器中，所以让我们把它移到一个更安全的地方：'
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Execute the `dup2` syscall:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dup2`系统调用：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, we will execute it three times to duplicate our file descriptor to `stdin`,
    `stdout`, and `stderr`, which take (`0`, `1`, `1`), respectively.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行它三次，将我们的文件描述符复制到`stdin`，`stdout`和`stderr`，分别为（`0`，`1`，`1`）。
- en: 'The `dup2` syscall takes two arguments. The first argument is the old file
    descriptor—in our case, it is `clientfd`. The second argument is our new file
    descriptors (`0`, `1`, `2`). Now, let''s get the `dup2` syscall number:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`dup2`系统调用需要两个参数。第一个参数是旧文件描述符，在我们的情况下是`clientfd`。第二个参数是我们的新文件描述符（`0`，`1`，`2`）。现在，让我们获取`dup2`系统调用号：'
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00210.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00210.jpeg)'
- en: 'Now, let''s build the `dup2` syscall:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建`dup2`系统调用：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we add our `execve` syscall:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加我们的`execve`系统调用：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, everything is ready; let''s put all the pieces together in one code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都准备就绪；让我们把所有的部分放在一起写成一段代码：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s assemble and link it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们汇编和链接它：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s convert it to a shellcode:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换为shellcode：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：
- en: '![](img/00211.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00211.jpeg)'
- en: 'Let''s inject it into our C code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其注入到我们的 C 代码中：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s compile it and run it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它：
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00212.gif)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00212.gif)'
- en: 'Now our shellcode is working and waiting; let''s confirm:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 shellcode 已经在工作并等待；让我们确认一下：
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00213.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00213.jpeg)'
- en: 'It''s listening now on port `1234`; now, from another Terminal window, start
    `nc`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它现在在端口 `1234` 上监听；现在，从另一个终端窗口，启动 `nc`：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00214.gif)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00214.gif)'
- en: 'Now, it''s connected and waiting for our commands; let''s try:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它已连接并等待我们的命令；让我们试试：
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00215.gif)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00215.gif)'
- en: Now we have our first real shellcode!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的第一个真正的 shellcode！
- en: Reverse TCP shell
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向 TCP shell
- en: In this section, we will create another useful shellcode, which is the reverse
    TCP shell. A reverse TCP shell is the opposite of the bind TCP, as the victim's
    machine establishes a connection to the attacker again.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建另一个有用的 shellcode，即反向 TCP shell。反向 TCP shell 是绑定 TCP 的相反，因为受害者的机器再次建立与攻击者的连接。
- en: 'First, let''s have a look at it in C code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 C 代码中让我们看一下它：
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: First, we will compile and execute this on one of our victim machines (Ubuntu).
    We will set up a listener on the attacking machine (Kali), and the shell will
    connect back from Ubuntu to Kali by adding Kali's IP in the code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的受害者机器之一（Ubuntu）上编译并执行它。我们将在攻击机器（Kali）上设置一个监听器，然后 shell 将从 Ubuntu 连接回
    Kali，通过在代码中添加 Kali 的 IP。
- en: 'Let''s set up a listener on Kali using the `nc` command or the `netcat` tool:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上使用 `nc` 命令或 `netcat` 工具设置一个监听器：
- en: '[PRE76]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On Ubuntu, let''s compile and run our `reverse-tcp` shellcode:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，让我们编译并运行我们的 `reverse-tcp` shellcode：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Back to my Kali again—I'm connected!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到我的 Kali —— 我连接上了！
- en: '![](img/00216.gif)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00216.gif)'
- en: That was simple!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是简单的！
- en: Now, let's build up a reverse TCP shell in assembly, and then convert it into
    a shellcode.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在汇编中构建一个反向 TCP shell，然后将其转换为一个 shellcode。
- en: 'The `socket` function is exactly as we explained in bind TCP. Move the output
    of the `socket` to the RDI register:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket` 函数与我们在绑定 TCP 中解释的一样。将 `socket` 的输出移动到 RDI 寄存器中：'
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next is filling the `mysockaddr` structure, except that we have to push out
    the attacker''s IP address in 32-bit packed format. We will do that using Python:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是填充 `mysockaddr` 结构，除了我们必须以 32 位打包格式推出攻击者的 IP 地址。我们将使用 Python 来做到这一点：
- en: '![](img/00217.gif)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00217.gif)'
- en: So our IP address in 32-bit packed format is `01eea8c0`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的 IP 地址以 32 位打包格式是 `01eea8c0`。
- en: 'Let''s build our structure and move the stack pointer to RSI:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的结构并将栈指针移动到 RSI：
- en: '[PRE79]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, let''s build the `connect` function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建 `connect` 函数：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, run the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE81]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00218.gif)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00218.gif)'
- en: The `connect` function also takes three arguments. The first argument is `sockfd`
    (the output from the `socket` function), which is stored in the RDI register.
    The second is a reference to our structure, which is stored in the RSI register.
    The third argument is the size of our structure.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 函数也接受三个参数。第一个参数是 `sockfd`（来自 `socket` 函数的输出），存储在 RDI 寄存器中。第二个是我们结构的引用，存储在
    RSI 寄存器中。第三个参数是我们结构的大小。'
- en: 'Let''s get the `connect` syscall number:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取 `connect` 系统调用号：
- en: '[PRE82]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00219.gif)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00219.gif)'
- en: 'From the obtained output, we can see that the syscall number is `42`. Now,
    let''s build the `connect` syscall:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从获得的输出中，我们可以看到系统调用号是 `42`。现在，让我们构建 `connect` 系统调用：
- en: '[PRE83]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, the `dup2` function is the same except that the first argument will be `sockfd`,
    which is already stored in the RDI register; let''s build that too:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`dup2` 函数与之前的相同，只是第一个参数将是 `sockfd`，它已经存储在 RDI 寄存器中；让我们也构建它：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, the final part, which is the `execve` syscall for `/bin/sh`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一部分，即 `/bin/sh` 的 `execve` 系统调用：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, let''s pack them together:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把它们打包在一起：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s assemble and link it to our victim machine:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其汇编和链接到我们的受害者机器上：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, on our attacker machine run the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的攻击者机器上运行以下命令：
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, back again to our victim machine and run our code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再回到我们的受害者机器并运行我们的代码：
- en: '[PRE89]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, on our attacker machine, we are connected to our victim machine (Ubuntu):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的攻击者机器上，我们连接到了受害者机器（Ubuntu）：
- en: '![](img/00220.gif)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00220.gif)'
- en: 'Now, let''s convert it to a shellcode:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其转换为一个 shellcode：
- en: '[PRE90]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00221.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00221.jpeg)'
- en: 'Let''s copy this machine language into our C code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个机器语言复制到我们的 C 代码中：
- en: '[PRE91]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s compile it on our victim machine:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的受害者机器上编译它：
- en: '[PRE92]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, set up a listener on our attacker machine:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的攻击者机器上设置一个监听器：
- en: '[PRE93]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, set up a listener on our victim machine:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的受害者机器上设置一个监听器：
- en: '[PRE94]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](img/00222.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00222.jpeg)'
- en: 'Now, we are connected to our attacker machine:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们连接到了攻击者的机器：
- en: '![](img/00223.gif)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00223.gif)'
- en: We did it!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功了！
- en: Generating shellcode using Metasploit
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Metasploit 生成 shellcode
- en: Here, things are simpler than you think. We will generate shellcodes using Metasploit
    for multiple platforms with multiple architectures, and remove bad characters
    in one command.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，事情比你想象的简单。我们将使用 Metasploit 为多个平台和多个架构生成 shellcode，并在一个命令中删除坏字符。
- en: 'We will use the `msfvenom` command. Let''s show all the options using `msfvenom
    -h`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `msfvenom` 命令。让我们使用 `msfvenom -h` 显示所有选项：
- en: '![](img/00224.gif)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00224.gif)'
- en: 'Let''s list all of its payloads using `msfvenom -l`—and it''s a very big list
    of payloads:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`msfvenom -l`列出所有的有效载荷-这是一个非常庞大的有效载荷列表：
- en: '![](img/00225.gif)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00225.gif)'
- en: This is just a small section from that list.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是列表中的一个小部分。
- en: 'Let''s take a look at our output formats using `msfvenom --help-formats`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`msfvenom --help-formats`来查看输出格式：
- en: '![](img/00226.jpeg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00226.jpeg)'
- en: 'Let''s try to create bind TCP shellcode on Linux:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Linux上创建绑定TCP shellcode：
- en: '[PRE95]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'What we have here is simple: `-a` to specify the arch, then we specified the
    platform as Linux, then we selected our payload to be `linux/x64/shell/bind_tcp`,
    then we removed bad characters, `\x00`, using the `-b` option, and finally we
    specified the format to C. Let''s execute to see:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这里很简单：`-a`指定架构，然后我们指定平台为Linux，然后选择我们的有效载荷为`linux/x64/shell/bind_tcp`，然后使用`-b`选项去除不良字符`\x00`，最后我们指定格式为C。让我们执行一下看看：
- en: '![](img/00227.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00227.jpeg)'
- en: 'Now, copy that shellcode to our C code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将那个shellcode复制到我们的C代码中：
- en: '[PRE96]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Then, copy it to our victim machine. Now, compile it and run it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其复制到我们的受害者机器上。现在，编译并运行它：
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It''s waiting for the connection. Now, let''s set up our listener on the attacker
    machine using the Metasploit Framework with the `msfconsole` command, and then
    choose the handler:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在等待连接。现在，让我们在攻击者机器上使用Metasploit Framework和`msfconsole`命令设置我们的监听器，然后选择处理程序：
- en: '[PRE98]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we select our payload using this command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个命令选择我们的有效载荷：
- en: '[PRE99]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we specify our victim machine''s IP:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们指定受害者机器的IP：
- en: '[PRE100]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, we specify the port—the default port for Metasploit is `4444`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定端口- Metasploit的默认端口是`4444`：
- en: '[PRE101]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, we run our handler:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行我们的处理程序：
- en: '[PRE102]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](img/00228.jpeg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00228.jpeg)'
- en: 'It says that the session is active on `session 1`. Let''s activate this session
    using `session 1`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 它说会话在`session 1`上是活动的。让我们使用`session 1`激活这个会话：
- en: '![](img/00229.jpeg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00229.jpeg)'
- en: It worked!
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through how to create simple shellcodes and how to
    remove bad characters. We moved on to use `execve` for system commands. Then,
    we built advanced shellcode, such as bind TCP shell and reverse TCP shell. Finally,
    we saw how to use the Metasploit Framework to build shellcodes in one line and
    how to set up a listener using Metasploit.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建简单的shellcode以及如何去除不良字符。我们继续使用`execve`执行系统命令。然后，我们构建了高级的shellcode，比如绑定TCP
    shell和反向TCP shell。最后，我们看到了如何使用Metasploit Framework在一行中构建shellcode以及如何使用Metasploit设置监听器。
- en: We now know exactly how to build a payload, so we'll see how to use them. In
    the next chapter, we will talk about buffer overflow attacks.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在确切地知道如何构建有效载荷，所以我们将看看如何使用它们。在下一章中，我们将讨论缓冲区溢出攻击。
