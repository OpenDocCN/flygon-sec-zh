- en: Exploit Development – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用开发-第1部分
- en: Exploit development, here we are! Now we are starting the real stuff! In this
    chapter, we will walk through how to deal with exploits fuzzing. We will also
    learn techniques in exploit development, such as controlling the instruction pointer
    and how to find a place to put our shellcode in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 利用开发，我们来了！现在我们开始真正的东西！在本章中，我们将学习如何处理利用模糊测试。我们还将学习利用开发中的技术，如控制指令指针以及如何找到放置我们的shellcode的位置。
- en: 'The following are the topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中涵盖的主题：
- en: Fuzzing and controlling instruction pointer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试和控制指令指针
- en: Injecting a shellcode
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入shellcode
- en: A complete example of buffer overflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出的完整示例
- en: Let's start!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Fuzzing and controlling instruction pointer
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试和控制指令指针
- en: In the previous chapter, we injected characters, but we need to know the exact
    offset of the instruction pointer, which was injecting 24 As. The idea of finding
    the exact offset of the RIP register is injecting a specific sequence length of
    a pattern, and based on the last element on the stack, calculating the offset
    of the RIP register. Don't worry, you will understand in the next example. So
    how can we determine the exact offset of the RIP register? We have two tools for
    this, the Metasploit Framework and PEDA, and we will talk about both of them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们注入了字符，但我们需要知道指令指针的确切偏移量，即注入24个As。找到RIP寄存器的确切偏移量的想法是注入一个特定序列长度的模式，并根据堆栈上的最后一个元素计算RIP寄存器的偏移量。别担心，你将在下一个例子中理解。那么我们如何确定RIP寄存器的确切偏移量呢？我们有两个工具可以做到这一点，Metasploit框架和PEDA，我们将讨论它们两个。
- en: Using Metasploit Framework and PEDA
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit框架和PEDA
- en: First, we will use the Metasploit Framework to create the pattern, and to do
    so we need to navigate to this location: `/usr/share/metasploit-framework/tools/exploit/`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用Metasploit框架创建模式，为此我们需要导航到此位置：`/usr/share/metasploit-framework/tools/exploit/`。
- en: Now, how to create a pattern? We can create one using `pattern_create.rb`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何创建一个模式？我们可以使用`pattern_create.rb`来创建一个。
- en: 'Let''s take an example using our vulnerable code but with a bigger buffer,
    let''s say `256`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，使用我们的易受攻击的代码，但使用一个更大的缓冲区，比如`256`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s compile it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译它：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we will use GDB:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用GDB：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we calculate the offset of the RIP location. So, first let''s create
    a pattern by using the Metasploit Framework on our attacking machine and inside
    `/usr/share/metasploit-framework/tools/exploit/`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算RIP位置的偏移量。因此，首先让我们在攻击机上使用Metasploit框架创建一个模式，并在`/usr/share/metasploit-framework/tools/exploit/`中进行操作：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous command, we generated a pattern with a length of `300` and
    saved it in a file with the name `pattern`. Now copy this file to our victim machine
    and use this pattern as input inside GDB:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，我们生成了一个长度为`300`的模式，并将其保存在名为`pattern`的文件中。现在将此文件复制到我们的受害机器上，并在GDB中使用此模式作为输入：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00285.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00285.jpeg)'
- en: 'The code stopped, as expected, with an error. Now, we need to extract the last
    element in the stack, because the next element after that should overflow the
    RIP register. Let''s see how to get the last element in the stack, using the `x`
    command to print the content of a memory. Let''s take a look at how the `x` command
    works in GDB, using `help x`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码停止了，如预期的那样，出现了错误。现在，我们需要提取堆栈中的最后一个元素，因为在那之后的元素应该溢出RIP寄存器。让我们看看如何使用`x`命令打印内存中的内容来获取堆栈中的最后一个元素。让我们看看`x`命令在GDB中的工作原理，使用`help
    x`：
- en: '![](img/00286.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00286.jpeg)'
- en: 'Now, let''s print the last element inside the stack using `x`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`x`打印堆栈中的最后一个元素：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00287.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00287.jpeg)'
- en: 'The last element in the stack is ;`0x41386941`. You can also use `x/wx $rsp`
    to print a full word from inside the RSP register. Now we need to calculate the
    exact location of the RIP register using `pattern_offset.rb` on our attacking
    machine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈中的最后一个元素是`0x41386941`。您还可以使用`x/wx $rsp`来打印RSP寄存器内的完整字。现在我们需要在攻击机上使用`pattern_offset.rb`计算RIP寄存器的确切位置：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we specified the query we extracted from the stack; then we specified
    the length of the pattern we used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定了我们从堆栈中提取的查询；然后我们指定了我们使用的模式的长度：
- en: '![](img/00288.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00288.jpeg)'
- en: 'It tells us that the last element in the stack is at location `264`, which
    means that the next six characters should overflow the RIP register:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们堆栈中的最后一个元素位于位置`264`，这意味着接下来的六个字符应该溢出RIP寄存器：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If our calculation is correct, we should see the 42s in the RIP. Let''s run
    this code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的计算是正确的，我们应该在RIP中看到42。让我们运行这段代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, from inside GDB, run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在GDB中运行以下命令：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00289.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00289.jpeg)'
- en: Our 42s are now in the instruction pointer, which is `bbbbbb` in ASCII.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的42现在在指令指针中，ASCII中是`bbbbbb`。
- en: Injecting shellcode
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入shellcode
- en: The RIP now contains our 6 Bs (`424242424242`) and the code has stopped complaining
    about where `0x0000424242424242` is in the memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RIP现在包含我们的6个Bs（`424242424242`），代码已经不再抱怨`0x0000424242424242`在内存中的位置了。
- en: 'We have succeeded with our exploit so far. This is what our payload looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功地利用了我们的漏洞。这就是我们的有效载荷：
- en: '![](img/00290.gif)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00290.gif)'
- en: We need to find a way to inject a shellcode in the As so we can jump to it easily.
    To do so, we need to first inject `0x90` or the NOP instruction, which is NOP,
    just to make sure that our shellcode is injected correctly. After injecting our
    shellcode, we change the instruction pointer (RIP) to any address in the memory
    containing the NOP instruction (`0x90`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来注入shellcode到As中，这样我们就可以轻松地跳转到它。为此，我们需要首先注入`0x90`或NOP指令，即NOP，只是为了确保我们的shellcode被正确注入。在注入我们的shellcode之后，我们将改变指令指针（RIP）到内存中包含NOP指令（`0x90`）的任何地址。
- en: 'Then the execution should just pass on all **NOP** instructions until it hits
    the **Shellcode**, and it will start executing it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行应该只是在所有 **NOP** 指令上传递，直到它碰到 **Shellcode**，然后开始执行它：
- en: '![](img/00291.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00291.gif)'
- en: 'This is what our exploit should look like. Let''s try to inject the `execve
    /bin/sh` shellcode (length `32`). Now we need to get any address in the memory
    that contains `0x90`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的攻击应该是什么样子的。让我们尝试注入 `execve /bin/sh` shellcode（长度为 `32`）。现在我们需要在内存中找到包含
    `0x90` 的任何地址：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run the new exploit:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行新的攻击：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, from inside GDB, run the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 GDB 中，运行以下命令：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00292.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00292.jpeg)'
- en: 'The program stopped. Now, let''s look inside the stack to search for our NOP
    slide by printing `200` hex values from the memory:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序停止了。现在，让我们查看堆栈以搜索我们的 NOP 滑块，通过从内存中打印 `200` 个十六进制值：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00293.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00293.jpeg)'
- en: 'We got them! These are our NOP''s instructions that we injected. Also, after
    the NOPs, you can see 32 Cs (`43`), so now we can choose any address in the middle
    of this NOP''s instructions; let''s select `0x7fffffffe2c0`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了它们！这些是我们注入的 NOP 指令。此外，在 NOP 之后，你可以看到 32 个 C（`43`），所以现在我们可以选择这些 NOP 指令中间的任何地址；让我们选择
    `0x7fffffffe2c0`：
- en: '![](img/00294.gif)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00294.gif)'
- en: 'This is what the final payload should look like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终的有效载荷应该是什么样子的：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run the exploit:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行攻击：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, from inside GDB, run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 GDB 中，运行以下命令：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00295.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00295.jpeg)'
- en: 'Now we got the bash prompt inside GDB; let''s try to execute something like
    `cat /etc/issue`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 GDB 中得到了 bash 提示符；让我们尝试执行类似 `cat /etc/issue` 的命令：
- en: '![](img/00296.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00296.jpeg)'
- en: It gave us the content of `/etc/issue`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它给了我们 `/etc/issue` 的内容。
- en: It worked!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！
- en: A complete example of buffer overflow
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出的完整示例
- en: Now, let's see a complete example of the buffer overflow. What we need is to
    download and run vulnserver on Windows. Vulnserver is a vulnerable server, where
    we can practice exploit development skills. You can find it at [https://github.com/stephenbradshaw/vulnserver](https://github.com/stephenbradshaw/vulnserver).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个完整的缓冲区溢出示例。我们需要下载并在 Windows 上运行 vulnserver。Vulnserver 是一个易受攻击的服务器，我们可以在其中练习利用开发技能。你可以在
    [https://github.com/stephenbradshaw/vulnserver](https://github.com/stephenbradshaw/vulnserver)
    找到它。
- en: 'After downloading it, run it using `vulnserver.exe`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，使用 `vulnserver.exe` 运行它：
- en: '![](img/00297.gif)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00297.gif)'
- en: Now, it's working and waiting for a connection on port `9999` using netcat.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它正在工作，并等待在端口 `9999` 上使用 netcat 进行连接。
- en: 'Netcat is a tool used to initiate a connection with a server or listen on a
    port and wait for a connection from another client. Now, let''s use `nc` from
    the attacking machine:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 是一个用于与服务器建立连接或监听端口并等待来自另一个客户端的连接的工具。现在，让我们从攻击机器上使用 `nc`：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00298.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00298.jpeg)'
- en: 'Now, let''s try fuzzing a parameter, such as `TRUN` (which is a vulnerable
    parameter inside a vulnerable-by-design application). We need to build up a script
    to help us do that:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试模糊化一个参数，比如 `TRUN`（这是一个易受攻击的参数，在易受攻击的设计应用程序中）。我们需要建立一个脚本来帮助我们做到这一点：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s try to send `50` As:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试发送 `50` 个 A：
- en: '![](img/00299.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00299.jpeg)'
- en: 'It didn''t crash. How about `5000` As:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有崩溃。那么 `5000` 个 A 呢：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output for the `./fuzzing.py` command can be seen in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`./fuzzing.py` 命令的输出可以在以下截图中看到：'
- en: '![](img/00300.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00300.jpeg)'
- en: 'No reply! Let''s take a look at our Windows machine:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有回复！让我们看看我们的 Windows 机器：
- en: '![](img/00301.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00301.jpeg)'
- en: The program crashed and it's complaining about memory location `0x41414141`,
    which is our `5000` As. At the second stage, which is controlling the RIP, let's
    create a pattern with a length of `5000` bytes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃了，它抱怨内存位置 `0x41414141`，这是我们的 `5000` 个 A。在第二阶段，也就是控制 RIP，让我们创建一个长度为 `5000`
    字节的模式。
- en: 'From our attacking machine, navigate to `/usr/share/metasploit-framework/tools/exploit/`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的攻击机器，导航到 `/usr/share/metasploit-framework/tools/exploit/`：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00302.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00302.jpeg)'
- en: 'Copy the output pattern to our exploit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出模式复制到我们的攻击中：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s run vulnserver. Then, open the Immunity Debugger as an administrator.
    Navigate to File | Attach and select vulnserver:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 vulnserver。然后，以管理员身份打开 Immunity Debugger。导航到 文件 | 附加 并选择 vulnserver：
- en: '![](img/00303.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00303.jpeg)'
- en: 'Click on Attach and hit the run program. Then run our exploit, and look at
    what happens inside the Immunity Debugger:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击附加并运行程序。然后运行我们的攻击，并查看 Immunity Debugger 中发生了什么：
- en: '![](img/00304.gif)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00304.gif)'
- en: 'Let''s take a look inside the registers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看寄存器内部：
- en: '![](img/00305.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00305.jpeg)'
- en: 'Now, the EIP contains `396F4338`. Let''s try to find this pattern from our
    attacking machine:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，EIP 包含 `396F4338`。让我们尝试从我们的攻击机器中找到这个模式：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output for the preceding command can be seen in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![](img/00306.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00306.jpeg)'
- en: 'So, to control the instruction pointer, we need to inject `2006` As. Then,
    we need 4 bytes to control the EIP register and the rest will be injected as a
    shellcode (`5000-2006-4`); that gives us `2990` characters. Let''s try it to make
    sure we are going in the right direction:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了控制指令指针，我们需要注入 `2006` 个 A。然后，我们需要 4 个字节来控制 EIP 寄存器，其余的将被注入为 shellcode（`5000-2006-4`）；这给我们
    `2990` 个字符。让我们尝试一下，以确保我们走在正确的方向上：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is what our payload should look like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的有效载荷应该是什么样子的：
- en: '![](img/00307.gif)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00307.gif)'
- en: 'Close the Immunity Debugger and start the application again. Then, start the
    exploit code again. We should see Bs injected inside the EIP register:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭Immunity Debugger，然后重新启动应用程序。然后，再次启动利用代码。我们应该看到Bs被注入到EIP寄存器中：
- en: '![](img/00308.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00308.jpeg)'
- en: 'It worked! I''m going to recheck again using the Immunity Debugger. Let''s
    take a look inside the Registers (FPU):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我要再次使用Immunity Debugger进行重新检查。让我们来看看寄存器（FPU）里面的情况：
- en: '![](img/00309.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00309.jpeg)'
- en: 'Now we have control over the EIP register. Let''s take a look inside the stack:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们控制了EIP寄存器。让我们来看看堆栈里面的情况：
- en: '![](img/00310.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00310.jpeg)'
- en: As you can see, there are our As, then 4 bytes of Bs that overflowed the EIP
    register, and  then `299*0` of Cs .
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里有我们的As，然后是4个字节的Bs，溢出了EIP寄存器，然后是`299*0`个Cs。
- en: What we are going to do in the next chapter is inject a shellcode in those Cs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在这些Cs中注入一个shellcode。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through fuzzing and how to get the program to crash.
    Then, we saw how to get the exact offset of the RIP register using the Metasploit
    Framework and a very simple method of injecting a shellcode. Finally, we went
    through a complete example of fuzzing and controlling the instruction pointer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了fuzzing以及如何使程序崩溃。然后，我们看到了如何使用Metasploit Framework获得RIP寄存器的确切偏移量，以及一种非常简单的注入shellcode的方法。最后，我们经历了一个完整的fuzzing示例，并控制了指令指针。
- en: In the next chapter, we will continue with our example and see how to find a
    place for a shellcode and make it work. Also, we will learn more techniques in
    the buffer overflow.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的示例，看看如何找到一个地方放置shellcode并使其工作。此外，我们还将学习更多的缓冲区溢出技术。
