# 前言

本书主要介绍了如何发现缓冲区溢出漏洞，从头开始编写自己的 shellcode，学习操作系统的安全机制以及利用开发。您将了解如何使用 shellcode、汇编语言和 Metasploit 绕过操作系统和网络层的安全系统。您还将学习编写和修改 64 位 shellcode 以及内核级 shellcode 的概念。总的来说，本书是一本逐步指导的指南，将带您从低级安全技能到利用开发和 shellcode 的循环覆盖。

# 本书的读者对象

本书适合渗透测试人员、恶意软件分析人员、安全研究人员、取证从业人员、利用开发人员、C 语言程序员、软件测试人员以及安全领域的学生阅读。

# 本书涵盖内容

第一章，*介绍*，讨论了 shellcode、缓冲区溢出、堆破坏的概念，并介绍了计算机体系结构。

第二章，*实验室设置*，教授如何构建一个安全的环境来测试恶意代码，并向读者介绍调试器的图形界面。

第三章，*Linux 上的汇编语言*，解释了如何在 Linux 上使用汇编语言构建 shellcode。

第四章，*逆向工程*，介绍了如何使用调试器对代码进行逆向工程。

第五章，*创建 Shellcode*，解释了如何使用汇编语言和 Metasploit 构建 shellcode。

第六章，*缓冲区溢出攻击*，详细介绍了 Windows 和 Linux 上的缓冲区溢出攻击。

第七章，*利用开发-第 1 部分*，讨论了如何进行模糊测试和查找返回地址。

第八章，*利用开发-第 2 部分*，教授如何生成适当的 shellcode 以及如何在利用中注入 shellcode。

第九章，*真实场景-第 1 部分*，介绍了一个缓冲区溢出攻击的真实例子。

第十章，*真实场景-第 2 部分*，延续了前一章，但更加高级。

第十一章，*真实场景-第 3 部分*，提供了另一个真实场景的例子，但使用了更多的技术。

第十二章，*检测和预防*，讨论了检测和预防缓冲区溢出攻击所需的技术和算法。

# 充分利用本书

读者应该对操作系统内部有基本的了解（Windows 和 Linux）。对 C 语言的了解是必不可少的，熟悉 Python 会有所帮助。

本书中的所有地址都依赖于我的计算机和操作系统。因此，您的计算机上的地址可能会有所不同。

# 下载示例代码文件

您可以从[www.packtpub.com](http://www.packtpub.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，可以访问[www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。

您可以按照以下步骤下载代码文件：

1.  在[www.packtpub.com](http://www.packtpub.com/support)上登录或注册。

1.  选择“支持”选项卡。

1.  单击“代码下载和勘误”。

1.  在搜索框中输入书名，然后按照屏幕上的说明操作。

文件下载后，请确保使用最新版本解压缩或提取文件夹：

+   WinRAR/7-Zip for Windows

+   Zipeg/iZip/UnRarX for Mac

+   7-Zip/PeaZip for Linux

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Penetration-Testing-with-Shellcode`](https://github.com/PacktPublishing/Penetration-Testing-with-Shellcode)</span>。我们还有其他代码包来自我们丰富的书籍和视频目录，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

# 下载彩色图像

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图像。您可以从[`www.packtpub.com/sites/default/files/downloads/PenetrationTestingwithShellcode_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/PenetrationTestingwithShellcode_ColorImages.pdf)下载。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 用户名。以下是一个例子：“现在堆栈已恢复正常，`0x1234`已移至`rsi`。”

代码块设置如下：

```
mov rdx,0x1234
push rdx
push 0x5678
pop rdi
pop rsi
```

当我们希望引起您对代码块的特定部分的注意时，相关的行或项目将以粗体显示：

```
mov rdx,0x1234
push rdx
push 0x5678
pop rdi
pop rsi
```

任何命令行输入或输出都以以下形式编写：

```
$ nasm -felf64 stack.nasm -o stack.o
```

**粗体**：表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词会以这种形式出现在文本中。以下是一个例子：“选择 GNU GCC 编译器，点击设置为默认，然后点击确定。”

警告或重要说明会以这种形式出现。

技巧和窍门会以这种形式出现。
