- en: Buffer Overflow Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出攻击
- en: In this chapter, we will delve more deeply into buffer overflow attacks. We'll
    see how to change the flow of execution and look at very simple ways to inject
    shellcode. Shall we begin?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨缓冲区溢出攻击。我们将看到如何改变执行流程，并且看一些非常简单的方法来注入shellcode。我们开始吧？
- en: Stack overflow on Linux
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux上的堆栈溢出
- en: Now, we are about to learn what a buffer overflow is, and we will understand
    how to change the flow of an execution using a vulnerable source code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们即将学习什么是缓冲区溢出，并且我们将了解如何改变执行流程，使用一个有漏洞的源代码。
- en: 'We will be using the following code:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'OK, let''s tweak it a little to do something more useful:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们稍微调整一下，做一些更有用的事情：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we added a new function, `letsprint`, which contains `printf`, and since
    this function has never been called in the `main` function, it will never be executed.
    So, what if we use this buffer overflow to control the execution and change the
    flow to execute this function?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新函数`letsprint`，其中包含`printf`，由于这个函数从未在`main`函数中被调用过，它将永远不会被执行。那么，如果我们使用这个缓冲区溢出来控制执行并改变流程来执行这个函数呢？
- en: 'Now, let''s compile it and run it on our Ubuntu machine:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的Ubuntu机器上编译并运行它：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00230.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00230.jpeg)'
- en: 'As you can see, nothing happened. Let''s try to cause an overflow:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，什么都没有发生。让我们尝试造成溢出：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00231.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00231.jpeg)'
- en: 'OK, now let''s try to get that error inside our GDB:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们试着在我们的GDB中获取那个错误：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let''s set a breakpoint at the `main` function to pause the execution
    at the `main` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在`main`函数处设置一个断点，暂停执行在`main`函数处：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the program starts. It will pause at the `main` function. Proceed using
    24 `a` characters as input:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序开始。它将在`main`函数处暂停。使用24个`a`字符作为输入继续：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the code will pause at `main`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将在`main`处暂停：
- en: '![](img/00232.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00232.jpeg)'
- en: 'Hit the *C* and *Enter* keys to continue executing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*C*和*Enter*键继续执行：
- en: '![](img/00233.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00233.jpeg)'
- en: 'The program crashed as expected, so let''s try 26 `a` characters as input:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如预期地崩溃了，所以让我们尝试输入26个`a`字符：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use Python to generate the input instead of counting the characters:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python生成输入，而不是计算字符数：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, give it the execute permission and execute it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，给予它执行权限并执行它：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From inside GDB, run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中，运行以下命令：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, the code will pause at `main`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将在`main`处暂停：
- en: '![](img/00234.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00234.jpeg)'
- en: 'Hit *C* then *Enter* to continue executing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*C*然后*Enter*继续执行：
- en: '![](img/00235.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00235.jpeg)'
- en: Have you noticed the error `0x0000000000006161` in `?? ()`? From the preceding
    screenshot, the program doesn't know where  `0x0000000000006161` is, and `6161`
    is `aa`, which means we were able to inject 2 bytes into the RIP register, so
    that is how I got it to start after 24 characters. Don't worry, we will talk about
    that in the next chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到`??()`中的错误`0x0000000000006161`了吗？从前面的截图中，程序不知道`0x0000000000006161`在哪里，`6161`是`aa`，这意味着我们能够向RIP寄存器注入2个字节，这就是我如何在24个字符后开始的。别担心，我们将在下一章中讨论这个问题。
- en: 'Let''s confirm that by using 24 of the `a` characters and 6 of `b` characters:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认一下，使用24个`a`字符和6个`b`字符：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also use Python:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用Python：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, execute the exploit to generate the new input:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行利用以生成新的输入：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, run the following from inside GDB:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在GDB中运行以下命令：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, the code will hit the breakpoint:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将触发断点：
- en: '![](img/00236.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00236.jpeg)'
- en: 'Hit *C* then *Enter* to continue:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*C*然后*Enter*继续：
- en: '![](img/00237.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00237.jpeg)'
- en: 'Now, by looking at the error, we see our injected `b` characters in there.
    At this point, we are doing very well. Now we know our injection form, let''s
    try to execute the `letsprint` function using the `disassemble` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过查看错误，我们看到我们注入的`b`字符在里面。在这一点上，我们做得很好。现在我们知道了我们的注入形式，让我们尝试使用`disassemble`命令执行`letsprint`函数：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00238.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00238.jpeg)'
- en: 'We got the first instruction in the `letsprint` function, `push rbp` with address
    `0x00000000004005e3`, and the real address is what we need here; we can also get
    the address by using the `print` command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`letsprint`函数中的第一条指令，`push rbp`，地址为`0x00000000004005e3`，我们需要的是真实地址；我们也可以使用`print`命令来获取地址：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00239.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00239.jpeg)'
- en: 'Now that we have the address, let''s try to build our exploit using Python
    because we can''t pass the address directly:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了地址，让我们尝试使用Python构建我们的利用，因为我们不能直接传递地址：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we execute it to generate the new input:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行它以生成新的输入：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, from inside GDB, run the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在GDB中，运行以下命令：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, it will hit the breakpoint:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将触发断点：
- en: '![](img/00240.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00240.jpeg)'
- en: 'Hit *C* and then *Enter* to continue:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*C*然后*Enter*继续：
- en: '![](img/00241.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00241.jpeg)'
- en: 'We did it! Now, let''s confirm that from our shell instead of GDB:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！现在，让我们从我们的shell中确认，而不是从GDB中确认：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](img/00242.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00242.jpeg)'
- en: Yes, we changed the flow of execution to execute something that should never
    be executed!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们改变了执行流程，执行了本不应该执行的东西！
- en: 'Let''s try another payload just for fun. We will use our code here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个有趣的有效载荷。我们将使用我们的代码：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But we will add our `execve` syscall to run `/bin/sh` from the previous chapter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将在这里添加我们的`execve`系统调用来从上一章运行`/bin/sh`：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s put them together:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它们放在一起：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, here `shell_pwn` will never be executed because we never called it here,
    but now we know how to do it. First, let''s compile it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里`shell_pwn`永远不会被执行，因为我们从未在这里调用它，但现在我们知道如何做。首先，让我们编译它：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, open our code inside GDB:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在GDB中打开我们的代码：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, set a breakpoint at the `main` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`函数处设置断点：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'OK, now let''s prepare our exploit to confirm the exact position of the RIP
    register:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们准备我们的利用程序来确认RIP寄存器的确切位置：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, execute our exploit:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行我们的利用程序：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, from GDB, run the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从GDB中运行以下命令：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, it will hit the breakpoint at the `main` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将在`main`函数处触发断点：
- en: '![](img/00243.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00243.jpeg)'
- en: 'Let''s hit *C* and then *Enter* to continue:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按*C*然后*Enter*继续：
- en: '![](img/00244.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00244.jpeg)'
- en: 'Yes, it''s complaining about our 6 `b` characters, `0x0000626262626262`, so
    now we are on the right track. Now, let''s find the address of our shellcode:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它在抱怨我们的6个`b`字符，`0x0000626262626262`，所以现在我们走上了正确的道路。现在，让我们找到我们shellcode的地址：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下屏幕截图中看到：
- en: '![](img/00245.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00245.jpeg)'
- en: 'The first instruction''s address is `0x000000000040060d`. Also, we can use
    the `print` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令的地址是`0x000000000040060d`。此外，我们可以使用`print`函数：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下屏幕截图中看到：
- en: '![](img/00246.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00246.jpeg)'
- en: 'Perfect! Now, let''s build our final exploit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，让我们构建我们的最终利用：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, execute it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行它：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, from inside GDB, run the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在GDB内部，运行以下命令：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the code will pause at the `main` function; hit *C* to continue:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将在`main`函数处暂停；按*C*继续：
- en: '![](img/00247.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00247.jpeg)'
- en: 'Now we''ve got a shell; let''s try to execute it with `$ cat /etc/issue`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个shell；让我们尝试使用`$ cat /etc/issue`来执行它：
- en: '![](img/00248.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00248.jpeg)'
- en: 'Let''s confirm that, using our bash shell instead of GDB:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认一下，使用我们的bash shell而不是GDB：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下屏幕截图中看到：
- en: '![](img/00249.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00249.jpeg)'
- en: 'Let''s try to execute something:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试执行一些东西：
- en: '![](img/00250.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00250.jpeg)'
- en: It worked!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它奏效了！
- en: Stack overflow on Windows
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows上的堆栈溢出
- en: Now, let's try the previous vulnerable code to exploit the stack overflow on
    Windows 7\. We don't even have to disable any security mechanisms on Windows,
    such as **Address Space Layout Randomization **(**ASLR**) or **Data**** Execution
    Prevention** (**DEP**); we will talk about security mechanisms in the [Chapter
    12](part0115.html#3DLGM0-5bf3e26315164e77bbeecc4f75207114), *Detection and Prevention*—shall
    we begin?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试之前的易受攻击代码来利用Windows 7上的堆栈溢出。我们甚至不必在Windows上禁用任何安全机制，如**地址空间布局随机化**（**ASLR**）或**数据执行防护**（**DEP**）；我们将在[第12章](part0115.html#3DLGM0-5bf3e26315164e77bbeecc4f75207114)中讨论安全机制，*检测和预防*
    - 我们开始吧？
- en: 'Let''s try our vulnerable code using Code::Blocks:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Code::Blocks尝试我们的易受攻击代码：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Simply open Code::Blocks and navigate to File | New | Empty file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地打开Code::Blocks并导航到文件|新建|空文件。
- en: 'Then, write our vulnerable code. Go to File | Save file and then save it as
    `buffer2.c`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写我们的易受攻击代码。转到文件|保存文件，然后将其保存为`buffer2.c`：
- en: '![](img/00251.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00251.jpeg)'
- en: Now, let's build our code by navigating to Build | Build.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过导航到构建|构建来构建我们的代码。
- en: Let's try to see what is going on behind the scenes; open Immunity Debugger
    as the administrator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试看看幕后发生了什么；以管理员身份打开Immunity Debugger。
- en: 'Then, go to File | Open and select `buffer2`. Here, enter our argument as `aaaaaaaaaaaaaaaaaaaaaaaaaaabbbb`
    (27 characters of `a` and 4 characters of `b`); we will know later how to get
    the length of our payload:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到文件|打开并选择`buffer2`。在这里，将我们的参数输入为`aaaaaaaaaaaaaaaaaaaaaaaaaaabbbb`（27个`a`和4个`b`的字符）；稍后我们将知道如何获得我们有效负载的长度：
- en: '![](img/00252.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00252.jpeg)'
- en: 'Now, we can see our four windows. Hit the run program once. After that, we
    are at the entry point of our program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们的四个窗口。运行程序一次。之后，我们就到了程序的入口点：
- en: '![](img/00253.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00253.jpeg)'
- en: 'Now, hit the run program again and notice the status bar:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行程序并注意状态栏：
- en: '![](img/00254.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00254.jpeg)'
- en: 'The program crashed and gave us access violation when executing `62626262`,
    which are our characters `b` in ASCII, and the most important thing to notice
    is the Registers (FPU) window:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`62626262`时，程序崩溃并给出访问冲突，这些是我们的字符`b`的ASCII码，最重要的是要注意寄存器（FPU）窗口：
- en: '![](img/00255.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00255.jpeg)'
- en: The instruction pointer is pointing at the `b` characters `62626262`, that's
    perfect!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针指向`b`字符`62626262`，太完美了！
- en: Now, let's try to locate our function. From Immunity Debugger, navigate to Debug
    | Restart.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试定位我们的函数。从Immunity Debugger中，导航到调试|重新启动。
- en: 'Now we are starting over; hit the run program once and then right-click on
    the disassemble window and navigate to Search for | All referenced text strings:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新开始；运行程序一次，然后右键单击反汇编窗口，导航到搜索|所有引用的文本字符串：
- en: '![](img/00256.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00256.jpeg)'
- en: Here, we are searching for our string, which is inside the `letsprint` function, `Hey!!
    , you succeeded\n`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在搜索我们的字符串，它位于`letsprint`函数内部，`Hey!! , you succeeded\n`。
- en: 'A new window will pop up:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将弹出一个新窗口：
- en: '![](img/00257.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00257.jpeg)'
- en: The third one is our string, but it is not readable because of the `exit(0)` function.
    You can make sure by compiling another version without `exit(0)` and performing
    the same step, and you will be able to read our string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是我们的字符串，但由于`exit(0)`函数的存在，它是不可读的。您可以通过编译另一个版本并执行相同的步骤来确保，然后您将能够读取我们的字符串。
- en: Addresses here are not fixed—you may get a different address.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的地址不是固定的-您可能会得到不同的地址。
- en: 'Double-click on our string, then Immunity Debugger will set you exactly at
    our string at address, `0x00401367`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 双击我们的字符串，然后Immunity Debugger会将您准确设置在地址`0x00401367`处的字符串上：
- en: '![](img/00258.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00258.jpeg)'
- en: 'Really, we don''t need our string, but we need to locate the `letsprint` function.
    Keep going up until you hit the end of the previous function (`RETN` instruction).
    Then, the next instruction will be the start of the `letsprint` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要我们的字符串，但我们需要定位`letsprint`函数。继续向上直到到达上一个函数的末尾（`RETN`指令）。然后，下一条指令将是`letsprint`函数的开始：
- en: '![](img/00259.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00259.jpeg)'
- en: 'There it is! Address `0x0040135f` should be the start of the `letsprint` function. Now,
    let''s confirm that. Open IDLE (Python GUI) and navigate to File | New Window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！地址`0x0040135f`应该是`letsprint`函数的开始。现在，让我们确认一下。打开IDLE（Python GUI）并导航到文件|新建窗口：
- en: '![](img/00260.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00260.jpeg)'
- en: 'In the new window, write our exploit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在新窗口中，编写我们的利用程序：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, save it as `exploit.py`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其保存为`exploit.py`：
- en: '![](img/00261.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00261.jpeg)'
- en: Click on Run on the IDLE window, which will generate a new file, `input.txt`,
    in our current working directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 点击IDLE窗口上的运行，这将在当前工作目录中生成一个新文件`input.txt`。
- en: 'Open the `input.txt` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`input.txt`文件：
- en: '![](img/00262.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00262.jpeg)'
- en: 'Here is our payload; copy the contents of the output file. Then, go back to
    Immunity Debugger by navigating to File | Open, then paste the payload in Arguments
    and select `buffer2`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的有效载荷；复制输出文件的内容。然后，返回到Immunity Debugger，通过导航到文件|打开，然后将有效载荷粘贴到参数中并选择`buffer2`：
- en: '![](img/00263.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00263.jpeg)'
- en: 'Then, start the Immunity Debugger:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动Immunity Debugger：
- en: '![](img/00264.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00264.jpeg)'
- en: 'Now, hit the run program; then, it will pause at the program entry point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序；然后，它将暂停在程序的入口点：
- en: '![](img/00265.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00265.jpeg)'
- en: 'Now, hit the run program one more time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行程序一次：
- en: '![](img/00266.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00266.jpeg)'
- en: 'The program exited normally with exit code `0`. Now, let''s take a look at
    Immunity''s CLI:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正常退出，退出代码为`0`。现在，让我们来看看Immunity的CLI：
- en: '![](img/00267.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00267.jpeg)'
- en: 'It worked! Let''s take a look at the stack window:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它奏效了！让我们来看看堆栈窗口：
- en: '![](img/00268.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00268.jpeg)'
- en: Notice that the `a` characters are injected in the stack and the `letsprint`
    address is injected correctly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`a`字符被注入到堆栈中，`letsprint`地址被正确注入。
- en: 'Now, let''s try to inject a shellcode instead of using the `letsprint` function,
    using Metasploit to generate a shellcode for Windows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试注入一个shellcode，而不是使用`letsprint`函数，使用Metasploit生成Windows的shellcode：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在下面的截图中看到：
- en: '![](img/00269.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00269.jpeg)'
- en: 'We can test this shellcode before we use it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在使用之前测试这个shellcode：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, build it and run it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建并运行它：
- en: '![](img/00270.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00270.jpeg)'
- en: 'Now, it''s waiting for our connection. From our attacking machine, start Metasploit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它正在等待我们的连接。从我们的攻击机器上，启动Metasploit：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, select the handler to connect to the victim machine:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择处理程序以连接到受害者机器：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, select our payload, which is `windows/shell_bind_tcp`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择我们的有效载荷，即`windows/shell_bind_tcp`：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, set the IP address of the victim machine:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置受害者机器的IP地址：
- en: '![](img/00271.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00271.jpeg)'
- en: 'Now, set the rhost:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置rhost：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, let''s start:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们开始：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在下面的截图中看到：
- en: '![](img/00272.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00272.jpeg)'
- en: 'Now, the session starts on `session 1`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，会话开始于`session 1`：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在下面的截图中看到：
- en: '![](img/00273.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00273.jpeg)'
- en: 'We are now inside our victim machine. Exit this session and let''s get back
    to our code. So, our final code should look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在受害者机器内部。退出此会话，让我们回到我们的代码。因此，我们的最终代码应该是这样的：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, build it and let''s run it inside Immunity Debugger to find the address
    of the `shell_pwn` function. Start Immunity Debugger as the administrator and
    select our new code with any argument you want:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建它，并让我们在Immunity Debugger中运行它，以找到`shell_pwn`函数的地址。以管理员身份启动Immunity Debugger，并选择我们带有任何参数的新代码：
- en: '![](img/00274.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00274.jpeg)'
- en: 'Then, hit the run program once. Now, we are at the program''s entry point:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行程序一次。现在，我们在程序的入口点：
- en: '![](img/00275.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00275.jpeg)'
- en: 'Right-click on the main screen and navigate to Search for | All referenced
    text strings:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击主屏幕，导航到搜索|所有引用的文本字符串：
- en: '![](img/00276.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00276.jpeg)'
- en: 'Do you see `Shellcode Length`? This is a string in the `shell_pwn` function;
    now double-click on it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到`Shellcode Length`了吗？这是`shell_pwn`函数中的一个字符串；现在双击它：
- en: '![](img/00277.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00277.jpeg)'
- en: 'The program set us on the exact location of the `Shellcode Length` string.
    Now, let''s go up until we hit the function''s start address:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将我们设置在`Shellcode Length`字符串的确切位置。现在，让我们向上移动，直到我们达到函数的起始地址：
- en: '![](img/00278.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00278.jpeg)'
- en: 'That''s it at address `0x00401340`. Now, let''s set up our exploit code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就是在地址`0x00401340`。现在，让我们设置我们的利用代码：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, run the exploit code to renew `input.txt`; then, open `input.txt`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行利用代码以更新`input.txt`；然后，打开`input.txt`：
- en: '![](img/00279.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00279.jpeg)'
- en: 'Then, copy the contents of it. Go back to Immunity Debugger and open the program
    again and paste the payload:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，复制其中的内容。返回到Immunity Debugger，再次打开程序并粘贴有效载荷：
- en: '![](img/00280.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00280.jpeg)'
- en: 'Then, hit the run program twice. The code is still running:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次运行程序两次。代码仍在运行：
- en: '![](img/00281.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00281.jpeg)'
- en: 'Also, take a look at the status bar:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意状态栏：
- en: '![](img/00282.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00282.jpeg)'
- en: 'Our shellcode is running now and waiting for our connection. Let''s go back
    to our attacking machine and set up the handler to connect to the victim machine:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的shellcode现在正在运行并等待我们的连接。让我们回到我们的攻击机器上，设置处理程序以连接到受害者机器：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在下面的截图中看到：
- en: '![](img/00283.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00283.jpeg)'
- en: 'The connection has been established on `session 2`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 连接已在`session 2`上建立：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在下面的截图中看到：
- en: '![](img/00284.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00284.jpeg)'
- en: It worked!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它奏效了！
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, we know how buffer overflow attacks work on Linux and Windows.
    Also, we know how to exploit stack overflow.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们知道了如何在Linux和Windows上进行缓冲区溢出攻击。此外，我们知道如何利用堆栈溢出。
- en: In the next chapter, we will talk about more techniques, such as how to locate
    and control the instruction pointer, how to find the location of your payload,
    and more techniques for buffer overflow attacks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论更多的技术，比如如何定位和控制指令指针，如何找到有效载荷的位置，以及更多关于缓冲区溢出攻击的技术。
