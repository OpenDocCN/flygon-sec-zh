# 第二章： 自定义您的 Shell

您的 bash 终端的几乎每个方面都是可定制的。现在您已经学会了如何利用一些重要的信息处理实用程序，我们可以继续学习如何使用它们来自定义您的 shell。本章中我们将涵盖的大部分内容涉及从一个程序中获取信息，将其传输到另一个程序，并过滤出对我们重要的任何细节。

您还将学习一些关于 bash 脚本的知识，这是您的 Kali Linux 和更大的 Linux 家族中许多应用程序的组成部分。

# 格式化终端输出

在您的 bash 终端上打印的所有内容都是由光标完成的，光标只是您的 bash 终端的另一个组件，您可以使用非常方便的快捷方式来控制它。本节将介绍如何控制在终端上打印的输出的颜色和基本格式，并且您还将在本章后面看到一些非常酷的技巧和窍门。

首先，让我们谈谈控制序列。控制序列是引入在您的终端上显示的文本的特殊行为的字符模式。这些特殊字符总是在它们格式化的输出之前。控制序列通常由转义字符分隔，我们感兴趣的是由`\e`表示的一个。

使用这个控制序列，我们可以做一些很酷的事情；观察以下命令行：

```
for colorcode in {93..88} {124..129};  do echo –en "\e48;5;${colorcode}m \e[0m"; done

```

以下是上一个命令行的操作截图：

![格式化终端输出

另一个例子将是以下命令行：

```
for colorcode in {93..88} {124..129};  do echo –en "\e38;5;${colorcode}m|||\e[0m"; done

```

以下是上一个命令行的操作截图：

![格式化终端输出

这是如何工作的？我们需要讨论一些基本的文本格式控制序列。这些控制文本的样式，包括诸如加粗文本、下划线和倒置终端打印等属性。控制序列如下：

+   **0m**：这将删除所有格式并打印普通文本。我们将使用它来重置终端文本的所有属性。它作为一个控制，限制我们希望受到其前面的任何格式影响的文本量。

+   **[1m**：这将使其后的任何文本加粗。例如，考虑以下命令行：

```
echo –e "Kali Linux  + the bash shell is so \e[1m Epic \e[0m"
```

上一个命令行将在您的终端屏幕上输出以下内容：

![格式化终端输出

+   **2m**：这将*减弱*正在打印的文本，以下是一个演示：

```
echo –e "Other operating system are so \e[2m dim \e[0m"

```

输出应如下所示：

![格式化终端输出

+   **4m**：这将给其后的任何文本加下划线。

+   **[5m**：在某些终端上，这将导致其后的文本闪烁。

+   **[7m**：这会导致其后的视频或颜色被倒置。考虑以下示例：

```
echo –e "White on black \e[7mBlack on White \e[0m"

```

上一个命令行将在您的终端屏幕上输出以下内容：

![格式化终端输出

+   **8m**：这将隐藏其后的任何文本，这意味着文本将不会被打印。

请不要忘记，这些控制序列只有在它们之前加上`\e`转义字符时才起作用。另一种写这个转义字符的方法是使用八进制格式\033，这在一些旧版本的 bash 终端上是支持的。

这些控制序列的另一个有用功能是，您可以重置给定的属性。例如，如果您在一段文本中加下划线和加粗，并且您只想删除给定文本段的下划线，您可以像以下示例中所示那样做：

```
echo –e "\e[1;4m Underlined and Emboldened \e[24m Only Emboldened \e[0m"

```

前面的命令应在您的终端上打印出以下文本：

![格式化终端输出

弄清楚这些重置转义序列的其余部分并不难；如果您希望关闭给定的格式规则，您只需要在控制数字前加上`2`，如下所示：

+   `21m` 关闭加粗

+   `[22m` 关闭变暗

+   `[25m` 关闭闪烁

等等。

我们还没有结束！您还可以使用其他控制序列来控制正在打印的文本的颜色。就像重置控制序列一样，它们通过在控制所选颜色的给定数字之前加上控制颜色种类的另一个数字来工作。它们的工作原理如下：

+   `[3xm` 只是将文本更改为数字`x`索引的颜色。数字`x`可以是以下任何一个：

+   `0` 代表黑色

+   `1` 代表红色

+   `2` 代表绿色

+   `3` 代表黄色

+   `4` 代表蓝色

+   `5` 代表品红色

+   `6` 代表青色

+   `7` 代表浅灰色

考虑以下示例：

```
echo –e "\033[31m Red Red Red \033[0m"
echo –e "\033[32m Green Green Green \033[0m"
echo –e "\033[34m Blue \033[31m Red \033[36m Cyan \033[0m"

```

您还可以将这些与其他格式选项结合使用，如下所示：

```
echo –e "\033[1;31 Bold-Red \033[21m \033[3;36m Underlined Cyan \033[0m"

```

# 提示字符串

提示字符串是标记或界定您的 bash 命令行的字符串。Kali Linux 的默认提示字符串是`root@kali:#`。这个字符串不是静态值，可以更改为您想要的任何值。本节将介绍一些非常有用的修改，您可以对提示字符串进行。我们将使它显示有关您的 Linux 系统的一些有用信息。

要控制显示为提示字符串的值，您需要修改 PS1 变量的值，如下面的屏幕截图所示：

![提示字符串

所以您可能想知道何时以及如何为您的 bash 终端设置这个值。事实证明，提示字符串是在通常在终端启动时执行的`~/.bashrc`文件中设置的。以下是提到提示字符串的`.bashrc`文件的部分：

```
if [ "$color_prompt" = yes ]; then
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\$'
else
 PS1='${debian_chroot:+($debian_chroot)}{\j}\u@[\w]\n\$'
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
 PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: [\w]\a\]\n$PS1"
    ;;
*)
    ;;
esac
```

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://%20http://www.packtpub.com)的帐户中下载您购买的所有 Packt 图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的邮箱。

在上面的代码中，我们可以看到提示字符串有三种可能的设置，以便您的终端可以适应彩色打印，尽管它需要确保实际的 shell 可以支持它。这就是为什么它首先检查`color_prompt`变量是否被肯定设置。让我们详细看一下第一个可能的`PS1`设置（如果支持彩色打印），使用以下代码：

```
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\$'
```

前面的代码工作如下：

代码的`${debian_chroot:+($debian_chroot)}`部分使用变量扩展来获取关于 shell 是否在 chroot 文件系统上执行的详细信息，并显示信息以指示这一点。现在完全理解这一点并不是完全必要的，因为在大多数情况下，您可能永远不会使用它。

`\[\033[01;32m\]` 部分，如前一节所讨论的，会导致终端打印粗体绿色文本。这里的格式与前一节讨论的示例略有不同，因为转义括号用于标记控制序列的开始和结束。正如我们在之前的示例中看到的，这些对于后来的 bash shell 版本并不是硬性要求。

`\u` 部分是另一个非常有用的转义字符。这个字符作为您的用户名或当前用户的用户名的简写。

`\h` 部分这个转义字符跟在这个例子中的`@`符号后面——`@`符号只是普通文本，没有什么特别的。当提示字符串显示时，`\h`转义字符将打印您当前的主机名。

`\[\033[00m\]` 部分如前一节所讨论的。这将重置所有格式规则，使其后的所有内容都打印为普通文本。重置格式后，我们看到 `\[\033[01;34m\]`。这将格式化所有在它之前的文本，使其以蓝色加粗显示。

`\w` 部分是当前工作目录的简写。直接在工作目录之后是一个好老的换行符，通过使用`\n`转义字符简写打印出来。接着是`\$`转义字符，如果除了 root 用户之外的任何人当前在使用 shell，它将打印出`$`符号，当 root 用户登录时打印`#`。

bash shell 提供了一些其他有用的简写，可以在您的提示字符串中使用，每个简写都会直接打印一些不同的信息到您的提示字符串中。要了解更多信息，请参阅本章*进一步阅读*部分提供的链接。

## 提示字符串自定义

现在您知道文本格式和编辑提示字符串的一般过程是如何工作的，让我们走一遍一些有用的自定义。

您应该将您的提示字符串视为应该为您提供大部分时间都会有用的一般信息。为了让您开始进行自己的提示字符串修改，我们将讨论如何在终端提示中整洁地显示一些这些信息。

我们可以添加如下信息：

+   通过使用`\w`转义字符来获取当前工作目录

+   通过使用日期命令和一些命令替换来获取当前日期时间

+   通过使用`\j`转义字符来获取后台运行的作业数量

+   通过使用`\$`转义字符来获取当前用户的特权级别

+   通过使用`\$?`转义字符来获取上一个命令的返回代码

一旦添加了这些细节，提示字符串看起来像这样：

```
PS1="\e[33m{$(date)}\e[0m\e[1;36m[\j]\e0m\e[1;32m<$?>\e[0m\e[2;36m(\u\e[0m@\e[1;34m\w)\e[0m\n\$>"
```

如果您仔细观察，您应该看到我们提到的所有转义字符都被用在提示字符串中。如果一切顺利，并且您设定提示字符串与示例完全相同，您应该在终端屏幕上看到以下代码出现：

![提示字符串自定义

在前面的屏幕截图中，我们可以看到`\$?`转义字符的作用。用户访问一个不存在的目录，返回代码设置为`1`，表示上一个命令以错误条件退出或未成功。

您可以进行许多出色的修改。这里演示的仅仅是一个例子（尽管它们本身就很有用），旨在让您开始进行自己的修改。请参阅*进一步阅读*部分，了解您可以对提示字符串进行更强大和令人眼花缭乱的修改。

# 别名

别名是一种有效地为一组命令或单个命令分配名称的方式。每个标准问题 bash shell 附带的`.bashrc`文件默认包含一些有用的别名。其中一些如下：

```
# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
```

这些别名允许您使用一个通常更简单的命令来调用一系列复杂的命令。因此，关于前面的代码，您可以使用`grep`来调用`grep --color=auto`，这样可以启用文本输出高亮或彩色打印。

别名的一般目的或目标是使事情变得更简单。例如，如果您经常需要 SSH 到特定主机，并且想要避免重复输入该主机的 IP 地址或域名，您可以将别名添加到您的`.bashrc`中，如下所示：

```
alias ssh2wserver='ssh  -v root@192.168.10.34'

```

另一个例子是，如果您使用 John The Ripper 进行密码破解，并且经常使用给定的密码和破解模式，您可以添加这些别名，以使以期望的方式调用`john`变得不那么乏味：

```
alias john-mysql='john –-format=mysql-fast '

```

否则，您也可以使用它们，例如，如果您想使用特定的单词列表：

```
alias john-winwlist='john  --wordlist=windows-commons.txt'

```

你应该立即看到依赖`alias`简化某些复杂命令的好处。

# 自定义命令历史

通常，在渗透测试期间或在使用一些非常冗长的命令行来完成任务时，您可能经常要重复使用它们或将其记住以备将来使用。确保您的终端记录有关命令的正确细节，更重要的是，记录足够多的命令是一个重要的修改。

与其他讨论的主题一样，当然有一个专门的主页用于自定义命令历史记录行为。您可以通过执行以下命令来访问此 man 页面：

```
man bash 

```

查找提到`HISTORY`变量及其相关内容的部分。

当然，与 bash 终端的大多数其他组件和功能一样，您在命令记录方面有很大的发言权。控制记录内容和方式的这些环境变量将如下所述讨论：

+   `HISTSIZE`：这控制初始化到历史记录中的命令数量。

+   `HISTFILE`：这指定应使用哪个文件来初始化命令历史记录。

+   `HISTFILEZIE`：这指定应使用多少来自`HISTFILE`的命令来初始化命令历史记录。如果`HISTFILE`比`HISTFILESIZE`行长，它将被截断。

+   `HISTCONTROL`：这确定某些关于记录哪些命令的属性，例如：

+   如果设置为`ignorespace`，它将忽略（并且不记录到历史记录中）所有以空格开头的命令，例如：

```
 HISTCONTROL=ignorepsace

```

+   如果设置为`ignoredups`，bash 将不记录与前一个命令相同调用的任何命令。

+   如果设置为`erasedups`，bash 将完全擦除整个历史记录中的任何重复命令

您还可以通过用冒号分隔它们来组合不同的选项，例如：

```
 HISTCONTROL=ignoredups:ignorespaces

```

尝试在您的`.bashrc`文件的末尾添加一些设置，以便在启动终端时自动应用。

## 保护敏感信息免于泄露

`.bash_history`文件是保存所有命令的地方。通常，它位于您的主文件夹的根目录中；对于 Kali Linux 用户，这是`/root`文件夹。关于这个文件的一个重要事项是，它很可能包含您在终端使用期间在计算机上执行的所有命令。这意味着如果您在命令行中输入了任何敏感信息，比如密码、用户名或任何重要和敏感信息，该文件都会包含它。

最好确保此信息不重复，并始终保存在与其保护相关的位置，即需要与保护信息相同数量的工作量或知识来破坏或访问的位置。例如，如果您需要保护网站的密码，未经授权的一方访问保护密码的存储应与实际用于该网站的位置一样难或更难。在信息安全行业中，如果情况不是这样，我们会说存储是不安全或不足的。

为了确保您不将任何敏感信息保存到命令行中，您可能希望将敏感信息转移到更安全的位置，并在必要时将其包含在您的 bash 环境中。执行以下步骤来完成这一点：

1.  为您的敏感环境变量创建一个文件。在这里，我们将称之为`sens_env.sh`，如下命令所示：

```
touch sens_env.sh

```

1.  将其保存在安全位置并在可能的情况下加密。尝试使用`TrueCrypt`进行此操作，并参阅*进一步阅读*部分以获取有关使用`TrueCrypt`的信息。

1.  为每个用户名、密码或安全凭据将以下命令输入到此文件中，以安全保存：

```
SITE_USERNAME=foofoo
SITE_PASSWORD=barbar

```

1.  每次您需要使用此文件中保存的信息时，您只需解密、解压缩或以任何所需的方式访问它，然后执行以下命令：

```
. sens_env.sh

```

这将执行这些命令，而不会将敏感信息暴露到您的`.bash_history`文件中。

您可以通过将信息替换为用于引用它们的变量来使用此信息，例如，如下命令所示：

```
echo "the site password is : $SITE_USERNAME"

```

这样只有执行的命令会保存在历史记录中，它不会包含实际的用户名，而是用于引用它的变量。

另一个重要的事情要记住的是，如果您需要在`.bash_history`文件中保存敏感信息，或者出于任何其他原因想要备份或复制您的`.bash_history`文件，您可以通过执行以下命令来实现：

```
history –w [FILENAME]

```

history 命令允许您发出影响历史文件的命令。在这里，我们使用`-w 开关`，告诉它将当前内容保存到由`[FILENAME]`参数指定的文件中。

关于命令历史就是这些。有关更多信息，请参阅*进一步阅读*部分。

# 自定义 Tab 补全

在键入命令并在键盘上按两次*Tab*键时，会发生 Tab 补全。显示的可能选项列表是补全建议。信不信由你，你实际上可以控制在使用 Tab 补全时显示的命令甚至参数，这取决于您正在执行的命令。能够控制您的 Tab 补全在您日常使用 bash 时可能会证明是一项非常宝贵的技能。因此，不要对此过多地唠叨，让我们来看看 Tab 补全实际是如何工作的。

当您两次按下*Tab*键时，bash shell 会执行一个特殊的预定义函数。此函数确定您正在执行的命令（如果有的话），并挂接（这只是调度的行话）另一个定义的函数，负责确定要显示为建议的选项。在本节中，我们将开发一个或两个这些函数，以使 Kali bash 命令行上的一些工具更加用户友好，并再次设计另一种方式将更有用的信息放在您的指尖。

以下是一个补全函数的示例（这是为`tcpdump`的一个示例）：

```
_tcpdump()
{
    local cur prev

    COMPREPLY=()
    cur=`_get_cword`
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -@(r|w|F))
            _filedir
            return 0
            ;;
        -i)
            _available_interfaces -a
            return 0
            ;;
    esac

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $( compgen -W '-a -d -e -f -l -n -N -O -p \
            -q -R -S -t -u -v -x -C -F -i -m -r -s -T -w -E' -- "$cur" ) )
    fi

} &&
complete -F _tcpdump tcpdump
```

在上一个示例中有几件事情需要注意。首先，定义的`_tcpdump`函数是在您在命令行中输入`tcpdump`后按两次*TAB*键时将被调用的函数。这是因为上一个示例中的最后一行：

```
complete -F _tcpdump tcpdump

```

这意味着当要确定`tcpdump`的补全建议时，将调用由`-F`选项指定的函数——`_tcpdump`。补全函数的唯一目的是使用所需的建议填充`COMPREPLY`环境变量以完成命令。当您需要建议时，`COMPREPLY`变量将被插入到命令行中。还有许多其他非常有用的环境变量，旨在帮助您编写补全函数。它们如下：

+   `COMP_LINE`，这是当前的命令行。

+   `COMP_WORDS`，这是一个包含当前出现在命令行上的单词的数组。

+   `COMP_CWORD`，这是输入到命令行中的最后一个单词的索引。使用此索引来使用`COMP_WORDS`数组计算当前单词，如下所示：

```
${COMP_WORDS[$COMP_CWORD]}

```

所以基本上，当你为给定的命令开发完成函数时，你玩的游戏是检查最后输入的单词，或者说任何输入的单词，以确定到底应该放入`COMPREPLY`数组中的内容。当然，这只是一个简单的 bash 脚本被执行，任何事情都有可能。如果你想以另一种方式确定要显示的建议，当然可以这样做。例如，你可以使用`history`命令记录给定命令的所有调用到一个特殊文件中，然后根据提供的选项建议执行`host common`命令。如果你对自然语言处理或机器学习有一些了解，这种简单功能的应用就变得无穷无尽。例如，想象一下一个 bash 终端，它学会在一天中的特定时间建议你最喜欢的命令，甚至根据你正在听的音乐或当前在你的机器上活动的网络连接。

你可能需要开发自己的完成函数的另一个重要信息是在完成时将函数放在哪里。你系统上当前安装的大多数完成函数出现在`/etc/bash_completion.d/`。然而，如果你要开发自己的完成系统扩展，你可能希望将你的脚本放在一个你控制的地方。一个常见的约定是在你的`home`文件夹的根目录下创建一个名为`.bash_completion.d/`的目录，使用以下命令：

```
mkdir ~/.bash_completion.d/

```

你自己的所有完成脚本应该出现在这个文件夹中，保存为与其完成的命令相对应的名称。例如，我们将为 John the Ripper 开发的脚本——在命令行上指定为`john`——将被称为`john`。另外，为了使你的完成函数生效，你可能希望在使用任何受影响的命令之前避免自己执行它们。因此，为了使这变得简单和自主，你应该将这个命令放在你的`.bashrc`文件中，如下所示：

```
echo ". ~/.bash_completion.d/*" >> ~/.bashrc

```

执行了上述命令后，你可能想要解压随 Kali Linux 安装的`rockyou.txt.gz`单词列表，使用以下命令行代码：

```
cd /usr/share/wordlists
gunzip rockyou.txt.gz

```

你现在可以为`john`编写一个完成函数了。以下是它应该是什么样子的

（以下代码将在本书的网站上提供）

```
_john()
{
  local cur=${COMP_WORDS[COMP_CWORD]}
  local prev=${COMP_WORDS[COMP_CWORD-1]}
  case "$prev" in
    --format)
      COMPREPLY=($( compgen -W "bsdi md5 bf afs lm dynamic_n bfegg dmd5 dominosec epi hdaa ipb2 krb4 krb5 mschapv2 netlm netlmv2 netntlm netntlmv2 nethalflm md5ns nt phps po xsha crc32 gost keychain lotus5 md4-gen mediawiki mscash mscash2 mskrb5 mssql mssql05 mysql-sha1 mysql nsldap nt2 odf office oracle11 oracle osc phpass pix-md5 pkzip racf raw-md4 raw-md5 raw-sha1 raw-sha1-linkedin raw-md5u salted-sha1 sapb sapg sha1-gen sip vnc wbb3 hmac-md5 hmac-sha1 raw-sha raw-sha224 raw-sha256 raw-sha384 raw-sha512 hmac-sha224 hmac-sha256 hmac-sha384 hmac-sha512 xsha512 hmailserver sybasease dragonfly3-64 dragonfly4-64 dragonfly3-32 dragonfly4-32 drupal7 sha256crypt sha512crypt episerver keepass pwsafe django raw-sha1-ng crypt trip ssh pdf wpapsk rar zip dummy" -- $cur))
    return 0
    ;;
    --wordlist)
      COMPREPLY=($( compgen -W "`ls /usr/share/wordlists`" --$cur))
    return 0
    ;;
  esac
  if [[ "$cur" == -* ]]; then
    COMPREPLY=($( compgen -W "-i -s -u -w --shell --user --show --format --wordlist --incremental" -- $cur))
  fi
}
complete -F _john john
```

在函数的前几行，脚本抓取当前单词和前一个单词——当前单词之前的单词——并将它们分别存储在`cur`和`prev`变量中。然后它进入一个`case`语句，这基本上是一个带有许多比较和许多独特逻辑退出点的复合 if 语句，并将单词与以下字符串进行比较：

+   `--format`：这是 John the Ripper 用来指定要破解的密码格式的选项。脚本用与当前单词`$cur`相似的所有格式填充`COMPREPLY`数组。

+   `--wordlist`：这是 John the Ripper 用来指定要使用的单词的选项。在这里，脚本简单地抓取`/usr/share/wordlists`目录中的所有文件，并将它们用作要返回的建议。

接下来是一个`if`语句，用于匹配输入到命令行的任何选项，这可能是以连字符开头的任何内容。然后它用与当前单词`$cur`相匹配的任何内容填充`COMPREPLY`数组。

请注意，这个脚本只是用于演示；它缺少`john`的其他命令行参数的完成建议。作为练习，你可以通过向`switch`语句添加一些情况来填写 John the Ripper 的其余命令行选项和可能的参数。你可以从手册页或通过执行`man john`了解更多关于 John the Ripper 的参数。

您还可以使用这个非常有用的应用程序来处理 Metasploit 命令行界面。我们将在后面的章节中介绍这一系列工具，您可能会发现为其编写一组选项完成规则非常有用。

# 总结

在本章中，我们介绍了文本输出格式化和给终端文本上色。然后我们看到了如何使用文本格式化来修改 bash 提示字符串，并讨论了一些新颖的技巧和提示，您可以使用您的`prompt`字符串来显示一些有用的信息。然后我们转向别名，并讨论了如何通过使用简单的助记符别名来简化一些复杂和繁琐的命令。最后，我们介绍了选项完成，并学习了如何修改它以满足我们的需求。我们还讨论了一个涉及 John the Ripper 密码和哈希破解工具的例子。

希望您从本章中获得了一些有用的技巧，并能够对您的终端进行急需的和有益的修改，以便在渗透测试期间有效地使用它。一个很好的练习是查看 Kali Linux 命令行上安装的一些工具，并考虑通过使用本章介绍的一两个技巧来使它们更易于使用和更高效。例如，考虑一些有用的别名、选项完成脚本和文本格式化技巧，以便与 Nmap、Wireshark、Aircrack-NG 或 Netcat 命令一起使用。

下一章将重点介绍如何使用一些 Kali Linux 工具来确保您的数据，特别是来自渗透测试和敏感信息安全相关工作的证据，始终受到保护。

# 进一步阅读

+   Linux 文档项目，选项扩展，在[`tldp.org/LDP/abs/html/tabexpansion.html`](http://tldp.org/LDP/abs/html/tabexpansion.html)上 [访问时间 2014/04/28]

+   Linux 文档项目，别名，在[`tldp.org/LDP/abs/html/aliases.html`](http://tldp.org/LDP/abs/html/aliases.html)上 [访问时间 2014/04/28]

+   Openwall – John the ripper 选项在[`www.openwall.com/john/doc/OPTIONS.shtml`](http://www.openwall.com/john/doc/OPTIONS.shtml)上 [访问时间 2014/04/28]

+   Ubuntu Man Pages，John 在[`manpages.ubuntu.com/manpages/natty/man8/john.8.html`](http://manpages.ubuntu.com/manpages/natty/man8/john.8.html)上 [访问时间 2014/04/28]

+   ArchLinux Wiki 和 Color Bash Prompt 在[`wiki.archlinux.org/index.php/Color_Bash_Prompt`](https://wiki.archlinux.org/index.php/Color_Bash_Prompt)上 [访问时间 2014/04/28]

+   Bash 历史设施在[`www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html`](http://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html)上 [访问时间 2014/04/28]

+   TrueCrypt 在[`www.truecrypt.org/`](http://www.truecrypt.org/)上 [访问时间 2014/04/28]
