# 第一章：了解 Bash

**Bourne Again SHell**（bash）可以说是存在的最重要的软件之一。没有 bash shell 的许多实用程序和它通过可编程方式集成和接口系统实用程序给予用户的问题解决潜力（称为**bash 脚本**），现代世界的许多非常重要的安全相关问题将会非常繁琐。诸如`grep`、`wget`、`vi`和`awk`等实用程序使其用户能够进行非常强大的字符串处理、数据挖掘和信息管理。多年来，全世界的系统管理员、开发人员、安全工程师和渗透测试人员都发誓其强大的问题解决潜力和使他们能够应对日常技术挑战的有效性。

为什么要讨论 bash shell？为什么它在系统管理员、渗透测试人员和开发人员中如此受欢迎？嗯，可能还有其他原因，但基本上 bash shell 是最标准化的，通常情况下，关于最流行的操作系统，它是从单一代码库实现的——官方源代码的一个来源。这意味着可以保证一定的基本执行行为集合，无论托管 bash 实现的操作系统是什么。操作系统通常具有**Korn Shell**（ksh）和其他终端仿真器软件的独特实现。

Linux 或 Unix 环境的唯一缺点（如果有的话）是，对于大多数人，特别是那些习惯于图形用户界面（GUI）的人来说，学习曲线可能会有点陡峭。这主要是因为信息呈现的方式。对于新手来说，通常很难欣赏到 Linux/Unix 文化和惯例，可能是因为缺少工具提示、提示和丰富的图形交互设计和用户体验工程 GUI 的缘故。本书特别是本章将介绍一些巧妙但精彩的 Linux/Unix 文化和惯例，以便您可以对 bash shell 感到足够舒适，并最终找到自己的方式，并在本书的后面跟随更高级的主题。

在整本书中，将讨论的 bash 环境或主机操作系统将是 Kali Linux。Kali Linux 是从 Debian 改编的发行版，它装载了专注于技术安全问题解决和测试的实用程序。因为熟练使用终端与了解您的操作系统及其各种细微差别密切相关，本章和接下来的章节将介绍一些与 Kali Linux 操作系统相关的主题，其配置设置和默认行为，以便您能够正确使用您的终端实用程序。

如果您已经是一个经验丰富的“basher”，请随意跳过本章，转而阅读本书中更加关注安全的主题。

# 从 man 页面获取帮助

Bash shell 通常捆绑了一个非常有用的实用程序，称为 man 文件，简称手册文件。这是一个实用程序，为您提供了一个标准化的格式，用于记录 Unix/Linux 环境中大多数实用程序、库甚至系统调用的目的和用法。

在接下来的章节中，我们将经常使用 man 文件中使用的惯例和描述风格，以便您可以舒适地切换到使用 man 页面来支持您在接下来的章节和章节中学到的内容。

使用 man 文件非常容易；您只需要从终端中发出以下命令：

```
man [SECTION NUMBER] [MAN PAGE NAME]

```

在上一个命令中，`[SECTION NUMBER]`是要引用的手册页部分的编号，`[MAN PAGE NAME]`是手册页的名称。通常，它是命令、系统调用或库本身的名称。例如，如果您要查找 man 命令本身的手册页，您将从终端执行以下命令：

```
man 1 man

```

在上一个命令中，`1`告诉 man 使用第 1 部分，后面跟着的`man`参数是手册页的名称，也是页面专用的命令的名称。

手册页的各个部分按照它们自己的规范编号。以下是这些数字的分配方式：

1.  常用命令：通常使用此部分查找有关命令行使用的命令的信息。在本节的前一个示例中，我们使用它来查找有关手册文件的信息。

1.  系统调用：本节记录了主机操作系统支持的常见系统调用的参数和目的。

1.  C 库函数：对于 C 开发人员和使用 C 衍生语言（如 Python）的开发人员来说，这一部分非常有用。它将为您提供有关某些基本 C 库函数调用的参数、定义头文件、行为和目的的信息。

1.  特殊文件：本节记录了特殊用途的文件，通常位于`/dev/`目录中，例如字符设备、伪终端等。尝试选择操作系统`/dev/`目录中的一些文件，并执行以下命令：

```
man 4 [FILENAME]
```

例如：

```
man 4 pts
man 4 tty 
man 4 urandom
```

1.  文件格式和约定：本节记录了用于构造有关系统信息的常见文件格式，例如日志文件格式、密码文件格式等。通常，任何文件都用于记录常见操作系统实用程序生成的信息。

1.  游戏和屏幕保护程序：本节包含有关游戏和屏幕保护程序的信息。

1.  杂项：本节包含有关杂项命令和其他信息的信息。它用于记录任何不适合其他类别的文档。

1.  系统管理命令和守护进程：本节专门介绍管理命令和系统守护进程的信息。

有关这些部分的概要和完整描述，请尝试查看每个部分的介绍手册文件。您可以通过执行以下命令来访问这些文件的每个部分编号：

```
man [SECTION NUMBER] intro

```

我在这里记录了所有手册页部分编号及其传统用途。当然，开发人员要遵守这些约定，但通常您只会对第 1 部分感兴趣，如果您要进行一些逆向工程，第 2、3 和 4 部分也将非常有帮助。

手册页布局标准化，包含一定的部分集合。手册页的每个部分描述了所讨论的命令、系统调用或库的特定属性。以下列表解释了手册文件中常见部分的目的：

+   名称：这是命令、函数、系统调用或文件格式的名称。

+   概要：这是对命令、系统调用、文件格式等的正式描述，描述了使用规范。命令的语法或使用规范的指定方式需要一些理解才能正确理解。您可能会注意到规范中的大括号，这些不应被解释为命令调用的文字部分。实际上，它们表示括号内出现的任何内容都是可选参数。此外，"|"字符表示命令调用中可以指定其前面或后面的符号，但不能同时指定；将其视为逻辑或。

+   **描述**：这是 man 页面主题的非正式描述和讨论，详细说明了其目的以及在概要部分提到的选项和可能的参数的更多信息。

+   **示例**：这是 man 页面主题用法的示例集合。

+   **另请参阅**：这是包含有关正在讨论的主题的更多信息的参考资料、网页和其他资源的集合。

有关 Linux 手册页面的更多信息，请参阅本章末尾的*进一步阅读*部分。

# 导航和搜索文件系统

导航和搜索 Linux 文件系统是开发人员、系统管理员和渗透测试人员需要掌握的最基本技能之一，以实现其 bash 控制台和实用程序的全部潜力。要正确掌握这项技能，您需要对主机操作系统的组织有很好的理解，尽管在这本书的上下文中，对 Kali Linux 操作系统的内部工作和组织进行深入讨论有点脱离了主题。

导航文件系统需要使用一系列工具和实用程序的样本集。以下是这些工具的分解：

| 命令名称 | 通用名称 | 目的 |
| --- | --- | --- |
| `cd` | 更改目录 | 更改当前工作目录 |
| `ls` | 列表 | 列出当前工作目录的内容 |
| `pwd` | 打印工作目录 | 显示当前工作目录 |
| `find` | 查找 | 根据某些属性的值定位或验证文件的存在 |

## 导航目录

导航目录通常使用`cd`命令完成，这可能是最简单的命令之一。您只需要提供要更改的目录，`cd`将完成其余工作。它还具有非常有用的快捷方式，可以加快用户在导航文件系统时执行的最常见任务。

以下是命令使用规范的样子：

```
cd [ -L | -P ] [directory]

```

在语法规范中，`[directory]`是您希望将当前工作目录更改为的目录，`[-L|-P]`可以是以下任何一个：

+   `-L`：更改目录时，不应尊重符号链接。当前目录将更改为包括符号链接的名称，而不是其目标。这在文档中被描述为使符号链接逻辑，因为它强制符号链接的名称被视为路径中的逻辑元素。

### 注意

符号链接是文件系统上的构造，允许一个文件或目录纯粹作为对另一个文件的引用。这些链接会影响路径解析的方式，因为在某些情况下，当跟随符号链接时，它将允许一个路径将当前目录指向由另一个名称表示的文件，而不是严格按照路径名解析。

+   `-P`：这是`-L`命令的相反。这指定如果要设置为当前目录的文件是符号链接，则应在设置为当前目录之前完全解析它。这意味着如果您访问符号链接，您的当前路径将不会反映您用于到达它的符号链接的名称，除非当然该链接与其目标具有相同的名称。

以下是`cd`命令的典型用法示例：

```
cd / 

```

上述命令将更改您的当前目录到根目录，即名为`/`；通常情况下，您的文件系统上托管的所有内容都可以从此目录访问。

以下是一些更多的例子：

+   `cd ~`：此命令用于导航到当前用户的主目录

+   `cd ../`：此命令用于导航到当前目录直接上面的目录

在上述命令中，可以通过提供以下命令使`cd`导航到当前目录上面的任意数量的目录，例如：

```
cd ../../../../../

```

以下是可以用于导航到不同目录的一些其他命令：

+   `cd .`：这个命令用于导航到当前目录

+   `cd –`：这个命令用于导航到上一个目录

+   `cd --`：这个命令用于导航到倒数第二个目录

要查看您是否确实将当前工作目录更改为指定的目录，可以调用`pwd`命令，该命令将打印您的工作目录。`pwd`命令的语法如下：

```
pwd [-L|-P] [--help] [--version]
pwd [--logical | --physical ] 

```

`–L`或`--logical`和`–P`或`--physical`调用选项与`cd`命令中的作用相同。

## 列出目录内容

仅仅在目录之间移动是不够的。最终，您会想要找出这些目录里面有什么。您可以使用`ls`命令来做到这一点。

以下是`ls`命令的用法规范——改编自其 man 页面：

```
ls [-aAlbBCdDfFghHiIklLmNopqQrRsStTuvwxXZ1] [FILE/DIRECTORY]

```

前一个命令规范是另一个流行的 Linux/Unix 约定。这是一种简写，指定括号中出现的任何字母都可以作为命令调用的一部分。同时可以指定任意数量。例如，考虑以下命令：

```
ls –Ham
ls –and
ls –Rotti

```

根据命令规范，它们都是使用`ls`命令的可接受方式。这些是否会真正做一些有用的事情取决于每个开关如何影响`ls`命令的行为。您应该记住，某些选项可能具有相反的效果，或者某些组合可能没有效果，例如阅读`ls`的用法规范时的一般注意事项。

`[FILE]`或`[DIRECTORY]`参数将是您希望触发`ls`的任何路径或文件。没有任何参数，`ls`将列出当前工作目录的条目。

### 注意

开关是指命令调用的一部分，即紧随连字符后面的任何选项的流行行话。例如，`-l`是一个开关。

以下是一些开关的作用——为了简洁起见，我们只讨论一些最重要的开关。请记住，`ls`命令列出目录内容，因此它的所有选项都将专注于以指定的方式组织和呈现给定目录的内容。

以下是一些`ls`命令的调用选项：

+   `-a –-all`：这会显示所有目录条目，并且不会省略以“.”开头的目录或文件。

+   `-d –directory`：这会列出目录条目而不是它们的内容。这也会强制`ls`不解引用符号链接。

+   `-h`：这会以人类可读的格式打印大小，例如，而不仅仅是字节的数量，它将显示以 GB、KB 或 MB 为单位的文件大小。

+   `-i`：这会打印每个文件的**inode**号码。

### 注意

索引节点或`i-nodes`是分配给文件的数据结构，表示有关它们的访问权限、访问时间、大小、所有者以及文件在实际块设备上的位置的详细信息——物理介质托管文件——以及其他重要的维护导向的细节。

+   `-l`：这以长格式列出条目。

+   `-R –-recursive`：这会递归列出目录内容。这告诉`ls`嵌套所有指定路径的级别，并枚举所有可达的文件路径，而不是一旦列出工作目录就停止——这是默认行为。

+   `-S`：这会按文件大小列出条目。

+   `-x`：这会按扩展名按字母顺序对条目进行排序，例如，所有 PDF 文件在 MP3 文件之后。

以下是这些选项在实际操作中的一些示例。例如，如果您想要按文件大小对一堆文件进行排序，同时显示人类可读的文件大小和所有访问权限和创建时间——这似乎是很多工作——您将运行以下命令：

```
ls –alSh

```

你的输出可能看起来像下面的截图：

![列出目录内容](img/5107OT_01_05.jpg)

另一个非常有用的例子是检查系统的登录量。这可以通过查看以下命令的输出来完成：

```
ls –alSh /var/log/auth* 

```

通常，跟踪`/var/log/`目录的内容将始终是抓取系统活动的良好概要的好方法。

## 搜索文件系统

另一个重要的技能是以一种紧凑而强大的方式在文件系统中查找资源。其中一种方法是使用名为`find`的命令。以下命令是`find`的工作方式：

```
find [-H] [-L] [-P] [-D debugopts] [-0level] [path…] [expression]

```

您可以通过查看有关`find`命令的 man 文件来了解更多信息。这可以通过执行以下命令来完成：

```
man 1 find. 

```

这在本章的*从 man 页面获取帮助*部分中已经讨论过。

接下来，前三个开关，即`-H`，`-L`和`-P`，都控制符号链接的处理方式。以下列表告诉它们的作用：

+   `-H`：这告诉`find`不要跟随符号链接。符号链接将被视为普通文件，不会将其解析为其目标。简单地说，如果目录包含符号链接，则符号链接将被视为任何其他文件。这不会影响作为选择标准一部分的符号链接；这些将被解析。

+   `-L`：这会强制`find`跟随正在处理的目录中的符号链接。

+   `-P`：这会强制`find`将符号链接视为普通文件。如果在执行过程中遇到符号链接，`find`将检查符号链接本身的属性，而不是其目标。

`-D`开关用于允许`find`在搜索所需文件时打印调试信息，如果您需要了解`find`正在进行的操作。`-0level`控制`find`如何优化测试，还允许您重新排序一些测试。`level`部分可以指定为 0 到 3 之间的任何数字（包括 0 和 3）。

参数中的`[path...]`部分用于告诉`find`在哪里查找文件。您还可以使用`.`和`..`的简写来指定当前目录和上一级目录，就像`cd`命令一样。

下一个参数，或者说一组参数，是非常重要的：`[expression]`。它包括控制以下内容的所有参数：

+   **选项**：这告诉`find`应该寻找什么类型的文件

+   **测试**：这告诉如何识别它正在寻找的文件

+   **操作**：这告诉`find`在找到文件后应该做什么

以下是`find`表达式的结构分解：

```
[expression] := [options][[test][OPERATOR][test][OPERATOR]...][actions]

[options] :=  [-d][-daystart][-depth][-follow][-help]...
[tests] := [-amin n][-atime file][-cmin n][-cnewer file]...
[OPERATOR] := [()][!][-not][-a][-and][-or]...
[actions] := [-delete][-exec command [;|{} +]][-execdir command]...
```

### 注意

先前的代码仅用作有关表达式结构的信息，以便让您知道哪些选项放在哪里。为简洁起见，每个部分的许多开关都已被省略。`:=`字符意味着左侧的任何内容都由右侧定义。

现在您知道所有内容的位置，让我们看看其中一些参数的作用。`find`命令具有许多非常强大的选项和操作模式，一个人可以完全写一本关于`find`本身的书。因此，为了确保您不会因为购买一本关于“命令行黑客”的书而只了解`find`，我们将仅讨论一些最常见的选项和参数，渗透测试人员、系统管理员和开发人员使用。`find`命令的其余功能可以从 Linux 手册文件中学习。

以下是`find`命令可能的选项、测试和操作的摘要。

### 目录遍历选项

以下是您可以与`find`一起使用的一些选项参数：

+   `-maxdepth n`：这指定测试必须仅应用于当前目录下最多*n*级的目录中的条目。如果你正在搜索具有类似结构的目录，这个选项很有用。例如，如果你正在搜索的每个目录下都有一个类似`lib`目录，其中包含不感兴趣的文件，你可以通过指定这个选项来跳过所有这样的目录。

+   `-mindepth n`：这指定测试应该仅应用于深度至少为*n*的目录低于指定路径的文件。

+   `-daystart`：这会强制任何`-amin`、`-atime`、`-cmin`、`-ctime`或等效的与时间相关的测试使用从当前日期开始的时间，而不是 24 小时前的时间，这是默认行为。

+   `-mount`：这禁止`find`进入其他文件系统。

### 注意

`find`命令允许你使用方便的简写来指示使用指定时间进行“至少”或“至多”类型的比较的数值参数：

+   `+n`：这表示指定的参数要比*n*大，或至少是*n*

+   `-n`：这表示指定的参数要比*n*小，或至多是*n*

+   `n`：这会强制 find 将`n`作为原样比较，属性必须具有精确的值`n`

### 文件测试选项

测试被应用于一个文件，要么返回`true`，要么返回`false`：要么被测试的文件具有所需的属性，要么没有。也可以提供多个测试，这种情况下将应用逻辑组合，也可以指定。默认情况下，如果没有提供布尔值来组合测试，将假定逻辑 AND。这意味着文件必须同时满足两个测试才能被*找到*或*报告*。以下是一些文件测试选项：

+   `-amin n`：这指定文件的最后访问时间应该是*n*分钟前。例如：

+   `-amin 20`：这意味着文件必须在 20 分钟前被访问过

+   `-amin +35`：这意味着文件最多在 35 分钟前被访问过

+   `-atime n`：这指定文件应该在*n*24*小时前被访问，也就是*n*天。这个数字的小数部分将被忽略。

+   `-mmin n`：这指定文件应该在*n*分钟前被修改。

+   `-mtime n`：这与`-atime`相同，只是匹配文件的修改时间。

+   `-executable | -readable | -writable`：这匹配任何具有访问权限的文件，表明文件是可执行的、可读的或可写的。

+   `-perm`：这个模式指定文件组应该是名称。`-perm`选项提供了许多不同的方式来指定正在测试的访问模式，下面是它的工作原理。

### 注意

访问模式位可以以以下任何一种为前缀：

+   `mode`：这意味着没有前缀，模式必须完全匹配。

+   `-mode`：这意味着文件的模式必须至少设置了指定的位。这将匹配具有其他位设置的文件，只要指定的位也设置了。

+   `/mode`：这意味着文件必须设置任何指定的位。

模式本身也可以用两种不同的方式来指定，一种是使用字符来表示用户类型和访问模式，另一种是使用八进制十进制模式规范。

+   `-iname nAmE`：这指定文件的名称应该与`nAmE`匹配，如果忽略大小写；换句话说，是不区分大小写的名称匹配。

+   `-regex pattern`：这将指定的模式与文件的路径名作为正则表达式进行匹配。你的正则表达式必须描述整个路径名。

### 注意

正则表达式只是描述具有指定数量共同属性的一组字符串的方式。如果你想描述一个字符串，你必须能够从头到尾详细说明字符串的所有属性。如果你没有以某种方式描述单个字符，正则表达式就不会匹配！

正则表达式本身就是一种语言，例如，您可以编写一个正则表达式来描述正则表达式！这意味着您需要知道如何使用这种语言才能正确使用正则表达式。要了解如何做到这一点，请参阅本章末尾的*进一步阅读*部分。

以下是`-regex`选项使用的一些简单示例：

+   查找所有直接位于`/etc/`目录下以字母`p`开头并以任何内容结尾的文件，使用以下命令：

```
find / -regex '^/etc/p[a-z]*$'

```

+   查找文件系统上称为配置的所有文件，忽略大小写，并使用以下命令适应缩写，如`confg`、`cnfg`和`cnfig`：

```
find / -regex '^[/a-z_]*[cC]+[Oo]*[nN]+[fF]+[iI]*[gF]+$'

```

请参阅以下屏幕截图，以了解先前命令的实际示例：

![文件测试选项](img/5107OT_01_06.jpg)

这里使用的正则表达式必须描述整个文件的路径！例如，考虑以下两个正则表达式之间的结果差异：

```
find / -regex '^[/a-z_]*/$' #matches only the / directory
find / -regex '^[/a-z_]*/*$' #matches everything reachable from the / directory!

```

### 提示

**Bash 脚本注释**

任何传递给 bash 解释器并在井号字符之前的 bash 命令或文本都被视为注释，并且不会被解释。

### 文件操作选项

以下是您可以与`find`一起使用的一些操作参数：

+   `-delete`：此操作强制`find`删除指定测试返回`true`的任何文件。例如，考虑以下命令：

```
find / -regex '^/[a-z_\-]*/[Vv][iI][rR][uS]*$' –delete

```

这个命令将查找并删除从根目录可达的任何名称为'virus'的文件——不区分大小写。

+   `-exec`：这允许您指定要在所有匹配文件上执行的任意命令。

这个论点的工作方式是构建一个命令行——这可能会传递给一些`exec*`类型的系统调用——使用`find`操作的结果。`find`命令将使用`-exec`开关后的任何参数作为要执行的命令的文字参数，并将`{}`字符的任何实例作为文件名的占位符，直到遇到`;`字符为止。

例如，考虑以下作为`-exec`参数：

```
find /etc/ -maxdepth 1 -name passwd -exec stat {} \;

```

实际的命令行将看起来像以下命令，因为唯一匹配的文件将是`/etc/passwd`：

```
stat /etc/passwd

```

请参阅以下屏幕截图，以比较`stat`和`find -exec`命令：

![文件操作选项](img/5107OT_01_07.jpg)

+   `-execdir`：这与`-exec`的工作方式相同，只是它将指定的命令的执行隔离到匹配文件的目录中。如果您想要根据具有某些文件的目录的内容执行命令，这将非常有效。例如，您可能希望编辑所有没有`.vimrc`的用户的`.bashrc`文件，这是 VIM 文本编辑器的配置脚本。我们稍后将讨论更多关于`.bashrc`代码的内容。

+   `-print0`：这将文件的完整名称打印到标准输出。此参数还具有终止文件名的 NULL 字符或`0x0`字符的附加好处，以便允许文件名包含换行符。它还有助于确保任何解释 find 输出的程序能够确定文件名之间的分隔，因为它们将严格由 NULL 字符分隔。

### 注意

NULL 字符传统上用于标记字符字符串的结尾。NULL 字符本身在内存级别表示为`0`值，以便编译器和操作系统可以清楚地识别内存中出现的字符串之间的分隔。

+   `-ls`：这通过执行`ls -dils`列出当前文件，并将输出打印到标准输出。`-dils`选项确保打印目录条目。如果匹配的文件是目录，则打印 inode，并且该条目以`ls`命令的长列表格式以及文件的大小出现。

还有一些其他操作可以指定。有关其余操作，请参阅`find`命令的手册文件，您可以使用`man find`命令访问该手册文件。

所以就搜索文件系统中的文件、目录或其他任何有趣的东西而言，基本上就是这样。您需要掌握的下一个基本技能是将一个命令的输出重定向到另一个命令。

# 使用 I/O 重定向

当涉及到 bash 脚本时，I/O 重定向是最容易掌握的事情之一。只需知道您希望将输入发送到何处以及它来自何处即可。这可能看起来是一个非常有趣的话题，您可能不明白为什么需要了解这一点，但是重定向输出——如果您真正理解了它的全部意义——将是您在命令行上几乎 80%的时间所做的事情！这本质上是唯一的事情，它允许您以一种紧凑而简单的方式在命令行上组合不同的实用程序并使它们相当有效地一起工作。例如，您可能希望通过将其输出传递给另一个文件或程序来分析来自`nmap`、`tcpdump`或键盘记录器的输出。

## 重定向输出

要将从命令行调用的一个程序的输出重定向到文件中，您只需要在该程序的命令行末尾添加一个`>`符号，然后跟上文件名即可。

例如，使用最近的示例，如果您想将`find`命令的输出重定向到名为`writeable-files.txt`的文件中，可以这样做：

```
find / -writeable > writeable-files.txt 

```

不过，关于这种 I/O 重定向有一个小细节，就像许多常见的 bash 简写一样：在幕后通常有很多事情发生。如果像之前演示的那样使用，实际上只有输出到通常称为文件描述符 0 的标准输出文件的输出才会出现在所选择的文件中（对于上一个示例，它是`writeable-files.txt`），这是正常输出的默认目的地。

### 注意

文件描述符是操作系统中的构造，表示对物理存储机制或文件的实际部分的访问。文件描述符只不过是与内核管理的表示打开文件的其他数据结构相关联的数字。每个进程都有自己的“私有”文件描述符集。

每当您使用文本编辑器打开文件或通常对存储在物理介质上的资源进行任何编辑时，表示所涉及文件的文件描述符将通过系统调用传递给内核。然后内核使用这个数字来查找关于文件的其他细节，这些细节只有内核才能访问的数据结构中。

文件描述符的主要目的是帮助抽象和逻辑上隔离有关访问存储机制的实际过程的细节。毕竟，读写文件对计算机系统来说是非常重要的操作，如果写入文件意味着需要执行旋转/停止硬盘驱动器盘、解释不同文件系统的组织以及处理读/写错误等操作，那将会非常繁琐和容易出错！

可以重定向任何文件描述符的输出，只要您从 bash shell 具有正确的访问权限！以下是执行此操作的代码：

```
[command line] a>&b > [output file]

```

在上一个命令中，`a`和`b`都是文件描述符。如果`a`或`b`没有明确设置，那么它们默认为 1，即标准输出。

那么输出到标准错误文件的输出怎么重定向呢？事实证明这也很简单，以下是执行此操作的代码：

```
[command] 2> [output file]

```

如前面的示例所示，我们指定了重定向符号`2>`，它的意思很简单：

> 将文件描述符 1 的所有内容重定向到名为`writeable-files.txt`的文件中。

您还可以组合或绑定两个标准输出文件，即如果标准错误输出中有任何有趣的内容被打印出来，可以将输入和输出的输出发送到单个文件中。使用以下命令完成：

```
[command line] 2>&1 > [output file]

```

这也有一个更简单的缩写，看起来像这样：

```
[command line] &> [output file]

```

这意味着以下内容：

> 将所有从文件描述符 1 重定向到文件描述符 0，然后将所有从文件描述符 0 重定向到`[output file]`。

前面的重定向命令都假定指定的文件不存在；如果存在，被重定向的输出将覆盖文件中当前的内容。如果您想要将文本附加到文件中，您会怎么做呢？以下命令展示了如何实现：

```
[command line] [&][n] >> [&][m] [filename.txt]

```

与以前一样，`&`、`n`和`m`标记都是可选参数，与以前的示例完全相同。

## 重定向输入

如果您可以重定向输出，那么您也应该能够使用以下命令重定向输入：

```
[command line] < [input file | command line]

```

这实际上非常简单：如果`>`表示重定向输出，那么`<`表示重定向右操作数的“输出”，从左操作数的角度来看，这是输入。

与输出重定向一样，您还可以使用以下命令控制要包括在重定向中的文件描述符：

```
[command line] <[n] [input file | command line]

```

在前面的命令中，`[n]`是文件描述符号码，与输出重定向一样。以下是您可以在终端控制台上测试的一些示例：

+   `keylogs.txt < /dev/`tty``

前面的命令将所有写入终端的输入重定向到名为`keylogs.txt`的文件中。它通过使用`tty`命令获取与终端控制台关联的当前`tty`设备来实现这一点。

+   `wc -l < /etc/passwd`

前面的命令将输入重定向到包含所有用户名和其他用户账户相关详细信息的`/etc/passwd`文件，以便使用`wc`命令来计算行数、文件大小和其他文件属性。使用`-l`开关会导致`wc`命令计算所有行，或者更具体地说，直到达到文件结束（`EOF`）标记为止，遇到的所有换行符。

# 使用管道

在本节中我们讨论的所有内容都是将输出命令重定向到另一个文件；那么将一个命令的输出重定向到另一个命令呢？下一节正是为此而设。

### 注意

管道是进程间通信机制，允许进程在允许一个进程的输出被传送到另一个进程作为输入的操作系统中相互通信的机制。换句话说，您可以将一个程序的标准输出转换为另一个程序的标准输入。

实际上，许多管道的工作方式都是通过复制文件描述符 0 来为一个进程工作，并允许另一个进程向其写入。

以下命令显示了如何在 bash 中使用管道：

```
[command line] | [another command line]

```

请注意，这次`|`字符，如果以这种方式使用，被称为管道，实际上是命令调用的实际部分。当然，`[command line]`将是您想要调用的命令。管道将把第一个命令行的输出作为第二个命令行参数的输入。您实际上可以指定尽可能多的管道，看起来会像以下语法：

```
[command] | [command] | [command] | ... | [command]

```

以下是一些示例：

+   `cat /etc/passwd | wc -l`

+   这相当于以下内容：

```
 wc –l < /etc/passwd

```

+   以下截图显示了上一个命令的输出：

![使用管道](img/5107OT_01_08.jpg)

+   使用以下命令计算操作系统的`root`目录中的文件数：

```
ls –al / | wc –l

```

+   使用以下命令列出所有可用的用户名：

```
cat /etc/passwd | awk –F: '{print $1}'

```

以下截图显示了上一个命令的输出：

![使用管道](img/5107OT_01_09.jpg)

+   使用以下命令列出`nmap`扫描的所有开放服务：

```
nmap –v scanme.nmap.org | grep –e '^[0-9]*/(udp|tcp)[\ ]*open'

```

# 了解 grep

**全局正则表达式打印**（**grep**）实用程序是所有命令行专家的基本工具。`grep` 实用程序在其最基本的功能中使用户能够在给定的输入文件或流上运行正则表达式，并打印匹配的结果。`grep` 的更高级功能允许您指定您想要打印的匹配文本的哪些属性，是否要对输出进行着色，甚至您应该打印匹配输出周围的多少行。它充满了许多非常有用的功能，一旦掌握，它们将成为任何渗透测试人员、开发人员或系统管理员工具箱的重要组成部分。

### 提示

要正确使用 `grep`，您至少需要基本的理解和实践正则表达式。正则表达式不会在这里完全涵盖，但会涵盖简单的示例和正则表达式语言的基本元素。有关正则表达式及其工作原理的更广泛阅读，请参阅本章末尾的 *进一步阅读* 部分。

## 正则表达式语言 - 速成课程

正则表达式只是描述使用特殊语言的字符串的集合 - 在形式语言理论术语中，任何字符串的集合或集合被称为语言。能够运用这种语言是一项无价的技能。它将帮助您从静态代码源分析、逆向工程、恶意软件指纹识别和更大的漏洞评估以及利用开发等许多方面。

`grep` 支持的正则表达式语言充满了有用的简写，以简化一组常见字符串的描述，例如，描述由任何十进制数、任何小写或大写字母字符或甚至任何可打印字符组成的字符串。因此，鉴于任何字符串或字符串集合必须由一组较小的字符串组成，如果您知道如何匹配或描述任何字母字符或任何十进制数，您应该能够描述由这些字符类中的字符组成的任何内容。字符类只是由特定字符集合中的长度为 1 的字符串组成的语言。

首先，我们需要定义一些 "控制" 字符。鉴于您将使用其他字符串描述字符串，需要一种方法来指定正则表达式中给定字符或子字符串的特殊含义。否则，您只能逐个字符地比较一个字符串与另一个字符串。您可以这样做：

+   `^`: 以下正则表达式必须在行的开头匹配，例如，`^this is the start of the line`。

+   `$`: 前面的正则表达式必须在行的末尾匹配，例如，`this is the end of the line$`。

+   `[]`: 字符类的描述，或者字符列表，包含在方括号中，匹配的字符串包含指定列表中的字符。某些字符类可以使用简写来描述。我们将在本章的其余部分中看到其中一些。

+   `()`: 这将正则表达式逻辑分组在一起。

+   |: 这是两个正则表达式的逻辑或，例如，`([expression]) | ([expression])`。

+   `?`: 这匹配前面的正则表达式至少一次。例如，`keith?` 将匹配包含 "keith" 或根本不包含的任何字符串。

+   `+`: 这匹配前面的正则表达式至少一次。

+   `{n}`: 这匹配前面的正则表达式恰好 *n* 次。

+   `{n,m}`: 这匹配前面的正则表达式至少 *n* 次，最多 `m` 次。例如 `[0-9]{0,10}` 将匹配包含 0 到 10 位数字的任何十进制数。

以下是 `grep` 支持的一些简写的小集合，作为扩展的正则表达式语言：

+   `[:alnum:]`: 这匹配字母数字字符，任何十进制数字，或字母字符

+   `[:alpha:]`: 这严格匹配字母字符 a-z

+   `[:digit:]`: 这严格匹配十进制数字 0-9

+   `[:punt:]`: 任何标点符号都将被匹配

还有许多其他字符类速记可用；有关更多信息，请参阅`grep`的 man 页面。

正则表达式只是这些控制字符和字符类的集合。例如，只要所有的括号、大括号和括号都是平衡的，您可以以任何您喜欢的方式组合它们。

现在您对正则表达式有了一些基本背景，让我们看一下`grep`实用程序的使用规范，使用以下命令：

```
grep [options] PATTERN [file list]
[options] := [matcher selection][matching control][output control][file selection][other]
PATTERN := a pattern used to match with content in the file list.
[matcher selection] := [-E|--extended-regexp][-F|--fixed-strings]...
[matching control] := [-e|--regexp][-f|--file][-i|--ignore-case]... 
[output control] := [-c][--count][-L|--files-without-match]...
[file selection] := [-a | --text][--binary-files=TYPE][--exclude]...
[file list] := [file name] [file name] ... [file name]

```

请记住，这只是对命令结构的简单总结，并未提及所有可能的选项。有关`grep`实用程序的正则表达式语法的更多信息，请参阅本章末尾的*进一步阅读*部分，以及 Perl 正则表达式的 man 页面，可以通过执行命令`man 3 pcresyntax`来查看。您还可以通过查看 POSIX.2 正则表达式的 man 页面来了解更多关于正则表达式的信息，Kali Linux 可能没有前面命令中提到的 man 页面。您可以使用命令`man 7 regex`获取正则表达式手册页。

在此规范的基础上，让我们详细了解一些选项。

## 正则表达式匹配选择选项

调用`grep`的一部分需要让`grep`知道您想要使用什么方法来将模式与文件内容进行匹配。这是因为`grep`不仅能够运行正则表达式。

以下是匹配选择的选项：

+   `-E`或`--extended-regexp`: 这将解释`PATTERN`参数作为扩展的正则表达式

### 注意

扩展的正则表达式语言几乎是今天每个人都在使用的，但这并不总是这样。在 Unix 的鼎盛时期，正则表达式是使用一种称为**POSIX**（**可移植操作系统接口**）基本正则表达式语言表示的。几年后，Unix 开发人员为正则表达式语言添加了一些功能，并创建了一种新的标准来表示这种新的、更简短的语言，称为**扩展正则表达式**（**ERE**）语言标准。

+   `-F 或--fixed-strings`: 这告诉`grep`将`PATTERN`解释为由换行符分隔的固定字符串列表，以便在给定文件列表中查找

例如，以下屏幕截图显示了此命令的输出：

![正则表达式匹配选择选项](img/5107OT_01_10.jpg)

+   -`P`或`--perl-regexp`: 这允许`grep`将`PATTERN`解释为 Perl 正则表达式

## 正则表达式匹配控制选项

以下选项允许您控制数据匹配的处理方式，无论您想要匹配输入中的整个单词、整行或从给定文件中引入多个模式。

以下是匹配控制的选项：

+   `-e PATTERN`或`--regexp=PATTERN`: 这将强制使用此处提供的`PATTERN`参数作为匹配输入文件的`PATTERN`。

以下命令是前述选项的用法示例：

```
cat /etc/passwd | grep –e '^root' 

```

前面的示例匹配以单词`root`开头的行。

+   `-f`或`--file=FILE`: 这从提供的文件中获取要使用的模式列表。

例如，考虑一个包含以下文本的文件：

```
^root
^www
^nobody
```

此文件可以与`-f`选项一起使用，如下所示：

```
grep –f patterns.txt < /etc/passwd

```

+   `-v`或`--invert-match`: 这反转匹配，意味着只选择或报告不匹配的文件内容。

+   `-w`或`--word-regexp`: 报告输入文件中具有完全匹配单词的行。

例如，查看以下命令的输出：

```
root@kali:~# grep r –w < /etc/passwd

root@kali:~# grep ro –w < /etc/passwd

root@kali:~# grep root –w < /etc/passwd
root:x:0:0:root:/root:/bin/bash

```

正如您从前面的输出和您自己的一些测试中看到的，前两次运行没有描述`/etc/passwd`文件内容的完整单词。然而，最后一次运行做到了；所以它是唯一实际产生输出的运行。

+   `-x`或`–-line-regexp`：这会报告或打印输入文件中整行匹配的行。

## 输出控制选项

`grep`实用程序还允许您控制其报告有关成功匹配的信息的方式。您还可以指定要报告的匹配的属性。

以下是一些输出控制选项：

+   `-c`或`–-count`：这不会报告匹配的数据，而是打印匹配的次数。

+   `-L`或`–-files-without-match`：这只会打印不包含匹配的文件名。

+   `-l`或`–-files-with-matches`：这只会打印包含匹配的文件名。

+   `-m`或`–max-count=NUM`：这会在`NUM`次匹配后停止处理输入。如果输入来自标准输入或使用输入重定向，则在读取`NUM`行后处理将停止。

+   `-o`或`–only-matching`：这会打印输入数据的匹配部分，每个部分占一行。

## 文件选择选项

以下选项允许您指定输入文件的来源，并控制整体输入数据的一些属性。

文件选择的选项如下：

+   `-a`或`–-text`：这会强制处理二进制文件作为文本。这使您可以像使用 strings 实用程序一样操作`grep`，它返回给定文件中的所有可打印字符串，并且能够使用正则表达式匹配这些字符串。

例如：

```
grep 'printf' –m 1 –color –text `which echo`

```

### 注意

**which 命令**

`which`命令会打印所提供参数的规范文件路径。在这里，它出现在反引号中，这样 bash shell 将用它产生的值替换这个命令，这实际上意味着`grep`将通过`echo`命令的二进制文件运行。

上一条命令的输出如下截图所示：

![文件选择选项](img/5107OT_01_11.jpg)

+   `--binary-files=TYPE`：这会检查输入的文件是否是二进制文件。如果是，它会将文件视为指定的`TYPE`。

+   `-D ACTION`或`–-devices=ACTION`：这会将输入文件处理为设备，并使用`ACTION`参数从中提取输入。默认情况下，`ACTION`是读取。

+   `--exclude=GLOB`：这会跳过与 GLOB 匹配的任何文件；通配符在匹配中受到尊重。

+   `-R`，`–r`或`–-recursive`：这会处理当前目录中嵌套目录中的所有可达文件条目。

这基本上就是`grep`的全部内容了。希望您能够利用这些选项找到您要找的内容。这需要一些练习和适应，但一旦掌握，`grep`就是一个非常有价值的实用程序。

# 摘要

在本章中，我们了解了 bash shell 的一些基础知识。我们介绍了 man 页面，这是一个非常重要的资源，适用于经验丰富的系统管理员和内核开发人员，也适用于新手渗透测试人员和安全工程师。我们还使用了强大而高效的方法，通过非常描述性的属性和正则表达式来查找特定文件。我们介绍了另一个非常重要的工具叫做`grep`，它允许我们有效地使用正则表达式来查找文件的内容，并以细节的方式定位它们。

下一章将重点介绍如何自定义您的 bash 终端，并启用强大的功能，使使用终端更加丰富和便利。

# 进一步阅读

作者在 2014 年 4 月 22 日访问了以下参考资料：

+   Linux 手册页面[`www.tldp.org/manpages/man.html`](http://www.tldp.org/manpages/man.html)

+   Linux man 页面在线[`man7.org/linux/man-pages/index.html`](http://man7.org/linux/man-pages/index.html)

+   15 个实用的 grep 命令示例在[`www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/`](http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/)

+   使用 grep 的示例在[`tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html`](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html)

+   正则表达式在[`tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html`](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html)

+   Linux 程序员手册，Man 1 介绍在[`www.man7.org/linux/man-pages/man1/intro.1.html`](http://www.man7.org/linux/man-pages/man1/intro.1.html)

+   Linux 程序员手册，Man 2 介绍在[`www.man7.org/linux/man-pages/man1/intro.2.html`](http://www.man7.org/linux/man-pages/man1/intro.2.html)
