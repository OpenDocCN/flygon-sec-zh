# 第五章：网络利用和监控

在上一章中，我们学习了基于主机和应用程序的利用，以及如何使用 Metasploit Framework 命令行界面和其他命令行和 shell 环境驱动的实用程序来逆向工程应用程序，并根据 Nmap 输出自主启动工具。接下来的章节将重点介绍 Kali Linux 中可用的网络利用以及如何在现代 bash shell 环境中利用它。

首先，我们将讨论 MAC 地址欺骗和（ARP）地址解析协议滥用，这是常见的困扰现成网络解决方案的问题，在大多数情况下，如果不加以检查，可能会产生非常大的影响。

# MAC 和 ARP 滥用

（MAC）媒体访问控制地址是分配给本地网络设备的地址。这些地址由第 2 层协议用于定位物理设备，如路由器、笔记本电脑、DNS 服务器和其他在逻辑网络上相邻的设备。从本质上讲，除非实施其他控制，否则没有什么可以阻止一个设备通过使用另一个设备的 MAC 地址来伪造其数据包的来源。这被称为 MAC 地址欺骗攻击。通常，如果目标网络上的某些资源是通过 MAC 地址控制的，那么您可能希望伪造或欺骗您的 MAC 地址，特别是如果给定资源的保护使用 MAC 地址作为身份验证凭据或识别材料。这个想法本质上是有缺陷的，纯粹是因为如果您试图保护一些秘密的东西，您不能这样做而不依赖于一些秘密的东西。这是对密码学和信息理论的一个古老原则的一种解释方式。因为 MAC 地址在许多常见情况下应该在网络上广播，由于一些基本协议的运行，比如 ARP，因此网络上的每个人都可以访问其他人的 MAC 地址。

MAC 地址欺骗（尽管可能是最简单的网络攻击；您实际上只是在数据包中更改 MAC 地址字段）对许多利用技术也非常基本。基本上，几乎所有的黑客行为都是在滥用信任；当有很多信任集中在数据包中如 MAC 地址这样容易受攻击的地方时，您可以通过滥用这种情况实现很多事情。

## 欺骗 MAC 地址

如前所述，欺骗您的 MAC 地址相对容易，但它也是许多利用技术的基本要素；无论是 ARP 欺骗、端口窃取还是路由篡改，所有这些精彩的技巧都严重依赖于源 MAC 地址。

要使用 Kali Linux 更改 MAC 地址，您可以使用一个名为`macchanger`的工具，并使用以下命令：

```
macchanger [-hVeaArls] [-m,--mac,--mac= MAC_ADDRESS] INTERFACE

```

基本上，`MAC_ADDRESS`将是您想要将当前 MAC 地址更改为的 MAC 地址，`INTERFACE`是应该对应于这个新 MAC 地址的接口。出于简洁起见，这里不讨论其他选项；建议您查看 man 文件以获取更多详细信息。

以下是`macchanger`的示例：

```
ifconfig down eth0
macchanger –-mac=01:02:03:04:05:06 eth0
ifconfig up eth0

```

前面的命令产生以下输出：

![欺骗 MAC 地址](img/5107OT_05_01.jpg)

对于随机 MAC，您可以使用以下命令：

```
macchanger –r eth0

```

在前面的屏幕截图中，您将看到为主机配置的 MAC 地址已更改为 macchanger 指定的 MAC 地址。此外，您可能需要确保您重新配置新 MAC 地址的接口没有在使用中，就像我们在前面的屏幕截图中所做的那样。这就是`ifconfig`命令的目的。

## 滥用地址解析

地址解析协议作为一种服务存在，它将 IP 地址转换为 MAC 地址。主机发出 ARP 请求以获取与给定 IP 地址关联的 MAC 地址的信息。主机将在整个本地网络段广播一条消息，希望从与请求的 IP 地址关联的主机接收响应。地址解析协议的根本缺陷在于，它本质上缺乏任何形式的身份验证和消息完整性。这意味着，当接收到 MAC 地址查找的响应时，接收主机无法确定其来源，并且只能盲目地假定它来自正确的主机。对于攻击者来说，这意味着您可以通过伪造 ARP 请求的响应来说服设备将实际上是为另一个用户而不是自己的数据包转发给您。

Kali Linux 有一个工具可以帮助促进 ARP 滥用；它被称为 ArpSpoof，以下是其使用规范：

```
arpspoof [-ictr] [GATEWAY]

```

+   `-i`：这指定了发送 ARP 回复的接口。您可以使用`ifconfig`命令找出哪个网络接口配置了地址并与网络关联。

+   `-c`：这指定了在将 ARP 解析恢复为其原始形式时要使用的 MAC 地址。

+   `-t`：此选项指定目标主机，即您想要毒害的主机。

+   `-r`：这告诉`arpspoof`毒害两个主机；这意味着不仅向目标发送 ARP 回复，而且在您回复时也向您冒充的主机发送 ARP 回复。这样做的效果是，涉及的两个主机的 ARP 表都会反映出您是其中一个主机；`TARGET`将相信您是`GATEWAY`，反之亦然。

+   `GATEWAY`：这是您在发送伪造 ARP 回复时想要冒充的主机的 IP 地址。

这里有一个例子：假设我们想说服地址为`192.168.10.107`的主机，我们是地址为`192.168.10.1`的主机，这是我们目标主机的默认网关。在这种情况下，您将向 ArpSpoof 发出的命令如下：

```
arpspoof –t 192.168.10.107 192.168.10.1 

```

上述命令将产生以下输出：

![滥用地址解析](img/5107OT_05_02.jpg)

上述屏幕截图显示了攻击者的 MAC 地址以粗体显示。在这里，它被配置为`08:00:27:29:d2:29`。如果 ARP 欺骗攻击在我们的示例中起作用，此地址将与目标主机上的`192.168.10.1` IP 关联，如下图所示：

![滥用地址解析](img/5107OT_05_03.jpg)

# 中间人攻击

利用本章 ARP 滥用子部分中学到的知识，我们实际上可以执行更复杂的**中间人**（**MITM**）风格的攻击，建立在滥用地址解析和主机识别方案的能力之上。本节将重点介绍您可以使用的方法。

MITM 攻击旨在愚弄给定网络上的两个实体，使它们通过未经授权的第三方代理进行通信，或允许第三方访问正在两个实体之间传输的信息。例如，当受害者连接到本地网络或远程网络上的服务时，中间人攻击将使您作为攻击者能够窃听或甚至增强受害者与其服务之间的通信。通过服务，我们可能指的是 Web（HTTP）、FTP、RDP 服务，或者今天使用的许多服务中的任何一种，它们都没有固有的手段来抵御 MITM 攻击！

## Ettercap DNS 欺骗

Ettercap 是一个工具，它提供了一个简单的命令行和图形界面，用于执行各种技术的 MITM 攻击。在本节中，我们将重点关注 ARP 欺骗攻击的应用，即 DNS 欺骗。

您可以通过执行以下步骤使用 ettercap 设置 DNS 欺骗攻击：

1.  在我们启动 ettercap 之前，我们需要修改保存我们即将欺骗的 DNS 服务器的 DNS 记录的文件。这个文件位于`/usr/share/ettercap/etter.dns`下。您需要做的是添加 DNS 名称和 IP 地址，或者通过用您自己的 IP 替换文件中当前的所有 IP 来修改文件中的 IP。如果您想要充当拦截主机的话。

1.  现在我们的 DNS 服务器记录已经设置好，我们可以调用 ettercap。调用 ettercap 非常简单；以下是用法规范：

```
ettercap [OPTIONS] [TARGET1] [TARGET2]

```

1.  要使用 ettercap 执行 MITM 攻击，您需要提供`-M`开关，并传递一个指示您想要使用的 MITM 方法的参数。此外，您还需要指定您想要使用 DNS 欺骗插件。以下是调用的样子：

```
ettercap –M arp:remote –P dns_spoof [TARGET1] [TARGET2]

```

其中`TARGET1`和`TARGET2`是您想要拦截的主机和默认网关或 DNS 服务器，可以互换使用。

1.  要针对地址为`192.168.10.106`的主机，使用默认网关为`192.168.10.1`，您将调用以下命令：

```
ettercap –M arp:remote –P dns_spoof /192.168.10.107/ /192.168.10.1/

```

一旦启动，ettercap 将开始毒化指定主机的 ARP 表，并监听任何对其配置为解析的域的 DNS 请求。

# 询问服务器

任何网络设备要参与通信，都需要访问某些信息，没有设备能够查找域名或找到 IP 地址，而不需要负责某些信息的设备的参与。在本节中，我们将详细介绍一些技术，您可以使用这些技术来询问关于目标网络和其中的主机的敏感信息的常见网络组件。

## SNMP 询问

**简单网络管理协议**（**SNMP**）被路由器和其他网络组件使用，以支持远程监视诸如带宽、CPU/内存使用情况、硬盘空间使用情况、已登录用户、运行进程等一系列非常敏感的信息。自然地，任何在目标网络上暴露了 SNMP 服务的渗透测试人员都需要知道如何从中传播任何潜在有用的信息。本章讨论了一些工具，您可以使用这些工具来做到这一点。

### 注意

**关于 SNMP 安全**

版本 3 之前的 SNMP 服务并不考虑安全性。对这些服务的身份验证通常以一串简单的字符形式出现，称为社区字符串。SNMP 版本 1 和 2 固有的另一个常见实现缺陷是能够对通信进行暴力破解和窃听。

要使用 Kali Linux 工具枚举 SNMP 服务器的信息，您可以采用多种技术。最明显的方法将是使用`snmpwalk`，您可以通过以下命令使用它：

```
snmpwalk –v [1 | 2c | 3 ] –c [community string] [target host]

```

例如，假设我们以`public`作为社区字符串，针对`192.168.10.103`进行目标定位，这是一个常见的社区字符串设置；然后，您将调用以下命令从 SNMP 服务中获取信息：

```
snmpwalk –v 1 –c public 192.168.10.103

```

在这里，我们选择使用 SNMP 版本 1，因此在前面的命令调用中使用了`-v 1`。输出将看起来像以下的屏幕截图：

![SNMP 询问](img/5107OT_05_04.jpg)

正如您所看到的，这实际上提取了有关目标主机的一些非常详细的信息。这是否是一个关键的漏洞将取决于暴露了哪种类型的信息。

在 Microsoft Windows 机器和一些流行的路由器操作系统上，SNMP 服务可能会暴露用户凭据，甚至允许远程攻击者恶意增加它们，如果他们对 SNMP 数据库具有写访问权限。成功利用 SNMP 通常严重依赖于实施服务的设备。您可以想象，对于路由器，您的目标可能是路由表或设备上的用户帐户。对于其他主机类型，攻击面可能会有所不同。尝试评估与其主机以及可能托管在其上的更广泛网络相关的基于 SNMP 的缺陷和信息泄漏的风险。不要忘记，SNMP 的全部内容都是关于共享信息，其他网络上的主机可能会信任这些信息。考虑可访问的信息类型以及如果您有能力影响它，您将能够做些什么。如果您可以攻击主机，请攻击信任它的主机。

另一个收集来自 SNMP 服务的信息的工具集是 Metasploit Framework 中可用的`snmp_enum`、`snmp_login`和类似脚本。`snmp_enum`脚本基本上与`snmpwalk`做的事情一样，只是它以更友好的格式结构化提取的信息。这使得它更容易理解。以下是一个示例：

```
msfcli auxiliary/scanner/snmp/snmp_enum [OPTIONS] [MODE]

```

该模块可用的选项显示在以下屏幕截图中：

![SNMP 询问](img/5107OT_05_05.jpg)

以下是针对我们正在运行的示例主机的示例调用：

```
msfcli auxiliary/scanner/snmp/snmp_enum RHOSTS=192.168.10.103

```

上述命令产生以下输出：

![SNMP 询问](img/5107OT_05_06.jpg)

您会注意到我们在调用中没有指定社区字符串。这是因为该模块假定默认为`public`。您可以使用`COMMUNITY`参数指定不同的社区字符串。

在其他情况下，您可能并不总是那么幸运，能够预先知道正在使用的社区字符串。然而，幸运的是，SNMP 版本 1、2、2*c*和 3*c*并没有固有的防范暴力攻击的保护措施，也没有使用任何形式的基于网络的加密。对于 SNMP 版本 1 和 2*c*，您可以使用一个巧妙的 Metasploit 模块，称为`snmp-login`，它将运行一个可能的社区字符串列表，并确定列举的字符串给您带来的访问级别。您可以通过运行以下命令来使用它：

```
msfcli auxiliary/scanner/snmp/snmp_login RHOSTS=192.168.10.103 

```

上述命令产生以下输出：

![SNMP 询问](img/5107OT_05_07.jpg)

如前面的屏幕截图所示，一旦运行完成，它将列出列举的字符串以及授予的访问级别。

`snmp_login`模块默认使用一个可能的字符串的静态列表进行枚举，但您也可以在 Kali Linux 中的一些密码列表上运行此模块，如下所示：

```
msfcli auxiliary/scanner/snmp/snmp_login PASS_FILE=/usr/share/wordlists/rockyou.txt RHOSTS=192.168.10.103 

```

这将使用`rockyou.txt`单词列表来查找要猜测的字符串。

由于所有这些 Metasploit 模块都是基于命令行的，您当然可以将它们组合在一起。例如，如果您想要对主机进行 SNMP 社区字符串的暴力破解，然后对找到的字符串运行枚举模块，您可以通过编写一个 bash 脚本来实现，如下例所示：

```
#!/bin/bash
if [ $# != 1 ]
then
 echo "USAGE: . snmp [HOST]"
 exit 1
fi
TARGET=$1
echo "[*] Running SNMP enumeration on '$TARGET'"
for comm_string in \
`msfcli auxiliary/scanner/snmp/snmp_login RHOSTS=$TARGET E 2> /dev/null\
 | awk -F\' '/access with community/ { print $2 }'`; 
do 
 echo "[*] found community string '$comm_string' ...running enumeration"; 
 msfcli auxiliary/scanner/snmp/snmp_enum RHOSTS=$TARGET COMMUNITY=$comm_string E 2> /dev/null;
done

```

以下命令向您展示如何使用它：

```
. snmp.sh [TAGRET]

```

在我们正在运行的示例中，它的使用如下：

```
. snmp.sh 192.168.10.103

```

除了猜测或暴力破解 SNMP 社区字符串，您还可以使用 TCPDump 来过滤出可能包含未加密 SNMP 认证信息的数据包。以下是一个有用的示例：

```
tcpdump udp port 161 –i eth0 –vvv –A

```

这些参数的具体内容将在后面的部分中介绍。上述命令将产生以下输出：

![SNMP 询问](img/5107OT_05_08.jpg)

不要过多地详细了解 SNMP 数据包结构，通过查看捕获的可打印字符串，通常很容易看到社区字符串。有关 SNMP 数据包工作原理的更多信息，建议您查看“进一步阅读”部分中的链接。您可能还希望考虑使用诸如 Scapy 等工具构建更全面的数据包捕获工具，这些工具在 Kali Linux 版本中可用。

有关 SNMP 枚举的更多信息，请参阅“进一步阅读”部分中的链接。

## SMTP 服务器询问

SMTP 服务器用于转发电子邮件，它们使用简单的基于文本的协议。由于这些机器存在于定义了用户帐户的操作系统上，并且由于其中一些配置为处理伪造的电子邮件接收者的方式，您通常可以滥用电子邮件地址验证或查找工作的方式来枚举主机操作系统上的用户帐户列表。Kali 有一个名为 `smtp-user-enum` 的出色命令行工具来执行此操作。它的工作原理如下：

```
smtp-user-enum [-hvd] [-M EXPN | VRFY | RCPT] [-u username | -U USER_FILE ] [-t host | -T HOST_FILE] [-p PORT] 

```

前一个命令行的组件解释如下：

+   -M：这是枚举方法。这是用于确定用户是否实际存在于目标服务器上的命令。

+   -u：用于指定要检查的单个用户名。

+   -U：用于指定要检查的用户名列表。

+   -t：用于指定要针对枚举攻击的单个主机。

+   -T：这允许您指定 `HOST_FILE`，这是一个要针对攻击的主机列表。

+   -h：指定输出的 `help` 文件。

+   –v：指定输出的详细程度。

要有效使用 `smtp-user-enum`，您需要一个相当全面的用户名列表。网上有很多这样的列表；对于我们的目的，我们将简单地获取 `/etc/passwd`，通过 `awk` 进行处理，并使用主机系统上的用户列表进行猜测。这也是一种识别类似于您自己的操作系统的好方法。通过执行以下步骤完成：

1.  按以下方式剥离用户名：

```
cat /etc/passwd | awk –F\: '{ print $1}' > users_list.txt

```

1.  针对 `smtp` 服务器进行枚举攻击：

```
smtp-user-enum –t [HOST] –U ./users_list.txt 

```

然后，`smtp-user-enum` 将使用 `VRFY` 命令来确定用户是否存在于目标上。您还可以按以下方式指定其他枚举方法：

```
smtp-user-enum –t [HOST] –U ./users_list.txt –M EXPN
smtp-user-enum –t [HOST] –U ./users_list.txt –M RCPT

```

就 SMTP 枚举而言，大概就是这样；从现在开始，您应该记录您枚举的用户名，并在下次运行 SMTP 用户名枚举攻击时重放它们。

# 暴力破解身份验证

在渗透测试中，许多成功或失败取决于您猜测密码的能力。这可能会让您感到惊讶，但网络工程师和开发人员有时确实会做对，您需要依赖用户的可预测性来找到您的方式“进入”。Kali Linux 提供了一系列新的、复杂的、老的和值得信赖的身份验证破解工具，当您需要快速猜测密码时，这些工具通常会是您的首选。

## 使用 Medusa

Medusa 是 Kali Linux 中可用的更好的多用途破解工具之一。它支持许多不同的身份验证模式，并且还允许您定义自己的插件，以防遇到它本身不支持的任何内容。

您可以通过以下命令调用 medusa：

```
medusa [-h host | -H file] [-u username | -U file ] [-p password | -P file] [-C file ] –M MODULE [OPTIONS]

```

Medusa 支持许多模块。您可以通过执行以下命令来查找您的版本支持哪些模块：

```
medusa –d

```

上一个命令将生成支持的模块列表。如果您想使用其中一个，可以使用 `–M` 开关指定模块的名称，就像前面的用法规范一样。以下是一个示例，针对 `192.168.10.105` 上的 SSH 服务：

```
medusa –h 192.168.10.105 –u k3170makan –P /usr/share/wordlists/rockyou.txt –M ssh

```

上一个命令将产生以下输出：

![使用 Medusa](img/5107OT_05_09.jpg)

同样，您可以针对其他服务，如以下命令所示：

```
medusa –h 192.168.10.105 –u k3170makan –P /usr/share/wordlists/rockyou.txt –M ftp

medusa –h 192.168.10.105 –u k3170makan –P /usr/share/wordlists/rockyou.txt –M http

medusa –h 192.168.10.105 –u k3170makan –P /usr/share/wordlists/rockyou.txt –M web-form

```

Medusa 还允许你为暴力破解开发自己的模块，并提供了一些非常有用的方法来指定密码和用户名列表。有关 Medusa 的其他选项，请参考*进一步阅读*部分。

# 使用 TCPDump 进行流量过滤

TCPDump 是迄今为止最广泛使用的网络流量检查工具之一。它支持许多丰富的信息驱动功能，就像本书中讨论的其他工具一样，它提供了一个纯命令行驱动的界面。TCPDump 允许你过滤网络流量以获取有用的信息。在这里，我们将介绍一些基本用法。稍后，我们将继续讨论如何使用 TCPDump 来检查你感兴趣的流量，所有这些都将直接来自你可靠的 bash shell。

## 开始使用 TCPDump

首先，让我们看一下 TCPDump 的用法规范：

```
tcpdump [ -AbdDefhHIJKlLnNOpqRStuUvxX ] 
[ -B buffer_size ] [ -c count ] [ -C file_size ] 
[ -G rotate_seconds ] [ -F file ] 
[ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] 
[ -Q in|out|inout ] [ -r file ] 
[ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ]
[ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ]
[ -z postrotate-command ] [ -Z user ] [ expression ]

```

正如你所看到的，这个小小的数据包转储工具功能丰富，几乎可以满足你的每一个数据包分析需求。作为一个谚语中的“hello world”例子，让我们以最基本的形式调用 TCPDump 并看看它的作用。可以通过以下命令调用它：

```
tcpdump

```

你需要 root 访问权限来运行`tcpdump`，但由于 Kali 默认以 root 身份运行，你只需要打开一个终端并调用前面的命令。前面的命令应该会产生以下输出：

![开始使用 TCPDump](img/5107OT_05_10.jpg)

在前面的屏幕截图中，你可以看到 TCPDump 首先让你知道还有其他可用的调用选项，特别是那些控制输出冗长度的选项。TCPDump 的开发人员认为，如果没有参数调用，让你知道更冗长的选项将是一个好主意。如果你使用冗长开关，你将得到以下输出：

![开始使用 TCPDump](img/5107OT_05_11.jpg)

TCPDump 对数据包的结构进行了更详细的解码，正如你在前面的例子中所看到的，并提供了更多的细节。例如，IP、TCP 和 UDP 标志都包含在数据包转储中。除了控制输出的冗长度，你还可以控制数据包捕获的工作方式。这些选项包括以下内容：

+   `-i`：这允许你指定要捕获的接口。TCPDump 会自动轮询操作系统配置的接口，并开始在找到的第一个接口上进行捕获。这个选项允许你严格指定要使用的接口。如果你需要帮助找出可用的接口，可以尝试执行`ifconfig -a`命令。或者，你也可以使用以下命令：

```
tcpdump –D

```

这将列出`tcpdump`识别出的可用于数据包捕获的接口。

+   `-c`：这允许你指定在退出`tcpdump`之前捕获的数据包数量。如果你不需要无限期地捕获数据包，或者想要对满足给定过滤器条件的数据包进行抽样，这将非常有用。

+   `-w`：这允许你指定要保存数据包捕获的文件。这个选项非常适合在远程渗透测试的审计跟踪中使用，因为你可以清楚地证明你的机器从主机发送和接收了什么。对于某些渗透测试结果来说，几乎没有比数据包捕获更简洁的证据了。事实上，如果可能的话，把这些文件交给你的客户在他们的易受攻击设备上重放！这是一个非常有效的方法，可以自主地为你的发现构建概念验证。

+   -r：这从文件中读取数据包。这是前面小节中`-w`选项的补充。

+   `-A`：在打印数据包时，这会省略链路层头，并以 ASCII 形式打印它们。

+   `-x`：这以十六进制打印数据包，而不包括它们的链路级标头。如果您需要将捕获结果粘贴到模糊框架或 C/C++程序中以后以原始形式操纵，这非常有用。这也是以最诚实和原始的方式打印数据包，同时保持它免受可打印编码的缺陷。

+   `-I`：这将接口置于监视器模式。这仅适用于某些无线接口；一些驱动程序不正确地支持此功能。此选项允许您的无线接口捕获广播到网络上任何设备的数据包，而无需与访问点关联的要求。

+   `-s`：这允许您指定`snaplen`或捕获长度。这是每个数据包捕获的最大字节数。

TCPDump 有许多其他有用的功能。在这里，我们讨论了您作为系统管理员、开发人员或渗透测试人员在日常活动中可能会发现最有用的功能。有关 TCPDump 的其他功能，请参考本章的*进一步阅读*部分。

下一节将介绍 TCPDump 中一个非常强大的功能，即根据数据包属性描述过滤数据包的能力。

## 使用 TCPDump 数据包过滤器

TCPDump 有一个强大的语言，您可以使用它来描述和过滤数据包，从匹配数据包的语义属性、协议、主机和端口，一直到过滤 TCP 和 UDP 头中的属性。在本节中，我们将讨论数据包过滤语言的工作原理以及如何过滤特定属性的数据包。您可以使用以下命令指定 TCPDump 要过滤的一些属性：

```
tcpdump [filter]

```

在上一个命令中，`[filter]`将是您想要过滤的属性的描述。

表达式有一个易于理解的结构；它的工作方式如下：

```
<expression> := <expression><operator><expression>
<expression> := <qualifier><id>
<qualifier> := <proto><dir><type>
<id> := IP address, port number, network address, etc.
<operator> := and,or,not
<type> := host, net, port, portrange
<dir> := src, dst, src or dst, src and dst
<proto> := ether, fddi, wlan, ip, ip6, arp, rarp, decent, tcp, udp
```

这意味着每个表达式都由逻辑运算符粘合在一起的一组表达式，或者由限定词和 ID 组成。这些元素中的每一个都被分解。如果将所有这些放在一起，这意味着您可以指定过滤器，例如以下命令：

```
tcpdump host 192.168.10.102

```

前面的命令匹配所有将`192.168.10.102`设置为源或目的地的数据包。此过滤器等同于以下命令：

```
tcpdump src host 192.168.10.102 or dst host 192.168.10.102

```

前面的命令将产生以下输出：

![使用 TCPDump 数据包过滤器](img/5107OT_05_12.jpg)

您还可以将其与整个网络匹配，例如，`192.168.10.0-255`子网中的所有内容：

```
tcpdump net 192.168.10.0/24 

```

您还可以将其他限定词聚集到前面的示例中：

```
tcpdump net 192.168.10.0/24 and tcp port 80 

```

前面的命令将产生以下输出：

![使用 TCPDump 数据包过滤器](img/5107OT_05_13.jpg)

这将匹配来自`192.168.10.0/24`网络上任何主机发送或接收的所有 TCP 数据，使用端口 80。

您还可以单独使用任何限定词，如下所示：

```
tcpdump port 80
tcpdump tcp
tcpdump src 192.168.10.10
tcpdump portrange 0-1023
tcpdump wlan

```

除了根据宽泛的语义描述（端口、协议和方向）指定数据包外，您还可以指定有关数据包本身的非常细致的细节，直到描述被过滤数据包中任何字段的任何值。

您可以让`tcpdump`根据`TCP`、`ICMP`或`UDP`或任何受支持的协议头值中的属性匹配数据包。这是通过使用以下命令完成的：

```
tcpdump 'tcp[13] & 2!=0'

```

前面的命令将产生以下输出：

![使用 TCPDump 数据包过滤器](img/5107OT_05_14.jpg)

这样做的作用是告诉 TCPDump 检查字节偏移 13 处的 TCP 头是否设置为`2`，这意味着这是一个`SYN`数据包。以下是一些其他常见的例子：

```
tcpdump 'tcp[13] & 32!=0' # for matching ACK packets
tcpdump 'tcp[13] & 8!=0' # for matching PSH packets

```

TCP 和 ICMP 标志也有一些助记符可用；您可以按以下方式使用它们：

```
tcpdump 'tcp[tcpflags] & tcp-syn != 0' 
tcpdump 'tcp[tcpflags] & tcp-ack != 0'

```

同样，对于 ICMP 数据包，您可以使用以下命令：

```
tcpdump 'icmp[icmptype] & icmp-echo!= 0'

```

您需要了解一些关于 TCP 头结构的知识，以充分利用这个功能。如果您想了解更多关于 TCP 协议、数据包结构和操作的信息，请参阅*进一步阅读*部分中的一些链接。

# 评估 SSL 实现安全性

几十年来，人们一直在使用加密、哈希和密钥交换机制来在不受信任的网络上安全地传输信息。他们将使用复杂和错综复杂的哈希、加密和交换密码原语的组合来建立一个安全的通信渠道。SSL 和 TLS 系列协议是一组规则，指定了如何管理加密原语、通信数据和通信的其他属性，以确保从客户端到服务器以及反之的安全对话。

不幸的是，许多 SSL/TLS 版本在它们的存在期间遭受了许多毁灭性的漏洞。一些已发布的攻击最近才出现，仍然影响着许多 SSL/TLS 实现。除了 TLS/SSL 的固有实现缺陷外，这些服务的配置中也经常出现问题——它们的使用方式出现了错误，而不是它们的工作方式。许多开箱即用的配置支持令人震惊的脆弱和过时的密码套件，而其他一些根本没有提供强大的保护；有些甚至完全省略了加密或消息认证方案！

本章的后续部分将详细介绍您可以使用一个名为 SSLyze 的非常流行的工具来评估 SSL/TLS 实现的方法。它还将向您展示一些新颖的 bash 黑客技巧，以便您可以自动化 SSL/TLS 实现的风险分析。

## 使用 SSLyze

SSLyze 是 iSec 合作伙伴开发的另一个优秀工具，我可以诚实地说，在我的经验中，每次渗透测试或漏洞评估都会用到它。

SSLyze 的作用是连接到目标服务器上实现的 SSL 服务；它试图详细说明 SSL/TLS 密码套件和其他 SSL/TLS 配置的具体情况。

以下是 SSLyze 的使用规范：

```
sslyze [--version][-h][--help][--xml_out=XML_FILE]
[--targets_in=TARGETS][--timeout=TIMEOUT]
[--https_tunnel=HTTPS_TUNNEL][--starttls=STARTTLS]
[--regular][--cert=CERT][--certform=CERTFORM][--key=KEY]
[--pass=PASSWORD][--sslv2][--sslv3][--tlsv1][--tlsv1_1][--tlsv1_2]
[--http_get][--hide_rejected_ciphers][--reneg][--resum]
[--resum_rate][--certinfo basic| full ] [--compression]

```

让我们看看当我们将 SSLyze 指向一个支持 SSL/TLS 的 Web 服务器时会发生什么；您可以使用以下命令来做到这一点：

```
sslyze [options] [address]:[port]

```

例如，如果您想评估 SSL 实现`192.168.10.101`，特别是查询 TLS 版本 1 配置，您将执行以下命令：

```
sslyze –-tlsv1 192.168.10.101:443

```

前面的命令产生了以下输出：

![使用 SSLyze](img/5107OT_05_15.jpg)

在前面的屏幕截图中，我们看到了所配置的密码套件的规格。它具体提到了服务器支持的密码套件以及用于给定对称密码的对称密钥的长度。

### 提示

每个密码套件都根据密钥交换算法、对称加密算法和消息摘要（或哈希）算法以及伪随机函数进行描述。以下是一个密码套件名称的示例：

`TLS_RSA_WITH_AES_256_CBC_SHA`

下划线之前的前几个字母要么提到密钥交换机制，要么说明密码套件是用于 TLS 协议的。在这里，密钥交换机制是`RSA`。接下来的规格是对称加密操作。在这里，这被指定为`AES_256`，这是 AES 算法，块长度为 256，用于**密码块链接**（**CBC**）模式。在提到加密算法之后，密码套件提到了哈希算法。在这里，它被指定为 SHA。

SSLyze 支持所有的 SSL/TLS 版本，并且您可以指定要测试哪个版本作为命令行选项。如果您想测试所有版本，您将指定以下命令行选项：

```
sslyze –-sslv2 –-sslv3 –-tlsv1 –-tlsv1_1 –-tlsv1_2 [host]:[port]

```

除了 TLS/SSL 版本，您还可以让它测试其他属性。以下是一些其他选项的工作原理：

+   `--reneg`：此测试用于重新协商支持。注意客户端发起的重新协商；在 SSL 版本中，这可能意味着 DoS 漏洞。

+   `--compression`：此测试用于消息压缩支持。在 TLS 版本 1.0 中，这会导致关键信息泄漏漏洞。

+   `--resum`：此测试用于使用会话 ID 或 TLS 会话票证进行恢复支持。

SSLyze 提供的另一个非常有用的选项是大多数常用选项的快捷方式。以下是使用方法：

```
sslyze –-regular [host]:[port]

```

密码是否存在潜在危险取决于服务器是否支持此类易受攻击的密码套件。危险在于客户端可能会受到攻击，泄露与受影响服务器的通信相关的信息。例如，如果服务器支持使用易受攻击的密钥长度的对称密码套件，通常小于 128 位，很容易想象攻击者可以暴力破解 SSL/TLS 会话期间使用的会话密钥。可能有许多在线评估方法。我在*进一步阅读*部分中包含了 Qualys Labs 的一个非常好的方法。

## Bash 黑客和 SSLyze

一旦您了解了哪些 SSL 套件、密钥长度和其他 TLS/SSL 配置辅助功能应被视为易受攻击，您可以过滤 SSLyze 输出以突出显示易受攻击的配置细节。一种方法是使用 bash 脚本，避免阅读所有输入并手动查找易受攻击的实例。以下是您可以在 SSL 评估期间使用和修改的示例：

```
#!/bin/bash
HOST=$1
SSL_PORT=$2
KEY_LEN_LIMIT=$3
VULN_SUIT_LIST=$4
echo -e "[*] assessing host \e[3;36m $HOST:$SSL_PORT\e[0m"
for cipher in `sslyze --regular $HOST:$SSL_PORT | awk -F\  '/[0-9]* bits/ { print $1"_"$2"_"$3 }'`
do
 suit=`echo $cipher | awk -F\_ '{ print $1 }' | sed 's/ //g'`
 keylen=`echo $cipher | awk -F\_ '{ print $2 }' | sed 's/ //g'`
 for bad_suit in `cat $VULN_SUIT_LIST`
 do
 BAD_SUIT="0"
 if [ "$suit" = "`echo $bad_suit | sed 's/ //g'`" ]
 then
 suit=`echo -e "\e[1;31m*$suit\e[0m"` #make it red forbad
 BAD_SUIT="1"
 fi
 done
 if [ "$keylen" -lt "$KEY_LEN_LIMIT" ]
 then
 keylen=`echo -e "\e[1;31m*$keylen\e[0m"` #make it red for bad
 fi
 echo -e "\t[+]$suit : $keylen" 
done | column -t -s:

```

先前的脚本接受以下参数：

+   `HOST`：这是要评估的 IP 地址

+   `SSL_PORT`：这是用于 SSL/TLS 服务的端口号

+   `KEY_LEN_LIMIT`：这是安全密钥的最低限制，例如 128

+   `VULN_SUIT_LIST`：这是一个被认为易受攻击的密码套件列表

以下是一个快速示例：

```
. cipher_filter.sh 192.168.10.103 443 128 ./vulnerable_cipher_list

```

上述命令将产生以下输出：

![Bash 黑客和 SSLyze](img/5107OT_05_16.jpg)

`./vulnerable_cipher_list`是一个包含每行一个密码套件名称的文件，以下是一个示例。它提到了一些带有`NULL`一词的密码套件：

```
  DHE_PSK_WITH_NULL_SHA256
  DHE_PSK_WITH_NULL_SHA384
  RSA_PSK_WITH_AES_128_CBC_SHA256
  RSA_PSK_WITH_AES_256_CBC_SHA384
  RSA_WITH_NULL_SHA
```

这些密码的更完整列表可从该书的网站获得。

# 自动化 Web 应用程序安全评估

Web 应用程序是非常复杂的技术组件，而且它们每天都变得更加复杂。可以想象，对这些庞大、沉重且经常非常隐秘的应用程序进行渗透测试可能是一项相当繁重的任务。幸运的是，用于 Web 应用程序安全评估的工作中有相当大一部分可以自动化。我说“部分”，因为对于 Web 应用程序存在一些攻击面，目前还没有看到太多成功的自动化，即需要用户交互的 XSS，定制加密缺陷和业务逻辑缺陷。如果你只是运行了一个扫描器，就认为你已经很好地掌握了 Web 应用程序安全，那是不安全的！也就是说，像爬行、模糊头部、拾取认证表单和其他简单重复的任务已经在 Web 应用程序扫描器中得到了很好的自动化。在本节中，我们将看一下 Kali Linux 中可用的一小部分命令行驱动工具，以自动化 Web 应用程序安全评估。

## 使用 SkipFish 进行扫描

SkipFish 是一种由一些在谷歌工作的人使用和创建的工具。SkipFish 与其领域中的大多数工具一样，简单地爬行 Web 应用程序，并通过检测引擎分析每个页面，以分析页面中的常见缺陷和错误配置。SkipFish 以交互式网页的形式报告其输出。让我们看看如何使用 SkipFish 以及它支持的一些功能。

要启动 SkipFish，您需要两样必要的东西：一个词列表和一个目录来存储其结果。执行以下步骤使其正常工作：

1.  通过以下命令为 SkipFish 准备一个输出目录：

```
mkdir skipfish-ouput/

```

1.  通过以下命令获取 SkipFish 工作所需的样本词列表：

```
cp /usr/share/skipfish/dictionaries/medium.wl .

```

在这里，我们使用中等字典。这只是一个演示；请随意尝试提到的文件夹中的其他字典。

1.  确保目录没有标记为只读；您需要删除此文件的第一行，因为它作为只读文件与 SkipFish 一起提供。您需要删除类似以下的行：

```
# ro

```

1.  现在，您可以通过执行以下命令来启动 SkipFish：

```
skipfish –W medium –o skipfish-out/

```

在 Kali Linux 命令行上执行时，整个过程将如下截屏所示：

![使用 SkipFish 进行扫描](img/5107OT_05_17.jpg)

当 SkipFish 运行完成时，它将向您呈现以下截图：

![使用 SkipFish 进行扫描](img/5107OT_05_18.jpg)

如果这是您第一次运行 SkipFish，您可以预先中止它，因为它将自动报告到目前为止收集的所有结果。您可以通过按*Ctrl* + *C*来做到这一点。

当 SkipFish 运行完成时，它将在为其输出创建的目录中呈现一个`index.html`文件。此文件包含报告。在 Iceweasel 中打开 SkipFish 报告时，报告看起来像以下截图：

![使用 SkipFish 进行扫描](img/5107OT_05_19.jpg)

SkipFish 支持许多其他调用选项，其中一些控制如何处理词列表；其他控制 SkipFish 在测试期间的侵略性。有关这些选项的更多信息，请参阅*进一步阅读*部分中的一些链接。

## 使用 Arachni 进行扫描

Arachni 是另一个在 Kali Linux 中可用的出色的命令行驱动的 Web 应用程序扫描工具。它配备了一系列模块和插件，允许用户评估各种 Web 应用程序安全重点领域。要以默认模式启动 Arachni，您必须调用以下命令：

```
arachni –u [URL]

```

例如，如果您想对[privatebankloans.com](http://privatebankloans.com)进行 Arachni 扫描，您将发出以下命令：

```
arachni –u http://www.privatebankloans.com 

```

这将加载所有扫描模块，并使 Arachni 针对指定 Web 应用程序的所有可能攻击面。您还可以将 Arachni 专注于特定类型的扫描。例如，仅运行检测 XSS 漏洞，您将指定以下命令：

```
arachni –u [URL] –mods=xss_*

```

要加载所有审计模块，请使用以下命令：

```
arachni –u [URL] –mods=audit*

```

您可以使用`--lsmod`命令行选项列出可用的模块。此选项将接受正则表达式作为参数，并查找所有模块的名称产生匹配的模块，然后 Arachni 显示有关它们的一些基本信息。Arachni 还支持一个报告框架，允许您生成关于它发现的问题的整洁格式的报告。您可以通过输入以下命令来使用它：

```
arahni –u [URL] –-report=[FORMAT]:[FILENAME]

```

其中`[FORMAT]`是您想要报告的文档格式，`FILENAME`是报告要保存的文件名。`FORMAT`可以是 HTML、`.txt`或其他许多格式。

这是一个生成 HTML 报告的示例：

```
arachni –u http://www.privatebankloans.com –-report:html:privatebankloads.html

```

与许多命令行参数一样，您可以指定多个报告格式。这将导致生成多个报告，如以下命令中指定的那样：

```
arachni –u http://www.privatebankloans.com –-report:html:privatebankloads.html –-report:json:privatebankloads.html

```

Arachni 支持一系列参数，控制其操作的其他方面。有关更多详细信息，请参阅*进一步阅读*部分。

# 总结

在本章中，我们学习了使用各种工具来评估 OSI 协议栈的不同层。我们涵盖了攻击第 2 层协议实现的工具，即 ARP 和其他基于 MAC 的身份验证方案。

我们还介绍了使用 ArpSpoof 进行简单 ARP 欺骗攻击，并学习了如何伪造 MAC 地址。在此基础上，我们应用这些技术来执行完整的中间人攻击，从而使我们能够拦截流量并欺骗 DNS 服务器。

该章节还包括专门针对本地网络上的 SMTP 和 SNMP 服务的技术部分。这些部分详细介绍了一个名为`snmpwalk`的工具的用法，以及 Metasploit 模块`snmp-enum`和`snmp-login`的用法，这些模块用于暴力破解 SNMP 认证。信息收集部分以讨论 SMTP 枚举攻击结束，我们学会了使用`smtp-user-enum`工具来完成这项工作。

除了滥用网络协议的功能外，本章还讨论了滥用安全措施的实施，特别是认证凭据——密码、用户名、安全令牌等。我们介绍了一个非常强大的认证暴力破解工具 Medusa，它支持各种认证机制，如 SSH、FTP，甚至 Web HTML 表单。

在学会攻击之后，我们退后一步，介绍了一个称为 TCPDump 的有用的数据包分析和流量监控工具。我们学会了使用 TCPDump 根据主机、端口甚至详细的传输层数据包偏移来过滤数据包。

然后，本章介绍了 SSL 安全评估，并演示了如何使用 SSLyze 来枚举目标主机上实现的密码套件和 SSL/TLS 版本。我们还了解了一个有用的 bash 脚本，可以帮助检测有缺陷的密码，并允许我们根据我们的评估需求更改易受攻击的密码套件的定义。

我们通过学习使用两个非常强大的 Web 应用程序扫描工具 SkipFish 和 Arachni 来结束了本章。

本章旨在作为介绍所讨论的非常强大和灵活的工具。我敦促每个阅读本章的人都要研究我们讨论过的工具，了解它们的优势和劣势，并将它们结合起来创建一个强大的安全评估工具库。当你掌握了这些工具之后，写一些属于你自己的吧！

# 进一步阅读

+   [`www.wains.be/pub/networking/tcpdump_advanced_filters.txt`](http://www.wains.be/pub/networking/tcpdump_advanced_filters.txt)上的 TCPDump 过滤器(accessed 2014/03/30)

+   [`www.tcpdump.org/manpages/tcpdump.1.html`](http://www.tcpdump.org/manpages/tcpdump.1.html)上的 TCPDump 手册(accessed 2014/03/30)

+   [`www.cs.ucr.edu/~marios/ethereal-tcpdump.pdf`](http://www.cs.ucr.edu/~marios/ethereal-tcpdump.pdf)上的 TCPDump 过滤器(accessed 2014/03/30)

+   [`www.tcpdump.org/`](http://www.tcpdump.org/)上的 TCPDump & libpacp(accessed 2014/03/30)

+   以太网地址解析协议在[`tools.ietf.org/html/rfc826`](http://tools.ietf.org/html/rfc826)上(accessed 2014/04/03)

+   [`github.com/iSECPartners/sslyze`](https://github.com/iSECPartners/sslyze)上的 SSLyze Github 页面(accessed 2014/03/30)

+   [`www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices_1.3.pdf`](https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices_1.3.pdf)上的 SSL 部署最佳实践，2013 年 9 月(accessed 2014/04/03)

+   传输层安全性（TLS）协议版本 1.2 在[`tools.ietf.org/html/rfc5246`](http://tools.ietf.org/html/rfc5246)上(accessed 2014/03/30)

+   SSL 协议版本 3.0 在[`tools.ietf.org/html/rfc6101`](http://tools.ietf.org/html/rfc6101)上(accessed 2014/03/30)

+   SSL 3.0 协议分析在[`www.schneier.com/paper-ssl.pdf`](https://www.schneier.com/paper-ssl.pdf)上(accessed 2014/03/30)

+   明文的压缩和信息泄露在[`www.iacr.org/cryptodb/archive/2002/FSE/3091/3091.pdf`](http://www.iacr.org/cryptodb/archive/2002/FSE/3091/3091.pdf)上(accessed 2014/03/30)

+   TLS 和 SSLv3 重新协商漏洞在[`www.g-sec.lu/practicaltls.pdf`](http://www.g-sec.lu/practicaltls.pdf)中 (访问时间 2014/03/30)

+   Breach TLS HTTP 压缩漏洞在[`breachattack.com/`](http://breachattack.com/)中 (访问时间 2014/03/30)

+   TLS 密码套件注册表在[`www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4`](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4)中 (访问时间 2014/04/01)

+   关于 TLS 和 WPA 中 RC4 的安全性在[`www.isg.rhul.ac.uk/tls/`](http://www.isg.rhul.ac.uk/tls/)中 (访问时间 2014/04/01)

+   《Essential SNMP》在[`oreilly.com/catalog/esnmp/chapter/ch02.html`](http://oreilly.com/catalog/esnmp/chapter/ch02.html)中

+   SNMPv3 的漏洞在[`smartech.gatech.edu/bitstream/handle/1853/44881/lawrence_nigel_r_201208_mast.pdf?sequence=2`](https://smartech.gatech.edu/bitstream/handle/1853/44881/lawrence_nigel_r_201208_mast.pdf?sequence=2)中 (访问时间 2014/04/06)

+   思科安全公告：SNMP 版本 3 认证漏洞在[`www.securityfocus.com/archive/1/493238`](http://www.securityfocus.com/archive/1/493238)中 (访问时间 2014/04/06)

+   多供应商 SNMPv3 HMAC 安全绕过在[`www.iss.net/security_center/reference/vuln/SNMP_V3_HMAC_Security_Bypass.htm`](http://www.iss.net/security_center/reference/vuln/SNMP_V3_HMAC_Security_Bypass.htm)中 (访问时间 2014/04/06)

+   SSL 最佳实践指南在[`labs.portcullis.co.uk/whitepapers/ssl-good-practice-guide/`](https://labs.portcullis.co.uk/whitepapers/ssl-good-practice-guide/)中 (访问时间 2014/04/07)

+   Medusa 并行网络登录审计器在[`foofus.net/goons/jmk/medusa/medusa.html`](http://foofus.net/goons/jmk/medusa/medusa.html)中 (访问时间 2014/04/07)

+   Ncrack 官方页面在[`nmap.org/ncrack/`](http://nmap.org/ncrack/)中

+   Arachni 命令行用户界面在[`github.com/Arachni/arachni/wiki/Command-line-user-interface`](https://github.com/Arachni/arachni/wiki/Command-line-user-interface)
