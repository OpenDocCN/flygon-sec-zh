- en: Chapter 9. Attack Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。攻击自动化
- en: Automating tools enable us to explore and exploit more vulnerabilities than
    any manual method possibly could. In my opinion, nothing beats manual security
    testing combined with a set of automated sections performed by an experienced
    security specialist. Sophisticated scripts can split the attack between several
    hosts and avoid being blacklisted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工具使我们能够探索和利用比任何手动方法可能的漏洞更多。在我看来，没有什么能比得上由经验丰富的安全专家执行的手动安全测试结合一组自动化部分。复杂的脚本可以将攻击分散到多个主机，并避免被列入黑名单。
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: SFTP automations with paramiko
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用paramiko进行SFTP自动化
- en: Nmap automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap自动化
- en: W3af REST API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3af REST API
- en: Metasploit scripting with MSGRPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MSGRPC进行Metasploit脚本化
- en: OWASP zap API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP zap API
- en: Breaking captcha
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解验证码
- en: Accessing BeEF API with Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python访问BeEF API
- en: Accessing Nessus 6 API with Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python访问Nessus 6 API
- en: Paramiko
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paramiko
- en: Running commands in remote systems via SSH is one of the most common components
    of automation. The Python module paramiko makes this easy by providing a programmatic
    interface to SSH. Paramiko gives you an easy way to use SSH functions in Python
    through an imported library. This allows us to drive SSH tasks, which you would
    normally perform manually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH在远程系统中运行命令是自动化的最常见组件之一。Python模块paramiko通过提供对SSH的编程接口，使这变得容易。Paramiko通过导入库为您提供了在Python中使用SSH功能的简便方法。这使我们能够执行通常需要手动执行的SSH任务。
- en: Establish SSH connection with paramiko
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用paramiko建立SSH连接
- en: 'The main class of paramiko is `paramiko.SSHClient`, which provides a basic
    interface to initiate server connections:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: paramiko的主要类是`paramiko.SSHClient`，它提供了一个基本的接口来初始化服务器连接：
- en: '![Establish SSH connection with paramiko](img/1-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用paramiko建立SSH连接](img/1-1.jpg)'
- en: This will create a new SSHClient instance, and we then call the `connect()`
    method, which connects to the SSH server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的SSHClient实例，然后我们调用`connect()`方法，该方法连接到SSH服务器。
- en: 'When we connect to a remote machine with any SSH client, that remote host''s
    key will be automatically stored in the `.ssh/known_hosts` file in our home directory.
    So, the first time we connect to a remote system, we will get a message, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用任何SSH客户端连接到远程机器时，该远程主机的密钥将自动存储在我们的主目录中的`.ssh/known_hosts`文件中。因此，第一次连接到远程系统时，我们将收到以下消息：
- en: '![Establish SSH connection with paramiko](img/4323OS_09_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用paramiko建立SSH连接](img/4323OS_09_01.jpg)'
- en: 'When you type `yes` for this message, it will add an entry in the `known_hosts`
    file. By accepting this message, a level of trust is added for that host. The
    same rule is applicable for paramiko. By default, the SSHClient instance will
    refuse to connect a host that does not have a key saved in our `known_hosts` file.
    This will create problems when creating automation scripts. We can set the host
    key policy to add missing host keys automatically with paramiko as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在此消息中输入“是”时，它将在“known_hosts”文件中添加一个条目。通过接受此消息，为该主机添加了一定程度的信任。相同的规则适用于paramiko。默认情况下，SSHClient实例将拒绝连接没有在我们的“known_hosts”文件中保存密钥的主机。这将在创建自动化脚本时造成问题。我们可以将主机密钥策略设置为使用paramiko自动添加丢失的主机密钥，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, the script to connect to `ssh` with auto-add host keys will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，连接到`ssh`并自动添加主机密钥的脚本将如下所示：
- en: '![Establish SSH connection with paramiko](img/2-1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用paramiko建立SSH连接](img/2-1.jpg)'
- en: Running commands with paramiko
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用paramiko运行命令
- en: 'We are now connected to the remote host with paramiko. We can then run commands
    on the remote host using this connection:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用paramiko连接到远程主机。然后，我们可以使用此连接在远程主机上运行命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The response data will be the tuple (`stdin`, `stdout`, `stderr`), and we could
    read the output and write to input. For example, if we are running a command which
    requires an input, we could use `stdin`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 响应数据将是元组（`stdin`，`stdout`，`stderr`），我们可以读取输出并写入输入。例如，如果我们运行一个需要输入的命令，我们可以使用`stdin`：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we could create an interactive shell that could automate many tasks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以创建一个可以自动化许多任务的交互式shell。
- en: SFTP with paramiko
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用paramiko进行SFTP
- en: We can also use paramiko to handle file manipulations on a remote host with
    SFTP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用paramiko处理远程主机上的文件操作。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**SFTP** stands for **SSH File Transfer Protocol**, or **Secure File Transfer
    Protocol**. It is a separate protocol that works almost the same as FTP over a
    secure connection with SSH.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFTP**代表**SSH文件传输协议**，或**安全文件传输协议**。这是一个单独的协议，几乎与通过SSH进行安全连接的FTP相同。'
- en: 'To do this, we first instantiate a new `paramiko.SSHClient` instance as before:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先像以前一样实例化一个新的`paramiko.SSHClient`实例：
- en: '![SFTP with paramiko](img/3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![使用paramiko进行SFTP](img/3.jpg)'
- en: Then we use `open_sftp()` after connecting to the remote host, which will return
    a `paramiko.SFTPClient` client object. The `paramiko.SFTPClient` will support
    all the SFTP operations. Here, we listed the files in the root of the remote server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在连接到远程主机后，我们使用`open_sftp()`，它将返回一个`paramiko.SFTPClient`客户端对象。`paramiko.SFTPClient`将支持所有的SFTP操作。在这里，我们列出了远程服务器根目录中的文件。
- en: We can use the `get()` method to download and the `put()` method to upload files
    with paramiko.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`get()`方法下载文件，使用`put()`方法上传文件。
- en: 'To download the remote password file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载远程密码文件：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To upload a file to a remote host:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件上传到远程主机：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: python-nmap
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: python-nmap
- en: '**Network Mapper** (**Nmap**) is a free and open-source tool used for network
    discovery and security auditing. It runs on all major computer operating systems,
    and official binary packages are available for Linux, Windows, and Mac OS X. The
    `python-nmap` library helps to programmatically manipulate scanned results of
    `nmap` to automate port scanning tasks.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络映射器**（**Nmap**）是用于网络发现和安全审计的免费开源工具。它可以在所有主要计算机操作系统上运行，并且Linux、Windows和Mac
    OS X都提供官方的二进制软件包。`python-nmap`库有助于以编程方式操作`nmap`的扫描结果，以自动化端口扫描任务。'
- en: 'As usual, we have to import the module `nmap` after installing `python-nmap`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在安装了`python-nmap`后，我们必须导入模块`nmap`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instantiate the `nmap` port scanner:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化`nmap`端口扫描程序：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set `host` and `port` range to scan:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要扫描的`host`和`port`范围：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could print the `command_line` command used for the scan:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印用于扫描的`command_line`命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, we could get the `nmap` scan information:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以获取`nmap`扫描信息：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we scan all the hosts:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们扫描所有主机：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also scan all protocols:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还扫描所有协议：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This script will provide an output like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将提供以下输出：
- en: '![python-nmap](img/image_09_002.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![python-nmap](img/image_09_002.jpg)'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You could get more options of `python-nmap` from here:  [https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里获取更多关于`python-nmap`的选项：[https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap)。
- en: W3af REST API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: W3af REST API
- en: '**Web Application audit and attack framework** (**W3af**) is a powerful and
    flexible environment for web vulnerability assessments and for exploiting web
    application vulnerabilities. It has many plugins that could communicate with each
    other. For instance, the discovery plugin collects different URLs to test and
    pass on to the audit plugin, which uses these URLs to search for vulnerabilities.
    W3af could also exploit the vulnerabilities that it finds.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用程序审计和攻击框架**（**W3af**）是一个强大而灵活的环境，用于Web漏洞评估和利用Web应用程序漏洞。它有许多插件可以相互通信。例如，发现插件收集不同的URL进行测试，并传递给审计插件，审计插件使用这些URL来搜索漏洞。W3af还可以利用它发现的漏洞。'
- en: 'W3af has eight different types of plugin:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: W3af有八种不同类型的插件：
- en: '**Discovery plugins**: Crawl the web application to find new URLs, forms, and
    many other interesting parts of the web application. These plugins run in a loop,
    and the output is fed as the input to the next plugin.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现插件**：爬行Web应用程序以查找新的URL、表单和许多其他有趣的Web应用程序部分。这些插件在循环中运行，输出作为输入提供给下一个插件。'
- en: '**Audit plugins**: These are the main parts of W3af, and they take the output
    of discovery plugins as input and scan for all types of web application vulnerabilities
    like SQL, XSS injections, and others.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计插件**：这些是W3af的主要部分，它们将发现插件的输出作为输入，并扫描各种Web应用程序漏洞，如SQL、XSS注入等。'
- en: '**Grep plugins**: Like the UNIX grep utility, they search each and every HTTP
    request and response to find unusual and interesting information. It can be anything
    like IPs, Error codes, e-mail IDs, credit card numbers, or even risky JavaScript
    codes.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grep插件**：像UNIX grep实用程序一样，它们搜索每个HTTP请求和响应，以查找异常和有趣的信息。它可以是IP地址、错误代码、电子邮件ID、信用卡号，甚至是风险的JavaScript代码。'
- en: '**Bruteforce plugins**: These help to brute-force the basic HTTP authentications
    and form login authentications that are found during the discovery phase.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bruteforce插件**：这些插件有助于暴力破解在发现阶段发现的基本HTTP身份验证和表单登录身份验证。'
- en: '**Attack plugins**: This plugin will read the vulnerability objects from the
    knowledge base and try to exploit them.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击插件**：此插件将从知识库中读取漏洞对象并尝试利用它们。'
- en: '**Mangle plugins**: These help to modify requests and responses based on regular
    expressions like sed editor.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mangle插件**：这些插件有助于基于sed编辑器的正则表达式修改请求和响应。'
- en: '**Evasion plugins**: These help to avoid simple **Intrusion Detection Rules**
    (**IDS**).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Evasion插件**：这些插件有助于避免简单的**入侵检测规则**（**IDS**）。'
- en: '**Output plugins**: These help to create output files in different file formats
    as reports.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出插件**：这些插件有助于创建不同文件格式的输出文件，如报告。'
- en: 'We could use the `w3af` API to connect to `w3af` and use these modules. First,
    we have to run the `w3af` API. To do this, get the `w3af` and run `w3af_api`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`w3af` API连接到`w3af`并使用这些模块。首先，我们必须运行`w3af` API。要做到这一点，获取`w3af`并运行`w3af_api`：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `w3af` API already has some configured profiles that can be used for particular
    tasks. For instance, the `OWASP_TOP10` profile includes several discovery, audit,
    and grep plugins to perform OWASP Top 10 security analysis. So, we could make
    use of those profile files, or we could create our own profiles to run the `w3af`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`w3af` API已经配置了一些可用于特定任务的配置文件。例如，`OWASP_TOP10`配置文件包括几个发现、审计和grep插件，用于执行OWASP
    Top 10安全性分析。因此，我们可以使用这些配置文件，或者我们可以创建自己的配置文件来运行`w3af`。'
- en: 'Use the `w3af_api_client` to access `w3af_api` from scripts. Install `w3af_api_client`
    and import it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`w3af_api_client`从脚本中访问`w3af_api`。安装`w3af_api_client`并导入它：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can create a connection to the `w3af` API. This will be running at port
    `5000`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建到`w3af` API的连接。这将在端口`5000`上运行：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can make sure the connection is proper by checking its version:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查其版本来确保连接正确：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can define the profile file and the target URL to scan:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义配置文件和要扫描的目标URL：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we instantiate the scan instance:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化扫描实例：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can start the scan:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始扫描：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After starting the scan we could get the findings, URLs, and logs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开始扫描后，我们可以获取发现、URL和日志：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could get the `fuzzable` URLs with the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法获取`fuzzable` URL：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As W3af is a Python tool, we can import `w3af` as a module in our scripts and
    use its functionalities in our script. For that, we have to download `setup.py`
    for `w3af`. We can get the whole module's files from [https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于W3af是一个Python工具，我们可以在脚本中将`w3af`作为模块导入并在脚本中使用其功能。为此，我们必须下载`w3af`的`setup.py`。我们可以从[https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module)获取整个模块的文件。
- en: Download this module and verify that the sub-module folder `w3af` has all the
    files in it. If not, download the `w3af` folder from [https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af)
    and replace that folder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下载此模块并验证子模块文件夹`w3af`中是否包含所有文件。如果没有，请从[https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af)下载`w3af`文件夹并替换该文件夹。
- en: 'Then, run the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will install `w3af` as a Python module. Next, we can import it, as we
    do for other Python modules:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`w3af`作为Python模块。接下来，我们可以像导入其他Python模块一样导入它：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, we could import other `w3af` modules such as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以导入其他`w3af`模块，例如：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Metasploit scripting with MSGRPC
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MSGRPC的Metasploit脚本
- en: '**Metasploit** is an open-source project that provides public resources for
    developing, testing, and executing exploits. It can also be used to create security
    testing tools, exploit modules, and as a penetration testing framework.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Metasploit**是一个开源项目，提供公共资源用于开发、测试和执行利用。它还可以用于创建安全测试工具、利用模块，以及作为渗透测试框架。'
- en: Metasploit is written in Ruby and it does not support modules or scripts written
    in Python.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit是用Ruby编写的，不支持用Python编写的模块或脚本。
- en: However, Metasploit does have a MSGRPC, Bidirectional RPC (Remote Procedure
    Call) interface using MSGPACK. The `pymetasploit` Python module helps to interact
    between Python and Metasploit's `msgrpc`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Metasploit确实有一个MSGRPC，使用MSGPACK的双向RPC（远程过程调用）接口。`pymetasploit` Python模块有助于在Python和Metasploit的`msgrpc`之间进行交互。
- en: 'So before scripting, we have to load `msfconsole` and start the `msgrpc` service.
    Next, let''s start Metasploit and the MSGRPC interface. We could start MSGRPC
    with `msfrpcd` in Metasploit. Here are the full options for `msfrpcd`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在编写脚本之前，我们必须加载`msfconsole`并启动`msgrpc`服务。接下来，让我们启动Metasploit和MSGRPC接口。我们可以在Metasploit中使用`msfrpcd`启动MSGRPC。以下是`msfrpcd`的完整选项：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Metasploit scripting with MSGRPC](img/image_09_007.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![使用MSGRPC进行Metasploit脚本编写](img/image_09_007.jpg)'
- en: 'To start MSGRPC with the password `123456`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以密码`123456`启动MSGRPC：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Metasploit scripting with MSGRPC](img/image_09_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![使用MSGRPC进行Metasploit脚本编写](img/image_09_008.jpg)'
- en: Now that Metasploit's RPC interface is listening on port `55553`. We can proceed
    to write our Python script.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Metasploit的RPC接口正在侦听端口`55553`。我们可以继续编写我们的Python脚本。
- en: Interacting with MSGRPC is almost similar to interacting with `msfconsole`.
    First, we have to create an instance of the `msfrpc` class. Then, log in to the
    `msgrpc` server with the credentials, and create a virtual console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与MSGRPC交互几乎与与`msfconsole`交互类似。首先，我们必须创建`msfrpc`类的实例。然后，使用凭据登录到`msgrpc`服务器，并创建一个虚拟控制台。
- en: 'We can use the PyMetasploit Python module to automate the exploitation tasks
    with Python. Clone the module from [https://github.com/allfro/pymetasploit](https://github.com/allfro/pymetasploit):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PyMetasploit Python模块来自动化Python的利用任务。从[https://github.com/allfro/pymetasploit](https://github.com/allfro/pymetasploit)克隆该模块：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Move to the following module folder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 转到以下模块文件夹：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Install the module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can import the module in our scripts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的脚本中导入该模块：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can create a new instance for `MsfRpcClient`. We have to authenticate
    into the Metasploit to run any commands in it. So, pass the password to authenticate
    to Metasploit:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为`MsfRpcClient`创建一个新实例。我们必须对Metasploit进行身份验证才能在其中运行任何命令。因此，传递密码以对Metasploit进行身份验证：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can navigate through the core Metasploit functionalities with this instance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这个实例浏览核心Metasploit功能：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will list the core functionalities. Now we can list the auxiliary options:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出核心功能。现在我们可以列出辅助选项：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, we can list all the core modules of exploits, encoders, payloads,
    and post, using the same syntax. We can activate one of these modules with the
    use method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用相同的语法列出所有利用、编码器、有效载荷和后续的核心模块。我们可以使用`use`方法激活其中一个模块：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we can set the parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以设置参数：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, run the module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行模块：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the execution was successful, then the output will be as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行成功，则输出如下：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If this fails, the `job_id` will be none.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，`job_id`将为none。
- en: 'Next we can use the sessions method to access the shells and consoles if the
    attack was a success:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果攻击成功，我们可以使用会话方法访问shell和控制台：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will list all current active sessions. If the attack provides shell access
    to the victim, then we can get the available shells and access them with the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有当前活动的会话。如果攻击为受害者提供了shell访问权限，那么我们可以获取可用的shell，并使用以下方法访问它们：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also connect to the console and run the commands as we do in the `msfconsole`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以连接到控制台并运行命令，就像在`msfconsole`中一样：
- en: 'Import the modules:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the client:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建客户端：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create console with the client:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端创建控制台：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use this instance to run Metasploit commands as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个实例来运行Metasploit命令，如下所示：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output will print in the console itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将打印在控制台本身。
- en: Here we used the PyMetasploit module, but we can also use the msgrpc module
    ([https://github.com/SpiderLabs/msfrpc](https://github.com/SpiderLabs/msfrpc)).
    This will help us to get access to underlying functions and to handle the results
    and console output within the scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了PyMetasploit模块，但我们也可以使用msgrpc模块（[https://github.com/SpiderLabs/msfrpc](https://github.com/SpiderLabs/msfrpc)）。这将帮助我们访问底层功能，并在脚本中处理结果和控制台输出。
- en: ClamAV antivirus with Python
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的ClamAV防病毒软件
- en: We can use pyClamd, an open-source Python module, to use the ClamAV antivirus
    engine on Linux, MacOSX, and Windows. To use ClamAV programmatically from Python,
    you have to run an instance of the `clamd` daemon.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用pyClamd，一个开源的Python模块，在Linux、MacOSX和Windows上使用ClamAV防病毒引擎。要从Python中以编程方式使用ClamAV，您必须运行`clamd`守护程序的一个实例。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can install ClamAV in Windows, Linux, and MacOSx. To install it in Windows
    and Linux, refer to the official ClamAV documentation at [http://www.clamav.net/documents/installing-clamav](http://www.clamav.net/documents/installing-clamav).
    To install in MacOSX, use homebrew.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Windows、Linux和MacOSx上安装ClamAV。要在Windows和Linux上安装它，请参考官方ClamAV文档[http://www.clamav.net/documents/installing-clamav](http://www.clamav.net/documents/installing-clamav)。要在MacOSX上安装，请使用homebrew。
- en: After installing ClamAV, configure it to work with the network socket or Unix
    socket. To do this, we have to update the `clamd` configurations. You can find
    two configuration files in the `/etc/clamav/` folder for Linux, `c:\clamAV\` for
    Windows, and at `/usr/local/etc/clamav` for MacOSX. The files are as follows: `freshclam.conf` and
    `clamd.conf`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ClamAV后，配置它以与网络套接字或Unix套接字一起工作。为此，我们必须更新`clamd`配置。您可以在Linux的`/etc/clamav/`文件夹中找到两个配置文件，Windows的`c:\clamAV\`，以及MacOSX的`/usr/local/etc/clamav`。文件如下：`freshclam.conf`和`clamd.conf`。
- en: 'If you cannot find these configuration files, create them from sample config
    files, and update the database mirror URL in the `freshclam.conf` file. Freshclam
    will fetch the antivirus database updates, so we should immediately run it in
    order to get the initial database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到这些配置文件，请从示例配置文件创建它们，并在`freshclam.conf`文件中更新数据库镜像URL。Freshclam将获取防病毒数据库更新，因此我们应立即运行它以获取初始数据库：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After updating the database mirror, download the ClamAV database with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据库镜像后，使用以下命令下载ClamAV数据库：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enable the Unix socket or network socket in `clamd.conf`. To enable Unix socket,
    update `clamd.conf` with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clamd.conf`中启用Unix套接字或网络套接字。要启用Unix套接字，请使用以下内容更新`clamd.conf`：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can run the `clamd` daemon with `clamd` in a terminal window.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在终端窗口中使用`clamd`命令运行`clamd`守护程序。
- en: When installing `clamd` as a service in Windows, run the installer and let it
    install to the default location at `c:\clamav\`. Also, make sure you configure
    the Unix socket properly and that the location you specified in the `config` file
    exists.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中将`clamd`安装为服务时，请运行安装程序，并让其安装到默认位置`c:\clamav\`。还要确保正确配置Unix套接字，并且您在`config`文件中指定的位置存在。
- en: 'Then you can use `clamd` from the Python script. Import the `pyclamd` module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从Python脚本中使用`clamd`。导入`pyclamd`模块：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, try to connect to the `clamd` daemon with Unix socket and if it fails,
    try to connect with the network socket:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试使用Unix套接字连接到`clamd`守护程序，如果失败，则尝试使用网络套接字连接：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can confirm the code by printing the `clamd` version:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印`clamd`版本来确认代码：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, scan the file or folder for viruses:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，扫描文件或文件夹以查找病毒：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will output the details of virus signatures, if any are found.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现病毒签名，这将输出详细信息。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can get the full pyclamd documentation here: [http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处获取完整的pyclamd文档：[http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html)。
- en: OWASP ZAP from Python
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python中的OWASP ZAP
- en: '**OWASP ZAP** (**Zed Attack Proxy**) is an open-source, cross-platform web
    application security scanner written in Java, and is available in all the popular
    operating systems: Windows, Linux, and Mac OS X.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**OWASP ZAP**（**Zed Attack Proxy**）是一个开源的跨平台Web应用程序安全扫描器，用Java编写，并在所有流行的操作系统中都可用：Windows、Linux和Mac
    OS X。'
- en: OWASP ZAP provides a REST API, which allows us to write a script to communicate
    with Zap programmatically. We can use the `python-owasp-zap` module to access
    this API. The `python-owasp-zap-v2.4` module can be installed with pip.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP提供了一个REST API，允许我们编写脚本以编程方式与Zap通信。我们可以使用`python-owasp-zap`模块来访问此API。可以使用pip安装`python-owasp-zap-v2.4`模块。
- en: 'Start by loading the required modules:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先加载所需的模块：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the target to scan:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义要扫描的目标：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can instantiate the `zap` instance, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化`zap`实例，如下所示：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will instantiate a new instance with the assumption `zap` listens in the
    default port `8080`. If Zap listens a non-default port, then we have to pass the
    custom proxy settings as the parameters, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用假设`zap`在默认端口`8080`上监听来实例化一个新实例。如果Zap监听非默认端口，则必须将自定义代理设置作为参数传递，如下所示：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Set the target and start a session in `zap`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 设置目标并在`zap`中启动会话：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It would be better to wait for some time, so that the URL list gets updated
    in `zap`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最好等一段时间，以便URL列表在`zap`中得到更新：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can start the spidering task:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始爬虫任务：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can start a passive scan with the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令开始被动扫描：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we can use `pprint` to print the alerts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`pprint`来打印警报：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This gives us the alerts from `zap`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了来自`zap`的警报。
- en: Breaking weak captcha
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解弱验证码
- en: A **captcha** (**Completely Automated Public Turing test to tell Computers and
    Humans Apart**) is a type of challenge-response test to ensure that the response
    is generated by a human. It helps to prevent bots from sending spam, fraudulent
    registrations, fake sweepstakes entries, and so on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证码**（**Completely Automated Public Turing test to tell Computers and Humans
    Apart**）是一种挑战-响应测试，用于确保响应是由人类生成的。它有助于防止机器人发送垃圾邮件、欺诈性注册、虚假的抽奖参与等。'
- en: Many sites implement their own captcha, and in such cases we can get the captcha
    image from the source. This can be a link that generates an image with a new random
    digit every time we access the URL. Hence, to bypass the captcha, we need to get
    the random number or word in that image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站实施自己的验证码，在这种情况下，我们可以从源获取验证码图像。这可以是一个链接，每次访问URL时都会生成一个带有新随机数字的图像。因此，为了绕过验证码，我们需要获取该图像中的随机数字或单词。
- en: We have already learnt how to send the post requests automatically with Python.
    Here we can learn to get the random code from the image. We can use the `pytesseract`
    Python moduleto read the image with an **optical character reader** (**OCR**)
    engine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用Python自动发送post请求。在这里，我们可以学习如何从图像中获取随机代码。我们可以使用`pytesseract` Python模块来读取带有**光学字符识别**（**OCR**）引擎的图像。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can read more on pytesseract here to install it on your system: [https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处阅读更多关于pytesseract的内容，以在您的系统上安装它：[https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract)。
- en: 'As usual, we can import the required modules:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以导入所需的模块：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Download the captcha image and save it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下载验证码图像并保存：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Read the image with the OCR engine:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OCR引擎读取图像：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will print out the word in captcha. At times, it requires some image manipulations,
    according to the noise used in the captcha image. We can use `PIL` library features
    for this purpose. Here is an example for making the letters bold:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出验证码中的单词。有时，根据验证码图像中使用的噪音，需要进行一些图像操作。我们可以使用`PIL`库的功能来实现这一目的。以下是一个使字母加粗的示例：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Then, use this output image to feed the OCR engine. After getting the word in
    the captcha image, we can post the form with the captcha value filled in.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此输出图像来输入OCR引擎。在获取验证码图像中的单词后，我们可以填写验证码值并提交表单。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For better accuracy, we can train the OCR engine. To read more on training the
    Tesseract: [https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的准确性，我们可以训练OCR引擎。要了解有关训练Tesseract的更多信息：[https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract)。
- en: Automating BeEF with Python
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Python自动化BeEF
- en: '**Browser Exploitation Framework** (**BeEF**) is a security tool that advantages
    browser vulnerabilities to assess the security issues of the target. BeEF is a
    framework which provides client-side attack vectors for the security testers.
    Also, it allows us to select specific modules for each browser and context. This
    section will discuss how to use the REST API that is available with the framework
    to automate the tasks and its features.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器利用框架**（**BeEF**）是一种利用浏览器漏洞来评估目标安全问题的安全工具。BeEF是一个框架，为安全测试人员提供了客户端攻击向量。此外，它允许我们为每个浏览器和上下文选择特定的模块。本节将讨论如何使用框架提供的REST
    API自动化任务及其功能。'
- en: BeEF focuses on the context of customers using a JavaScript hook. It create
    a botnet that can be controlled from a control panel. When a user navigates a
    website which contains a hook, that browser will automatically become part of
    that botnet. Then an attacker can send instructions to a hook to perform tasks
    on the hooked web browser of the victim. This will give access to the basic information
    about the web browser, enable or disable plugins and extensions, or can force
    navigation to another website. As it is a  simple JavaScript file running in the
    context of the web page visited by the victim, closing this website including
    the hook will disconnect the browser from the botnet and thus solve the problems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF专注于使用JavaScript挂钩的客户端上下文。它创建一个可以从控制面板控制的僵尸网络。当用户浏览包含挂钩的网站时，该浏览器将自动成为该僵尸网络的一部分。然后，攻击者可以向挂钩发送指令，以执行受害者的挂钩Web浏览器上的任务。这将提供有关Web浏览器的基本信息，启用或禁用插件和扩展，或者可以强制导航到另一个网站。由于它是在受害者访问的网页上下文中运行的简单JavaScript文件，因此关闭包括挂钩在内的此网站将使浏览器与僵尸网络断开连接，从而解决问题。
- en: Installing BeEF
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装BeEF
- en: BeEF is developed in Ruby. So, it requires Ruby interpreter installed on your
    system. Usually, it is a bit difficult to work with multiple tools like BeEF and
    Metasploit as both are developed in Ruby  and use different versions of Ruby.
    So, it would be better to use **Ruby Version Manager** (**RVM**) to manage multiple
    versions of Ruby on your system.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF是用Ruby开发的。因此，它需要在您的系统上安装Ruby解释器。通常，使用BeEF和Metasploit等多个工具会有点困难，因为它们都是用Ruby开发的，并且使用不同版本的Ruby。因此，最好使用**Ruby版本管理器**（**RVM**）在您的系统上管理多个Ruby版本。
- en: You can have a look at the official website of RVM  here [https://rvm.io](https://rvm.io).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在RVM的官方网站上查看官方网站 [https://rvm.io](https://rvm.io)。
- en: It will help to make things easier and you'll save a lot of time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于使事情变得更容易，您将节省大量时间。
- en: 'To install BeEF, download the latest version of the project from GitHub using
    the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装BeEF，请使用以下命令从GitHub下载项目的最新版本：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then install the bundler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装bundler：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then install the BeEF:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装BeEF：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To run the BeEF  use the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行BeEF，请使用以下命令：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Installing BeEF](img/Capture.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![安装BeEF](img/Capture.jpg)'
- en: To manage multiple victims from a web interface is inefficient and tedious.
    BeEF has a REST API that helps to automate many tasks. To access this API it requires
    an API key which is generated by BeEF when it starts.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Web界面管理多个受害者是低效和繁琐的。BeEF有一个REST API，可以帮助自动化许多任务。要访问此API，需要一个API密钥，该密钥在BeEF启动时生成。
- en: '![Installing BeEF](img/4323OS_09_06.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![安装BeEF](img/4323OS_09_06.jpg)'
- en: Connecting BeEF with Metasploit
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接BeEF与Metasploit
- en: 'BeEF can be integrated with Metasploit and run exploits and payloads in hooked
    victim browsers. To use the Metasploit extension, we have to start the MSGRPC
    with the `msfrpcd` utility in the Metasploit framework as we done before. In addition
    to that, we have to enable the Metasploit extension available in the BeEF, to edit
    the master configuration file in the root of the BeEF folder (`config.yaml`) and
    enable Metasploit extensions in the `"extension"` section by changing:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF可以与Metasploit集成，并在挂钩的受害者浏览器中运行利用和有效载荷。要使用Metasploit扩展，我们必须在Metasploit框架中使用`msfrpcd`实用程序启动MSGRPC，如前所述。除此之外，我们还必须在BeEF中启用可用的Metasploit扩展，通过更改BeEF文件夹根目录中的主配置文件（`config.yaml`）中的“extension”部分来启用Metasploit扩展：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The main configuration file is ready to support the Metasploit extension and
    the MSGRPC service has started. Now, we have to update the extension settings
    to update connection details to the MSGRPC server. To do this, edit the configuration
    file of the Metasploit extension (`extensions/metasploit/config.xml`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 主配置文件已准备好支持Metasploit扩展，并且MSGRPC服务已启动。现在，我们必须更新扩展设置以更新连接详细信息到MSGRPC服务器。要做到这一点，编辑Metasploit扩展的配置文件（`extensions/metasploit/config.xml`）：
- en: '![Connecting BeEF with Metasploit](img/4323OS_09_07.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![连接BeEF与Metasploit](img/4323OS_09_07.jpg)'
- en: 'Now, we can start the BeEF. There will be an extra notification which indicates
    the number of  loaded Metasploit exploits if the connection is successful as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动BeEF。如果连接成功，将会有一个额外的通知，指示加载的Metasploit利用的数量如下：
- en: '![Connecting BeEF with Metasploit](img/Capture-2.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![连接BeEF与Metasploit](img/Capture-2.jpg)'
- en: Accessing BeEF API with Python
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python访问BeEF API
- en: The Rest API of BeEF has almost everything required to automate activities that
    can be done from the Wed UI. This API is not very complicated as it is only required
    to send HTTP requests with the correct parameters. So, it is possible to use Python
    to automate these HTTP requests using different libraries.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF的Rest API几乎包含了从Web UI执行的自动化活动所需的一切。这个API并不复杂，因为只需要发送带有正确参数的HTTP请求。因此，可以使用Python使用不同的库自动化这些HTTP请求。
- en: As we discussed in previous chapters, Python has many libraries for handling
    HTTP requests like  `urllib`, `urllib2`, `httplib`,  and `requests`. Here, we
    will use a simple library called BeEF-API written with the `requests` module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的，Python有许多处理HTTP请求的库，如`urllib`、`urllib2`、`httplib`和`requests`。在这里，我们将使用一个简单的库，称为BeEF-API，它是使用`requests`模块编写的。
- en: We can download the BeEF-API Python library from GitHub [https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API).
    To install it you only need to run the `setup.py` script with the parameter `install`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从GitHub [https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API)下载BeEF-API
    Python库。要安装它，只需运行带有参数`install`的`setup.py`脚本。
- en: 'Then, we can import the `BeefAPI` module and login to the BeEF-API:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入`BeefAPI`模块并登录到BeEF-API：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can list all the loaded modules with:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以列出所有加载的模块：
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can search the modules for a specific string with:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码搜索特定字符串的模块：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This will print all the modules with the string `firefox` in its name.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所有名称中包含字符串`firefox`的模块。
- en: 'We can run a module against one or more hooked browsers, for that we have to
    obtain the corresponding browser object and then run the module on it by specifying
    the identifier of the module to be used against the browser. Each hooked browse
    object has a method called `run` which receives a numeric value that represents
    the identifier of a module as an argument:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对一个或多个挂钩浏览器运行一个模块，为此我们必须获取相应的浏览器对象，然后通过指定要针对浏览器使用的模块的标识符在其上运行该模块。每个挂钩浏览器对象都有一个名为`run`的方法，该方法接收表示模块标识符的数值作为参数：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The module with the identifier `231` is the *replace videos* module. This module
    will rewrite all the href attributes of all the matched links. The `run` method
    will execute the specified module and return a structure in the `.json` format
    with an identifier (`command_id`) of the command, which will be subsequently used
    to obtain the results returned by the module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 具有标识符`231`的模块是*替换视频*模块。该模块将重写所有匹配链接的href属性。`run`方法将执行指定的模块，并以`.json`格式返回一个带有命令标识符(`command_id`)的结构，随后将用于获取模块返回的结果。
- en: Accessing Nessus 6 API with Python
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python访问Nessus 6 API
- en: Nessus is one of the popular vulnerability scanners developed by Tenable Network
    Security, which scans a computer and raises an alert if it discovers any vulnerabilities
    that an attacker could use to access any computer you have connected to a network.
    Nessus provides an API to access it programmatically. We can use any library to
    make HTTP requests, which abound in Python.  Tenable created a `python` library
    nessrest ([https://github.com/tenable/nessrest](https://github.com/tenable/nessrest))
    with the `requests`  module for using the Nessus 6  REST API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus是由Tenable Network Security开发的流行漏洞扫描器之一，它会扫描计算机，并在发现攻击者可能用来访问您连接到网络的任何计算机的漏洞时发出警报。Nessus提供了API以便以编程方式访问。我们可以使用Python中丰富的HTTP请求库来进行HTTP请求。Tenable创建了一个`python`库nessrest
    ([https://github.com/tenable/nessrest](https://github.com/tenable/nessrest))，其中使用了Nessus
    6的`requests`模块。
- en: 'To use this module in our Python script, import it as we did for other modules
    after installation. We can install the `nessrest` module with `pip`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的Python脚本中使用此模块，请在安装后导入它。我们可以使用`pip`安装`nessrest`模块：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, import it in our script:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的脚本中导入它：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can initialize the scanner, as we are running Nessus with a self-signed
    certificate, we have to disable SSL certificate checking. For that, pass another
    parameter `insecure=True` to the `Scanner` initializer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以初始化扫描器，因为我们正在使用自签名证书运行Nessus，所以我们必须禁用SSL证书检查。为此，将另一个参数`insecure=True`传递给`Scanner`初始化程序。
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To add and launch a scan, specify the target and run the scan:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加和启动扫描，请指定目标并运行扫描：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can get the scan results with:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取扫描结果：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To know more about services that are available in Nessus 6, you can check the
    documentation included in the Nessus installation `https://localhost:8834/nessus6-api.html`.
    You have to start a Nessus instance to see this documentation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Nessus 6中可用的服务，可以查看Nessus安装中包含的文档`https://localhost:8834/nessus6-api.html`。您必须启动Nessus实例才能查看此文档。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have gone through some of the libraries which can be used for security automation.
    Now we are ready to use these modules in our scripts. This will help us to automate
    many security tasks. We can also use the results from one script or tool to another,
    thus cascading the tools to automate pentesting.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些可用于安全自动化的库。现在我们准备在我们的脚本中使用这些模块。这将帮助我们自动化许多安全任务。我们还可以将一个脚本或工具的结果用于另一个，从而级联工具以自动化渗透测试。
- en: This book brings insight into the basic usage of Python and its related modules,
    which helps the reader to attain profound knowledge in Penetration Testing. The
    chapters cover the fundamental ideas of performing security testing with Python,
    in a nutshell. The reader can attain unprecedented heights in security testing
    with the help of the techniques and resources presented in this book. The power
    of Python is yet to be harnessed in its entirety. Its outreach in security testing
    is broad, and we leave the reader at a crossroads, to explore this in more depth.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本书深入探讨了Python及其相关模块的基本用法，帮助读者在渗透测试方面获得深入的知识。本书的章节概括了使用Python进行安全测试的基本思想。读者可以借助本书中介绍的技术和资源在安全测试方面取得前所未有的成就。Python的潜力尚未完全发挥。它在安全测试中的影响广泛，我们让读者自行探索更深入的内容。
