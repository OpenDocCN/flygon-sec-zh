# 第七章。加密，哈希和转换函数

密码学可以在某些类型的信息安全漏洞中发挥重要作用，因为它有助于实现单向安全交付认证数据，认证令牌的安全交付，访问控制等。单向密码函数用于网站中以一种无法检索的方式存储密码。在本章中，我们将讨论 Python 中的各种密码函数。

本章涵盖的主题如下：

+   哈希函数

+   秘密密钥（加密算法）

+   公钥算法

# 密码算法

以下三种类型的密码算法最常用：

+   **哈希函数**：哈希函数也被称为**单向加密**，没有密钥。哈希函数为明文输入输出固定长度的哈希值，不可能恢复明文的长度或内容。

+   **密钥哈希函数**：密钥哈希用于构建**消息认证码**（**MACs**）；MAC 旨在防止暴力攻击。因此，它们被故意设计成缓慢的。

+   **对称加密/秘密密钥（加密算法）**：加密算法使用可变密钥为一些文本输入输出密文，我们可以使用相同的密钥解密密文。

+   **公钥算法**：对于公钥算法，我们有两个不同的密钥：一个用于加密，另一个用于解密。因此，我们可以共享可以加密消息的公钥，但只能使用未共享的解密密钥解密。

# 哈希函数

哈希函数主要用于加密学中检查消息的完整性，数字签名，操作检测，指纹和密码存储。如果根据输出无法猜测输入字符串，则函数是一个好的哈希函数。由于哈希函数将随机数量的数据转换为固定长度的字符串，可能会有一些输入哈希为相同的字符串。哈希函数被创建为使这些碰撞极其难以找到。最常用的哈希函数如下：

![哈希函数](img/image_07_001.jpg)

**MD2**，**MD4**和**MD5**具有**128 位**长度，不安全。**SHA-1**具有**160 位**长度，但也不安全。

## 哈希消息认证码（HMAC）

**哈希消息认证码**（**HMAC**）在需要检查*完整性*和*真实性*时使用。它为服务器和客户端提供公钥和私钥。私钥只为服务器和客户端所知，但公钥为所有人所知。

在 HMAC 的情况下，密钥和消息在单独的步骤中被哈希。客户端通过将数据与私钥合并并哈希来为每个请求创建一个哈希，并将其作为请求的一部分发送。在服务器接收到请求后，它生成另一个哈希并将其与接收到的哈希进行比较。如果它们相等，那么我们可以认为客户端是真实的。

## 消息摘要算法（MD5）

MD5 用于通过 128 位消息摘要来保持数据完整性。根据标准，由于两条消息可能具有相同的消息摘要作为输出，或者可能创建一个错误的消息，因此这是*计算上不可行*的。

## 安全哈希算法（SHA）

**SHA**系列在安全应用和协议中被广泛使用，包括 TLS/SSL，PGP 和 SSH。SHA-1 用于版本控制系统，如 Git 和 Mercurial，用于标识修订版本和检测数据损坏。有关 SHA-0 和 SHA-1 报告了一些弱点。因此，建议使用 SHA-2 系列的哈希函数。我们应该在需要抗碰撞的应用程序上使用 SHA-2 系列。

## Python 中的 HMAC

使用 Python 简单地创建文件的哈希。要使用默认的 MD5 算法创建 HMAC 哈希，我们可以使用 Python 中的`hmac`模块：

```py
import hmac 

hmac_md5 = hmac.new('secret-key') 

f = open('sample-file.txt', 'rb') 
try: 
    while True: 
        block = f.read(1024) 
        if not block: 
            break 
        hmac_md5.update(block) 
finally: 
    f.close() 

digest = hmac_md5.hexdigest() 
print digest 

```

第一行导入了`hmac`模块。`hmac`模块从 Python 2.2 开始默认包含在 Python 安装中。然后，使用共享的密钥作为参数启动`hmac`实例。

然后以 1024 字节块读取文件并创建`digest`，最后打印`digest`。

尽管默认的`hmac`模块 Python 的加密算法是 MD5，被认为是不安全的，我们应该使用 SHA 算法。要使用 SHA256，我们必须使用`hashlib`模块。从 Python 2.5 版本开始，`hashlib`随默认 Python 安装。因此，我们可以更新前面的脚本以使用 SHA256：

```py
import hmac 
import hashlib 

digest_maker = hmac.new('secret-key', '', hashlib.sha256) 

f = open('sample-file.txt', 'rb') 
try: 
    while True: 
        block = f.read(1024) 
        if not block: 
            break 
        digest_maker.update(block) 
finally: 
    f.close() 

digest = digest_maker.hexdigest() 
print digest 

```

同样，我们可以在`hmac`中包含其他`hashlib`方法。

## hashlib 算法

要使用特定的哈希算法，我们可以使用`hashlib`模块中的适当构造函数创建哈希对象，该对象可用于与哈希进行交互。`hashlib`模块由 OpenSSL 支持，因此`hashlib`中的所有算法，如`md5`、`sha1`、`sha224`、`sha256`、`sha384`和`sha512`都可用。

![hashlib 算法](img/image_07_002.jpg)

以下是重要的`hashlib`方法：

+   `hashlib.md5()`: 创建 MD5 哈希对象

+   `hashlib.sha1()`: 创建 SHA1 哈希对象

+   `hashlib.new(hash_name)`: 通过名称传递算法以创建哈希对象

例如，尝试以下代码：

```py
try: 
    hash_name = sys.argv[1] 
except IndexError: 
    print 'Specify the hash name as the first argument.' 
else: 
    try: 
        data = sys.argv[2] 
    except IndexError:     
        print 'Specify the data to hash as the second argument.' 
h = hashlib.new(hash_name) 

```

这将创建一个哈希对象，该对象使用我们作为第一个参数传递的哈希算法名称。方法`update()`将重复调用哈希计算器并相应地更新摘要。

## 密码哈希算法

MD5、SHA1 和所有 SHA 变种都旨在非常快速。在密码的情况下，快速算法容易受到暴力破解攻击的影响，因为 MD5 和 SHA1 的哈希可以以每秒数百万或数十亿的速度产生。有一些专门设计用于密码的算法。我们可以使用 Argon2，并在可用时将其视为首选。另外两个主要选项是`pbkdf2`和`bcrypt`。这些函数计算成本很高，因此可以保护您免受暴力破解和字典攻击。

我们可以使用`argon2`模块来使用 Argon2：

```py
import argon2 
hashed = argon2.argon2_hash("password", "some_salt", ) 

```

此外，我们可以使用模块`bcrypt`和`pbkdf2`来使用这些算法。

使用`bcrypt`的示例如下：

```py
import bcrypt 
hashed = bcrypt.hashpw(password, bcrypt.gensalt()) 

```

这将使用随机生成的盐对密码进行哈希处理。

使用`pbkdf2`的示例如下：

```py
import pbkdf2 
salted_password = pbkdf2.pbkdf2_hex(password, some_random_salt, 
                                  iterations=1000, keylen=24)

```

这将使用`1000`次迭代创建一个 24 字节长的哈希。我们可以通过增加迭代次数来减慢哈希函数的速度。

## 对称加密算法

对称加密算法，或称为秘密密钥算法，使用私有变量密钥将其输入数据或明文转换为密文。我们可以使用相同的密钥解密密文，该密钥用于加密消息。密码是一种简单的加密和解密消息的方法。

加密算法主要分为两类：

+   **对称加密中使用的算法**：对称加密是一种同时用于加密和解密的单一密钥。一些对称加密算法的示例包括 AES、Blowfish、DES、IDEA、serpent 等。

+   **非对称加密中使用的算法**：非对称加密使用两个密钥：私钥和公钥——一个用于加密，另一个用于解密。非对称算法的示例包括 Diffe-Hellman（**DH**）和**RSA**。

### 提示

您可以在这里阅读更多关于对称加密的内容：[`www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html`](http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html)。

### 块和流密码

**分组密码**加密已知为块的固定大小数据。通常，每个块的大小相对较大，为 64 位、128 位或 256 位。因此，分组密码将每个块分别加密到与密文相同大小。在输入位较短于块大小的情况下，会调用填充方案。每个块都使用相同的密钥。分组密码的例子包括 AES、DES、Blowfish 和 IDEA。

**流密码**一次加密一位或一字节的小块明文。它使用无限的伪随机位流作为密钥，这个伪随机生成器应该是不可预测的。此外，为了以安全的方式实现流密码，密钥不应该被重复使用。

## PyCrypto

**PyCrypto**，全称**Python 密码学工具包**，是一个包含哈希函数和加密算法的不同加密模块的集合。PyCrypto 模块提供了在 Python 程序中实现强加密所需的所有函数。

要使用加密算法，我们可以从`Crypto.Cipher`中导入它：

```py
from Crypto.Cipher import AES 
encrypt_AES = AES.new('secret-key-12345', AES.MODE_CBC, 'This is an IV456') 
message = "This is message " 
ciphertext = encrypt_AES.encrypt(message) 
print ciphertext 

```

这将创建密文。由于 PyCrypto 块级加密 API 非常低级，它只接受 16、24 或 32 字节长的密钥用于 AES-128、AES-196 和 AES-256，分别。密钥越长，加密越强。我们可以按以下方式解密它：

```py
decrypt_AES = AES.new('secret-key-12345', AES.MODE_CBC, 'This is an IV456') 
message_decrypted =  decrypt_AES.decrypt(ciphertext) 
print message_decrypted 

```

现在我们将得到我们的明文。

### 文件的 AES 加密

**高级加密标准**（**AES**）是一种对称分组密码，由三种分组密码组成：AES-128、AES-192 和 AES-256。每个加密/解密数据的块大小为 128 位，密钥分别为 128、192 和 256 位。

以下脚本加密所提供的文件。此外，它处理**初始化向量**（**IV**）的随机生成。

首先加载所有所需的模块：

```py
from Crypto.Cipher import AES 
import os, random, struct 

```

现在，定义加密文件的函数：

```py
def encrypt_file(key, filename, chunk_size=64*1024): 

    output_filename = filename + '.encrypted' 

```

在函数内部创建初始化向量：

```py
iv = ''.join(chr(random.randint(0, 0xFF)) for i in range(16))
# Initialization vector  

```

然后我们可以在 PyCrypto 模块中初始化 AES 加密方法：

```py
    encryptor = AES.new(key, AES.MODE_CBC, iv) 
    filesize = os.path.getsize(filename)  

```

读取文件并写入加密输出文件：

```py
     with open(filename, 'rb') as inputfile: 
        with open(output_filename, 'wb') as outputfile: 
            outputfile.write(struct.pack('<Q', filesize)) 
            outputfile.write(iv) 

            while True: 
                chunk = inputfile.read(chunk_size) 
                if len(chunk) == 0: 
                    break 
                elif len(chunk) % 16 != 0: 
                    chunk += ' ' * (16 - len(chunk) % 16) 

                outputfile.write(encryptor.encrypt(chunk)) 

```

最后，调用函数加密文件：

```py
encrypt_file('abcdefghji123456', 'sample-file.txt');

```

现在我们可以检查如何解密这个加密文件。要编写一个可以解密的函数，我们必须导入相同的模块。然后，定义函数如下：

```py
def decrypt_file(key, filename, chunk_size=24*1024): 

    output_filename = os.path.splitext(filename)[0] 

```

读取加密文件并输出解密文件：

```py
    with open(filename, 'rb') as infile: 
        origsize = struct.unpack('<Q', infile.read(struct.calcsize('Q')))[0] 
        iv = infile.read(16)

```

初始化`decryptor`方法以解密文件：

```py
        decryptor = AES.new(key, AES.MODE_CBC, iv) 

        with open(output_filename, 'wb') as outfile: 
            while True: 
                chunk = infile.read(chunk_size) 
                if len(chunk) == 0: 
                    break 
                outfile.write(decryptor.decrypt(chunk)) 

            outfile.truncate(origsize) 

```

最后，输出原始解密文件：

```py
decrypt_file('abcdefghji123456', 'sample-file.txt.encrypted'); 

```

# 摘要

我们已经讨论了 Python 中使用的哈希和加密模块。现在您将能够在您的脚本中使用这些模块。我们将在下一章中讨论一些键盘记录技术。
