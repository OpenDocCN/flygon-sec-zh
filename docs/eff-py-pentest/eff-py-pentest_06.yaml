- en: Chapter 6. Debugging and Reverse Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。调试和逆向工程
- en: Debuggers are the main tools used for reverse engineering. With debuggers, we
    can perform analysis at runtime to understand the program. We can identify the
    call chains and track indirect calls. With debuggers, we can analyze and watch
    program runtime to guide our reverse engineering. In this chapter, we'll learn
    how to use debuggers in our scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是逆向工程中使用的主要工具。使用调试器，我们可以在运行时执行分析以了解程序。我们可以识别调用链并跟踪间接调用。使用调试器，我们可以分析和监视程序运行时，以指导我们的逆向工程。在本章中，我们将学习如何在脚本中使用调试器。
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Portable executable analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植可执行文件分析
- en: Disassembling with Capstone
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Capstone进行反汇编
- en: PEfile with Capstone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Capstone的PE文件
- en: Debugging using PyDBG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyDBG进行调试
- en: Reverse engineering
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程
- en: 'There are three main kinds of reverse engineering analysis:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程分析主要有三种类型：
- en: '**Static analysis**: Analysis of the contents of a binary file. This helps
    to determine the structure of the executable portions and print out readable portions
    to get more details about the purpose of the executable.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分析**：分析二进制文件的内容。这有助于确定可执行部分的结构，并打印出可读部分，以获取有关可执行文件目的的更多细节。'
- en: '**Dynamic analysis**: This type will execute the binary with or without attaching
    a debugger to discover what the purpose is and how the executable works.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态分析**：这种类型将执行二进制文件，无论是否附加调试器，以发现其目的和可执行文件的工作方式。'
- en: '**Hybrid analysis**: This is a mixture of static and dynamic analysis. Repeating
    between static analyses, followed by a dynamic debugging, will give better intuition
    about the program.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合分析**：这是静态和动态分析的混合。在静态分析之间重复，然后进行动态调试，将更好地了解程序。'
- en: Portable executable analysis
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植可执行文件分析
- en: Any UNIX or Windows binary executable file will have a header to describe its
    structure. This includes the base address of its code, data sections, and a list
    of functions that can be exported from the executable. When an executable file
    is executed by the operating system, first of all the operating system reads its
    header information and then loads the binary data from the binary file to populate
    the contents of the code and data sections of the address for the corresponding
    process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何UNIX或Windows二进制可执行文件都将具有描述其结构的头部。这包括其代码的基地址、数据部分和可以从可执行文件中导出的函数列表。当操作系统执行可执行文件时，首先操作系统读取其头部信息，然后加载二进制数据从二进制文件中以填充相应进程的代码和数据部分的地址内容。
- en: A **Portable Executable** (**PE**) file is the file type that a Windows operating
    system can execute or run. The files that we run on Windows systems are Windows
    PE files; these can have EXE, DLL (Dynamic Link Library), and SYS (Device Driver)
    extensions. Also, they contain the PE file format.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**可移植可执行文件**（**PE**）文件是Windows操作系统可以执行或运行的文件类型。我们在Windows系统上运行的文件是Windows PE文件；这些文件可以具有EXE、DLL（动态链接库）和SYS（设备驱动程序）扩展名。此外，它们包含PE文件格式。'
- en: 'Binary executable files on Windows have the following structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的二进制可执行文件具有以下结构：
- en: DOS Header (64 bytes)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOS头部（64字节）
- en: PE Header
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE头部
- en: Sections (code and data)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分（代码和数据）
- en: We will now examine each of them in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细研究每一种。
- en: DOS header
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOS头部
- en: The DOS Header starts with the magic numbers `4D 5A 50 00` (the first two bytes
    are the letters `MZ`), and the last four bytes (`e_lfanew`) indicates the location
    of the PE header in the binary executable file. All other fields are not relevant.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DOS头部以魔术数字`4D 5A 50 00`开头（前两个字节是字母`MZ`），最后四个字节（`e_lfanew`）指示二进制可执行文件中PE头部的位置。所有其他字段都不相关。
- en: PE header
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PE头部
- en: 'The PE header contains more interesting information. The following is the structure
    of the PE header:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PE头部包含更多有趣的信息。以下是PE头部的结构：
- en: '![PE header](img/image_06_001-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![PE头部](img/image_06_001-2.jpg)'
- en: 'The PE header consists of three parts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PE头部由三部分组成：
- en: 4-byte magic code
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4字节的魔术代码
- en: 20-byte file header, whose data type is **IMAGE_FILE_HEADER**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20字节的文件头，其数据类型为**IMAGE_FILE_HEADER**
- en: 224-byte optional header, whose data type is **IMAGE_OPTIONAL_HEADER32**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 224字节的可选头，其数据类型为**IMAGE_OPTIONAL_HEADER32**
- en: Also, the optional header has two parts. The first 96 bytes contain information
    such as major operating systems and entry point. The second part consists of 16
    entries with 8 bytes in each entry, to form a data directory of 128 bytes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可选头部有两部分。前96字节包含诸如主要操作系统和入口点之类的信息。第二部分由16个条目组成，每个条目有8个字节，形成128字节的数据目录。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about PE files at: [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) and 
    structures used within the file headers at: [http://msdn2.microsoft.com/en-gb/library/ms680198.aspx](http://msdn2.microsoft.com/en-gb/library/ms680198.aspx).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于PE文件的信息：[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) 以及文件头中使用的结构：[http://msdn2.microsoft.com/en-gb/library/ms680198.aspx](http://msdn2.microsoft.com/en-gb/library/ms680198.aspx)。
- en: We can use the `pefile` module (a multi-platform full Python module intended
    for handling PE files) to get all the details of these file headers in Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pefile`模块（一个用于处理PE文件的多平台全功能Python模块）在Python中获取这些文件头的所有细节。
- en: Loading PE file
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载PE文件
- en: Loading a file is as simple as creating an instance of the PE class in the module
    with the path to the executable as the argument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 加载文件就像在模块中创建PE类的实例一样简单，参数是可执行文件的路径。
- en: 'First, import the module `pefile`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入`pefile`模块：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initiate the instance with the executable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可执行文件初始化实例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inspecting headers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查头部
- en: In an interactive terminal, we can do a basic inspection of PE file headers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式终端中，我们可以对PE文件头进行基本检查。
- en: 'As usual, import the `pefile` and load the executable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，导入`pefile`并加载可执行文件：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print the object. To better understand, we can use the `pprint` module
    to print this object in a readable format:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印对象。为了更好地理解，我们可以使用`pprint`模块以可读格式打印此对象：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will list all in a readable format, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以可读格式列出所有内容，如下所示：
- en: '![Inspecting headers](img/image_06_002-2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![检查标头](img/image_06_002-2.jpg)'
- en: 'We can also print the contents of a specific header as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以打印特定标头的内容，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can get the hex value of each header with hex():'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用hex()获取每个标头的十六进制值：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inspecting sections
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查节
- en: 'To inspect sections in the executable, we have to iterate `pe.sections`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查可执行文件中的节，我们必须迭代`pe.sections`：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PE packers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PE打包器
- en: '**Packers** are the tools used to compress PE files. This will reduce the size
    of the file as well as adding another layer of obfuscation to the file being reverse
    engineered statically. Even though packers were created to decrease the overall
    file size of executables, later, the benefits of obfuscation were used by many
    malware authors. Packers wrap the compressed data inside a working PE file structure
    and decompress the PE file data into memory, and run it while executing.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包器**是用于压缩PE文件的工具。这将减小文件的大小，并为被静态反向工程的文件添加另一层混淆。尽管打包器是为了减小可执行文件的总体文件大小而创建的，但后来，许多恶意软件作者利用了混淆的好处。打包器将压缩的数据包装在一个工作的PE文件结构中，并将PE文件数据解压缩到内存中，并在执行时运行它。'
- en: We can use signature databases to detect the packer used if the executable is
    packed. Signature database files can be found by searching the Internet.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用签名数据库来检测可执行文件是否被打包。可以通过搜索互联网找到签名数据库文件。
- en: For this we require another module, `peutils`, which comes with the `pefile`
    module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要另一个模块`peutils`，它与`pefile`模块一起提供。
- en: 'You can load the signature database from a local file or from a URL:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本地文件或URL加载签名数据库：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下内容：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After loading the signature database, we can run the PE instance with this
    database to identify the signature for the packer used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加载签名数据库后，我们可以使用这个数据库运行PE实例，以识别使用的打包器的签名：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will output the possible packer used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出可能使用的打包器。
- en: Also, if we check the section names in the packed executable, they will have
    a slight difference. For example, an executable which is packed with UPX, its
    section names will be `UPX0`, `UPX1`, and so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我们检查打包的可执行文件中的节名称，它们将有轻微的差异。例如，使用UPX打包的可执行文件，其节名称将是`UPX0`，`UPX1`等。
- en: Listing all imported and exported symbols
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有导入和导出的符号
- en: 'The imports can be listed as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 导入项可以列出如下：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Likewise, we can''t list the exports:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们无法列出导出项：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Disassembling with Capstone
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Capstone进行反汇编
- en: '**Disassembling** is the opposite process of assembling. Disassemblers try
    to create the assembly code from the binary machine code. For this, we are using
    a Python module named **Capstone**. Capstone is a free, multiplatform and multi-architecture
    disassembler engine.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编**是组装的相反过程。反汇编器试图从二进制机器代码创建汇编代码。为此，我们使用一个名为**Capstone**的Python模块。Capstone是一个免费的、多平台和多架构的反汇编引擎。'
- en: After installation, we can use this module in our Python scripts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以在我们的Python脚本中使用这个模块。
- en: 'First, we need to run a simple test script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要运行一个简单的测试脚本：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the script will be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出将如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first line imports the module, then initiates the `capstone` Python class
    with `Cs`, which takes two arguments: hardware architecture and hardware mode.
    Here we instruct to disassemble 64 bit code for x86 architecture.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入模块，然后使用`Cs`初始化`capstone` Python类，它需要两个参数：硬件架构和硬件模式。在这里，我们指示对x86架构的64位代码进行反汇编。
- en: The next line iterates the code list and passes the code to the `disasm()` in
    the `capstone` instance `cs`. The second parameter for `disasm()` is the address
    of the first installation. The output of `disasm()` is a list of installations
    of type `Cslnsn`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行迭代代码列表，并将代码传递给`capstone`实例`cs`中的`disasm()`。`disasm()`的第二个参数是第一个安装的地址。`disasm()`的输出是`Cslnsn`类型的安装列表。
- en: Finally, we print out some of this output. `Cslnsn` exposes all internal information
    about the disassembled installations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出一些这些输出。`Cslnsn`公开了有关已反汇编安装的所有内部信息。
- en: 'Some of these are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些如下：
- en: '**Id**: Instruction ID of the instruction'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Id**：指令的指令ID'
- en: '**Address**: Address of the instruction'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：指令的地址'
- en: '**Mnemonic**: Mnemonic of the instruction'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**助记符**：指令的助记符'
- en: '**op_str**: Operand of the instruction'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op_str**：指令的操作数'
- en: '**size**: Size of the instruction'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**size**：指令的大小'
- en: '**byte**: The byte sequence of the instruction'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节**：指令的字节序列'
- en: Like this, we can disassemble binary files with Capstone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样，我们可以使用Capstone反汇编二进制文件。
- en: PEfile with Capstone
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Capstone的PEfile
- en: Next, we use the `capstone` disassembler to disassemble the code we extracted
    with `pefile` to get the assemble code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`capstone`反汇编器对我们使用`pefile`提取的代码进行反汇编，以获取组装代码。
- en: 'As usual, we start by importing the required modules. Here, these are `capstone`
    and `pefile`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先导入所需的模块。在这里，这些是`capstone`和`pefile`：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AddressofEntryPoint` value within the `IMAGE_OPTIONAL_HEADER` is the pointer
    to the entry point function relative to the image base address. In the case of
    executable files, this is the exact point where the code of the application begins.
    So, we get the starting of the code with the help of `pefile` as `pe.OPTIONAL_HEADER.AddressOfEntryPoint` 
    and pass this to the disassembler.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE_OPTIONAL_HEADER`中的`AddressofEntryPoint`值是相对于图像基地址的入口点函数的指针。对于可执行文件，这是应用程序代码开始的确切位置。因此，我们使用`pefile`获取代码的起始位置，如`pe.OPTIONAL_HEADER.AddressOfEntryPoint`，并将其传递给反汇编器。'
- en: Debugging
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Debugging is the process of fixing bugs in a program. Debuggers are those programs
    that can run and watchdog the execution of another program. So, the debugger can
    have control over the execution of the target program and can monitor or alter
    the memory and variables of the targeted program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是修复程序中的错误的过程。调试器是可以运行并监视另一个程序执行的程序。因此，调试器可以控制目标程序的执行，并监视或更改目标程序的内存和变量。
- en: Breakpoints
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: Breakpoints help to stop the execution of the target program within the debugger
    at a location where we choose. At that time, execution stops and control is passed
    to the debugger.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有助于在调试器中选择的位置停止目标程序的执行。在那时，执行停止并控制传递给调试器。
- en: 'Breakpoints come in two different forms:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有两种不同的形式：
- en: '**Hardware Breakpoints**: Hardware breakpoints require hardware support from
    the CPU. They use special debug registers. These registers contain the breakpoint
    addresses, control information, and breakpoint type.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件断点**：硬件断点需要CPU的硬件支持。它们使用特殊的调试寄存器。这些寄存器包含断点地址、控制信息和断点类型。'
- en: '**Software Breakpoints**: A software breakpoint replaces the original instruction
    with an instruction that traps the debugger. This can only break on execution.
    The main difference between them is that hardware breakpoints can be set on memory.
    But, software breakpoints cannot be set on memory.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件断点**：软件断点用一个陷阱调试器的指令替换原始指令。这只能在执行时中断。它们之间的主要区别是硬件断点可以设置在内存上。但是，软件断点不能设置在内存上。'
- en: Using PyDBG
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyDBG
- en: We can use the PyDBG module to debug executables in run time. We can go through
    a basic script with PyDBG to understand how it works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PyDBG模块在运行时调试可执行文件。我们可以通过一个基本的PyDBG脚本来了解它的工作原理。
- en: 'First, we import the modules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入模块：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we define a function to handle the breakpoint. Also, it takes the `pydbg`
    instance as the argument. Inside this function, it prints out the execution context
    of the process and instructs `pydbg` to continue:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个处理断点的函数。它也将`pydbg`实例作为参数。在这个函数内部，它打印出进程的执行上下文，并指示`pydbg`继续执行：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we initialize the `pydbg` instance and set the `handler_breakpoint` function
    to handle the breakpoint exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们初始化`pydbg`实例，并设置`handler_breakpoint`函数来处理断点异常：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then attach the process ID of the process which we need to debug using `pydbg`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后附加需要使用`pydbg`调试的进程的进程ID：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next we will set the address at which to trigger the breakpoint. Here, we use
    `bp_set()` function, which accepts three arguments. The first is the address at
    which to set the breakpoint, the second is an optional description, and the third
    argument indicates whether `pydbg` restores this breakpoint:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将设置触发断点的地址。在这里，我们使用`bp_set()`函数，它接受三个参数。第一个是设置断点的地址，第二个是可选的描述，第三个参数指示`pydbg`是否恢复此断点：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, start `pydbg` in the event loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在事件循环中启动`pydbg`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we pass the breakpoint as an argument to this script. So,
    we can run this script as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将断点作为参数传递给这个脚本。所以，我们可以按照以下方式运行这个脚本：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`pydbg` contains many other useful functionalities that can be found in the
    documentation at: [http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html](http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`pydbg`包含许多其他有用的功能，可以在文档中找到：[http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html](http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html)。'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have discussed the basic tools that can be used to programmatically reverse
    engineer and debug binary files with Python. Now you will be able to write custom
    scripts to debug and reverse engineer the executables, which will help in malware
    analysis. We will discuss some crypto, hash, and conversion functions with Python
    in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了可以用Python编程逆向工程和调试二进制文件的基本工具。现在你将能够编写自定义脚本来调试和逆向工程可执行文件，这将有助于恶意软件分析。我们将在下一章讨论一些Python中的加密、哈希和转换函数。
