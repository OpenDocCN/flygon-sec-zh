- en: Chapter 7. Crypto, Hash, and Conversion Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。加密，哈希和转换函数
- en: Cryptography can play an important role in certain types of information security
    vulnerability, as it helps to implement secure delivery of authenticating data
    in one direction, secure delivery of the authentication token, access control,
    and much more. One-way cryptographic functions are used in websites to store passwords
    in a manner that they cannot be retrieved. In this chapter, we will discuss various
    cryptographic functions in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学可以在某些类型的信息安全漏洞中发挥重要作用，因为它有助于实现单向安全交付认证数据，认证令牌的安全交付，访问控制等。单向密码函数用于网站中以一种无法检索的方式存储密码。在本章中，我们将讨论Python中的各种密码函数。
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Hash functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数
- en: Secret key (Encryption algorithms)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密密钥（加密算法）
- en: Public key algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥算法
- en: Cryptographic algorithms
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码算法
- en: 'The following three types of cryptography algorithms are used most often:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三种类型的密码算法最常用：
- en: '**Hash functions**: Hash functions are also known as **one-way encryption**,
    and have no key. A hash function outputs a fixed-length hash value for plaintext
    inputs, and it''s impossible to recover the length or content of the plaintext.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希函数**：哈希函数也被称为**单向加密**，没有密钥。哈希函数为明文输入输出固定长度的哈希值，不可能恢复明文的长度或内容。'
- en: '**Keyed hash functions**: Keyed hashing is used to build **message authentication
    codes** (**MACs**); MACs are intended to prevent brute-force attacks. So, they
    are intentionally designed to be slow.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥哈希函数**：密钥哈希用于构建**消息认证码**（**MACs**）；MAC旨在防止暴力攻击。因此，它们被故意设计成缓慢的。'
- en: '**Symmetric encryption / Secret key (Encryption algorithms)**: Encryption algorithms
    output a ciphertext for some text inputs using a variable key and, we can decrypt
    the ciphertext using the same key.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密/秘密密钥（加密算法）**：加密算法使用可变密钥为一些文本输入输出密文，我们可以使用相同的密钥解密密文。'
- en: '**Public key algorithms**: For public key algorithms, we have two different
    keys: one for encryption and the other to decrypt. So, we can share the public
    key that can encrypt the message, but it can only be decrypted using the decrypt
    key, which is not shared.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥算法**：对于公钥算法，我们有两个不同的密钥：一个用于加密，另一个用于解密。因此，我们可以共享可以加密消息的公钥，但只能使用未共享的解密密钥解密。'
- en: Hash functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: 'Hash functions are mainly used in cryptography to check the integrity of messages,
    digital signatures, manipulation detection, fingerprints, and password storage.
    A function is a good hash function if the input string cannot be guessed based
    on the output. As hash functions convert random amounts of data to fixed-length
    strings, there may be some inputs that hash into the same string. Hash functions
    are created in such a way as to make these collisions extremely difficult to find.
    The most used hash functions are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数主要用于加密学中检查消息的完整性，数字签名，操作检测，指纹和密码存储。如果根据输出无法猜测输入字符串，则函数是一个好的哈希函数。由于哈希函数将随机数量的数据转换为固定长度的字符串，可能会有一些输入哈希为相同的字符串。哈希函数被创建为使这些碰撞极其难以找到。最常用的哈希函数如下：
- en: '![Hash functions](img/image_07_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![哈希函数](img/image_07_001.jpg)'
- en: '**MD2**, **MD4**, and **MD5** have **128-bits** length and are not secure.
    **SHA-1** has **160-bits** length, but it is also not secure.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**MD2**，**MD4**和**MD5**具有**128位**长度，不安全。**SHA-1**具有**160位**长度，但也不安全。'
- en: Hashed Message Authentication Code (HMAC)
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希消息认证码（HMAC）
- en: '**Hashed Message Authentication Code** (**HMAC**) is used when we need to check
    for *integrity* and *authenticity*. It provides both server and client with a
    public key and a private key. The private key is only known to the server and
    client, but the public key is known to all.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希消息认证码**（**HMAC**）在需要检查*完整性*和*真实性*时使用。它为服务器和客户端提供公钥和私钥。私钥只为服务器和客户端所知，但公钥为所有人所知。'
- en: In the case of HMAC, the key and the message are hashed in separate steps. The
    client creates a hash per request by merging and hashing the data along with the
    private key and sends this as part of the request. After receiving the request
    in the server, it generates another hash and compares it with the one received.
    If they are equal, then we can consider that the client is authentic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在HMAC的情况下，密钥和消息在单独的步骤中被哈希。客户端通过将数据与私钥合并并哈希来为每个请求创建一个哈希，并将其作为请求的一部分发送。在服务器接收到请求后，它生成另一个哈希并将其与接收到的哈希进行比较。如果它们相等，那么我们可以认为客户端是真实的。
- en: Message-digest algorithm (MD5)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息摘要算法（MD5）
- en: MD5 is used for data integrity through 128-bit message digest from data. According
    to the standard, it is *computationally infeasible*, as two messages may have
    the same message digest as the output or may create a false message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MD5用于通过128位消息摘要来保持数据完整性。根据标准，由于两条消息可能具有相同的消息摘要作为输出，或者可能创建一个错误的消息，因此这是*计算上不可行*的。
- en: Secure Hash Algorithm (SHA)
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全哈希算法（SHA）
- en: '**SHA** series is widely used in security applications and protocols, including
    TLS/SSL, PGP, and SSH. SHA-1 is used in version-control systems like Git and Mercurial
    to identify revisions and to detect data corruption. There are some weaknesses
    reported for SHA-0 and SHA-1\. So, the SHA-2 family of hash functions is recommended.
    We should use the SHA-2 family on applications that require collision resistance.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHA**系列在安全应用和协议中被广泛使用，包括TLS/SSL，PGP和SSH。SHA-1用于版本控制系统，如Git和Mercurial，用于标识修订版本和检测数据损坏。有关SHA-0和SHA-1报告了一些弱点。因此，建议使用SHA-2系列的哈希函数。我们应该在需要抗碰撞的应用程序上使用SHA-2系列。'
- en: HMAC in Python
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的HMAC
- en: 'Creating the hash of a file is simple with Python. To create a HMAC hash with
    the default MD5 algorithm, we can use the `hmac` module in Python:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python简单地创建文件的哈希。要使用默认的MD5算法创建HMAC哈希，我们可以使用Python中的`hmac`模块：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line imports the `hmac` module. The `hmac` module comes with default
    Python installation starting from Python 2.2\. Then, start the `hmac` instance
    with the shared secret key as the parameter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了`hmac`模块。`hmac`模块从Python 2.2开始默认包含在Python安装中。然后，使用共享的密钥作为参数启动`hmac`实例。
- en: Then read the file in 1024-byte blocks and create the `digest`, and finally,
    print the `digest`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以1024字节块读取文件并创建`digest`，最后打印`digest`。
- en: 'Even though the default cryptographic algorithm for the `hmac` module Python
    is MD5 which is considered insecure, we should use a SHA algorithm. To use SHA256,
    we have to use the `hashlib` module. Hashlib comes with default Python installation
    from version 2.5 onwards. So, we can update the preceding script to use SHA256:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认的`hmac`模块Python的加密算法是MD5，被认为是不安全的，我们应该使用SHA算法。要使用SHA256，我们必须使用`hashlib`模块。从Python
    2.5版本开始，`hashlib`随默认Python安装。因此，我们可以更新前面的脚本以使用SHA256：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Likewise, we could include other `hashlib` methods in `hmac`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在`hmac`中包含其他`hashlib`方法。
- en: hashlib algorithms
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hashlib算法
- en: 'To use a specific hash algorithm, we can make use of the appropriate constructor
    function from the `hashlib` module, which will create a hash object that can be
    used to interact with the hash. The `hashlib` module is backed by OpenSSL, so
    all the algorithms in OpenSSL, like `md5`, `sha1`, `sha224`, `sha256`, `sha384`,
    and `sha512` are available in `hashlib`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定的哈希算法，我们可以使用`hashlib`模块中的适当构造函数创建哈希对象，该对象可用于与哈希进行交互。`hashlib`模块由OpenSSL支持，因此`hashlib`中的所有算法，如`md5`、`sha1`、`sha224`、`sha256`、`sha384`和`sha512`都可用。
- en: '![hashlib algorithms](img/image_07_002.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![hashlib算法](img/image_07_002.jpg)'
- en: 'The following are important `hashlib` methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是重要的`hashlib`方法：
- en: '`hashlib.md5()`: Creates the MD5 hash object'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashlib.md5()`: 创建MD5哈希对象'
- en: '`hashlib.sha1()`: Creates the SHA1 hash object'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashlib.sha1()`: 创建SHA1哈希对象'
- en: '`hashlib.new(hash_name)`: Used to pass the algorithm by name to create a hash
    object'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashlib.new(hash_name)`: 通过名称传递算法以创建哈希对象'
- en: 'For example, try the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试以下代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will create a hash object of the hash algorithm name we passed as a first
    argument. The method `update()` will call the hash calculator repeatedly and update
    the digest accordingly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个哈希对象，该对象使用我们作为第一个参数传递的哈希算法名称。方法`update()`将重复调用哈希计算器并相应地更新摘要。
- en: Password hashing algorithms
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码哈希算法
- en: MD5, SHA1, and all SHA variants are intended to be very fast. In the case of
    passwords, fast algorithms are prone to brute-force attacks, as the hashes for
    MD5 and SHA1 can be produced at a rate of millions or billions per second. There
    are some algorithms specifically designed for passwords. We could use Argon2,
    and consider this as your first choice when solid implementations are available.
    The other main two options are `pbkdf2` and `bcrypt`. These functions are expensive
    to compute, so it will you protect from brute-force and wordlist attacks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MD5、SHA1和所有SHA变种都旨在非常快速。在密码的情况下，快速算法容易受到暴力破解攻击的影响，因为MD5和SHA1的哈希可以以每秒数百万或数十亿的速度产生。有一些专门设计用于密码的算法。我们可以使用Argon2，并在可用时将其视为首选。另外两个主要选项是`pbkdf2`和`bcrypt`。这些函数计算成本很高，因此可以保护您免受暴力破解和字典攻击。
- en: 'We can use the `argon2` module to use Argon2:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`argon2`模块来使用Argon2：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, we could use modules `bcrypt` and `pbkdf2` to make use of these algorithms.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用模块`bcrypt`和`pbkdf2`来使用这些算法。
- en: 'An example for using `bcrypt` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bcrypt`的示例如下：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will hash the password with a randomly generated salt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用随机生成的盐对密码进行哈希处理。
- en: 'An example for using `pbkdf2` is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pbkdf2`的示例如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will create a 24-byte-long hash using `1000` iterations. We can slow down
    the hash function by increasing the iterations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`1000`次迭代创建一个24字节长的哈希。我们可以通过增加迭代次数来减慢哈希函数的速度。
- en: Symmetric encryption algorithms
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密算法
- en: Symmetric encryption algorithms, or secret key algorithms, convert their input
    data or plaintext to a cipher text using a private variable key. We can decrypt
    the cipher text using the same key that was used to encrypt the message. Cipher
    is simply a method for encrypting and decrypting messages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法，或称为秘密密钥算法，使用私有变量密钥将其输入数据或明文转换为密文。我们可以使用相同的密钥解密密文，该密钥用于加密消息。密码是一种简单的加密和解密消息的方法。
- en: 'Encryption algorithms are mainly grouped into two:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法主要分为两类：
- en: '**Algorithms used in symmetric encryption**: Symmetric encryption is the one
    which uses a single key for both encryption and decryption. Some examples of symmetric
    encryption algorithms are AES, Blowfish, DES, IDEA, serpent, and so on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密中使用的算法**：对称加密是一种同时用于加密和解密的单一密钥。一些对称加密算法的示例包括AES、Blowfish、DES、IDEA、serpent等。'
- en: '**Algorithms used in asymmetric encryption**:Asymmetric encryption use two
    keys: a private key and a public key—one for encryption and the other for decryption.
    Examples for asymmetric algorithms are Diffe-Hellman (**DH**) and **RSA**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称加密中使用的算法**：非对称加密使用两个密钥：私钥和公钥——一个用于加密，另一个用于解密。非对称算法的示例包括Diffe-Hellman（**DH**）和**RSA**。'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can read more on symmetric encryption here: [http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html](http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里阅读更多关于对称加密的内容：[http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html](http://www.cs.cornell.edu/courses/cs5430/2010sp/TL03.symmetric.html)。
- en: Block  and stream cipher
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块和流密码
- en: A **block cipher** encrypts fixed-size data which is known as a block. Usually,
    each block has the relatively large size of 64 bits, 128 bits, or 256 bits. So,
    a block cipher will take each block and encrypt it separately to the same size
    as the cipher text. In cases where input bits are shorter than the block size,
    padding schemes are called into play. The same key is used at each block. Examples
    of block ciphers are AES, DES, Blowfish, and IDEA.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**分组密码**加密已知为块的固定大小数据。通常，每个块的大小相对较大，为64位、128位或256位。因此，分组密码将每个块分别加密到与密文相同大小。在输入位较短于块大小的情况下，会调用填充方案。每个块都使用相同的密钥。分组密码的例子包括AES、DES、Blowfish和IDEA。'
- en: A **stream cipher** encrypts small blocks of one bit or byte of plaintext at
    a time. It uses an infinite stream of pseudorandom bits as the key and this pseudorandom
    generator should be unpredictable. Also, the key should never be reused to implement
    the stream cipher in a secure way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**流密码**一次加密一位或一字节的小块明文。它使用无限的伪随机位流作为密钥，这个伪随机生成器应该是不可预测的。此外，为了以安全的方式实现流密码，密钥不应该被重复使用。'
- en: PyCrypto
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCrypto
- en: '**PyCrypto**, which stands for **Python Cryptography Toolkit**, is a collection
    of different cryptographic modules that include both hash functions and encryption
    algorithms. The PyCrypto module provides all needed functions for implementing
    strong cryptography in a Python program.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyCrypto**，全称**Python密码学工具包**，是一个包含哈希函数和加密算法的不同加密模块的集合。PyCrypto模块提供了在Python程序中实现强加密所需的所有函数。'
- en: 'To use an encryption algorithm, we can import it from `Crypto.Cipher`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用加密算法，我们可以从`Crypto.Cipher`中导入它：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will create the ciphertext. As the PyCrypto block-level encryption API
    is very low-level, it only accepts 16-, 24-, or 32-bytes-long keys for AES-128,
    AES-196, and AES-256, respectively. The longer the key, the stronger the encryption.
    We can decrypt it as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建密文。由于PyCrypto块级加密API非常低级，它只接受16、24或32字节长的密钥用于AES-128、AES-196和AES-256，分别。密钥越长，加密越强。我们可以按以下方式解密它：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we will get our plaintext back.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将得到我们的明文。
- en: AES encryption of a file
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件的AES加密
- en: '**Advanced Encryption Standard** (**AES**) is a symmetric block cipher, which
    consists of three block ciphers: AES-128, AES-192, and AES-256\. Each one encrypts/decrypts
    data in blocks of 128 bits with keys of 128, 192, and 256 bits, respectively.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级加密标准**（**AES**）是一种对称分组密码，由三种分组密码组成：AES-128、AES-192和AES-256。每个加密/解密数据的块大小为128位，密钥分别为128、192和256位。'
- en: The following script encrypts the file provided. Also, it handles the random
    generation of **initialization vector** (**IV**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本加密所提供的文件。此外，它处理**初始化向量**（**IV**）的随机生成。
- en: 'First we load all required modules:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先加载所有所需的模块：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, define the function to encrypt the file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义加密文件的函数：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we create the initialization vector inside the function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部创建初始化向量：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we can initialize the AES encryption method in the PyCrypto module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在PyCrypto模块中初始化AES加密方法：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Read the file and write the encrypted output file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件并写入加密输出文件：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, call the function to encrypt the file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用函数加密文件：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can check how to decrypt this encrypted file. To write a function that
    can decrypt, we have to import the same modules. Then, define the function as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查如何解密这个加密文件。要编写一个可以解密的函数，我们必须导入相同的模块。然后，定义函数如下：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Read the encrypted file and output the decrypted file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 读取加密文件并输出解密文件：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initialize the `decryptor` method to decrypt the file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`decryptor`方法以解密文件：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, output the original decrypted file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出原始解密文件：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have discussed the hashing and cryptographic modules used in Python. Now
    you will be able to use these modules in your scripts. We will look at some keylogging
    techniques in the next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python中使用的哈希和加密模块。现在您将能够在您的脚本中使用这些模块。我们将在下一章中讨论一些键盘记录技术。
