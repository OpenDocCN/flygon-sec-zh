- en: Chapter 2. Analyzing Network Traffic with Scapy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Scapy分析网络流量
- en: 'Traffic analysis is the process of intercepting and analyzing network traffic
    in order to deduce information from communication. The size of the packets exchanged
    between two hosts, details of the systems communicating, time and duration of
    communication are some of the valuable information to an attacker. In this chapter,
    we will learn how to analyze network traffic with Python scripts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 流量分析是拦截和分析网络流量以推断通信信息的过程。两个主机之间交换的数据包大小，通信系统的详细信息，通信的时间和持续时间是攻击者的一些有价值的信息。在本章中，我们将学习如何使用Python脚本分析网络流量：
- en: Networking basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络基础知识
- en: Raw socket programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始套接字编程
- en: Packet sniffing with Scapy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy进行数据包嗅探
- en: Packet injection with Scapy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy进行数据包注入
- en: Parse DNS traffic with Scapy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy解析DNS流量
- en: OS fingerprinting with Scapy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy进行操作系统指纹识别
- en: Sockets modules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字模块
- en: Network sockets is a way to talk to other computers using standard Unix file
    descriptors, which allow communication between two different processes on the
    same or different machines. A socket is almost similar to a low-level file descriptor,
    because commands such as `read()` and `write()` also work with sockets as they
    do with files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字是一种使用标准Unix文件描述符与其他计算机通信的方式，它允许在同一台或不同机器上的两个不同进程之间进行通信。套接字几乎类似于低级文件描述符，因为诸如`read()`和`write()`之类的命令也可以与套接字一样与文件一起使用。
- en: 'Python has two basic sockets modules:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个基本的套接字模块：
- en: '**Socket**: The standard BSD sockets API.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：标准的BSD套接字API。'
- en: '**SocketServer**: A server-centric module that defines classes for handling
    synchronous network requests that simplify the development of network servers.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SocketServer**：一个以服务器为中心的模块，定义了处理同步网络请求的类，简化了网络服务器的开发。'
- en: Socket
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字
- en: The `socket` module has almost everything you need to build a socket server
    or client. In the case of Python, the `socket` returns an object to which the
    socket methods can be applied.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`模块几乎包含了构建套接字服务器或客户端所需的一切。在Python的情况下，`socket`返回一个对象，可以对其应用套接字方法。'
- en: Methods in socket module
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 套接字模块中的方法
- en: 'The socket module has the following class methods:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字模块具有以下类方法：
- en: '`socket.socket(family, type)`: Create and return a new socket object'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.socket(family, type)`：创建并返回一个新的套接字对象'
- en: '`socket.getfqdn(name)`: Convert a string IP address to a fully qualified domain
    name'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getfqdn(name)`: 将字符串IP地址转换为完全合格的域名'
- en: '`socket.gethostbyname(hostname)`: Resolve a hostname to an IP address'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyname(hostname)`：将主机名解析为IP地址'
- en: '**Instance methods** require a socket instance returned from `socket`. The
    `socket` module has the following instance methods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例方法**需要从`socket`返回的套接字实例。`socket`模块具有以下实例方法：'
- en: '`sock.bind( (address, port) )`: Bind the socket to the address and port'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.bind( (address, port) )`：将套接字绑定到地址和端口'
- en: '`sock.accept()`: Return a client socket with peer address information'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.accept()`: 返回带有对等地址信息的客户端套接字'
- en: '`sock.listen(backlog)`: Place the socket into the listening state'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.listen(backlog)`: 将套接字置于监听状态'
- en: '`sock.connect( (address, port) )`: Connect the socket to the defined host and
    port'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.connect( (address, port) )`：将套接字连接到定义的主机和端口'
- en: '`sock.recv( bufferLength[, flags] )`: Receive data from the socket, up to `buflen`
    (maximum bytes to receive) bytes'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.recv( bufferLength[, flags] )`：从套接字接收数据，最多`buflen`（要接收的最大字节数）字节'
- en: '`sock.recvfrom( bufferLength[, flags] )`: Receive data from the socket, up
    to `buflen` bytes, also returning the remote host and port from which the data
    came'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.recvfrom( bufferLength[, flags] )`：从套接字接收数据，最多`buflen`字节，并返回数据来自的远程主机和端口'
- en: '`sock.send( data[, flags] )`: Send data through the socket'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.send( data[, flags] )`：通过套接字发送数据'
- en: '`sock.sendall( data[, flags] )`: Send data through the socket, and continues
    to send data until either all data has been sent or an error occurred'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.sendall( data[, flags] )`：通过套接字发送数据，并继续发送数据，直到所有数据都已发送或发生错误'
- en: '`sock.close()`: Close the socket'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.close()`: 关闭套接字'
- en: '`sock.getsockopt( lvl, optname )`: Get the value for the specified socket option'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.getsockopt( lvl, optname )`：获取指定套接字选项的值'
- en: '`sock.setsockopt( lvl, optname, val )`: Set the value for the specified socket
    option'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock.setsockopt( lvl, optname, val )`：设置指定套接字选项的值'
- en: Creating a socket
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建套接字
- en: 'A socket can be created by making a call to the class method `socket()` in
    the `socket` module. This will return a socket in the domain specified. The parameters
    to the method are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`socket`模块中调用类方法`socket()`来创建套接字。这将返回指定域中的套接字。该方法的参数如下：
- en: '**Address family**: Python supports three address families.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址族**：Python支持三种地址族。'
- en: '**AF_INET**: Used for IP version 4 or IPv4 Internet addressing.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AF_INET**：用于IP版本4或IPv4互联网寻址。'
- en: '**AF_INET6**: Used for IPv6 Internet addressing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AF_INET6**：用于IPv6互联网寻址。'
- en: '**AF_UNIX**: Used for **UNIX domain sockets** (**UDS**).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AF_UNIX**：用于**UNIX域套接字**（**UDS**）。'
- en: '**Socket type**: Usually, socket type can be either `SOCK_DGRAM` for **User
    Datagram Protocol** (**UDP**) or `SOCK_STREAM` for **Transmission Control Protocol**
    (**TCP**). `SOCK_RAW` is used to create raw sockets.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字类型**：通常，套接字类型可以是`SOCK_DGRAM`用于**用户数据报协议**（**UDP**）或`SOCK_STREAM`用于**传输控制协议**（**TCP**）。`SOCK_RAW`用于创建原始套接字。'
- en: '**Protocol**: Generally left at the default value. Default value is 0.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：通常保持默认值。默认值为0。'
- en: 'The following is an example for creating a socket:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建套接字的示例：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Connecting to a server and sending data
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到服务器并发送数据
- en: The socket created can be used in both server-side or client-side.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的套接字可以在服务器端或客户端端使用。
- en: The `connect()` method of socket object is used to connect the client to a host.
    This *instance method* accepts either the host name or a tuple, which contains
    the host name/address and port number as a parameter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字对象的`connect()`方法用于将客户端连接到主机。这个*实例方法*接受主机名或一个包含主机名/地址和端口号的元组作为参数。
- en: 'We can rewrite the preceding code to send a message to the server as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写前面的代码，向服务器发送消息如下：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Receiving data
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收数据
- en: 'We need a server to receive data. To use a socket on the server side, the `bind()`
    method of the `socket` object binds a socket to an address. It takes a tuple as
    the input parameter, which contains the address to the socket and the port to
    listen for incoming requests. The `listen()` method puts the socket into listening
    mode and the method `accept()` waits for an incoming connection. The `listen()`
    method accepts a parameter representing the maximum number of queued connections.
    So by specifying this parameter to `3`, it means that if three connections are
    waiting to process, then the fourth connection will be rejected:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个服务器来接收数据。要在服务器端使用套接字，`socket`对象的`bind()`方法将套接字绑定到地址。它以元组作为输入参数，其中包含套接字的地址和用于接收传入请求的端口。`listen()`方法将套接字放入监听模式，`accept()`方法等待传入连接。`listen()`方法接受一个表示最大排队连接数的参数。因此，通过将此参数指定为`3`，这意味着如果有三个连接正在等待处理，那么第四个连接将被拒绝：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Method `accept()` will return an active connection between the server and client.
    Data can be read from the connection using the `recv()` method, and can be transmitted
    using `sendall()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`accept()`将返回服务器和客户端之间的活动连接。可以使用`recv()`方法从连接中读取数据，并使用`sendall()`进行传输：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It would be better to keep the server live by putting `socket_accept` in a
    loop, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过将`socket_accept`放在循环中来保持服务器处于活动状态，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save this to `server.py` and start the server as follows in a terminal:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存到`server.py`并在终端中启动服务器如下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then server terminal might look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器终端可能如下所示：
- en: '![Receiving data](img/image_02_001.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![接收数据](img/image_02_001.jpg)'
- en: 'Now we can modify the client script to receive a response from the server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改客户端脚本以从服务器接收响应：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save this to `client.py` and run. Please make sure the server script is running.
    The client-side terminal might look like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存到`client.py`并运行。请确保服务器脚本正在运行。客户端终端可能如下所示：
- en: '![Receiving data](img/image_02_002.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![接收数据](img/image_02_002.jpg)'
- en: Handling multiple connections
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个连接
- en: In the previous example, we used the while loop to handle different clients;
    this can only interact with one client at a time. To make the server interact
    with multiple clients, we have to use multi-threading. When the `main` program
    accepts a connection, it creates a new thread to handle communication for this
    connection, and then goes back to accept more connections.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用while循环来处理不同的客户端；这只能一次与一个客户端交互。为了使服务器与多个客户端交互，我们必须使用多线程。当`main`程序接受连接时，它会创建一个新线程来处理此连接的通信，然后返回以接受更多连接。
- en: We can use the threads module to create thread handlers for each connection
    that the server accepts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用线程模块为服务器接受的每个连接创建线程处理程序。
- en: '`start_new_thread()` takes two arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_new_thread()`接受两个参数：'
- en: A function name to be run
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行的函数名称
- en: A tuple of arguments to that function
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给该函数的参数元组
- en: 'Let''s see how we can rewrite the preceding example with threads:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用线程重写前面的示例：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on socket modules, go to [https://docs.python.org/2.7/library/socket.html](https://docs.python.org/2.7/library/socket.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关套接字模块的更多详细信息，请访问[https://docs.python.org/2.7/library/socket.html](https://docs.python.org/2.7/library/socket.html)。
- en: SocketServer
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SocketServer
- en: '`SocketServer` is an interesting module, which is a framework for creating
    network servers. It has pre-defined classes for handling synchronous requests
    using TCP, UDP, UNIX streams, and UNIX datagrams. We can also create forking and
    threading versions of each type of server using the mix-in classes. In many cases,
    you can simply use one of the existing server classes. Five different server classes
    defined in `SocketServer` module are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SocketServer`是一个有趣的模块，它是用于创建网络服务器的框架。它具有预定义的类，用于使用TCP、UDP、UNIX流和UNIX数据报处理同步请求。我们还可以使用混合类创建每种类型服务器的分叉和线程版本。在许多情况下，您可以简单地使用现有的服务器类。`SocketServer`模块中定义的五种不同的服务器类如下：'
- en: '`BaseServer`: Defines the API, not used directly'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseServer`: 定义API，不直接使用'
- en: '`TCPServer`: Uses TCP/IP sockets'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCPServer`: 使用TCP/IP套接字'
- en: '`UDPServer`: Uses datagram sockets'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDPServer`: 使用数据报套接字'
- en: '`UnixStreamServer`: Unix-domain stream sockets'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnixStreamServer`: Unix域流套接字'
- en: '`UnixDatagramServer`: Unix-domain datagram sockets'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnixDatagramServer`: Unix域数据报套接字'
- en: 'To construct a server with this module, we have to pass the address to listen
    (a tuple consisting of the address and port number) and a request handler class.
    Request handlers will receive incoming requests and decide what action to take.
    This class must have a method, which overrides any of the following `RequestHandler`
    methods; mostly, we can simply override a `handle()` method. A new instance of
    this class is created for each and every request:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块构建服务器，我们必须传递要监听的地址（由地址和端口号组成的元组）和一个请求处理程序类。请求处理程序将接收传入的请求并决定采取什么行动。这个类必须有一个方法，覆盖以下任何一个`RequestHandler`方法；大多数情况下，我们可以简单地覆盖`handle()`方法。对于每个请求，都会创建此类的新实例：
- en: '`setup()`: Called before the `handle()` method to prepare the request handler
    for the request'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`: 在`handle()`方法之前调用以准备请求处理程序的请求'
- en: '`handle()`: Parses the incoming requests, processes the data, and responds
    to the requests'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle()`: 解析传入的请求，处理数据并响应请求'
- en: '`finish()`: Called after the `handle()` method to clean up anything created
    during `setup()`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish()`: 在`handle()`方法之后调用以清理`setup()`期间创建的任何内容'
- en: Simple server with the SocketServer module
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SocketServer模块的简单服务器
- en: 'The following script shows how we can use `SocketServer` to create a simple
    echo server:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了如何使用`SocketServer`创建一个简单的回显服务器：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first line of the script imports the `SocketServer` module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一行导入了`SocketServer`模块：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we created a request handler that inherits the `SocketServer.StreamRequestHandler`
    class and overrides the `handle()` method to handle the requests for the server.
    The method `handle()` receives the data, prints it, and then responds the same
    to the client:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个请求处理程序，该处理程序继承了`SocketServer.StreamRequestHandler`类，并覆盖了`handle()`方法来处理服务器的请求。`handle()`方法接收数据，打印它，然后向客户端发送相同的数据：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This request handler class is instantiated for every request to the server.
    This server is created using the `SocketServer.TCPServer` class, where we provide
    the address to which the server will be bound and request the handler class. It
    will return a `TCPServer` object. Finally, we called the `serve_forever()` method
    to start the server and handle requests until we send an explicit `shutdown()`
    request (keyboard interrupt):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器的每个请求，都会实例化这个请求处理程序类。这个服务器是使用`SocketServer.TCPServer`类创建的，我们提供服务器将绑定到的地址和请求处理程序类。它将返回一个`TCPServer`对象。最后，我们调用`serve_forever()`方法来启动服务器并处理请求，直到我们发送一个显式的`shutdown()`请求（键盘中断）：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on Socket module, go to [http://xahlee.info/python_doc_2.7.6/library/socketserver.html](http://xahlee.info/python_doc_2.7.6/library/socketserver.html).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Socket模块的更多详细信息，请访问[http://xahlee.info/python_doc_2.7.6/library/socketserver.html](http://xahlee.info/python_doc_2.7.6/library/socketserver.html)。
- en: Raw socket programming
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始套接字编程
- en: 'Everything we send and receive on the Internet involves packets; every web
    page and e-mail we receive comes as a series of packets, and everything we send
    leaves as a series of packets. Data breaks into packets of a certain size in bytes.
    Each packet carries the information to identify its destination, source, and other
    details of the protocols that the Internet uses, along with a part of the body
    of our data. Network packets are split into three parts:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在互联网上发送和接收的所有内容都涉及数据包；我们接收的每个网页和电子邮件都作为一系列数据包发送，我们发送的每个内容都作为一系列数据包离开。数据以一定大小的字节分成数据包。每个数据包携带用于识别其目的地、源和互联网使用的协议的其他细节以及我们数据的一部分的信息。网络数据包分为三部分：
- en: '**Header**: This contains the instructions about the data carried by the packet'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标头**：这包含了数据包携带的指令'
- en: '**Payload**: This is the data of a packet'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：这是数据包的数据'
- en: '**Trailer**: This is the trailer, notify the end of the packet to receiving
    device'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾部**：这是尾部，通知接收设备数据包的结束'
- en: Headers for protocols like TCP/IP are provided by the kernel or operating system
    stack, but we can provide custom headers to this protocol with raw sockets. Raw
    sockets have support in the native socket API in Linux, but support is absent
    in Windows. Even though raw sockets are rarely used in applications, they are
    extensively used in network security applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像TCP/IP这样的协议的标头由内核或操作系统堆栈提供，但我们可以使用原始套接字为该协议提供自定义标头。原始套接字在Linux的本机套接字API中得到支持，但在Windows中不支持。尽管原始套接字在应用程序中很少使用，但在网络安全应用程序中广泛使用。
- en: 'All packets are structured in the same format consisting of, IP headers and
    a variable-length data field. First we have the Ethernet header, which is of a
    fixed size of 14 bytes, followed by the IP header if it is an IP packet, or TCP
    header if it is a TCP packet, based on the Ethernet type specified in the last
    two bytes of the Ethernet header:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据包都以相同的格式结构化，包括IP标头和可变长度的数据字段。首先是以太网标头，固定大小为14个字节，然后是IP标头（如果是IP数据包），或者TCP标头（如果是TCP数据包），根据以太网标头的最后两个字节指定的以太网类型：
- en: '![Raw socket programming](img/image_02_004.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![原始套接字编程](img/image_02_004.jpg)'
- en: 'In the Ethernet header, the first six bytes are the destination host, followed
    by a six-byte source host. The final two bytes are the Ethernet type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太网标头中，前六个字节是目标主机，接着是六个字节的源主机。最后两个字节是以太网类型：
- en: '![Raw socket programming](img/image_02_006.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![原始套接字编程](img/image_02_006.jpg)'
- en: 'The IP header is 20 bytes long; the first 12 bytes include version, **IHL**,
    **Total** **Length**, **Flags**, and so on, and the next four bytes represent
    the source address. Finally, the last four bytes are the destination address:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: IP标头长20个字节；前12个字节包括版本、**IHL**、**总长度**、**标志**等，接下来的四个字节表示源地址。最后四个字节是目标地址：
- en: '![Raw socket programming](img/image_02_008.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![原始套接字编程](img/image_02_008.jpg)'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on IP packet structure, go to [http://www.freesoft.org/CIE/Course/Section3/7.htm](http://www.freesoft.org/CIE/Course/Section3/7.htm).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关IP数据包结构的更多详细信息，请访问[http://www.freesoft.org/CIE/Course/Section3/7.htm](http://www.freesoft.org/CIE/Course/Section3/7.htm)。
- en: Creating a raw socket
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建原始套接字
- en: 'To create a raw socket with Python, the application must have root privileges
    on the system. The following example creates a `IPPROTO_RAW` socket, which is
    a raw IP packet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python创建原始套接字，应用程序必须在系统上具有根权限。以下示例创建了一个`IPPROTO_RAW`套接字，这是一个原始IP数据包：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After creating a `raw` socket, we have to construct the packet which is to be
    sent. These packets are similar to structures in C, which are not available in
    Python, hence we have to use a Python `struct` module to pack and unpack packets
    in the structure specified previously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`raw`套接字后，我们必须构造要发送的数据包。这些数据包类似于C语言中的结构，而在Python中不可用，因此我们必须使用Python的`struct`模块来按照先前指定的结构打包和解包数据包。
- en: Basic raw socket sniffer
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本原始套接字嗅探器
- en: 'The most basic form of a `raw` socket sniffer is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的`raw`套接字嗅探器如下：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As usual, we imported the socket module in the first line. Later we created
    a socket with the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在第一行导入了socket模块。稍后我们使用以下代码创建了一个套接字：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first parameter indicates that the packet interface is `PF_PACKET(Linux
    specific, we have to use AF_INET for Windows)` and the second parameter specifies
    it is a raw socket. The third argument indicates the protocol we are interested
    in. The value `0x0800` specifies we are interested in the IP protocol. After that,
    we call the `recvfrom` method to receive the packet in an infinite loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示数据包接口是`PF_PACKET（Linux特定，我们必须在Windows上使用AF_INET）`，第二个参数指定它是原始套接字。第三个参数指示我们感兴趣的协议。值`0x0800`指定我们对IP协议感兴趣。之后，我们调用`recvfrom`方法以无限循环接收数据包：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can parse the `packet`, as the first 14 bytes are the Ethernet header,
    of which the first six bytes are the destination host and the next six bytes are
    the source host. Let''s rewrite the infinite loop and add code to parse the destination
    host and source host from the Ethernet header. First we can rip off the Ethernet
    header as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解析`packet`，因为前14个字节是以太网头部，其中前6个字节是目标主机，接下来的6个字节是源主机。让我们重写无限循环并添加代码来解析以太网头部的目标主机和源主机。首先我们可以按如下方式去掉以太网头部：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we can parse and unpack the header with `struct`, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`struct`解析和解包头部，如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will return a tuple with three hex values in it. We can convert it to
    the hex value with `hexlify` in `binascii` module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含三个十六进制值的元组。我们可以使用`binascii`模块中的`hexlify`将其转换为十六进制值：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we can get the IP header, which is the next 20 bytes in the packet.
    The first 12 bytes include version, IHL, Length, Flags, and so on, which we are
    not interested in, but the next eight bytes are the source and destination IP
    address as shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以获取IP头部，即数据包中的接下来20个字节。前12个字节包括版本、IHL、长度、标志等，我们对此不感兴趣，但接下来的8个字节是源IP地址和目标IP地址，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final script will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终脚本如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will output the source and destination MAC addresses of the network card,
    as well as the source and destination IP of the packets. Make sure the packet
    interface set properly. `PF_PACKE` is Linux-specific, we have to use `AF_INET`
    for Windows. Similarly, we can parse the TCP headers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出网络卡的源和目标MAC地址，以及数据包的源和目标IP。确保数据包接口设置正确。`PF_PACKE`是Linux特定的，我们必须在Windows上使用`AF_INET`。同样，我们可以解析TCP头部。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on the `struct` module, read [https://docs.python.org/3/library/struct.html](https://docs.python.org/3/library/struct.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`struct`模块的更多详细信息，请阅读[https://docs.python.org/3/library/struct.html](https://docs.python.org/3/library/struct.html)。
- en: Raw socket packet injection
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始套接字数据包注入
- en: 'We can send custom crafted packets with a raw socket. As we did before, we
    can create a raw socket with a socket module, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原始套接字发送自定义制作的数据包。与之前一样，我们可以使用socket模块创建原始套接字，如下所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To inject packets, we need to bind the socket to an interface:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要注入数据包，我们需要将套接字绑定到一个接口：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can create an Ethernet packet using the pack method in `struct`, with
    the source address, destination address, and Ethernet type in it. Also, we can
    add some data to the packet and send it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`struct`的`pack`方法创建以太网数据包，其中包含源地址、目标地址和以太网类型。此外，我们可以向数据包添加一些数据并发送它：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The whole script to inject an IP packet will be as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注入IP数据包的整个脚本如下：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Investigate network traffic with Scapy
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy调查网络流量
- en: 'In previous sections, we sniffed and injected packets with raw sockets, where
    we have to do parsing, decoding, creating, and injecting packets all by ourselves.
    Also, raw sockets are not compatible with all operating systems. There are many
    third-party libraries that will help us to work with packets. Scapy is a very
    powerful interactive packet manipulation library and tool that stands out from
    all these libraries. Scapy provides us different commands, from basic level to
    advanced level, for investigating a network. We can use Scapy in two different
    modes: interactively within a terminal window, and programmatically from a Python
    script by importing it as a library.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用原始套接字嗅探和注入数据包，其中我们必须自己进行解析、解码、创建和注入数据包。此外，原始套接字不兼容所有操作系统。有许多第三方库可以帮助我们处理数据包。Scapy是一个非常强大的交互式数据包操作库和工具，它在所有这些库中脱颖而出。Scapy为我们提供了不同级别的命令，从基本级别到高级级别，用于调查网络。我们可以在两种不同的模式下使用Scapy：在终端窗口内交互式地使用，以及通过将其作为库导入到Python脚本中以编程方式使用。
- en: 'Let''s start Scapy using the interactive mode. Interactive mode is like Python
    shell; to activate this, just run Scapy with root privileges in a terminal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用交互模式启动Scapy。交互模式类似于Python shell；要激活它，只需在终端中以root权限运行Scapy：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will return an interactive terminal in Scapy:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个交互式的Scapy终端：
- en: '![Investigate network traffic with Scapy](img/image_02_010.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用Scapy调查网络流量](img/image_02_010.jpg)'
- en: 'These are some basic commands for interactive usage:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些交互式使用的基本命令：
- en: '`ls()`: Displays all the protocols supported by Scapy'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls()`: 显示Scapy支持的所有协议'
- en: '`lsc()`: Displays the list of commands supported by Scapy'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsc()`: 显示Scapy支持的命令列表'
- en: '`conf`: Displays all configurations options'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf`: 显示所有配置选项'
- en: '`help()`: Display help on a specific command, for example, `help(sniff)`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help()`: 显示特定命令的帮助信息，例如，`help(sniff)`'
- en: '`show()`: Display the details about a specific packet, for example, `Newpacket.show()`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show()`: 显示有关特定数据包的详细信息，例如，`Newpacket.show()`'
- en: 'Scapy helps to create custom packets based on the huge set of protocols it
    supports. Now we can create simple packets with Scapy in an interactive Scapy
    shell:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy有助于基于其支持的大量协议创建自定义数据包。现在我们可以在交互式Scapy shell中使用Scapy创建简单的数据包：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will create a packet; now we can see the packet using the following method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个数据包；现在我们可以使用以下方法查看数据包：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This use of the packet is shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的使用如下截图所示：
- en: '![Investigate network traffic with Scapy](img/image_02_012.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![使用Scapy调查网络流量](img/image_02_012.jpg)'
- en: 'Scapy creates and parses packets by the layers in each packet and by the fields
    in every layer. Each layer is encapsulated inside the parent layer. Packets in
    Scapy are Python dictionaries, so each packet is a set of nested dictionaries
    with each layer being a child dictionary of the parent layer. The `summary()`
    method will provide the details of the packet''s layers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy通过每个数据包中的层和每个层中的字段来创建和解析数据包。每个层都封装在父层内。Scapy中的数据包是Python字典，因此每个数据包都是一组嵌套字典，每个层都是父层的子字典。`summary()`方法将提供数据包层的详细信息：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The layer structure of a packet can be better seen with the nesting of brackets
    (`<` and `>`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的层结构可以通过括号的嵌套（`<`和`>`）更好地看到：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can dig into a specific layer by its name or its index number in the list
    index. For example, we can get the UDP layer of the preceding packets with the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过名称或列表索引中的索引号深入特定层。例如，我们可以使用以下方法获取前面数据包的UDP层：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or you can get the UDP layer using the following method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用以下方法获取UDP层：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With Scapy, we can parse the value of fields within each layer. For example,
    we can get the source field in the Ethernet layer with the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scapy，我们可以解析每个层中字段的值。例如，我们可以使用以下方法获取以太网层中的源字段：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Packet sniffing with Scapy
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scapy进行数据包嗅探
- en: 'With Scapy, it is very simple to `sniff` packets with the `sniff` method. We
    can run the following command in a Scapy shell to `sniff` in interface `eth0`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scapy，使用`sniff`方法`sniff`数据包非常简单。我们可以在Scapy shell中运行以下命令，在接口`eth0`中`sniff`：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will get three packets from the `eth0` interface. With `hexdump()`, we
    can dump the packet in `hex`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`eth0`接口获取三个数据包。使用`hexdump()`，我们可以以`hex`格式转储数据包：
- en: '![Packet sniffing with Scapy](img/image_02_014.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用Scapy进行数据包嗅探](img/image_02_014.jpg)'
- en: 'The arguments for the `sniff()` method are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`sniff()`方法的参数如下：'
- en: '`count`: Number of packets to capture, but 0 means infinity'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：要捕获的数据包数量，但0表示无限'
- en: '`iface`: Interface to sniff; sniff for packets only on this interface'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iface`：嗅探的接口；仅在此接口上嗅探数据包'
- en: '`prn`: Function to run on each packet'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prn`：在每个数据包上运行的函数'
- en: '`store`: Whether to store or discard the sniffed packets; set to 0 when we
    only need to monitor'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store`：是否存储或丢弃嗅探到的数据包；当我们只需要监视时设置为0'
- en: '`timeout`: Stops sniffing after a given time; the default value is none'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：在给定时间后停止嗅探；默认值为none'
- en: '`filter`: Takes BPF syntax filters to filter sniffing'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：采用BPF语法过滤器以过滤嗅探'
- en: 'If we want to see more of the packet contents, the `show()` method is good.
    It will display the packet in a cleaner and produce a formatted print out, as
    follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看更多的数据包内容，`show()`方法很好。它将以更清晰的方式显示数据包，并产生格式化的打印输出，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command will give the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将产生以下输出：
- en: '![Packet sniffing with Scapy](img/image_02_016.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![使用Scapy进行数据包嗅探](img/image_02_016.jpg)'
- en: 'To see the sniffed packets in realtime, we have to use the lambda function,
    along with the `summary()` or `show()` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时查看嗅探到的数据包，我们必须使用lambda函数，以及`summary()`或`show()`方法：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, it is possible to write the packets to a `pcap` file with Scapy. To write
    the packets to a `pcap` file, we can use the `wrpcap()` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用Scapy还可以将数据包写入`pcap`文件。要将数据包写入`pcap`文件，我们可以使用`wrpcap()`方法：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will write the packets to a `pkt-output.cap` file. We can read from the
    `pcap` file with `rdpcap()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把数据包写入`pkt-output.cap`文件。我们可以使用`rdpcap()`从`pcap`文件中读取：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Packet injection with Scapy
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scapy进行数据包注入
- en: 'Before injecting, we have to create a spoofed packet. With Scapy, it is very
    simple to create a packet if we know the packet''s layered structure. To create
    an IP packet, we use the following syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入之前，我们必须创建一个伪造的数据包。使用Scapy，如果我们知道数据包的分层结构，创建数据包非常简单。要创建IP数据包，我们使用以下语法：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To add more child layers to this packet, we can simply add the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要向此数据包添加更多子层，我们只需添加以下内容：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will create a packet with an IP layer, `ICMP` layer, and raw payload,
    as `"Hello Packt"`. The `show()` method will display this packet as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有IP层、`ICMP`层和原始有效载荷的数据包，如`"Hello Packt"`。`show()`方法将显示此数据包如下：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To send the packet, we have two methods:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 发送数据包有两种方法：
- en: '`sendp()`: Layer-2 send; sends layer-2 packets'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendp()`: 第二层发送；发送第二层数据包'
- en: '`send()`: Layer-3 send; only sends layer-3 packets like IPv4 and Ipv6'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()`: 第三层发送；仅发送第三层数据包，如IPv4和Ipv6'
- en: 'The main arguments for send commands are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 发送命令的主要参数如下：
- en: '`iface`: The interface to send packets'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iface`：发送数据包的接口'
- en: '`inter`: The time in between two packets (in seconds)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inter`：两个数据包之间的时间（以秒为单位）'
- en: '`loop`: To keep sending packets endlessly, set this to `1`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：设置为`1`以无限发送数据包'
- en: '`packet`: Packet or a list of packets'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packet`：数据包或数据包列表'
- en: 'If we are using a layer-2 send, we have to add an Ethernet layer and provide
    the correct interface to send the packet. But with layer-3, sending all this routing
    stuff will be handled by Scapy itself. So let''s send the previously created packet
    with a layer-3 send:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是第二层发送，我们必须添加一个以太网层并提供正确的接口来发送数据包。但是对于第三层，发送所有这些路由信息将由Scapy自己处理。因此，让我们使用第三层发送先前创建的数据包：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The packet we send can be sniffed using another Scapy interactive terminal.
    The output will be like this, the second packet is the response we received from
    `packtpub.com`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个Scapy交互式终端来嗅探我们发送的数据包。输出将如下所示，第二个数据包是我们从`packtpub.com`收到的响应：
- en: '![Packet injection with Scapy](img/image_02_017.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用Scapy进行数据包注入](img/image_02_017.jpg)'
- en: 'Similarly, to send a layer-2 packet, we have to add the Ethernet header and
    interface as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要发送第二层数据包，我们必须添加以太网标头和接口，如下所示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Scapy send and receive methods
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scapy发送和接收方法
- en: 'These methods are used to send a packet or group of packets when we expect
    a response back. There are four different types of send and receive methods. They
    are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于在期望收到响应时发送数据包或一组数据包。有四种不同类型的发送和接收方法。它们如下：
- en: '`sr()`: Layer-3 send and receive, returns both answers and unanswered packets'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sr()`: 第三层发送和接收，返回答案和未答案数据包'
- en: '`sr1()`: Layer-3 send and receive, returns only answers or sent packets'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sr1()`: 第3层发送和接收，仅返回答案或已发送的数据包'
- en: '`srp()`: Layer-2 send and receive, returns both answers and unanswered packets'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srp()`: 第2层发送和接收，返回答案和未答复的数据包'
- en: '`srp1()`: Layer-2 send and receive, returns only answers or sent packets'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srp1()`: 第2层发送和接收，仅返回答案或已发送的数据包'
- en: 'These methods are almost similar to the `send()` method. To send a packet and
    receive its response, use the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法几乎与`send()`方法相似。要发送数据包并接收其响应，请使用以下命令：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, while waiting for the response, Scapy got three packets and exited when
    the response received. If we used `sr1()`, this will wait only for one response
    and print the response packet. Similarly, we can send layer-2 packets with the
    `srp()` and `srp1()` methods.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待响应时，Scapy收到了三个数据包，并在收到响应时退出。如果我们使用`sr1()`，这将仅等待一个响应并打印响应数据包。同样，我们可以使用`srp()`和`srp1()`方法发送第2层数据包。
- en: Programming with Scapy
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scapy进行编程
- en: 'Earlier, we were using Scapy in interactive mode. But in some cases, we may
    need to use Scapy in scripts. Scapy can be used as a library if it is imported
    in our programs. We can import all Scapy functions as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们在交互模式下使用了Scapy。但在某些情况下，我们可能需要在脚本中使用Scapy。如果在我们的程序中导入了Scapy，Scapy可以作为一个库来使用。我们可以按照以下方式导入所有Scapy函数：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or we can import specific packages if we only need a few of the functions,
    as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们只需要一些功能，我们可以导入特定的包，如下所示：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example we can create a DNS request. With `sr1()` method, we can create
    and get the response for a DNS request. As DNS packets are built from IP and UDP
    packets, we can create a DNS packet with IP and UDP layers in it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个DNS请求。使用`sr1()`方法，我们可以创建并获取DNS请求的响应。由于DNS数据包是由IP和UDP数据包构建的，因此我们可以在其中创建一个包含IP和UDP层的DNS数据包：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have to run this script with root privileges. If the verbose option is `1`,
    the output will be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以root权限运行此脚本。如果verbose选项为`1`，输出将如下所示：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To parse DNS packets, we can use the `sniff()` method. The `prn` argument in
    `sniff()` can be used to change the output by Scapy for each packet. It helps
    to replace the default Scapy printout with our own function, thus we can decide
    how Scapy will print the output for each packet. Here, in the following example,
    we are using the `select_DNS()` function each time a matched packet is identified
    by the filter and sniffed with Scapy:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析DNS数据包，我们可以使用`sniff()`方法。`sniff()`中的`prn`参数可用于更改Scapy对每个数据包的输出。它有助于用我们自己的函数替换默认的Scapy打印输出，因此我们可以决定Scapy如何打印每个数据包的输出。在以下示例中，每次通过过滤器匹配数据包并使用Scapy进行嗅探时，我们都使用`select_DNS()`函数：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As usual, we imported the necessary modules, Scapy and datetime, in the first
    two lines; later, we declared the interface to sniff and the filter to get the
    `udp` packet from port `53` with the **Berkeley Packet Filter** (**BPF**) syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在前两行中导入了必要的模块Scapy和datetime；稍后，我们声明了要嗅探的接口和使用**伯克利数据包过滤器**（**BPF**）语法从端口`53`获取`udp`数据包的过滤器：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we declared the function to be called when each packet is sniffed with
    the `sniff()` method. This will modify the default printout summary in `sniff()`
    and provide custom output. Here, it will check the DNS packet and output its source
    destination and time. The `prn` argument is used to bind this function to the
    `sniff()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明了每次使用`sniff()`方法嗅探数据包时要调用的函数。这将修改`sniff()`中的默认打印摘要并提供自定义输出。在这里，它将检查DNS数据包并输出其源目的地和时间。`prn`参数用于将此函数绑定到`sniff()`方法：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally we will call the `sniff()` method with a `select_DNS()` function as
    a `prn` argument.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`sniff()`方法和`select_DNS()`函数作为`prn`参数进行调用。
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on Berkeley Packet Filter (BPF) syntax, read [http://biot.com/capstats/bpf.html](http://biot.com/capstats/bpf.html).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有关伯克利数据包过滤器（BPF）语法的更多详细信息，请阅读[http://biot.com/capstats/bpf.html](http://biot.com/capstats/bpf.html)。
- en: 'Let''s check another example in OS fingerprinting; we can do this by two methods:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查另一个操作系统指纹识别的示例；我们可以通过两种方法来实现：
- en: Nmap fingerprinting
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nmap指纹识别
- en: p0f
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: p0f
- en: If Nmap is installed on your system, we can utilize its active OS fingerprinting
    database with Scapy. Make sure the signature database is located in the path specified
    in `conf.nmap_base`. If you are using the default installation directory, Scapy
    will automatically detect the fingerprints file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上安装了Nmap，我们可以利用其主动OS指纹数据库与Scapy一起使用。确保签名数据库位于`conf.nmap_base`中指定的路径中。如果您使用默认安装目录，Scapy将自动检测指纹文件。
- en: 'We can load `nmap` module with the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令加载`nmap`模块：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then we can use `nmap_fp()` function to start fingerprinting the OS.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`nmap_fp()`函数开始对操作系统进行指纹识别。
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we have `p0f` installed, we can use this to identify the OS. Make sure the
    configuration `conf.p0f_base` is correct. We can guess the OS from a single captured
    packet with the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装了`p0f`，我们可以使用它来识别操作系统。确保配置`conf.p0f_base`是正确的。我们可以从单个捕获的数据包中猜测操作系统，方法如下：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on Scapy, read [http://www.secdev.org/projects/scapy/doc/usage.html](http://www.secdev.org/projects/scapy/doc/usage.html).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Scapy的更多详细信息，请阅读[http://www.secdev.org/projects/scapy/doc/usage.html](http://www.secdev.org/projects/scapy/doc/usage.html)。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have gone through the basics of packet crafting and sniffing with various
    Python modules, and saw that Scapy is very powerful and easy to use. By now we
    have learned the basics of socket programming and Scapy. During our security assessments,
    we may need the raw outputs and access to basic levels of packet topology so that
    we can analyze and make decisions ourselves. The most attractive part of Scapy
    is that it can be imported and used to create networking tools without going to
    create packets from scratch.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用各种Python模块进行数据包制作和嗅探的基础知识，并且发现Scapy非常强大且易于使用。到目前为止，我们已经学习了套接字编程和Scapy的基础知识。在我们的安全评估过程中，我们可能需要原始输出和对数据包拓扑的基本访问权限，以便我们可以自行分析和做出决策。Scapy最吸引人的部分是可以将其导入并用于创建网络工具，而无需从头开始创建数据包。
- en: We will discuss application fingerprinting with Python in more detail in the
    next chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地讨论使用Python进行应用指纹识别。
