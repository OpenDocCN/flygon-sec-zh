- en: Chapter 4. Attack Scripting with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Python进行攻击脚本编写
- en: '**Open Web Application Security Project** (**OWASP**) Top 10 is a list of the
    10 most critical web application security risks. In this chapter, we will discuss
    how to script OWASP top 10 attack with Python libraries:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放式Web应用安全项目**（**OWASP**）十大是对最严重的网络应用安全风险的列表。在本章中，我们将讨论如何使用Python库编写OWASP十大攻击脚本：'
- en: Injections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Broken authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏的身份验证
- en: Cross-site scripting (XSS)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: Insecure direct object references
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的直接对象引用
- en: Security misconfiguration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全配置错误
- en: Sensitive data exposure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感数据暴露
- en: Missing function level access control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少功能级访问控制
- en: CSRF attack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSRF攻击
- en: Using components with known vulnerabilities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知漏洞的组件
- en: Unvalidated redirects and forwards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经验证的重定向和转发
- en: Injections
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入
- en: SQL Injection is the method where an attacker may create or alter SQL commands
    in order to disclose data in the database. This can be effective on an application
    that takes user input and combines it with static parameters to build a SQL query
    without proper validation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是攻击者可能创建或更改SQL命令以披露数据库中的数据的方法。这对于接受用户输入并将其与静态参数结合以构建SQL查询而没有适当验证的应用程序非常有效。
- en: Likewise, all types of injection attacks can be done with manipulating input
    data to the application. With Python, we could inject some attack vectors to the
    application and analyze the output to verify the possibility of the attack. Mechanize
    is a very useful Python module for navigating through web forms, which provide
    a stateful programmatic web-browsing experience with Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，所有类型的注入攻击都可以通过操纵应用程序的输入数据来完成。使用Python，我们可以向应用程序注入一些攻击向量，并分析输出以验证攻击的可能性。Mechanize是一个非常有用的Python模块，用于浏览网页表单，它提供了一个具有状态的编程式网络浏览体验。
- en: 'We could use `mechanize` to submit forms and analyze the response:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mechanize`来提交表单并分析响应：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will print out the response for the POST request. Here we submit an attack
    vector to break the SQL query and print all the data in the table instead of one
    row. When testing a website, we have to create many customized scripts like this
    to test with many similar attack vectors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出POST请求的响应。在这里，我们提交一个攻击向量来破坏SQL查询，并打印表中所有数据而不是一行。在测试网站时，我们必须创建许多类似的自定义脚本来测试许多类似的攻击向量。
- en: 'So let us rewrite the script to get all the attack vectors from a file and
    send all of them one by one to the server, and save the output to a file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重写脚本，从文件中获取所有攻击向量，然后逐个发送到服务器，并将输出保存到文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could check the responses for the requests and identify the possible attacks.
    For instance, the preceding code sample will provide responses which include the
    sentence `You have an error in your SQL syntax`. From this, we could identify
    that this form may be prone to SQL injection. After that we could exclude the
    responses which contain an error, as they won't have the required data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查请求的响应并识别可能的攻击。例如，前面的代码示例将提供包含句子“您的SQL语法有错误”的响应。从中，我们可以确定这种形式可能容易受到SQL注入攻击。之后，我们可以排除包含错误的响应，因为它们不会包含所需的数据。
- en: Furthermore, we could write custom scripts to inject LDAP, XPath, or NoSQL queries,
    OS commands, XML parsers, and all other Injection vectors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以编写自定义脚本来注入LDAP、XPath或NoSQL查询、操作系统命令、XML解析器和所有其他注入向量。
- en: Broken authentication
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏的身份验证
- en: When authentication functions that help to authenticate users to the application
    are not implemented correctly, that may allow hackers to compromise passwords
    or session IDs, or to exploit other implementation flaws using other users' credentials.
    These types of flaws are known as broken authentication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于对应用程序进行用户身份验证的身份验证功能实施不正确时，可能会允许黑客破解密码或会话ID，或利用其他用户的凭据来利用其他实施缺陷。这些类型的缺陷被称为破坏的身份验证。
- en: We can use mechanize scripts to check the authentication mechanism in an application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用机械化脚本来检查应用程序中的身份验证机制。
- en: With this, we have to check the account management functions like account creation,
    change password, and recover password. We could also write customized brute-force
    and dictionary attack scripts to check the login mechanism of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须检查账户管理功能，如账户创建、更改密码和找回密码。我们还可以编写定制的暴力和字典攻击脚本，以检查应用程序的登录机制。
- en: 'We can generate all possible passwords with a range of characters in them as
    follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成包含一系列字符的所有可能密码，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Later, we can use these passwords in a brute-force attack as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们可以使用这些密码进行暴力攻击，方法如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we can analyze the response and confirm the login. For that we have to
    search the response for the error messages. If no error messages are found in
    the response it will be a successful login.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以分析响应并确认登录。为此，我们必须搜索错误消息的响应。如果在响应中找不到错误消息，那么登录将成功。
- en: 'In the preceding example, we can check if we were taken back to the login page
    or not. If we are taken to the login page, the login failed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以检查是否被带回登录页面。如果我们被带回登录页面，登录失败：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can also modify this script to brute-force predictable, or less random session
    cookies. For that we have to analyze authentication cookie patterns. We can also
    replace the password with the words in a dictionary. The code will be the same
    as we have done for injections, The attack vector will be replaced with the words
    in the dictionary file provided.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改此脚本以暴力破解可预测或不太随机的会话cookie。为此，我们必须分析身份验证cookie的模式。我们还可以用字典中的单词替换密码。代码将与我们为注入所做的相同，攻击向量将被字典文件中提供的单词替换。
- en: Cross-site scripting (XSS)
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: Cross-site scripting is also a type of injection attack, which occurs when attackers
    inject malicious attack vectors in the form of a browser-side script. This occurs
    when a web application uses input from a user to craft the output without validating
    or encoding it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本也是一种注入攻击类型，当攻击者注入恶意攻击向量以浏览器端脚本的形式时发生。这是在Web应用程序使用用户的输入来构建输出而不进行验证或编码时发生的。
- en: 'We could modify the script used to inject SQL attack vectors to test XSS injection.
    To verify the output response, we could search for the expected script in the
    response:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改用于注入SQL攻击向量的脚本以测试XSS注入。为了验证输出响应，我们可以在响应中搜索预期的脚本：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: XSS occurs when user input prints to the response without any validation. So,
    to check the possibility of an XSS attack, we can check the response text for
    the attack vector we provided. If the attack vector is present in the response
    without any escaping or validation there is a high possibility of XSS attack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: XSS发生在用户输入未经验证地打印到响应中。因此，为了检查XSS攻击的可能性，我们可以检查响应文本中我们提供的攻击向量。如果攻击向量在响应中出现而没有任何转义或验证，那么就有很高的可能性发生XSS攻击。
- en: Insecure direct object references
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的直接对象引用
- en: This vulnerability occurs when an application uses actual reference identifiers
    (IDs), names, or keys to create web pages or URLs, and the application does not
    verify the authenticity of the user to access the requested page. An attacker
    may change the parameters in the URLs to detect such vulnerabilities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序使用实际的引用标识符（ID）、名称或键来创建网页或URL时，且应用程序不验证用户访问请求页面的真实性时，就会发生这种漏洞。攻击者可能会更改URL中的参数以检测此类漏洞。
- en: 'In an application, the data of a user will not be accessible for another user.
    Check the following script sample; It will iterate through the users and check
    the data is visible for the logged-in user:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，用户的数据对另一个用户是不可访问的。检查以下脚本示例；它将遍历用户并检查数据是否对已登录用户可见：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Security misconfiguration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全配置错误
- en: 'For better secure applications, it requires a secure configuration of each
    of its underlying technologies, like application, web server, database server,
    and operating system. Also, we need to keep all software up to date. Some of the
    examples for security misconfigurations are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更安全的应用程序，需要对其所有基础技术进行安全配置，如应用程序、Web服务器、数据库服务器和操作系统。此外，我们需要保持所有软件保持最新。一些安全配置错误的示例如下：
- en: Outdated software
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过时的软件
- en: Presence of sample application or sample databases in server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器中存在示例应用程序或示例数据库
- en: Enabling directory listings that lead to data disclosure, including codebase
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用导致数据泄露的目录列表，包括代码库
- en: Unhandled error pages, which can reveal sensitive information
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未处理的错误页面，可能会泄露敏感信息
- en: Active default passwords in the applicable or applicable framework
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用或适用框架中的默认密码
- en: We can use Python scripts to verify these types of vulnerabilities. As we discussed
    in the previous sections, we can use Python libraries to send crafted requests
    and analyze their responses.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Python脚本来验证这些类型的漏洞。正如我们在前面的章节中讨论的那样，我们可以使用Python库发送精心制作的请求并分析它们的响应。
- en: Sensitive data exposure
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感数据暴露
- en: We could write customized Python scripts to check the possible data exposure
    in the web pages. For instance, we have discussed the e-mail gathering script
    in the previous chapter, which could also be used to check if there are any e-mail
    IDs exposed in the web pages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写定制的Python脚本来检查网页中可能的数据暴露。例如，我们在上一章中讨论了电子邮件收集脚本，也可以用来检查网页中是否有任何暴露的电子邮件ID。
- en: For that, we have to write a script to check the HTTP responses for the patterns
    we are looking for. Sensitive data may vary according to the website and its usage.
    But we can check for the exposure of sensitive information like credit card, bank
    details, Personal Identification numbers, and many more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须编写一个脚本来检查我们正在寻找的模式的HTTP响应。敏感数据可能会根据网站及其用途而有所不同。但我们可以检查敏感信息的暴露，如信用卡、银行详细信息、个人身份识别号码等。
- en: Missing function level access control
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺少功能级访问控制
- en: Web applications verify the function level access rights for a user before providing
    access to a specific functionality. These access control checks also need to be
    verified server-side. If these types of access checks are missing on the server
    side, an attacker can enter the application without any authorization. To check
    this type of vulnerability, we can create custom scripts to authenticate a less
    privileged user to the application and try accessing restricted pages. We can
    make sure that all restricted pages are not accessible for any less privileged
    user.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序在向用户提供特定功能的访问权限之前会验证用户的功能级访问权限。这些访问控制检查也需要在服务器端进行验证。如果服务器端缺少这些类型的访问检查，攻击者可以在没有任何授权的情况下进入应用程序。为了检查这种类型的漏洞，我们可以创建自定义脚本来验证应用程序的低权限用户，并尝试访问受限页面。我们可以确保所有受限页面对于任何低权限用户都是不可访问的。
- en: CSRF attacks
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF攻击
- en: '**Cross-Site Request Forgery** (**CSRF**) attacks deceive the victim''s browser
    into sending a manipulated request to the vulnerable application while the victim
    is logged in. So, an application should make sure the request is legitimate.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）攻击欺骗受害者的浏览器在受害者登录时向易受攻击的应用程序发送操纵的请求。因此，应用程序应确保请求是合法的。'
- en: 'As a CSRF attack is an attack on a logged-in user, we have to send the session
    cookie with the request. We can use `cookielib` to remember cookies between sessions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSRF攻击是针对已登录用户的攻击，我们必须在请求中发送会话cookie。我们可以使用`cookielib`在会话之间记住cookie：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To test for CSRF, we have to submit the form from a page other than the actual
    page. We could also check the form for a CSRF token. If such a token exists in
    the form, manipulate the values and make sure the form fails with incorrect CSRF
    token and it generate a new one on each request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试CSRF，我们必须从实际页面以外的页面提交表单。我们还可以检查CSRF令牌。如果表单中存在这样的令牌，操纵值并确保表单在错误的CSRF令牌下失败，并在每个请求上生成一个新的令牌。
- en: Using components with known vulnerabilities
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已知漏洞的组件
- en: This type of vulnerability occurs when we use components like libraries, frameworks,
    and so on without proper validation. These components may always execute in full
    privilege in the application. So, when a vulnerable component is used in the application,
    it makes the job easier for an attacker. We can write a Python script to check
    the versions of used components in the application and to verify it with **Open
    Source Vulnerability Database** (**OSVDB**) for any unpatched known vulnerabilities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中使用类似库、框架等组件时，如果没有进行适当的验证，就会出现这种类型的漏洞。这些组件可能始终在应用程序中以完全特权执行。因此，当应用程序中使用了一个有漏洞的组件时，这会让攻击者的工作变得更容易。我们可以编写一个
    Python 脚本来检查应用程序中使用的组件的版本，并与**开放源漏洞数据库**（**OSVDB**）进行验证，查看是否存在未修补的已知漏洞。
- en: OSVDB lists almost all known vulnerabilities for libraries and frameworks. So
    we have to make sure that we are using the latest components with the latest patches
    applied on them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OSVDB 列出了几乎所有已知的库和框架漏洞。因此，我们必须确保我们使用的是最新的组件，并且已经应用了最新的补丁。
- en: Unvalidated redirects and forwards
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未经验证的重定向和转发
- en: Web applications frequently redirect users to other pages or external websites.
    We have to validate the credibility of those redirected pages and websites. If
    the redirect target is passed as a parameter to the application, an attacker can
    lead the user to any phishing or malware-injected web page. We can write a Python
    script to validate all external links in the application. To validate the credibility,
    we can depend on any third-party service like Google Safe Browsing checker or
    site advisor from McAfee.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序经常将用户重定向到其他页面或外部网站。我们必须验证这些重定向页面和网站的可信度。如果重定向目标作为应用程序的参数传递，攻击者可以将用户引导到任何钓鱼或注入恶意软件的网页。我们可以编写一个
    Python 脚本来验证应用程序中的所有外部链接。为了验证可信度，我们可以依赖于像 Google 安全浏览检查器或 McAfee 网站顾问这样的第三方服务。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Google Safe Browsing checker can be found here: [https://www.google.com/transparencyreport/safebrowsing/diagnostic/index.html](https://www.google.com/transparencyreport/safebrowsing/diagnostic/index.html) and
    McAfee site adviser here: [http://www.siteadvisor.com/sites/](http://www.siteadvisor.com/sites/).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Google 安全浏览检查器可以在这里找到：[https://www.google.com/transparencyreport/safebrowsing/diagnostic/index.html](https://www.google.com/transparencyreport/safebrowsing/diagnostic/index.html)，而
    McAfee 网站顾问可以在这里找到：[http://www.siteadvisor.com/sites/](http://www.siteadvisor.com/sites/)。
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have discussed the basic possibilities of attack scripting. Now you can create
    custom scripts according to your needs. In this chapter we have used mechanize
    for the scripting. We can also use any other modules we have discussed in the
    previous chapters to achieve the requirements. We will discuss more on fuzzing
    and brute-forcing attacks in the next chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了攻击脚本的基本可能性。现在你可以根据自己的需求创建自定义脚本。在本章中，我们使用了 mechanize 进行脚本编写。我们也可以使用前几章讨论过的任何其他模块来满足需求。在下一章中，我们将更多地讨论模糊测试和暴力攻击。
