- en: '*Chapter 7*: Assessing and Pentesting Lambda Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：评估和渗透Lambda服务'
- en: Lambda services run code that can later respond to events and other tasks within
    the Lambda environment as needed. These events and tasks are anything that occurs
    within the AWS environment – HTTP requests, modifications to S3 buckets, and new
    EC2 instances being brought up, for instance. This makes Lambda an essential service
    when it comes to setting up and extending a network and its services for an organization.
    However, Lambda does present some issues, such as creating weak restrictions on
    accessing Lambda, vulnerable functions that can carry out unauthorized actions,
    and rules built within the Lambda policies that allow exploitation to occur.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda服务运行代码，稍后可以根据需要在Lambda环境内响应事件和其他任务。这些事件和任务是发生在AWS环境内的任何事情-HTTP请求、对S3存储桶的修改，以及例如新的EC2实例被启动。这使得Lambda在为组织设置和扩展网络及其服务时成为一个重要的服务。然而，Lambda确实存在一些问题，比如对访问Lambda的限制较弱，可以执行未经授权的操作的易受攻击的函数，以及允许发生利用的Lambda策略内建规则。
- en: This chapter will focus on how vulnerability discovery in Lambda can lead to
    exploiting services and discovering internal processes and objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍Lambda中的漏洞发现如何导致利用服务以及发现内部流程和对象。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding and setting up Lambda services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和设置Lambda服务
- en: Digging into Lambda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Lambda
- en: Understanding misconfigurations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解错误配置
- en: Popping reverse shells with Lambda
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda进行反向shell弹出
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code used in this chapter is available at the following link: [https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services](https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可在以下链接找到：[https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services](https://github.com/PacktPublishing/AWS-Penetration-Testing/tree/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services)。
- en: You will also need Kali Linux on an EC2 instance with a public DNS name.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在具有公共DNS名称的EC2实例上安装Kali Linux。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35XHn7Q](https://bit.ly/35XHn7Q)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/35XHn7Q](https://bit.ly/35XHn7Q)
- en: Understanding and setting up a Lambda service
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和设置Lambda服务
- en: Welcome to Lambda, where your code is executed on an easily run and managed
    server. Lambda is an excellent way for companies to simplify things for ops and
    devs within their organizations due to how Lambda substantially scales and automates
    infrastructure. It allows code to be executed only when it needs to be executed
    and can help automate other services so that you don't have to worry about all
    the upkeep!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Lambda，在这里您的代码将在一个易于运行和管理的服务器上执行。Lambda对于公司来说是简化运维和开发人员工作的绝佳方式，因为Lambda可以大幅度扩展和自动化基础架构。它允许代码仅在需要执行时执行，并可以帮助自动化其他服务，这样您就不必担心所有的维护工作！
- en: Let's look at how we can set up a Lambda function!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置Lambda函数！
- en: Creating a Lambda function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Lambda函数
- en: 'Lambda functions are much like Python functions as they execute the code that
    is built within them, not outside them. In Python, this is what we call **internal**
    and **global** syntax. The internal syntax is the code that is built within the
    function and can only run within the function, whereas global syntax can run outside
    the function. Lambda functions run everything within the function. These functions
    are used to automate, scale, and do everything in between. While we aren''t going
    to look at the various reasons for using Lambda functions, you can find plenty
    of resources on Amazon about the possibilities of Lambda. To find out more, check
    out this AWS resource for extensive information on AWS Lambda: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数很像Python函数，因为它们执行其中构建的代码，而不是在外部执行。在Python中，这就是我们所谓的**内部**和**全局**语法。内部语法是在函数内部构建的代码，只能在函数内部运行，而全局语法可以在函数外部运行。Lambda函数在函数内部运行所有内容。这些函数用于自动化、扩展和处理中间的所有事情。虽然我们不打算讨论使用Lambda函数的各种原因，但您可以在亚马逊上找到大量关于Lambda可能性的资源。要了解更多信息，请查看AWS关于AWS
    Lambda的广泛信息资源：[https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)。
- en: Let's log back in to our AWS console and pin the Lambda dashboard shortcut to
    our main dashboard. Having the Lambda function icon pinned will make it easier
    for us to reference the Lambda section a little more quickly, because we won't
    have to scroll through all the services when locating Lambda.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新登录到AWS控制台，并将Lambda仪表板快捷方式固定到我们的主仪表板上。将Lambda函数图标固定在那里将使我们更容易地引用Lambda部分，因为我们在定位Lambda时不必浏览所有服务。
- en: 'The following steps help us create a Lambda function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤帮助我们创建Lambda函数：
- en: Go to the AWS console and search for `Lambda`:![Figure 7.1 – Pinning Lambda
    to AWS console
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到AWS控制台并搜索`Lambda`：![图7.1-将Lambda固定到AWS控制台
- en: '](img/Figure_7.01_B15630.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B15630.jpg)'
- en: Figure 7.1 – Pinning Lambda to AWS console
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1-将Lambda固定到AWS控制台
- en: 'Once you have the Lambda shortcut, go ahead and click on it; let''s get started
    with making a function that we can test. When you get into the Lambda dashboard,
    click on `testFunction`. The **Runtime** option will use **Python 3.6**, which
    will be the environment for the code we write:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您有了Lambda的快捷方式，就可以点击它；让我们开始制作一个可以测试的函数。当您进入Lambda仪表板时，点击`testFunction`。**Runtime**选项将使用**Python
    3.6**，这将是我们编写代码的环境：
- en: '![Figure 7.2 – Creating a Lambda function from scratch'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2-从头创建Lambda函数'
- en: '](img/Figure_7.02_B15630.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B15630.jpg)'
- en: Figure 7.2 – Creating a Lambda function from scratch
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2-从头创建Lambda函数
- en: Upon completion, you'll be shown where you can save and "test" your function.
    While it is essential to look at portions within the function configuration manager,
    we won't worry about that too much right now because it doesn't have much to do
    with what we are doing. The important part is that we understand where and how
    to set up Lambda within our AWS console – as we just did and will be doing more
    of throughout this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将看到可以保存和“测试”函数的位置。虽然查看函数配置管理器中的部分很重要，但现在我们不会太担心这个，因为它与我们正在做的事情关系不大。重要的是，我们了解在AWS控制台中如何设置Lambda的位置和方式-就像我们刚刚做的那样，并且在本章中将会更多地进行。
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For more on Lambda, take a look at the AWS docs: [https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html](https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Lambda的更多信息，请查看AWS文档：[https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html](https://docs.aws.amazon.com/lex/latest/dg/gs-bp-create-lambda-function.html)。
- en: Let's take this knowledge a little bit further in the next section and start
    looking at how we can create more with Lambda, as well as looking at how security
    engineers and pentesters use certain techniques to find misconfigurations within
    Lambda.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中进一步了解这些知识，并开始研究安全工程师和渗透测试人员如何使用某些技术来发现Lambda中的配置错误。
- en: Digging into Lambda
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究Lambda
- en: Now that we have had a brief introduction to what Lambda is and how to set up
    our own Lambda service, it's time we started looking at some of the security issues
    with Lambda. You may see some of them during an actual pentesting engagement.
    When it comes to AWS, one of the most significant issues I have seen as a pentester
    is policy issues associated with Lambda. Policies are what restrict and allow
    access to resources, similar to what we looked at in [*Chapter 4*](B15630_04_Final_ASB_ePub.xhtml#_idTextAnchor171)*,
    Exploiting S3 Buckets*. We are going to be doing something using the same *methodology*
    within this section, but we will be looking at misconfigurations with Lambda.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了Lambda是什么，以及如何设置我们自己的Lambda服务，是时候开始研究Lambda的一些安全问题了。在实际的渗透测试过程中，您可能会遇到其中一些问题。在AWS方面，我作为渗透测试人员看到的最重要的问题之一是与Lambda相关的策略问题。策略是限制和允许访问资源的东西，类似于我们在[*第4章*](B15630_04_Final_ASB_ePub.xhtml#_idTextAnchor171)*，利用S3存储桶*中所看到的。在本节中，我们将使用相同的*方法论*做一些事情，但我们将研究Lambda的配置错误。
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You'll begin to notice that, while the target differs in each chapter in this
    book, the methodology stays more or less the same, because we use the same steps
    to extract results from our targets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您将开始注意到，虽然本书中每一章的目标都不同，但方法论基本上是相同的，因为我们使用相同的步骤从目标中提取结果。
- en: Let's begin to move forward with more concepts and start building some stuff
    in Lambda. Let's start by making a Lambda function that works with S3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始向前迈进，学习更多的概念，并在Lambda中开始构建一些东西。让我们首先创建一个与S3配合工作的Lambda函数。
- en: Creating a Lambda function that is compatible with S3
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个与S3兼容的Lambda函数
- en: In this section, we are just going to continue building. It's important that
    we understand the Lambda service and what it is capable of. In this case, it is
    capable of linking together services that could be potential **pivot** points
    during a pentest.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续构建。了解Lambda服务及其功能是非常重要的。在这种情况下，它能够链接在渗透测试过程中可能成为潜在**枢纽**点的服务。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Pivoting is the process of performing lateral movements in an environment after
    gaining access.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 枢纽是在获得访问权限后在环境中进行横向移动的过程。
- en: What we are going to do here is start looking at how Lambda and S3 work together,
    and then we can look at some misconfigurations that can lead to some downfalls
    if not mitigated properly. It's essential that we understand how systems are created
    before we exploit them. Doing so allows us to be able to take a "hands-on" approach
    to mitigating these issues, and it also helps us understand how to flow break
    on a first-hand basis between various services such as S3 and Lambda.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是开始研究Lambda和S3如何协同工作，然后我们可以看一些配置错误，如果不正确地进行缓解可能会导致一些问题。在我们利用系统之前，了解系统是如何创建的是至关重要的。这样做可以让我们能够采取“实践”方法来缓解这些问题，也有助于我们了解如何在各种服务之间进行流程中断，比如S3和Lambda。
- en: 'Here is an idea of what to expect:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以期待的内容：
- en: '**Create an S3 bucket**: This bucket will be linked to the Lambda function.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个S3存储桶**：此存储桶将与Lambda函数关联。'
- en: '**Create a Lambda function**: The Lambda function will be integrated as a trigger
    for the S3 bucket.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个Lambda函数**：Lambda函数将作为S3存储桶的触发器进行集成。'
- en: '**Integrate the function with S3**.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将函数与S3集成**。'
- en: '**Begin exploring** what we created from a pentesting point of view.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始探索**我们从渗透测试的角度创建的东西。'
- en: 'Now let''s begin! Follow these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始吧！按照以下步骤进行：
- en: To begin, we will create our S3 bucket with the AWS command line, and verify
    that our bucket was created by viewing it from the AWS console – this is best
    practice in my opinion. Make sure you have your AWS ID and AWS secret for your
    account at hand. Once you have your credentials, log in to your AWS environment
    using the `aws configure` command.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用AWS命令行创建我们的S3存储桶，并通过从AWS控制台查看它来验证我们的存储桶是否已创建-这是我认为的最佳实践。确保您随身携带您的AWS
    ID和AWS账户的AWS密钥。一旦您获得了您的凭据，使用`aws configure`命令登录到您的AWS环境。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you need help locating your keys, here is a great reference that you can
    use for help: [https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/](https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助找到您的密钥，这是一个很好的参考资料，您可以使用它进行帮助：[https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/](https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/)。
- en: 'Now that you''re in the environment, let''s get started and create a bucket!
    Using the command line, use the following command to make a bucket that we will
    store in our AWS environment:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然您已经进入环境，让我们开始创建一个存储桶！使用命令行，使用以下命令创建一个我们将存储在AWS环境中的存储桶：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: You'll need to use your own unique naming scheme for the bucket name. Also,
    if you don't specify a region, it will be placed in the **US East** region by
    default.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为存储桶名称使用自己独特的命名方案。此外，如果您不指定区域，它将默认放置在**美国东部**区域。
- en: 'Once you''ve finished creating the bucket with the command line, log in to
    your AWS console and verify that the bucket was created. We can verify this by
    checking the S3 bucket dashboard:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成使用命令行创建存储桶后，请登录到AWS控制台并验证存储桶是否已创建。我们可以通过检查S3存储桶仪表板来验证这一点：
- en: '![Figure 7.3 – Created S3 bucket for Lambda'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3–为Lambda创建的S3存储桶'
- en: '](img/Figure_7.03_B15630.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B15630.jpg)'
- en: Figure 7.3 – Created S3 bucket for Lambda
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3–为Lambda创建的S3存储桶
- en: Now that we have our bucket set up, it's time to move on over and make another
    Lambda function that we can attach our new bucket to through a trigger. This bucket
    will be a little different from the first Lambda function we created, but now
    you know the basic methodology of setting up a Lambda function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的存储桶，是时候继续并创建另一个Lambda函数，我们可以通过触发器将我们的新存储桶连接到其中。这个存储桶将与我们创建的第一个Lambda函数有所不同，但现在您已经知道了设置Lambda函数的基本方法。
- en: Let's start by making a new function and calling it `s3lambda`. Remember that
    you can only use numbers and lowercase letters! For **Runtime**, select the current
    version of Python. For this example, we are using Python 3.8\. Before we click
    **Create function**, we do need to do a couple of other things with our Lambda
    function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新函数并将其命名为`s3lambda`开始。请记住，您只能使用数字和小写字母！对于**Runtime**，请选择当前版本的Python。在这个示例中，我们使用的是Python
    3.8。在点击**创建函数**之前，我们确实需要对我们的Lambda函数进行一些其他操作。
- en: 'Now we need to create a basic role of permissions that will be associated with
    our Lambda function. To do so, follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个基本的权限角色，这将与我们的Lambda函数关联。要做到这一点，请按照以下步骤：
- en: Click on the `s3_pentesting_lambda`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`s3_pentesting_lambda`
- en: '--**Policy templates**: **Amazon S3 object read-only permissions** and **AWS
    Config Rules permissions**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: --**策略模板**：**Amazon S3对象只读权限**和**AWS Config规则权限**：
- en: '![Figure 7.4 – Creating a new function for S3'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4–为S3创建一个新函数'
- en: '](img/Figure_7.04_B15630.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B15630.jpg)'
- en: Figure 7.4 – Creating a new function for S3
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4–为S3创建一个新函数
- en: 'Then, we need to go ahead and **create a trigger** in the Lambda function.
    This function is triggered by things going on within the Lambda environment. Click
    on **Add trigger** to get started, and select **S3** Link the bucket we made titled
    **pentestawslambda** and save:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要继续在Lambda函数中**创建一个触发器**。这个函数是由Lambda环境中发生的事情触发的。点击**添加触发器**开始，并选择**S3**链接我们创建的名为**pentestawslambda**的存储桶并保存：
- en: '![Figure 7.5 – Creating an S3 trigger'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5–创建一个S3触发器'
- en: '](img/Figure_7.05_B15630.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B15630.jpg)'
- en: Figure 7.5 – Creating an S3 trigger
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5–创建一个S3触发器
- en: Great job – we've created a new Lambda function that links with triggers! It
    is important to understand that Lambda can link to other environments, because
    you may come across it during a real pentest. If you find vulnerable Lambda functions
    connected to other services, ensure that you detail out the issues and how the
    vulnerable Lambda function may make other services weaker.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好–我们已经创建了一个与触发器关联的新Lambda函数！重要的是要理解Lambda可以链接到其他环境，因为在真正的渗透测试中可能会遇到它。如果发现与其他服务连接的易受攻击的Lambda函数，请确保详细说明问题以及易受攻击的Lambda函数可能使其他服务变得更脆弱。
- en: Speaking of vulnerabilities derived from misconfigurations, let's move forward
    and discuss misconfigurations within Lambda.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 说到由配置错误导致的漏洞，让我们继续讨论Lambda中的配置错误。
- en: Understanding misconfigurations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解配置错误
- en: Finding misconfigurations in weak policies is one of the more important portions
    of pentesting AWS services such as Lambda and S3\. Due to the security already
    being "built in" within the services, a lot of the issues presented in Lambda
    are due to misconfigurations on the user side of things. That does not mean that
    mistakes aren't made and that there couldn't be inherent flaws within Lambda;
    however, for sake of argument, we will be looking at its configurations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发现弱策略中的配置错误是渗透测试AWS服务（如Lambda和S3）中更重要的部分之一。由于安全性已经“内置”在服务中，Lambda中出现的许多问题是由于用户端的配置错误造成的。这并不意味着不会犯错误，也不意味着Lambda内部可能存在固有缺陷；然而，为了论证，我们将关注它的配置。
- en: A **misconfiguration** – for Lambda policy – occurs when a certain attribute
    is set in a "loose" manner. The word "loose" means that the policy allows more
    than was intended. These policies are what allow unauthorized individuals to view
    information that was not intended for their viewing, or worse, allow malicious
    vectors to view and exfiltrate that data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Lambda策略，**配置错误**发生在某个属性以“宽松”的方式设置时。 “宽松”一词意味着策略允许的内容超出了预期。这些策略是允许未经授权的个人查看未经其查看的信息，或者更糟糕的是，允许恶意向量查看和外泄数据的原因。
- en: '`List`, `Read`, `Write`, `Permissions management`, or `Tagging`. Actions noted
    as `"*"` in the actions for a policy mean that anyone can execute actions on the
    service, which is never good!'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`列出`、`读取`、`写入`、`权限管理`或`标记`。在策略的操作中标有“*”的操作意味着任何人都可以在服务上执行操作，这是绝对不好的！'
- en: So, what makes these loose policies, and how do we find them in Lambda? That's
    what we are about to discover. Moreover, we are going to do that by using the
    tools built into the AWS CLI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么造成了这些宽松的策略，我们如何在Lambda中找到它们？这就是我们将要发现的。此外，我们将通过使用内置在AWS CLI中的工具来做到这一点。
- en: To begin, we'll start looking at the bucket we made with S3\. Recall that we
    set some pretty "loose" permissions when creating the Lambda function and integrating
    it with the bucket. Let's take a look at how easily and quickly that can escalate
    to something it wasn't intended for.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始查看我们使用S3创建的存储桶。回想一下，我们在创建Lambda函数并将其与存储桶集成时设置了一些相当“宽松”的权限。让我们看看它是如何轻松快速地升级到不被预期的情况的。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: We will be doing both Lambda and S3 security checks as we assess the Lambda
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估Lambda函数时，我们将进行Lambda和S3安全检查。
- en: 'Moving forward, let''s query the policy of the Lambda function that we created.
    This will list the attributes of the Lambda function for us:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们查询我们创建的Lambda函数的策略。这将为我们列出Lambda函数的属性：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the layout of the policy is pretty straightforward. However,
    if you take a closer look, you''ll notice something interesting about this function.
    Before we keep going, let''s have a close look at the function. If we were on
    a pentest and pulled something similar to this policy, we would conclude the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，策略的布局非常简单明了。但是，如果您仔细观察，您会注意到有关此函数的一些有趣之处。在继续之前，让我们仔细看看这个函数。如果我们在渗透测试中拉取了类似于这个策略的东西，我们会得出以下结论：
- en: The `Allow` action for **invoking** the function is allowed. While this is good,
    we typically don't want to let anyone do this. Allowing anyone to invoke can create
    big issues later down the line, because if someone were to compromise the internal
    AWS network, they could essentially continue to run the Lambda function.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许**调用**函数的“允许”操作是允许的。虽然这很好，但我们通常不希望任何人都能这样做。允许任何人调用可能会在以后造成重大问题，因为如果有人成功入侵内部AWS网络，他们可能会继续运行Lambda函数。
- en: We also see the `pentestawslambda` S3 bucket in the policy. While this is more
    informational, it lets us know the full URL of the S3 bucket. An attacker could
    use this information to discover more about the S3 bucket, or to discover even
    more buckets that could be in that environment. Therefore, access controls such
    as IAM policies are crucial in only letting those with need-to-know access be
    able to access services within AWS environments.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在策略中看到了`pentestawslambda` S3存储桶。虽然这更多是信息性的，但它让我们知道了S3存储桶的完整URL。攻击者可以使用这些信息来了解更多关于S3存储桶，或者发现可能存在于该环境中的更多存储桶。因此，IAM策略等访问控制对于只允许那些需要知道的人能够访问AWS环境中的服务至关重要。
- en: Now that we know a little more about how to pentest Lambda and what to look
    out for, let's take a different approach and look at how we can get persistent
    access within a Lambda environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何渗透测试Lambda以及要注意的事项有了更多了解，让我们采取不同的方法，看看如何在Lambda环境中获得持久性访问。
- en: Popping reverse shells with Lambda
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda弹出反向shell
- en: 'The final section of this chapter covers one of my favorite parts of pentesting.
    This section is going to walk us through setting up a vulnerable Lambda function
    and then using that function to initiate a reverse connection on our pentesting
    machine. For this section, we will need to use the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分涵盖了我最喜欢的渗透测试部分之一。本节将指导我们设置一个易受攻击的Lambda函数，然后使用该函数在我们的渗透测试机器上启动反向连接。对于本节，我们需要使用以下内容：
- en: Kali Linux on an EC2 instance with a public DNS name
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux在具有公共DNS名称的EC2实例上
- en: A Lambda function
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Lambda函数
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Make sure that you are using an EC2 instance with a public DNS. The Lambda function
    will need to connect to that public DNS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您正在使用具有公共DNS的EC2实例。 Lambda函数将需要连接到该公共DNS。
- en: The coolness of reverse shells
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向shell的酷炫之处
- en: Getting a "shell" is one of the most rewarding parts of pentesting. Being able
    to get a reverse shell means that you were able to successfully exploit a target
    and get persistence on that machine (persistence being a terminal connection on
    that machine). However, it is more than just a connection; it also highlights
    issues within the tested environment. For example, a server that calls out to
    the web may have rules that allow various outgoing connections that you usually
    would not see. This allows reverse shells to go out to the public.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 获取“shell”是渗透测试中最有成就感的部分之一。能够获得反向shell意味着您成功利用了目标并在该机器上获得了持久性（持久性是指在该机器上的终端连接）。但它不仅仅是一个连接；它还突显了被测试环境中的问题。例如，调用网络的服务器可能允许各种通常看不到的出站连接。这使得反向shell可以传送到公共网络。
- en: Shells for pentesting?
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渗透测试的shell？
- en: A client may want you to test the monitoring and detection of their security.
    Creating a vulnerable Lambda function that makes calls inside and outside the
    network is a fantastic way to test companies' monitoring practices and solutions
    and have some fun with Lambda at the same time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可能希望您测试其安全性的监控和检测。创建一个易受攻击的Lambda函数，使其在网络内部和外部进行调用，是测试公司监控实践和解决方案的绝佳方式，同时还可以与Lambda一起玩得开心。
- en: Getting a shell is much more than *just* getting a shell – it tests monitoring,
    firewall rules, and general security posture. During a pentest, if you are able
    to get a reverse shell outside the network using a vulnerable Lambda function,
    it can be assumed that other vulnerabilities within the network could use the
    same route to call outside the network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取shell远不止于*仅仅*获取shell-它测试监控、防火墙规则和一般安全姿态。在渗透测试期间，如果您能够使用易受攻击的Lambda函数在网络外部获得反向shell，可以假定网络内部的其他漏洞可能使用相同的路径呼叫网络外部。
- en: Now that we know more about reverse shells, let's check out how we can set up
    a vulnerable Lambda function that can make callbacks to us and allow remote access
    to a Lambda environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更了解反向shell，让我们看看如何设置一个易受攻击的Lambda函数，可以向我们回拨并允许远程访问Lambda环境。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Before moving forward, it's essential to know that Lambda does bill by the millisecond.
    If you continuously run Lambda functions, you will be charged for them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有必要知道Lambda按毫秒计费。如果您不断运行Lambda函数，将对其收费。
- en: Time for the shell!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用shell了！
- en: The ethical hacking game plan
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道德黑客游戏计划
- en: 'Let''s get our shell, now that we understand a little background about shells
    and their impact on pentesting. We will take a look at the order of events that
    are going to occur before actually executing them. When performing an attack path,
    it can be good practice to have your game plan laid out before executing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们获取我们的shell，现在我们对shell及其对渗透测试的影响有了一些了解。在实际执行之前，我们将看一下即将发生的事件顺序。在执行攻击路径时，事先制定游戏计划可能是一个好的做法：
- en: Start up an EC2 instance with a public DNS.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个带有公共DNS的EC2实例。
- en: Create a vulnerable Lambda function that will call back to the public DNS.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个有漏洞的Lambda函数，将回调到公共DNS。
- en: Start a listener on the EC2 instance.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EC2实例上启动一个监听器。
- en: Test and run the vulnerable Lambda function.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试并运行有漏洞的Lambda函数。
- en: Get a shell.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个shell。
- en: Getting a shell
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取一个shell
- en: 'Now that we have a game plan, let''s move forward and start up the EC2 instance
    that we created earlier. Once that is up and running, go ahead and log in to our
    Lambda dashboard. Now let''s look at how we execute this by moving forward with
    the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个游戏计划，让我们继续并启动我们之前创建的EC2实例。一旦它运行起来，继续登录到我们的Lambda仪表板。现在让我们看看如何通过以下步骤继续执行：
- en: From here we will click the **Create function** button to get started:![Figure
    7.6 – Creating another function
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里开始，我们将点击**创建函数**按钮开始：![图7.6 - 创建另一个函数
- en: '](img/Figure_7.06_B15630.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B15630.jpg)'
- en: Figure 7.6 – Creating another function
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 创建另一个函数
- en: Once you have logged in, create a new function and name it `LambdaShell` and
    ensure that **Python 2.7** is selected. The role we created will work for this
    example:![Figure 7.7 – Creating a function for a reverse shell
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，创建一个名为`LambdaShell`的新函数，并确保选择**Python 2.7**。我们创建的角色将适用于此示例：![图7.7 - 为反向shell创建函数
- en: '](img/Figure_7.07_B15630.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B15630.jpg)'
- en: Figure 7.7 – Creating a function for a reverse shell
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 为反向shell创建函数
- en: 'Now it''s time to start setting up our function to create a reverse connection
    to the EC2 instance. I set up a GitHub repository from which we can pull the code:
    [https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt](https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt).'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候开始设置我们的函数，以创建与EC2实例的反向连接。我设置了一个GitHub存储库，我们可以从中拉取代码：[https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt](https://github.com/PacktPublishing/AWS-Penetration-Testing/blob/master/Chapter%207:%20Assessing%20and%20Pentesting%20Lambda%20Services/Lambda_Shell.txt)。
- en: 'The code that you put in should look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您放入的代码应该如下所示：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to make sure that the function does not time out too quickly.
    By default, the function should be set to time out after about 3 seconds or so.
    We need to establish persistence, so we can go ahead and set the timeout to about
    `5` minutes – feel free to set it longer if you like:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保函数不会太快超时。默认情况下，函数应该在大约3秒后超时。我们需要建立持久性，所以可以将超时设置为大约`5`分钟 - 如果需要，可以设置更长时间：
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The maximum time allowed for Lambda functions is `15` minutes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数允许的最长时间为`15`分钟。
- en: '![Figure 7.8 – Setting the shell timeout'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 设置shell超时'
- en: '](img/Figure_7.08_B15630.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B15630.jpg)'
- en: Figure 7.8 – Setting the shell timeout
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 设置shell超时
- en: Next, you'll need to SSH into your Kali machine and set up a `su -` command
    to switch over to the `sudo` before every command, since you'll be running as
    the root account.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要SSH到您的Kali机器，并设置一个`su -`命令，在每个命令之前切换到`sudo`，因为您将以root帐户运行。
- en: 'The next command sets up the **netcat** listener that we will use to **listen**
    for incoming connections from our target **Lambda service**:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个命令设置了我们将用于**监听**来自目标**Lambda服务**的传入连接的**netcat**监听器：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We should have our listener standing by and our function ready to test. Now
    comes the time when we get our reverse shell and gain some persistence in the
    Lambda environment. To execute, click the **Test** button in the top-right corner.
    You'll be prompted with a window that displays **Configure test event** – go ahead
    and click **Create** to move forward by clicking **Test** again. Note that before
    clicking **Test**, you will be given an event template with three keys. Leave
    those as default:![Figure 7.9 – Configuring the test event before executing the
    function
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该让我们的监听器待命，准备好测试我们的功能。现在是我们获得反向shell并在Lambda环境中获得一些持久性的时候了。要执行，请点击右上角的**测试**按钮。您将看到一个显示**配置测试事件**的窗口
    - 继续点击**创建**，然后再次点击**测试**。请注意，在点击**测试**之前，您将获得一个具有三个键的事件模板。将它们保留为默认值：![图7.9 -
    在执行函数之前配置测试事件
- en: '](img/Figure_7.09_B15630.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B15630.jpg)'
- en: Figure 7.9 – Configuring the test event before executing the function
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 在执行函数之前配置测试事件
- en: 'After you click the **Test** button, you''ll see that the function is running
    within the dashboard. Now move back over to the Terminal you have on the Kali
    machine. You''ll be greeted with a reverse connection on the Lambda instance!
    Feel free to run some Linux commands in your shell:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**按钮后，您将看到函数在仪表板中运行。现在回到您在Kali机器上的终端。您将在Lambda实例上收到一个反向连接！随时在您的shell中运行一些Linux命令：
- en: '![Figure 7.10 – Obtaining a reverse shell'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 - 获取反向shell'
- en: '](img/Figure_7.10_B15630.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B15630.jpg)'
- en: Figure 7.10 – Obtaining a reverse shell
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - 获取反向shell
- en: Check it out! We have consistent access to the Lambda environment! While this
    is a cool and fun example, we need to know some of the underlying problems and
    why we would log this during a pentest. Let's say we were testing a Lambda environment
    for weak policies. A policy should not be able to allow pentesters to execute
    calls outside the Lambda environment as we did – remember, we went to a public
    DNS, which means we went outside the VPC!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧！我们可以始终访问Lambda环境！虽然这是一个很酷的有趣的例子，但我们需要了解一些潜在的问题，以及为什么在渗透测试期间我们会记录这些。假设我们正在测试Lambda环境的弱策略。策略不应该允许渗透测试人员执行超出Lambda环境的调用
    - 记住，我们去了一个公共DNS，这意味着我们走出了VPC！
- en: Okay, so we did all this from the GUI within the AWS console, which was fun
    and pretty cool. Let's take a quick look at a more practical way – using the AWS
    CLI. We will assume that credentials have been compromised and that the function
    is ready to go for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们之前在AWS控制台的GUI中完成了所有这些操作，这很有趣也很酷。让我们快速看一下更实用的方法 - 使用AWS CLI。我们将假设凭据已被泄露，并且该函数已经准备好供我们使用。
- en: Invoking with AWS CLI
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AWS CLI调用
- en: 'Now that we have our function in the environment, let''s see how we could use
    this for persistence only using our Kali Linux machine that is hosted on our public
    EC2 instance. To start, make sure you''re logged in to Kali via SSH and run `netcat`
    in the background by putting `&` at the end of the command. Running the command
    in the background allows you to still use the Terminal:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的函数已经在环境中，让我们看看如何只使用托管在我们的公共EC2实例上的Kali Linux机器来实现持久性。首先，确保您通过SSH登录到Kali，并通过在命令的末尾加上`&`来在后台运行`netcat`。在后台运行命令可以让您仍然使用终端：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now your listener is set up in the background and ready to go. We need to be
    configured to the AWS environment before we can execute the connection. Type `aws
    configure` in your Terminal and ensure that you use the ID and secret key that
    we have used in previous chapters. Once set to the environment, run the following
    command to initiate a shell:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的监听器已经在后台设置好并准备就绪。在执行连接之前，我们需要配置到AWS环境。在终端中键入`aws configure`，确保使用我们在之前章节中使用的ID和密钥。一旦设置到环境中，运行以下命令来启动shell：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You may need to install the AWS CLI on your Kali instance. To install the AWS
    CLI, run the following command: `$ apt-get install awscli -y`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要在您的Kali实例上安装AWS CLI。要安装AWS CLI，请运行以下命令：`$ apt-get install awscli -y`。
- en: As you can see, getting a shell in Lambda can be fun, but it can also be dangerous
    for unsuspecting businesses. A great way to combat this is deploying monitoring
    solutions within a network – devices such as network prevention and detection
    systems that have egress rules that detect malformed traffic going out of the
    network, as well as ingress rules that look at packets coming in. In regard to
    AWS, **CloudTrail** is a great resource to use when attempting to detect traffic
    to and from your AWS environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在Lambda中获取shell可能很有趣，但对于毫无戒心的企业来说也可能很危险。对抗这种情况的一个很好的方法是在网络中部署监控解决方案
    - 诸如网络预防和检测系统之类的设备，这些设备具有检测网络中的异常流量的出口规则，以及检查进入的数据包的入口规则。在AWS方面，**CloudTrail**是在尝试检测与AWS环境之间的流量时使用的一个很好的资源。
- en: We have talked quite a bit about Metasploit throughout this book, so now let's
    look at how we can use Metasploit with Lambda. We are going to look at how we
    can leverage the handler within Metasploit to capture sessions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们已经谈论了很多关于Metasploit，现在让我们看看如何在Lambda中使用Metasploit。我们将看看如何利用Metasploit中的处理程序来捕获会话。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Sessions are connections that have been hooked within Metasploit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是在Metasploit中被挂钩的连接。
- en: Having fun with Metasploit and Lambda
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Metasploit和Lambda玩得开心
- en: Now that we understand how to create shell scripts with Python and Lambda, let's
    take a look at how we can use Metasploit to get similar results! For this exercise,
    we can use the same payload as before; however, you may need to change your instance
    DNS name if you restarted your instance or you're using a different EC2.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何使用Python和Lambda创建shell脚本，让我们看看如何使用Metasploit来获得类似的结果！在这个练习中，我们可以使用之前的相同有效载荷；但是，如果您重新启动了实例或者使用了不同的EC2，您可能需要更改您的实例DNS名称。
- en: Before we start, let's discuss what exactly we are going to be doing; remember,
    it's best to lay out a plan before executing it, even if that plan is small! For
    example, we will need to use the `netcat` to establish connections. We learned
    about `netcat` when setting up reverse shells with our Lambda function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们讨论一下我们将要做什么；记住，最好在执行计划之前制定计划，即使这个计划很小！例如，我们需要使用`netcat`建立连接。我们在设置Lambda函数的反向shell时学习了`netcat`。
- en: Since we have used Metasploit before, in [*Chapter 3*](B15630_03_Final_ASB_ePub.xhtml#_idTextAnchor098)*,
    Exploring Pentesting and AWS*, there won't be a need to talk about Metasploit
    or how to start it up. We will need to ensure that we use the correct payload,
    however. The following steps will show how to set up a handler using a Python
    payload that will catch our connection from our vulnerable Lambda function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前在[*第3章*](B15630_03_Final_ASB_ePub.xhtml#_idTextAnchor098)*，探索渗透测试和AWS*中使用过Metasploit，所以不需要讨论Metasploit或如何启动它。但是，我们需要确保使用正确的有效载荷。以下步骤将展示如何使用Python有效载荷设置处理程序，以捕获我们的脆弱Lambda函数的连接。
- en: 'Start up Metasploit and input the following commands to begin setting up your
    handler:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Metasploit并输入以下命令开始设置处理程序：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you begin running the handler, your handler will go into `netcat` works,
    except we are using Meterpreter for our interpreting shell instead of the default
    Bash shell used in the connection with our shell and `netcat`. Meterpreter shells
    are much more powerful than `netcat` connections because they offer copious amounts
    of modules that you can load within your Meterpreter shell. We will learn more
    about it in [*Chapter 9*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*, Real-Life
    Pentesting with Metasploit and More!*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始运行处理程序，您的处理程序将进入`netcat`工作，除了我们使用Meterpreter来解释我们的shell和`netcat`连接中使用的默认Bash
    shell之外。Meterpreter shell比`netcat`连接更强大，因为它们提供了大量的模块，您可以在Meterpreter shell中加载这些模块。我们将在[*第9章*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*，使用Metasploit进行真实渗透测试和更多内容*中了解更多。
- en: 'Now that our listener is running, go back to your vulnerable Lambda function
    and test it and try to connect to your Meterpreter listener. If all goes well,
    you''ll have a stager and then a session. Your session is your interactive shell
    with the target:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的监听器正在运行，回到您的易受攻击的Lambda函数并测试它，尝试连接到您的Meterpreter监听器。如果一切顺利，您将拥有一个分段器，然后是一个会话。您的会话是与目标的交互式shell：
- en: '![Figure 7.11 – Obtaining a reverse shell via Meterpreter'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11-通过Meterpreter获取反向shell'
- en: '](img/Figure_7.11_B15630.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B15630.jpg)'
- en: Figure 7.11 – Obtaining a reverse shell via Meterpreter
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11-通过Meterpreter获取反向shell
- en: Great, now we have an interactive shell via Meterpreter on our Lambda instance.
    If this Lambda instance were connecting with other resources, the possibility
    of pivoting would exist – however, we aren't going to worry much about that in
    this example. There will be more on pivoting in [*Chapter 9*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*,
    Real-Life Pentesting with Metasploit and More!*. For now, feel free to move around
    with your shell, try different payloads, and even expand your environment to see
    what else you can do!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的Lambda实例上通过Meterpreter拥有了一个交互式shell。如果此Lambda实例正在连接其他资源，则可能存在转向的可能性-但是在本示例中，我们不会过多担心这一点。在[*第9章*](B15630_09_Final_ASB_ePub.xhtml#_idTextAnchor381)*，使用Metasploit进行真实渗透测试和更多内容*中将更多地涉及转向。目前，可以随意移动您的shell，尝试不同的有效载荷，甚至扩展您的环境，看看您还能做些什么！
- en: Great job making it through this portion of the book! This chapter focused quite
    a bit on some new techniques used in pentesting, and you also learned how to get
    reverse shells on Lambda!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的这一部分中做得很好！本章着重介绍了一些在渗透测试中使用的新技术，您还学会了如何在Lambda上获取反向shell！
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to create Lambda functions and their functionality
    in AWS. We also looked at vulnerable issues with Lambda and the vulnerabilities
    that those issues can present to an organization that fails to isolate those issues.
    Creating reverse shells helps us understand the seriousness of what can go wrong
    if a vulnerable Lambda function becomes present in an environment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何在AWS中创建Lambda函数以及它们的功能。我们还研究了Lambda的易受攻击问题以及这些问题可能给未能隔离这些问题的组织带来的漏洞。创建反向shell有助于我们了解如果易受攻击的Lambda函数出现在环境中会出现什么严重问题。
- en: In the next chapter, we are going to start looking at how we attack AWS APIs
    and see how they handle requests, as well as discussing the techniques used to
    secure them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始研究如何攻击AWS API，并查看它们如何处理请求，以及讨论用于保护它们的技术。
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Interactive Lambda shell: [http://www.lambdashell.com/](http://www.lambdashell.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式Lambda shell：[http://www.lambdashell.com/](http://www.lambdashell.com/)
- en: 'Metasploit handler: [https://www.rapid7.com/db/modules/exploit/multi/handler](https://www.rapid7.com/db/modules/exploit/multi/handler)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit处理程序：[https://www.rapid7.com/db/modules/exploit/multi/handler](https://www.rapid7.com/db/modules/exploit/multi/handler)
