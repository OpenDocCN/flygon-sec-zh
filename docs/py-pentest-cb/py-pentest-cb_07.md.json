["```py\nimport socket \n```", "```py\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP) \n```", "```py\nwhile True: \n  print(s.recvfrom(65565)) \n```", "```py\nsudo python3 basic-packet-sniffer-linux.py \n```", "```py\nfrom struct import * \nimport sys \n```", "```py\ndef ethernet_head(raw_data): \n    dest, src, prototype = struct.unpack('! 6s 6s H', raw_data[:14])  \n    dest_mac = get_mac_addr(dest) \n    src_mac = get_mac_addr(src) \n    proto = socket.htons(prototype) \n    data = raw_data[14:] \n    return dest_mac, src_mac, proto, data  \n```", "```py\ndef main(): \n    s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))  \n    while True: \n        raw_data, addr = s.recvfrom(65535) \n        eth = ethernet(raw_data) \n        print('\\nEthernet Frame:') \n        print('Destination: {}, Source: {}, Protocol: {}'.format(eth[0], eth[1], eth[2])) \n\nmain() \n```", "```py\ndef ipv4_head(raw_data): \n    version_header_length = raw_data[0] \n    version = version_header_length >> 4 \n    header_length = (version_header_length & 15) * 4 \n    ttl, proto, src, target = struct.unpack('! 8x B B 2x 4s 4s', raw_data[:20]) \n    data = raw_data[header_length:] \n    return version, header_length, ttl, proto, src, target, data \n```", "```py\ndef main(): \n    s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))  \n    while True: \n        raw_data, addr = s.recvfrom(65535) \n        eth = ethernet(raw_data) \n        print('\\nEthernet Frame:') \n        print('Destination: {}, Source: {}, Protocol: {}'.format(eth[0], eth[1], eth[2]))  \n        if eth[2] == 8: \n            ipv4 = ipv4(ethp[4]) \n            print( '\\t - ' + 'IPv4 Packet:') \n            print('\\t\\t - ' + 'Version: {}, Header Length: {}, TTL:{},'.format(ipv4[1], ipv4[2], ipv4[3])) \n            print('\\t\\t - ' + 'Protocol: {}, Source: {}, Target: {}'.format(ipv4[4], ipv4[5], ipv4[6])) \n```", "```py\ndef get_ip(addr): \n    return '.'.join(map(str, addr)) \n```", "```py\nsrc = get_ip(src) \ntarget = get_ip(target) \n```", "```py\ndef tcp_head( raw_data): \n    (src_port, dest_port, sequence, acknowledgment, offset_reserved_flags) = struct.unpack( \n        '! H H L L H', raw_data[:14]) \n    offset = (offset_reserved_flags >> 12) * 4 \n    flag_urg = (offset_reserved_flags & 32) >> 5 \n    flag_ack = (offset_reserved_flags & 16) >> 4 \n    flag_psh = (offset_reserved_flags & 8) >> 3 \n    flag_rst = (offset_reserved_flags & 4) >> 2 \n    flag_syn = (offset_reserved_flags & 2) >> 1 \n    flag_fin = offset_reserved_flags & 1 \n    data = raw_data[offset:] \n    return src_port, dest_port, sequence, acknowledgment, flag_urg, flag_ack, flag_psh, flag_rst, flag_syn, flag_fin, data \n```", "```py\nif ipv4[4] == 6:  \n    tcp = tcp_head(ipv4[7]) \n    print(TAB_1 + 'TCP Segment:') \n    print(TAB_2 + 'Source Port: {}, Destination Port: {}'.format(tcp[0], tcp[1])) \n    print(TAB_2 + 'Sequence: {}, Acknowledgment: {}'.format(tcp[2], tcp[3])) \n    print(TAB_2 + 'Flags:') \n    print(TAB_3 + 'URG: {}, ACK: {}, PSH:{}'.format(tcp[4], tcp[5], tcp[6])) \n    print(TAB_3 + 'RST: {}, SYN: {}, FIN:{}'.format(tcp[7], tcp[8], tcp[9]))  \n    if len(tcp[10]) > 0: \n         # HTTP \n        if tcp[0] == 80 or tcp[1] == 80: \n             print(TAB_2 + 'HTTP Data:') \n                 try: \n                    http = HTTP(tcp[10]) \n                    http_info = str(http[10]).split('\\n') \n                    for line in http_info: \n                       print(DATA_TAB_3 + str(line)) \n                 except: \n                       print(format_multi_line(DATA_TAB_3, tcp[10])) \n                 else: \n                      print(TAB_2 + 'TCP Data:') \n                      print(format_multi_line(DATA_TAB_3, tcp[10])) \n```", "```py\nelif ipv4[4] == 1: \n    icmp = icmp_head(ipv4[7]) \n    print('\\t -' + 'ICMP Packet:') \n    print('\\t\\t -' + 'Type: {}, Code: {}, Checksum:{},'.format(icmp[0], icmp[1], icmp[2])) \n    print('\\t\\t -' + 'ICMP Data:') \n    print(format_multi_line('\\t\\t\\t', icmp[3])) \n```", "```py\nelif ipv4[4] == 17: \n    udp = udp_head(ipv4[7]) \n    print('\\t -' + 'UDP Segment:') \n    print('\\t\\t -' + 'Source Port: {}, Destination Port: {}, Length: {}'.format(udp[0], udp[1], udp[2])) \n```", "```py\nsudo python3 basic-parse-packet-linux.py  \n```", "```py\npip3 install pyshark  \n```", "```py\n>>> import pyshark \n```", "```py\n>>> cap = pyshark.FileCapture('sample.pcap') \n```", "```py\n >>> cap = pyshark.LiveCapture(interface='wlp3s0b1')\n                  >>> cap.sniff(timeout=3)\n```", "```py\n>>> print(cap[0]) \n```", "```py\n>>> print(dir(cap[0])) \n```", "```py\n>>> import pprint \n>>> pprint.pprint(dir(cap[0])) \n```", "```py\nfor pkt in cap: print(pkt.highest_layer)\n```", "```py\ncap = pyshark.LiveCapture(interface='en0', bpf_filter='ip and tcp port 80')  \ncap.sniff(timeout=5) \n```"]