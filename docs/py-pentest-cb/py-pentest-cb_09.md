# 第九章：Wi-Fi 嗅探

在本章中，我们将涵盖以下内容：

+   寻找 Wi-Fi 设备

+   寻找 SSID

+   揭露隐藏的 SSID

+   对隐藏 SSID 进行字典攻击

+   使用 Scapy 创建虚假访问点

# 介绍

我们已经学会了在 Python 中使用 Scapy 模块。现在我们可以利用 Scapy 模块来嗅探访问点及其 MAC 地址。在此之前，了解 SSID 的概念将会很有用。**服务集标识符**（**SSID**）是无线网络的名称，有助于区分同一网络中的多个信号。我们可以使用 SSID 来识别和连接到网络。

# 寻找 Wi-Fi 设备

加入 Wi-Fi 网络的过程很简单。设备可以监听其他设备以识别它们。这些标识符会持续广播，并被称为**信标**。这些类型的唯一信标由充当访问点的设备广播。这些信标包括作为该访问点名称的 SSID。每个 SSID 都会广播自己独特的信标帧，以通知任何监听设备该 SSID 可用并具有特定功能。我们可以通过监听这些访问点广播的信标来嗅探 Wi-Fi 接口中的数据包，以获取该区域内可用的 Wi-Fi 设备。在这里，我们使用 Scapy 来分析接口捕获的数据包，以提取信标。

# 准备工作

由于我们需要从接口中嗅探数据包，因此我们需要一张能够以监视模式嗅探 Wi-Fi 信号的 Wi-Fi 卡。因此，我们必须确保该卡具备嗅探功能。然后，我们必须将接口设置为监视模式，这对不同的操作系统有不同的设置。由于 Scapy 在 Windows 系统中存在一些限制，因此我们必须在 Linux 或 macOS 环境中运行此操作。

在开始编码之前，我们必须了解 Wi-Fi 数据包。与其他数据包一样，Wi-Fi 数据包也有一定的结构。根据规范 802.11，每个访问点的信标帧包含有关特定 SSID 的大量信息。

以下是 802.11 mgmt 信标帧的帧格式：

![](img/00046.jpeg)

通过这个，我们可以了解信标帧的内容。信标帧中真正重要的项目如下：

+   **SSID 名称**: 这是 WLAN 网络的 1-32 个字符的名称，并且在所有信标中都存在。Wireshark 捕获将显示 SSID 标签如下：

![](img/00047.jpeg)

+   **BSSID**: 这是 SSID 的唯一的第 2 层 MAC 地址。在 Wireshark 捕获中如下所示：

![](img/00048.jpeg)

+   **时间戳**: 这代表访问点上的时间。

+   **安全功能**: 此项目指的是访问点的安全功能，如开放、WEP、WPA、WPA2、个人（密码）与企业（带有 RADIUS 服务器的 802.1x）。在 Wireshark 捕获中如下所示：

![](img/00049.jpeg)

+   **频道**: 这表示此 AP 上的 SSID 操作的特定频率。在 Wireshark 捕获中如下所示：

![](img/00050.jpeg)

+   **频道宽度**: 这表示频道的宽度，如 20、40、80 和 160 mbps。

+   **国家**: 这提供了所有支持的频道和相应的频道设置列表。每个国家都有自己的监管机构，决定其监管领域内允许的频道或功率级别。此标签定义了操作国家、允许的频道和允许的最大传输限制。

+   **信标间隔**: 这表示 AP 广播此信标帧的频率。在 Wireshark 捕获中如下所示：

![](img/00051.jpeg)

# 如何做...

在网络接口中启用监视模式。这对不同的操作系统有不同的设置。而且，并非所有的网络卡都支持监视模式。我们必须使用终端命令来执行此操作，因为无法通过 Python 脚本实现。这将把网络卡接口设置为 wlan0 并进入监视模式。

# Linux

按照以下步骤在 Linux 环境中启用监视模式：

1.  这可以通过`airmon-ng`包完成。请确保您安装了`airmon-ng`包。还要确保您提供正确的接口作为参数：

```py
airmon-ng start wlan0  
```

1.  也可以使用以下网络命令完成：

```py
ifconfig wlan0 down
iw dev wlan0 set type monitor
ifconfig wlan0 up  
```

1.  要禁用监视模式，我们可以使用以下命令：

```py
ifconfig wlan0 down
iw dev wlan1 set type managed
ifconfig wlan0 up  
```

# macOS

按照以下步骤在 macOS 环境中启用监视模式：

1.  我们可以使用`airport`实用程序命令在 macOS 中启用监视模式。由于这是库中的二进制命令，我们可以将其`symlink`到`usr/local/bin/`：

```py
sudo ln -s /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport /usr/local/bin/airport

```

现在我们可以使用`airport`选择要嗅探的信道：

```py
airport en0 channel 7  
```

然后我们可以使用以下命令开始嗅探：

```py
sudo airport en0 sniff  
```

这将`sniff`接口`en0`并将其保存到`tmp/`文件夹中的 pcap 文件中，例如：`/tmp/airportSniffXXXXXX.pcap.` 我们可以使用 Scapy 分析此文件。

1.  现在创建一个`wifi-sniff.py`文件并在编辑器中打开它。

1.  像往常一样，加载所需的模块：

```py
from scapy.all import *
```

1.  现在我们可以定义所需的变量。在这里，我们将为接入点创建一个列表：

```py
access_points = []    
```

1.  现在我们可以定义回调函数来解析数据包：

```py
def parsePacket(pkt):
    if pkt.haslayer(Dot11):
        print(pkt.show())  
```

这将打印捕获的 Wi-Fi 数据包。输出如下：

![](img/00052.jpeg)

对于 802.11 数据包层，主要变量是：

+   +   `type=0`：这表示帧是管理帧（类型 0）

+   `subtype=8`：这表示管理帧的子类型是信标（类型 8）

+   `addr1`：目标 MAC 地址

+   `addr2`：发送者的源 MAC 地址

+   `addr3`：接入点的 MAC 地址

1.  从前面的细节中，我们可以更新解析器函数以获取 Wi-Fi MAC 地址：

```py
def parsePacket(pkt):
    if pkt.haslayer(Dot11):
        if pkt.type == 0 and pkt.subtype == 8:
            if pkt.addr2 not in ap_list:
               print(pkt.addr2)
```

1.  现在调用`sniff`函数并将数据包传递给`callback`函数：

```py
sniff(iface='en0', prn=parsePacket, count=10, timeout=3, store=0)  
```

1.  保存脚本并以`sudo`权限调用：

```py
$ sudo python3 Wi-Fi-sniff.py  
```

# 查找 SSID

要获取 SSID，我们需要更新先前的方法并从数据包中解析 SSID。

# 如何做...

以下是使用`scapy`模块编写 SSID 嗅探器脚本的步骤：

1.  创建一个`sniff-ssid.py`文件并在编辑器中打开它。

1.  导入所需的模块：

```py
from scapy.all import *   
```

1.  现在创建一个函数来从数据包中解析 SSID：

```py
def parseSSID(pkt):
    if pkt.haslayer(Dot11):
        print(pkt.show())
        if pkt.type == 0 and pkt.subtype == 8:
                ap_list.append(pkt.addr2)
                print("SSID:" + pkt.info)
```

1.  现在运行`sniff`并在回调上调用解析函数。

```py
sniff(iface='en0', prn=ssid, count=10, timeout=3, store=0)  
```

1.  现在以`sudo`权限运行此脚本：

```py
$ sudo python3 sniff-ssid.py  
```

# 暴露隐藏的 SSID

我们可以修改先前的方法以获取隐藏的 SSID。使用 Scapy，我们可以识别探测响应和请求以提取隐藏的 SSID。

# 如何做...

按照以下步骤编写一个暴露隐藏 SSID 的脚本：

1.  创建一个`sniff-hidden-ssid.py`文件并在编辑器中打开它。

1.  导入`scapy`模块并为识别的 SSID 创建一个字典：

```py
from scapy.all import *
hiddenSSIDs = dict()  
```

1.  现在创建一个函数来从数据包中解析隐藏的 SSID：

```py
def parseSSID(pkt):
if pkt.haslayer(Dot11Beacon) or pkt.haslayer(Dot11ProbeResp):
   if not hiddenSSIDs.has_key(pkt[Dot11].addr3):
         ssid       = pkt[Dot11Elt].info
         bssid      = pkt[Dot11].addr3
         channel    = int( ord(pkt[Dot11Elt:3].info))
         capability = pkt.sprintf("{Dot11Beacon%Dot11Beacon.cap%}\{Dot11ProbeResp:%Dot11ProbeResp.cap%}")
    if re.search("privacy", capability): 
              encrypted = 'Y'
   else: 
              encrypted  = 'N'
    hiddenSSIDs[pkt[Dot11].addr3] =[encrypted, ssid, bssid, channel] 
          print (hiddenSSIDs)  
```

在这里，它检查探测响应和请求以提取 BSSID 和 SSID

1.  最后，`sniff`数据包并将其传递给`callback`函数。

```py
sniff(iface='wlan0', prn=parseSSID, count=10, timeout=3, store=0)    
```

1.  现在以 root 权限运行此脚本：

```py
sudo sniff-hidden-ssid.py    
```

# 隐藏 SSID 的字典攻击

对于隐藏的 SSID，我们可以运行字典攻击来识别隐藏的 SSID。为此，我们将遍历 SSID 列表并发送带有特定 SSID 的广播数据包。如果 SSID 存在，接入点将以数据包响应。因此，我们可以在先前的方法中启动 SSID 嗅探器，并在运行 SSID 的暴力攻击时等待来自接入点的响应。

# 如何做...

以下是编写可用于对 SSID 运行字典攻击的脚本的步骤：

1.  像往常一样，创建一个新的`dictionary-attack-ssid.py`文件并在编辑器中打开它。

1.  加载所有必需的模块，并初始化变量：

```py
from scapy.all import *
senderMac = "aa:aa:aa:aa:aa:aa"
broadcastMac = "ff:ff:ff:ff:ff:ff"  
```

1.  然后，我们遍历列表中的 SSID 并发送带有设置为参数的`RadioTap()`数据包：

```py
for ssid in open('ssidList.txt', 'r').readlines():
     pkt = RadioTap()/Dot11(type = 0, subtype = 4 ,addr1 = broadcastMac, addr2 = senderMac, addr3 = broadcastMac)/Dot11ProbeReq()/Dot11Elt(ID=0, info =ssid.strip()) / Dot11Elt(ID=1, info = "\x02\x04\x0b\x16") / Dot11Elt(ID=3, info="\x08")
     print ("Checking ssid:" + ssid)
     print(pkt.show())
     sendp (pkt, iface ="en0", count=1)
```

1.  现在在一个终端窗口中启动嗅探器脚本并等待响应。

1.  最后，以`sudo`权限启动字典攻击脚本：

```py
sudo python3  dictionary-attack-ssid.py  
```

# 使用 Scapy 创建虚假接入点

我们可以通过使用 Scapy 注入信标帧来创建虚假的 Wi-Fi 接入点。

# 如何做...

让我们尝试用以下步骤创建一个假的 SSID：

1.  创建一个新的`fake-access-point.py`文件并在编辑器中打开它。

1.  加载脚本所需的模块：

```py
from scapy.all import *
import random  
```

在这里，我们使用`scapy`和`random`模块来创建随机的 MAC ID

1.  然后定义接入点名称和要广播的接口：

```py
ssid = "fakeap" 
iface = "en0"  
```

1.  现在我们可以用`beacon`帧来制作数据包：

```py
dot11 = Dot11(type=0, subtype=8, addr1='ff:ff:ff:ff:ff:ff', addr2=str(RandMAC()), addr3=str(RandMAC()))
dot11beacon = Dot11Beacon(cap='ESS+privacy')
dot11essid = Dot11Elt(ID='SSID',info=ssid, len=len(ssid))
 rsn = Dot11Elt(ID='RSNinfo', info=(
    '\x01\x00'                 #For RSN Version 1
    '\x00\x0f\xac\x02'         #Group Cipher Suite : 00-0f-ac TKIP
    '\x02\x00'                 #2 Pairwise Cipher Suites (next two lines)
    '\x00\x0f\xac\x04'         #AES Cipher
    '\x00\x0f\xac\x02'         #TKIP Cipher
    '\x01\x00'                 #1 Authentication Key Managment Suite (line below)
    '\x00\x0f\xac\x02'         #Pre-Shared Key
    '\x00\x00'))               #RSN Capabilities (no extra capabilities)   
frame = RadioTap()/dot11/dot11beacon/dot11essid/rsn
```

1.  现在我们可以用`sendp()`方法广播接入点：

```py
sendp(frame, iface=iface, inter=0.0100 if len(frames)<10 else 0, loop=1)  
```

1.  现在以所需的权限运行脚本：

```py
sudo python3 fake-access-point.py  
```

这将广播一个带有提供的 SSID 的接入点
