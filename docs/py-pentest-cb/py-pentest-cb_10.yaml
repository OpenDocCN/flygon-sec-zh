- en: Layer 2 Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2层攻击
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: ARP Watcher
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP监视器
- en: ARP cache poisoning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP缓存中毒
- en: MAC flooder
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAC洪泛
- en: VLAN hopping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VLAN跳跃
- en: ARP spoofing over VLAN hopping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过VLAN跳跃进行ARP欺骗
- en: DHCP starvation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DHCP饥饿
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Layer 2 is the data link layer responsible for addressing packets in an Ethernet
    with MAC addresses. Layer 2 is used to transfer data between adjacent network
    nodes in a wide area network, or between nodes on the same LAN. In this chapter,
    we will go through some of the common attacks at the second layer of TCP/IP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第2层是数据链路层，负责在具有MAC地址的以太网中寻址数据包。第2层用于在广域网中的相邻网络节点之间或在同一局域网上的节点之间传输数据。在本章中，我们将介绍TCP/IP第二层的一些常见攻击。
- en: ARP Watcher
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP监视器
- en: With **Address Resolution Protocol** (**ARP**), we can find live internal hosts.
    We can write a script to scan for hosts in a given network with Scapy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**地址解析协议**（**ARP**），我们可以找到活动的内部主机。我们可以编写一个使用Scapy扫描给定网络中主机的脚本。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can write a ARP Watcher with the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤编写ARP监视器：
- en: Create an `arp-scanner.py` file and open it in your editor.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`arp-scanner.py`文件并在编辑器中打开它。
- en: 'We then have to import the required modules:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们必须导入所需的模块：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now declare the variables for the script:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为脚本声明变量：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can send ARP packets to all the IPs in the IP range, and get answered
    and unanswered packets.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以向IP范围内的所有IP发送ARP数据包，并获取已回答和未回答的数据包。
- en: 'Create the ARP packet as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建ARP数据包如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The structure of the packet will be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的结构将如下所示：
- en: '![](img/00053.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: 'Then, send the packet with `srp()` and receive the response:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`srp()`发送数据包并接收响应：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, iterate through all the answered packets and print their MAC and IPs:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，遍历所有已回答的数据包并打印它们的MAC和IP地址：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, run the script with required permission:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以所需的权限运行脚本：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print the MAC and IPs of all active systems in the network range
    provided. Output will be as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所提供的网络范围内所有活动系统的MAC和IP。输出将如下所示：
- en: '![](img/00054.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Now we can convert this to an ARP monitor, that has the ability to monitor the
    network for changes. For that, create another `arp-monitor.py` file and import
    the `scapy` module.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将其转换为ARP监视器，具有监视网络变化的能力。为此，创建另一个`arp-monitor.py`文件并导入`scapy`模块。
- en: 'Then, create a function to parse the packets and sniff the interface:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个函数来解析数据包并嗅探接口：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, start sniffing and call the `parsePacket()` method to parse the ARP packets:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始嗅探并调用`parsePacket()`方法来解析ARP数据包：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the script with required permission to start the monitoring:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本以开始监视：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ARP cache poisoning
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP缓存中毒
- en: As we know, systems on a TCP/IP LAN identify and communicate with each other
    via the MAC addresses of their network adapters. Each system keeps a list of systems
    and their MAC addresses for reference, known as the ARP cache. If possible, we
    need to spoof the cache of a machine with a wrong MAC address for another machine.
    All communication to that machine with the spoofed MAC address from the machine
    will be directed to the attached machine. So, ARP cache poisoning is the method
    of tricking a machine to save the wrong data about an IP address in its ARP table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，TCP/IP局域网上的系统通过其网络适配器的MAC地址识别和相互通信。每个系统都会保留一份系统和其MAC地址的列表以供参考，称为ARP缓存。如果可能的话，我们需要欺骗一台机器的缓存，使其用错误的MAC地址替换另一台机器的MAC地址。从机器发送到具有伪造MAC地址的机器的所有通信将被定向到连接的机器。因此，ARP缓存中毒是一种欺骗机器在其ARP表中保存有关IP地址的错误数据的方法。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we are performing a type of man-in-the-middle attack (getting the data from
    another device connected to the same network), we have to turn on the IP forwarding
    to make sure that the connection on the victim's machine is not affected or interrupted.
    For performing IP forwarding, we have different methods for Linux and macOS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在执行一种中间人攻击（从连接到同一网络的另一台设备获取数据），我们必须打开IP转发以确保受害者机器上的连接不受影响或中断。为了执行IP转发，我们在Linux和macOS上有不同的方法。
- en: Linux
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'We can check the status of IP forwarding by checking the content in the following
    file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查以下文件中的内容来检查IP转发的状态：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the output is `1`, IP forwarding is enabled; and if it''s `0`, IP forwarding
    is disabled. If it''s disabled, enable it as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出是`1`，则IP转发已启用；如果是`0`，则IP转发已禁用。如果已禁用，请按以下方式启用它：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: macOS
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: 'You can enable IP forwarding in macOS with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在macOS上启用IP转发：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Disable it with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令禁用它：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to write a script to poison ARP cache in a victim system:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是编写脚本以中毒受害系统的ARP缓存的步骤：
- en: Create a new `arp-cache-poisoning.py` file and open in your editor.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`arp-cache-poisoning.py`文件并在编辑器中打开。
- en: 'Import the `scapy` module:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`scapy`模块：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare the variables. We could also get these from arguments, or as: `raw_input()`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明变量。我们也可以从参数中获取这些，或者使用`raw_input()`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now define a function to get the MAC IDs from the IP provided:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个从提供的IP获取MAC ID的函数：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now get the MAC address of the target and gateway with the `getMac()` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用`getMac()`方法获取目标和网关的MAC地址：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the function to poison the ARP cache of the target:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义中毒目标ARP缓存的函数：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are sending two types of packets--one to the target machine, and one
    to the gateway. The first two blocks define these packets. The target packet will
    be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发送两种类型的数据包--一种是发送到目标机器，另一种是发送到网关。前两个块定义了这些数据包。目标数据包将如下所示：
- en: '![](img/00055.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: 'The `gateway` packet will be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`网关`数据包将如下所示：'
- en: '![](img/00056.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: 'Now create a function to reset the poisoned cache back to the normal state:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个函数将中毒的缓存重置为正常状态：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can start sending the packets:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以开始发送数据包：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the script with required permission:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MAC flooder
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC洪泛
- en: We can fill the MAC address store of a router by sending random Ethernet traffic
    over the network. This may lead to the malfunction of the switch, and may start
    sending all the network traffic to everyone connected to the router, or it may
    fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在网络上传送随机的以太网流量来填充路由器的MAC地址存储。这可能导致交换机故障，并可能开始将所有网络流量发送给连接到路由器的所有人，或者可能失败。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to flood MAC address store in a router:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是淹没路由器MAC地址存储的步骤：
- en: Create a `mac-flooder.py` file and open in your editor.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`mac-flooder.py`文件并在您的编辑器中打开。
- en: 'Import the required modules:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the `interface` to flood. We could also get it from the arguments:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要淹没的`interface`。我们也可以从参数中获取它：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the packets with random MAC IDs and random IPs:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有随机MAC ID和随机IP的数据包：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The packet structure will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包结构将如下所示：
- en: '![](img/00057.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: 'Finally, send the packets in an infinite loop:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在无限循环中发送数据包：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now run the file with required permission:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以所需的权限运行文件：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: VLAN hopping
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VLAN跳跃
- en: 'VLAN hopping is the type of attack in which the attacker is able to send traffic
    from one VLAN into another. We can do this with two methods: double tags and switch
    spoofing.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: VLAN跳跃是一种攻击类型，攻击者能够将一个VLAN的流量发送到另一个VLAN。我们可以用两种方法实现这一点：双标签和交换机欺骗。
- en: To create a double tag attack, the attacker sends a packet with two **802.1Q**
    tags--the inner VLAN tag is the VLAN that we are planning to reach, and the outer
    layer is the current VLAN.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建双标签攻击，攻击者发送一个带有两个**802.1Q**标签的数据包--内部VLAN标签是我们计划到达的VLAN，外层是当前的VLAN。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to simulate a simple VLAN hopping attack:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟简单的VLAN跳跃攻击的步骤：
- en: Create a `vlan-hopping.py` file and open in your editor.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`vlan-hopping.py`文件并在您的编辑器中打开。
- en: 'Import the modules and set the variables:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块并设置变量：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Craft the packet with two 802.1Q tags:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个802.1Q标签制作数据包：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The packet will be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包将如下所示：
- en: '![](img/00058.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: 'Now, send these packets in an infinite loop:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在无限循环中发送这些数据包：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the script with required permission:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ARP spoofing over VLAN hopping
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP欺骗跨VLAN跳跃
- en: As VLANs limit broadcast traffic to the same VLAN, here we tag every packet
    with our VLAN tag, and an extra with the destination VLAN.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于VLAN限制广播流量到相同的VLAN，因此我们为每个数据包打上我们的VLAN标记，并额外添加目标VLAN的标记。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to simulate ARP spoofing attack over VLAN hopping:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟ARP欺骗攻击跨VLAN跳跃的步骤：
- en: Create a new `arp-spoofing-over-vlan.py` file and open in your editor.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`arp-spoofing-over-vlan.py`文件并在您的编辑器中打开。
- en: 'Import modules and set variables:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块并设置变量：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create ARP packets with two 802.1Q tags:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有两个802.1Q标签的ARP数据包：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the packet with two 802.1Q tags and an ARP layer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有两个802.1Q标签和ARP层的数据包：
- en: '![](img/00059.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: 'Send the packets in an infinite loop:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环中发送数据包：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the script with required permission:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: DHCP starvation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DHCP饥饿
- en: DHCP is the protocol that helps to assign clients' IP addresses to the LAN.
    The process of assigning DHCP consists of four steps--DHCPDiscover, DHCPOffer,
    DHCPRequest, and DHCP ACK.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP是帮助为LAN分配客户端IP地址的协议。分配DHCP的过程包括四个步骤--DHCPDiscover、DHCPOffer、DHCPRequest和DHCP
    ACK。
- en: 'DHCPDiscover is the first step where the client broadcasts in the LAN to find
    a DHCP server that can provide an IP for the client. Then the server will respond
    with a unicast DHCPOffer, where it offers a possible IP. Then, the client will
    broadcast the DHCPRequest with the IP to all networks, and finally the server
    will respond with a DHCP ACK or DHCP NAK. ACK represents a successful DHCP process,
    while NAK represents when the IP is not available:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: DHCPDiscover是客户端在LAN中广播以查找可以为客户端提供IP的DHCP服务器的第一步。然后服务器将以单播DHCPOffer响应，其中提供可能的IP。然后，客户端将向所有网络广播DHCPRequest与IP，最后服务器将以DHCP
    ACK或DHCP NAK响应。ACK表示成功的DHCP过程，而NAK表示IP不可用：
- en: '![](img/00060.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: The DHCP server stores the IP information to MAC bindings. If we ask for too
    many IPs from the DHCP server, other legitimate clients will not get an IP to
    connect. This is known as a **DHCP starvation attack**. In this recipe, we will
    be attacking the third step of this process. After sending the DHCP request, the
    server will assign the requested IP for the client. This can be used to attack
    a specific range of IPs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP服务器将IP信息存储到MAC绑定。如果我们从DHCP服务器请求太多IP，其他合法客户端将无法获得IP连接。这被称为**DHCP饥饿攻击**。在这个示例中，我们将攻击这个过程的第三步。发送DHCP请求后，服务器将为客户端分配请求的IP。这可以用来攻击特定范围的IP。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try writing a script to starve the DHCP in the network:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个脚本来使网络中的DHCP饥饿：
- en: Create a `dhcp-starvation.py` file and open in your editor.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`dhcp-starvation.py`文件并在您的编辑器中打开。
- en: 'Import the required modules:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We require `Scapy` for crafting the packets, and a `threading` module for threaded
    execution of the script
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`Scapy`来制作数据包，并且需要`threading`模块来执行脚本的线程化
- en: 'Now, define the variables:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义变量：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can define the callback function to handle the captured DHCP packets:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义回调函数来处理捕获的DHCP数据包：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function is called to process each packet received by the sniffer
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被调用来处理嗅探器接收到的每个数据包
- en: 'Now we have to create another function to configure the sniffer. This function
    is called by the threads:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建另一个函数来配置嗅探器。这个函数被线程调用：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will start sniffing the UDP packets to the ports `67` and `68`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始嗅探到端口`67`和`68`的UDP数据包
- en: 'Now we can create a DHCPRequest packet and send it to the DHCP server that
    we are planning to starve:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个DHCPRequest数据包并将其发送到我们计划饥饿的DHCP服务器：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will first generate an IP within the specified range. Also, it will create
    a random MAC address for the packet. This will then craft a DHCPRequest packet
    with the generated IP addresses and MAC. Then, it will send the packet. The packet
    generated will be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先在指定范围内生成一个IP地址。此外，它将为数据包创建一个随机的MAC地址。然后，它将使用生成的IP地址和MAC地址来创建一个DHCP请求数据包。然后，它将发送数据包。生成的数据包将如下所示：
- en: '![](img/00061.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: 'Now we can start threads and try to occupy the IP address in the DHCP server:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动线程，尝试在DHCP服务器中占用IP地址：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, run the script with required permission.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以所需的权限运行脚本。
