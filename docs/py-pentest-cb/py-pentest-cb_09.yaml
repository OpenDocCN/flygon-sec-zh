- en: Wi-Fi Sniffing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wi-Fi嗅探
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Finding Wi-Fi devices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找Wi-Fi设备
- en: Finding SSIDs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找SSID
- en: Exposing hidden SSIDs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭露隐藏的SSID
- en: Dictionary attack on hidden SSIDs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对隐藏SSID进行字典攻击
- en: Fake access points with Scapy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy创建虚假访问点
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We have learned to use the Scapy module in Python. Now we can utilize the Scapy
    module for sniffing access points and their MAC addresses. Before that, it would
    be useful to have an idea of SSIDs. A **Service Set Identifier** (**SSID**) is
    the name of the wireless network that helps to separate the multiple signals in
    the same network. We can use the SSID to identify and connect to a network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了在Python中使用Scapy模块。现在我们可以利用Scapy模块来嗅探访问点及其MAC地址。在此之前，了解SSID的概念将会很有用。**服务集标识符**（**SSID**）是无线网络的名称，有助于区分同一网络中的多个信号。我们可以使用SSID来识别和连接到网络。
- en: Finding Wi-Fi devices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找Wi-Fi设备
- en: The process of joining a Wi-Fi network is simple. The devices can listen for
    other devices to identity them. These identifiers are broadcast continuously and
    are known as **beacons**. These types of unique beacons are broadcast by the devices,
    which act as access points. These beacons include an SSID that acts as the name
    of that access point. Every SSID broadcasts its own unique beacon frame to notify
    any listening device that this SSID is available and it has particular capabilities.
    We can sniff the packets in the Wi-Fi interface to get the Wi-Fi devices available
    in the area by listening to these beacons broadcast by the access points. Here
    we use Scapy to analyze the packets captured by the interface to extract the beacons.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 加入Wi-Fi网络的过程很简单。设备可以监听其他设备以识别它们。这些标识符会持续广播，并被称为**信标**。这些类型的唯一信标由充当访问点的设备广播。这些信标包括作为该访问点名称的SSID。每个SSID都会广播自己独特的信标帧，以通知任何监听设备该SSID可用并具有特定功能。我们可以通过监听这些访问点广播的信标来嗅探Wi-Fi接口中的数据包，以获取该区域内可用的Wi-Fi设备。在这里，我们使用Scapy来分析接口捕获的数据包，以提取信标。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we have to sniff the packets from the interface, we require a Wi-Fi card
    capable of sniffing the Wi-Fi signals with the Monitor Mode. So we have to make
    sure the card is capable of sniffing. Then we have to set the interface to the
    Monitor Mode which is different for different operating systems. As Scapy has
    some limitations in the Windows systems, we have to run this recipe in a Linux
    or macOS environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要从接口中嗅探数据包，因此我们需要一张能够以监视模式嗅探Wi-Fi信号的Wi-Fi卡。因此，我们必须确保该卡具备嗅探功能。然后，我们必须将接口设置为监视模式，这对不同的操作系统有不同的设置。由于Scapy在Windows系统中存在一些限制，因此我们必须在Linux或macOS环境中运行此操作。
- en: Before we start coding, we have to get an idea about the Wi-Fi packets. As with
    the other packets, Wi-Fi packets also have a structure. According to the specification
    802.11, each beacon frame from the access point contains a lot of information
    about the specific SSID.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，我们必须了解Wi-Fi数据包。与其他数据包一样，Wi-Fi数据包也有一定的结构。根据规范802.11，每个访问点的信标帧包含有关特定SSID的大量信息。
- en: 'Here is the frame format for an 802.11 mgmt beacon frame:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是802.11 mgmt信标帧的帧格式：
- en: '![](img/00046.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: 'From this, we can get an idea of the content of the beacon frame. The really
    important items in the beacon frame are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们可以了解信标帧的内容。信标帧中真正重要的项目如下：
- en: '**SSID name**: This is a 1-32 character name of the WLAN network and is present
    in all beacons. The Wireshark capture will display the SSID tag as follows:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSID名称**: 这是WLAN网络的1-32个字符的名称，并且在所有信标中都存在。Wireshark捕获将显示SSID标签如下：'
- en: '![](img/00047.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: '**BSSID**: This is a unique layer 2 MAC address of the SSID. Here is what it
    looks like in the Wireshark capture:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSSID**: 这是SSID的唯一的第2层MAC地址。在Wireshark捕获中如下所示：'
- en: '![](img/00048.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: '**Timestamp**: This represents the time on the access point.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**: 这代表访问点上的时间。'
- en: '**Security capabilities**: This item refers to the security capabilities of
    the access point, such as open, WEP, WPA, WPA2, personal (passphrase) versus enterprise
    (802.1x with RADIUS server). Here is what it looks like in the Wireshark capture:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全功能**: 此项目指的是访问点的安全功能，如开放、WEP、WPA、WPA2、个人（密码）与企业（带有RADIUS服务器的802.1x）。在Wireshark捕获中如下所示：'
- en: '![](img/00049.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: '**Channel**: This indicates the specific frequency that the SSID on this AP
    is operating on. Here is it what it looks like in the Wireshark capture:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道**: 这表示此AP上的SSID操作的特定频率。在Wireshark捕获中如下所示：'
- en: '![](img/00050.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: '**Channel width**: This indicates the width of the channel, such as 20, 40,
    80, and 160 mbps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道宽度**: 这表示频道的宽度，如20、40、80和160 mbps。'
- en: '**Country**: This provides a list of all the supported channels and corresponding
    channel settings. Each country has its own regulatory bodies that decide the channels
    or power levels allowed in their regulatory domain. This tag defines the country
    of operation and the allowed channels and the allowed maximum transmit limit.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国家**: 这提供了所有支持的频道和相应的频道设置列表。每个国家都有自己的监管机构，决定其监管领域内允许的频道或功率级别。此标签定义了操作国家、允许的频道和允许的最大传输限制。'
- en: '**Beacon interval**: This indicates how often the AP broadcasts this beacon
    frame. Here is what it looks like in the Wireshark capture:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信标间隔**: 这表示AP广播此信标帧的频率。在Wireshark捕获中如下所示：'
- en: '![](img/00051.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Enable the Monitor Mode in the network interface. This is different for different
    operating systems. Also, not all network cards support the Monitor Mode. We have
    to use a terminal command to do this as it is not possible through Python script.
    This will put the network card Interface as wlan0 into the Monitor Mode.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络接口中启用监视模式。这对不同的操作系统有不同的设置。而且，并非所有的网络卡都支持监视模式。我们必须使用终端命令来执行此操作，因为无法通过Python脚本实现。这将把网络卡接口设置为wlan0并进入监视模式。
- en: Linux
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'Follow the steps to enable Monitor Mode in a Linux environment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在Linux环境中启用监视模式：
- en: 'This can be done with the `airmon-ng` package. Please make sure you install
    the `airmon-ng` package for this. Also, make sure you provide the correct interface
    as the parameter:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过`airmon-ng`包完成。请确保您安装了`airmon-ng`包。还要确保您提供正确的接口作为参数：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can also be done with the following networking commands:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以使用以下网络命令完成：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To disable the Monitor Mode, we can use the following commands:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用监视模式，我们可以使用以下命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: macOS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: 'Follow the steps to enable Monitor Mode in a macOS environment:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在macOS环境中启用监视模式：
- en: 'We can use the airport utility command to enable the Monitor Mode in macOS.
    As this is a binary command in the library, we can `symlink` this to `usr/local/bin/`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`airport`实用程序命令在macOS中启用监视模式。由于这是库中的二进制命令，我们可以将其`symlink`到`usr/local/bin/`：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can select the channel to sniff with `airport` :'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`airport`选择要嗅探的信道：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we can start sniffing with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下命令开始嗅探：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will `sniff` the interface `en0` and save to a pcap file inside a `tmp/`
    folder such as this: `/tmp/airportSniffXXXXXX.pcap.` We can analyze this file
    with Scapy.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`sniff`接口`en0`并将其保存到`tmp/`文件夹中的pcap文件中，例如：`/tmp/airportSniffXXXXXX.pcap.`
    我们可以使用Scapy分析此文件。
- en: Now create a `wifi-sniff.py` file and open it in your editor.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个`wifi-sniff.py`文件并在编辑器中打开它。
- en: 'As usual, load the required modules:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，加载所需的模块：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can define the required variable. Here we will create a list for the
    access points:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义所需的变量。在这里，我们将为接入点创建一个列表：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can define the callback function to parse the packets:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义回调函数来解析数据包：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will print the captured Wi-Fi packets. The output will be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印捕获的Wi-Fi数据包。输出如下：
- en: '![](img/00052.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'For the 802.11 packet layer, the main variables are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于802.11数据包层，主要变量是：
- en: '`type=0`: This indicates that the frame is a management frame (type 0)'
  id: totrans-59
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type=0`：这表示帧是管理帧（类型0）'
- en: '`subtype=8`: This indicates the management frame''s subtype is a beacon (type
    8)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtype=8`：这表示管理帧的子类型是信标（类型8）'
- en: '`addr1`: Destination MAC address'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr1`：目标MAC地址'
- en: '`addr2`: Source MAC address of the sender'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr2`：发送者的源MAC地址'
- en: '`addr3`: MAC address of the access point'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr3`：接入点的MAC地址'
- en: 'From the preceding details, we can update the parser function to get the Wi-Fi
    MAC address:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的细节中，我们可以更新解析器函数以获取Wi-Fi MAC地址：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now call the `sniff` function and pass the packets to the `callback` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调用`sniff`函数并将数据包传递给`callback`函数：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the script and call with the `sudo` permission:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并以`sudo`权限调用：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finding SSIDs
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找SSID
- en: To get the SSID, we need to update the previous recipe and parse the SSID from
    the packets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取SSID，我们需要更新先前的方法并从数据包中解析SSID。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Following are the steps to write a SSID sniffer script with `scapy` module:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scapy`模块编写SSID嗅探器脚本的步骤：
- en: Create a `sniff-ssid.py` file and open it in your editor.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sniff-ssid.py`文件并在编辑器中打开它。
- en: 'Import the module required:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now create a function to parse the SSID from the packet:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个函数来从数据包中解析SSID：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now run the `sniff` and call the parse function on the callback.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`sniff`并在回调上调用解析函数。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now run this script with the `sudo` permission:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以`sudo`权限运行此脚本：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exposing hidden SSIDs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露隐藏的SSID
- en: We can modify the previous recipe to get the hidden SSIDs. With Scapy, we can
    identify probe answers and requests to extract the hidden SSIDs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改先前的方法以获取隐藏的SSID。使用Scapy，我们可以识别探测响应和请求以提取隐藏的SSID。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the steps to write a script to expose hidden SSIDs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编写一个暴露隐藏SSID的脚本：
- en: Create a `sniff-hidden-ssid.py` file and open it in the editor.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sniff-hidden-ssid.py`文件并在编辑器中打开它。
- en: 'Import the `scapy` module and create a dictionary for the identified SSIDs:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`scapy`模块并为识别的SSID创建一个字典：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now create the function to parse the hidden SSIDs from the packets:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个函数来从数据包中解析隐藏的SSID：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here it checks for the probe response and request to extract the BSSID and SSID
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它检查探测响应和请求以提取BSSID和SSID
- en: Finally, `sniff` the packet and pass it to the `callback` function.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`sniff`数据包并将其传递给`callback`函数。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now run this script with the root permission:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以root权限运行此脚本：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Dictionary attack on hidden SSIDs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏SSID的字典攻击
- en: With hidden SSIDs, we could run a dictionary attack to identify the hidden SSIDs.
    For that, we will iterate through a list of SSIDs and send a broadcast packet
    with a particular SSID. If the SSID exists, the access point will respond with
    a packet. So, we could start the SSID sniffer we created in the previous recipe
    and wait for the response from the access point while running the brute force
    attack with the SSIDs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于隐藏的SSID，我们可以运行字典攻击来识别隐藏的SSID。为此，我们将遍历SSID列表并发送带有特定SSID的广播数据包。如果SSID存在，接入点将以数据包响应。因此，我们可以在先前的方法中启动SSID嗅探器，并在运行SSID的暴力攻击时等待来自接入点的响应。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to write a script that can be used to run a dictionary attack
    on SSIDs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是编写可用于对SSID运行字典攻击的脚本的步骤：
- en: As usual, create a new `dictionary-attack-ssid.py` file and open it in an editor.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，创建一个新的`dictionary-attack-ssid.py`文件并在编辑器中打开它。
- en: 'Load all the required modules, and initialize the variables:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载所有必需的模块，并初始化变量：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we iterate through the SSIDs in the list and send a `RadioTap()` packet
    with the SSID set as the parameter:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历列表中的SSID并发送带有设置为参数的`RadioTap()`数据包：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now start the sniffer script in one terminal window and wait for the response.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在一个终端窗口中启动嗅探器脚本并等待响应。
- en: 'Finally, start the dictionary attack script with the `sudo` permission:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以`sudo`权限启动字典攻击脚本：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Fake access points with Scapy
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scapy创建虚假接入点
- en: We can create fake Wi-Fi access points by injecting beacon frames with Scapy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Scapy注入信标帧来创建虚假的Wi-Fi接入点。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try creating a fake SSID with the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用以下步骤创建一个假的SSID：
- en: Create a new `fake-access-point.py` file and open it in the editor.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`fake-access-point.py`文件并在编辑器中打开它。
- en: 'Load the required modules for the script:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载脚本所需的模块：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we use the `scapy` and `random` modules for creating random MAC IDs
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`scapy`和`random`模块来创建随机的MAC ID
- en: 'Then define the access point name and the interface to broadcast:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义接入点名称和要广播的接口：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can craft the packet with the `beacon` frame as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以用`beacon`帧来制作数据包：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can broadcast the access point with the `sendp()` method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以用`sendp()`方法广播接入点：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now run the script with the required permission:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以所需的权限运行脚本：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will broadcast an access point with the provided SSID
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将广播一个带有提供的SSID的接入点
