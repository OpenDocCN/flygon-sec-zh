# 利用开发简介

在本章中，我们将涵盖以下配方：

+   CPU 寄存器

+   内存转储

+   CPU 指令

# 介绍

Python 对于创建简单的原型代码来测试利用非常有帮助。在本章中，我们可以学习利用开发的基础知识，这可能有助于您修复损坏的利用，或者从头开始构建自己的利用。

# CPU 寄存器

CPU 寄存器，或处理器寄存器，是处理器中一小组数据存储位置之一，可以存储指令、存储地址或任何数据。寄存器应能够存储指令。寄存器是最快的计算机内存，用于加快计算机操作。

# 准备工作

在进行利用开发之前，您需要对寄存器有一个基本的了解。为了理解，让我们考虑寄存器主要有两种形式，通用寄存器和特殊目的寄存器。

# 通用寄存器

通用寄存器用于存储程序执行过程中的中间结果和运行数学运算。四个通用寄存器是 EAX、EBX、ECX 和 EDX：

+   EAX（累加器寄存器）：用于基本数学运算和返回函数的值。

+   EBX: 这用于根据需要进行名义存储。

+   ECX（计数器寄存器）：用于循环遍历函数和迭代。它也可以用于一般存储。

+   EDX（数据寄存器）：用于高级数学运算，如乘法和除法。它还在运行程序时存储函数变量。

# 特殊目的寄存器

特殊目的寄存器用于处理索引和指向。这些在编写利用时非常重要，因为我们将尝试操纵和覆盖这些寄存器中的数据。主要的特殊目的寄存器是 EBP、EDI、EIP 和 ESP：

+   EBP: 这个指针寄存器指示堆栈底部的位置。因此，这将指向堆栈顶部，或者在我们启动函数时设置为旧的指针值，因为这是开始。

+   EDI: 这是目的地索引寄存器，用于指向函数的指针。

+   EIP: 指令指针寄存器用于存储 CPU 要执行的下一条指令。因此，这对于利用编写非常重要，因为如果我们可以编辑这个，我们就可以控制下一条指令。此外，如果我们可以覆盖这个 EIP，这意味着程序本身已经失败。

+   ESP: 当堆栈指针指示堆栈的当前顶部（最低内存地址）时。随着程序运行，它会更新，因为项目从堆栈顶部移除。加载新函数时，它会返回到顶部位置。如果我们需要访问堆栈内存，我们可以使用 ESP。

在运行程序时查看寄存器，我们需要调试器，在您的系统中安装调试器。对于调试 Windows 程序，我们可以使用 Immunity Debugger，对于 Linux 和 Mac，我们可以使用`pwngdb`。

您可以从这里下载并安装 Immunity Debugger：[`www.immunityinc.com/products/debugger/`](https://www.immunityinc.com/products/debugger/)。

要安装`pwndbg`，请从 Git 存储库获取代码并运行安装脚本：

```py
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh  
```

# 如何做…

我们可以在调试器工具中执行一些快速任务，以更好地理解这些寄存器。

1.  在运行程序时查看寄存器，我们需要使用调试器。因此，在 Windows 机器上打开 Immunity Debugger 中的可执行文件。

1.  然后加载程序以在 Immunity Debugger 中进行分析。从菜单中转到文件|打开，并选择要监视的应用程序。

1.  它将以调试模式打开应用程序并打印出当前的详细信息。右上角的框将显示寄存器的详细信息。Immunity 中的寄存器窗格

调试器如下所示：

![](img/00066.gif)

1.  对于 Linux 和 macOS，在安装`pwndbg`之后，我们可以使用以下命令在`pwndbg`中打开应用程序：

```py
>> gdb ./app  
```

这将在调试器中打开应用程序`app`

1.  现在我们可以在调试模式下运行应用程序，并设置断点：

```py
pwndbg> break 5
pwndbg> run  
```

这将运行应用程序并在第`5`行处中断

1.  现在我们可以使用以下命令查看当前状态的寄存器：

```py
pwndbg>info registers    
```

输出将如下所示：

![](img/00067.jpeg)

如果可执行文件是 64 位的，则寄存器将以`r`开头。以`e`开头是无效的。

# 内存转储

我们可以使用内存转储轻松查看内存位置的内容。我们可以使用 Immunity Debugger 或`pwndbg`来实现这一点。

# 如何做…

按照以下步骤更好地理解内存转储：

1.  在 Immunity Debugger 中打开一个应用程序。

1.  如果要查看 ESI 寄存器中的内存转储，并右键单击地址，选择转到转储选项：

![](img/00068.jpeg)

1.  这将更新左下角的内存转储窗口。Immunity Debugger 中的内存转储窗口如下所示：

![](img/00069.gif)

1.  使用`pwndbg`，我们可以使用`hexdump`命令获取内存转储。为此，在`gdb`中加载应用程序并在断点处运行它：

```py
pwndbg> break 5
pwndbg> run  
```

1.  现在要查看 RSI 寄存器中的内存转储，请运行以下命令：

```py
pwndbg> hexdump $rsi  
```

输出将如下所示：

![](img/00070.jpeg)

# CPU 指令

当应用程序用高级语言编写并编译时，语言指令将被转换为相应的汇编语言。这是机器可以理解的代码。通过调试器，我们可以查看每个汇编指令。

# 如何做…

按照以下步骤了解调试器的用法：

1.  在 Immunity Debugger 中打开一个应用程序。

1.  我们可以在 Immunity Debugger 的左上角窗格中查看操作码。

1.  我们可以逐步执行指令，并通过按下*F7*来查看结果：

以下是指令窗格的外观：

![](img/00071.jpeg)

这将更新右上角窗格中相应的寄存器。通过这样，我们可以在 Immunity Debugger 中跟踪每个 CPU 指令的执行。

在`pwndbg`的情况下，我们可以使用`entry`命令在入口点执行：

```py
pwndbg> entry  
```

这将显示上下文屏幕。

1.  我们可以使用`nearpc`命令查看断点附近的操作码：

```py
pwndbg> nearpc  
```

输出将如下所示：

![](img/00072.jpeg)

1.  我们可以使用`stepi`命令逐步执行指令：

```py
pwndbg> stepi  
```

这将执行一条机器指令，然后停止并返回到调试器。

通过这样，我们可以逐步分析指令。
