- en: Network Scanning with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络扫描
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Simple port scanner
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单端口扫描器
- en: IP range/network scanner
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP范围/网络扫描器
- en: Stealth scanning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐蔽扫描
- en: FIN scanning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIN扫描
- en: XMAS scanning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMAS扫描
- en: TCP ACK scanning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP ACK扫描
- en: LanScan
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LanScan
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In penetration testing and network analysis, network scanners play a major role
    in getting the details of hosts that are available in the local network and applications
    running on those hosts. Network scanning helps to identify available UDP and TCP
    network services running on the hosts, and also helps to determine the **operating
    systems** (**OSs**) being used by the hosts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试和网络分析中，网络扫描器在获取本地网络中可用主机和运行在这些主机上的应用程序的详细信息方面发挥着重要作用。网络扫描有助于识别主机上运行的可用UDP和TCP网络服务，并有助于确定主机使用的操作系统（OSs）。
- en: Simple port scanner
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单端口扫描器
- en: A port scanner is designed to examine a server or host machine for open ports.
    It helps the attackers to identify the service running on the host machine and
    exploit the vulnerabilities, if there are any.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描器旨在检查服务器或主机机器上的开放端口。它帮助攻击者识别主机机器上运行的服务，并利用其中的漏洞。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can write a simple port scanner with Python using the `socket` module. The
    `socket` module is the default low-level networking interface in Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`socket`模块编写一个简单的端口扫描器。`socket`模块是Python中默认的低级网络接口。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can create a simple port scanner with the `socket` module, following are
    the steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`socket`模块创建一个简单的端口扫描器，以下是步骤：
- en: Create a new file called `port-scanner.py` and open it in your editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`port-scanner.py`的新文件并在编辑器中打开它。
- en: 'Import the required modules, as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Import the `socket` module along with the `sys` and `os` modules
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`socket`模块以及`sys`和`os`模块
- en: 'Now we can define the variables for our scanner:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的扫描器的变量：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we define the starting and ending ports that we plan to scan
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们计划扫描的起始和结束端口
- en: 'Get the IP from the domain name:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从域名获取IP：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we use the `gethostbyname` method in the `socket` module. This will return
    the IP of the domain
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用`socket`模块中的`gethostbyname`方法。这将返回域的IP
- en: 'Now we can write a function to `probe` the port:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个函数来`探测`端口：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we create a socket object named `sockObj` and try to connect it to the
    port. If the connection succeeds, then the port is open. The `socket` object created
    is using the IPv4 socket family (`AF_INET` ) and a TCP type connection (`SOCK_STREAM`).
    For the UDP type connection, we have to use `SOCK_DGRAM`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`sockObj`的套接字对象，并尝试将其连接到端口。如果连接成功，则端口是打开的。创建的`socket`对象使用IPv4套接字系列（`AF_INET`）和TCP类型连接（`SOCK_STREAM`）。对于UDP类型连接，我们必须使用`SOCK_DGRAM`。
- en: Finally, it returns the result as the output of the function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将返回作为函数输出的结果。
- en: 'Now we will write a *for* loop to iterate through the range of ports, and probe
    the port with the `probe_port` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写一个*for*循环来迭代端口范围，并使用`probe_port`方法探测端口：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the port is open then the result is added to a list `open_port`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口是打开的，则将结果添加到列表`open_port`
- en: 'Finally, print the result list as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按以下方式打印结果列表：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we can try changing the preceding script to scan a list of default ports.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试更改前面的脚本以扫描默认端口列表。
- en: 'For that, we will define a list of default ports:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将定义一个默认端口列表：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we change the loop to call `probe_port`, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们更改循环以调用`probe_port`，如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: IP range/network scanner
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP范围/网络扫描器
- en: We can use ICMP packets to create a network scanner. As ICMP is not an IP protocol,
    we have to access the network stack directly. So, here we can use Scapy to generate
    an ICMP packet and send it to the host.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ICMP数据包创建一个网络扫描器。由于ICMP不是IP协议，我们必须直接访问网络堆栈。因此，我们可以使用Scapy生成ICMP数据包并将其发送到主机。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start the scraping, we have to install the required Python packages. Here
    we use Scapy for the packet generation. To install Scapy, we can use `pip`. As
    we are using Python 3, make sure to install Scapy for Python 3\. Also install
    its dependency module, `netifaces`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始抓取，我们必须安装所需的Python包。这里我们使用Scapy进行数据包生成。要安装Scapy，我们可以使用`pip`。由于我们使用的是Python
    3，请确保为Python 3安装Scapy。还要安装其依赖模块`netifaces`：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps for creating a simple network scanner using the `scapy`
    module:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scapy`模块创建简单网络扫描器的步骤：
- en: Create a file called `network-scanner.py` and open it in your editor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`network-scanner.py`的文件并在编辑器中打开它。
- en: 'Import the required modules for the script:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入脚本所需的模块：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To get the local IP of the system, we use the `getsockname` method in the `socket`
    module. However, it require a connection. So, we create a UDP socket connection
    to connect to Google DNS and use this connection to enumerate the local IP:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取系统的本地IP，我们使用`socket`模块中的`getsockname`方法。但是，它需要一个连接。因此，我们创建一个UDP套接字连接以连接到Google
    DNS，并使用此连接来枚举本地IP：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we extract the local IP and truncate the last IP digits with a regular
    expression:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们提取本地IP并使用正则表达式截断最后的IP数字：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now create a function to generate an ICMP packet and send it to the host. Here
    we use Scapy:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个生成ICMP数据包并将其发送到主机的函数。这里我们使用Scapy：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create another function to check whether the IP is a loopback (`127.0.0.1`):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个函数来检查IP是否为环回（`127.0.0.1`）：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now run the LAN sweep scan for all IPs in the network by iterating through
    the last IP digits:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过迭代最后的IP数字运行网络扫描以扫描网络中的所有IP：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`conf.verb = 0` will disable the verbose mode in Scapy to avoid the logs from
    Scapy'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`conf.verb = 0`将禁用Scapy中的详细模式，以避免来自Scapy的日志'
- en: 'Make sure to run the script with an administrative privilege, as Scapy requires
    administrative access to create the packets:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以管理员权限运行脚本，因为Scapy需要管理员访问权限来创建数据包：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Stealth scanning
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐蔽扫描
- en: '![](img/00018.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Stealth scanning is a form of TCP scanning. Here the port scanner creates raw
    IP packets and sends them to the host to monitor for responses. This type of scan
    is also known as half-open scanning, or SYN scanning, as it never opens a complete
    TCP connection. This type of scanner creates a SYN packet and sends it to the
    host. If the target port is open, the host will respond with a SYN-ACK packet.
    Then the client will respond with an RST packet to close the connection before
    completing the handshake. If the port is closed but unfiltered, the target will
    instantly respond with an RST packet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 隐蔽扫描是一种TCP扫描形式。在这里，端口扫描器创建原始IP数据包并将其发送到主机以监视响应。这种类型的扫描也被称为半开放扫描或SYN扫描，因为它从不打开完整的TCP连接。这种类型的扫描器创建一个SYN数据包并将其发送到主机。如果目标端口是打开的，主机将用一个SYN-ACK数据包做出响应。然后客户端将用一个RST数据包做出响应，以在完成握手之前关闭连接。如果端口是关闭但未被过滤，目标将立即用一个RST数据包做出响应。
- en: To create a SYN scanner, we will use the Scapy module. It is a powerful interactive
    packet manipulation program and library.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个SYN扫描器，我们将使用Scapy模块。这是一个功能强大的交互式数据包操作程序和库。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For scanning ports, we will sending custom packets to the host we are scanning
    and parse the response to analyze the results. We require Scapy to generate and
    send packets to the host. Make sure to have the `scapy` module is installed in
    the system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扫描端口，我们将向正在扫描的主机发送自定义数据包，并解析响应以分析结果。我们需要Scapy来生成并发送数据包到主机。确保系统中安装了`scapy`模块。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We can create a SYN scanner with the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤创建一个SYN扫描器：
- en: Create a new file called `syn-scanner.py` and open it in your editor.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`syn-scanner.py`的新文件，并在编辑器中打开它。
- en: 'As usual, import the required modules:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，导入所需的模块：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will import the `scapy` module
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入`scapy`模块
- en: 'Now we can declare the variables, and we can also pass these variables as arguments,
    if required:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以声明变量，并且如果需要，也可以将这些变量作为参数传递：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can create a function to check whether the host is up or down:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个函数来检查主机是正常运行还是宕机：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We create and send an ICMP packet to the host. The host will respond if it is
    up.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并发送一个ICMP数据包到主机。如果主机正常运行，它将做出响应。
- en: 'Next, we can create a function to scan the port using SYN packets:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个使用SYN数据包扫描端口的函数：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here we set a random port as the destination port, and then create a SYN packet
    with the source port, destination port, and destination IP. Then we will send
    the packet and analyze the response. If the response type is `None`, then the
    port is closed. If the response has a TCP layer, then we have to check the flag
    value in it. The flag has nine bits, but we check for the control bits, which
    have six bits. They are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个随机端口设置为目标端口，然后创建一个带有源端口、目标端口和目标IP的SYN数据包。然后我们将发送数据包并分析响应。如果响应类型为`None`，则端口是关闭的。如果响应具有TCP层，则我们必须检查其中的标志值。标志有九位，但我们只检查控制位，它们有六位。它们是：
- en: URG = 0x20
  id: totrans-84
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: URG = 0x20
- en: ACK = 0x10
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACK = 0x10
- en: PSH = 0x08
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSH = 0x08
- en: RST = 0x04
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RST = 0x04
- en: SYN = 0x02
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN = 0x02
- en: FIN = 0x01
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIN = 0x01
- en: 'The following is the header structure for the TCP layer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是TCP层的头部结构：
- en: '![](img/00019.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: So, if the flag value is 0x12, then the response has a SYN flag and we can consider
    the port to be open. If the value is 0x14, then the flag is RST/ACK, so the port
    is closed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果标志值为0x12，则响应具有SYN标志，我们可以认为端口是打开的。如果值为0x14，则标志是RST/ACK，因此端口是关闭的。
- en: 'Then we will check whether the host is up or not, loop through the common ports
    list, and scan each port if the host is up:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将检查主机是否正常运行，循环遍历常见端口列表，并在主机正常运行时扫描每个端口：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each port from the common port list is scanned and the identified open ports
    are added to the open ports list, following the list that is printed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描常见端口列表中的每个端口，并将识别出的打开端口添加到打开端口列表中，然后打印列表
- en: 'Make sure to run the script with `sudo`, as we are using Scapy and Scapy requires
    admin privileges:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以`sudo`身份运行脚本，因为我们正在使用Scapy，而Scapy需要管理员权限：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: FIN scanning
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIN扫描
- en: '![](img/00020.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: SYN scanning can be blocked by firewalls. However, packets with the FIN flag
    set have the ability to bypass firewalls. Here is how it works--for a FIN packet,
    the closed ports reply with an RST packet, whereas the open ports ignore the packets.
    If it's an ICMP packet with type 3, and code 1, 2, 3, 9, 10, or 13, we may infer
    that the port is filtered and the port state cannot be found. We can use Scapy
    to create the FIN packet and scan the ports.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SYN扫描可以被防火墙阻止。然而，设置了FIN标志的数据包具有绕过防火墙的能力。它的工作原理是这样的--对于一个FIN数据包，关闭的端口会用一个RST数据包做出响应，而打开的端口会忽略这些数据包。如果是一个ICMP数据包，类型为3，代码为1、2、3、9、10或13，我们可以推断出端口被过滤，端口状态无法被找到。我们可以使用Scapy创建FIN数据包并扫描端口。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We can create a FIN scanner as following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式创建一个FIN扫描器：
- en: As we did in the previous recipe, we have to create another file, `fin-scanner.py`,
    and open it in our editor.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在上一个步骤中所做的那样，我们必须创建另一个文件`fin-scanner.py`，并在编辑器中打开它。
- en: 'Then import the required module:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后导入所需的模块：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we did for the SYN scanner, set the variables and create the function to
    check whether the server is up or not:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们为SYN扫描器所做的那样，设置变量并创建函数来检查服务器是否正常运行：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can create the function to probe the ports as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建探测端口的函数如下：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we changed the flag to `F` for `FIN`, while creating the packet to send
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将标志更改为`F`以进行`FIN`，同时创建要发送的数据包
- en: 'Finally, we will check whether the host is up or not, loop through the common
    ports list, and scan each port if the host is up:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将检查主机是否正常运行，循环遍历常见端口列表，并在主机正常运行时扫描每个端口：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: XMAS scanning
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMAS扫描
- en: With XMAS scanning, we will send a TCP packet with a bunch of flags all at once
    (PSH, FIN, and URG). We will get an RST if the port is closed. If the port is
    open or filtered, then there will be no response from the server. It's similar
    to the FIN scan, other than the packet-creating part.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XMAS扫描，我们将发送一个TCP数据包，其中包含一堆标志（PSH，FIN和URG）。如果端口关闭，我们将收到一个RST。如果端口是打开的或被过滤的，那么服务器将不会有任何响应。这与FIN扫描类似，只是在创建数据包的部分不同。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create a XMAS scanner with Scapy:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scapy创建XMAS扫描器的步骤如下：
- en: Create a copy of the file we created for the previous recipe (*FIN scanning*).
    As it is quite similar, we only need to change the packet-creation section.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们为上一个配方创建的文件的副本（*FIN扫描*）。由于它非常相似，我们只需要更改数据包创建部分。
- en: 'To create and send a packet with PSH, FIN, and URG flags in it, update the
    packet-crafting section inside the `probe_port` method, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建并发送一个带有PSH、FIN和URG标志的数据包，请更新`probe_port`方法中的数据包制作部分，如下所示：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Only update the flags parameter. Here we set the flags as `FPU` for PSH, FIN,
    and URG combined.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只更新标志参数。这里我们将标志设置为`FPU`，表示PSH、FIN和URG的组合。
- en: TCP ACK scanning
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP ACK扫描
- en: 'ACK flag scanning is useful to verify whether the server is blocked with firewalls,
    IPS, or other network security controls. As in the FIN scan, we will send an TCP
    ACK packet. No response or an ICMP error indicates the presence of a stateful
    firewall, as the port is filtered, and if we get back an RST-ACK, then the stateful
    firewall is absent:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ACK标志扫描对于验证服务器是否被防火墙、IPS或其他网络安全控制所阻塞非常有用。与FIN扫描一样，我们将发送一个TCP ACK数据包。没有响应或ICMP错误表明存在有状态的防火墙，因为端口被过滤，如果我们收到一个RST-ACK，那么有状态的防火墙就不存在：
- en: '![](img/00021.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps to create a TCP ACK scanner with Scapy are as following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scapy创建TCP ACK扫描器的步骤如下：
- en: 'As usual, import the required modules and set the variables. Also, define the
    method to check the status of the host:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，导入所需的模块并设置变量。还要定义检查主机状态的方法：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To send a TCP packet with the `ACK` flag, update the `probe_port` method in
    the previous recipe, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送一个带有`ACK`标志的TCP数据包，请更新上一个配方中的`probe_port`方法，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here we create a TCP ACK packet and send it to the host
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个TCP ACK数据包并将其发送到主机
- en: 'Finally, run the scanner, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行扫描程序，如下所示：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: LanScan
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LanScan
- en: LanScan is a Python 3 module that helps to scan a given local network. It can
    list all devices and their open ports. LanScan also helps to get the information
    about network interfaces and networks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LanScan是一个Python 3模块，可以帮助扫描给定的本地网络。它可以列出所有设备及其开放的端口。LanScan还可以帮助获取有关网络接口和网络的信息。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We can install `lanscan` using `pip`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pip`安装`lanscan`：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are some use cases for LanScan:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是LanScan的一些用例：
- en: 'LanScan has some options that we can use for scanning the LAN. To get the details
    about the available interfaces in the system, we can use the `interfaces` option:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LanScan有一些我们可以用来扫描局域网的选项。要获取系统中可用接口的详细信息，我们可以使用`interfaces`选项：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will print the available interfaces, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出可用的接口，如下所示：
- en: '![](img/00022.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'We can get the list of connected networks by using the network command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用network命令获取连接的网络列表：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/00023.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'We can start a local network scan from the terminal window. It requires admin
    privileges:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从终端窗口开始本地网络扫描。这需要管理员权限：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](img/00024.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: Here it will list the IP addresses in the LAN network and the open ports in
    each system
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出LAN网络中的IP地址以及每个系统中的开放端口
