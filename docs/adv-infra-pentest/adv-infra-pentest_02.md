# 第二章：高级 Linux 利用

现在我们对不同的渗透测试方法、阶段和要求有了清晰的理解，游戏才刚刚开始。是时候系好安全带了，因为在本章中，您将深入了解如何保护 Linux 环境，从对 Linux 基础设施渗透测试的高层概述，到发现内核漏洞的深层内容。本章概述了保护 Linux 基础设施所需的技能和工具。

# Linux 基础知识

Unix 是由贝尔实验室开发的操作系统。基本上，它是基于命令行界面工作的，并且设计用于大型系统。这个操作系统不是免费的，而是专有的和可移植的。Linux 是由 Linus Torvalds 在 1991 年开发的 Unix 克隆。它是开源的，您可以在任何有处理器的设备上使用。Linux 是灵活的，您可以根据需要进行修改和实现，因为它是根据 GNU 通用公共许可证（GPL）许可的。

# Linux 命令

在本小节中，让我们打开命令行并执行一些基本命令。在每个 Linux 主机上，都有名为*shell*的命令行界面，用于解释和执行键入的命令和脚本。有许多 shell 环境，如**Bourne Again Shell**（**Bash**，最常见的 shell）、**C shell**（**csh**）、**Korn shell**（**ksh**）等。要找到您的环境可用的 shell，只需打开命令行界面并键入`cat /etc/shells`：

![](img/00027.jpeg)

现在，让我们从 shell 中了解一些重要的基本 Linux 命令：

+   `pwd`: 知道您所在的目录

+   `ls`: 列出目录中的文件

+   `cd`: 进入一个目录

+   `mkdir`: 创建一个新目录

+   `rmdir`: 删除一个目录

+   `touch`: 创建一个新文件

+   `cat`: 读取一个文件

+   `cp`: 复制文件

+   `mv`: 移动一个文件

+   `man`: 显示如何使用一个命令

Linux 是区分大小写的（为了给用户提供多种命令选项的可能性，如`-T`、`- t`、`-a`、`- A`等），因此您需要检查您如何编写每个命令。

作为渗透测试人员，有多个重要的命令需要了解，以便测试 Linux 基础设施的安全状况：

+   `hostname`: 主机信息

+   `cat /proc/version`: 内核信息

+   `uname -r`: 内核版本

+   `uname -a`: 关于系统的更详细信息

+   `cat /proc/cpuinfo`: 读取有关处理器的信息

+   `echo $PATH`: 显示有关`PATH`变量的信息

+   `history`: 显示命令历史

# 流

Linux 提供了输入/输出重定向功能，以便简化任务。它使您能够使用以下三种类型的流来操作 I/O 流：

+   **标准输入（stdin）**：在这个流中，输入来自键盘

+   **标准输出（stdout）**：这个流直接在屏幕上显示结果

+   **标准错误（stderr）**：这是另一种标准输出流类型，但它携带错误信息而不是在屏幕上显示输出

# 重定向

重定向是 Linux 的另一个功能，可以提高生产力。您可以使用简单的符号重定向流。您可以使用`>`将命令的输出重定向到文本文件，如果要追加文件而不是覆盖它，则使用`>>`；例如，`ls > Simple_file.txt`。

另外，如果您想将一个命令的流重定向到另一个命令，建议使用管道，就像下面的行一样，它列出当前目录中的前两个文件，`ls | head -2`：

![](img/00028.jpeg)

# Linux 目录结构

Linux 目录有一个标准结构。根据 Linux 的说法，一般来说，一切都是文件，甚至目录和设备也是文件。为了正常工作，Linux 以分层设计的特定方式管理这些文件：

+   `/root`: 所有文件和目录都从这个目录开始

+   `/home`: 包含所有用户的个人文件

+   `/bin`: 包含所有二进制文件（可执行文件）

+   `/sbin`：类似于`/bin`，但它包含系统二进制文件

+   `/lib`：包含所需的库文件

+   `/usr`：包含普通用户使用的二进制文件

+   `/opt`：包含可选的附加应用程序

+   `/etc`：包含程序所需的所有配置文件

+   `/dev`：包含设备文件

+   `/media`：包含临时可移动设备的文件

+   `/mnt`：包含文件系统的挂载点

+   `/boot`：包含引导加载程序文件

+   `/tmp`：包含临时文件

+   `/var`：包含变量文件，如日志

+   `/proc`：包含有关系统进程的信息：

Linux 操作系统中有许多类型的文件。每个文件都由特定的符号表示——目录、普通文件和套接字，这是应用程序之间的通信技术。

# 用户和组

下面的小节将涵盖管理用户账户和组所需的 Linux 命令。要创建新用户，请使用`useradd`命令；例如，`useradd <user>`。

此外，您还可以添加有关新用户的更多信息，例如相关的 shell、用户目录和过期日期：

```
useradd <user> -d </Directory>
useradd <user> -e <date>
useradd <user> -s <shell>
```

每个用户必须有一个密码，并且为了更改密码，他们需要 root 访问权限。要更改用户密码，请使用`passwd`命令，如下所示：

```
passwd <user>
$ passwd
Changing password for user1
(current) UNIX password:
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
```

要删除用户，请使用`userdel`命令。例如，`userdel -r <user>`，其中添加了`-r`选项以删除所选用户的文件。

使用组是管理 Linux 账户的一种技术。将用户组织成组是一种安全措施和隔离方法。要列出 Linux 系统中的所有组，请使用`cat`命令在`/etc`目录中显示`group`文件。

从屏幕截图中可以看出，`group`文件包含您的 Linux 系统中的所有组。只需键入`cat /etc/group`：

![](img/00029.jpeg)

要创建新组，请使用`newgrp`命令`newgrp <Group_Name>`。

# 权限

Linux 是一个多用户操作系统。为了保护用户账户和组，给每个用户和组赋予不同的权限。在 Linux 系统中有三种主要权限：读取、写入和执行。这可以描述如下：

+   **读取**是查看文件和如果目标是目录则列出内容的能力。它由字母（`r`）表示。

+   **写入**允许用户修改某些文件和目录内容。它由字母（`w`）表示。

+   **执行**允许用户运行脚本或程序并更改目录。它由字母（`x`）表示。

有三种权限类型如下：

+   **设置用户标识**（**SUID**）：当设置 SUID 时，文件将以与用户相同的权限执行。

+   **设置组 ID**（**SGID**）：与 SUID 相同，但文件将以与组相同的权限执行。

+   **粘着位**：当您可以创建、修改或执行文件，但无法删除另一个用户的文件时使用。通常用于共享库。

# chmod 命令

要更改文件的权限，您需要使用`chmod`命令，`chmod <letters> <file or directory>`。您还可以使用八进制格式代替字母，`chmod <octal format> <file or directory>`。要将权限从字母格式转换为八进制格式，您需要将每个权限转换为一个值：

| **值** | **用户** | **组** | **其他** |
| --- | --- | --- | --- |
| 4 | 读取 | 读取 | 读取 |
| 2 | 写入 | 写入 | 写入 |
| 1 | 执行 | 执行 | 执行 |

现在，让我们举个例子，看看如何以八进制格式轻松使用`chmod`命令。假设我们需要给用户读取和写入的权限，组只能读取，其他人只能执行。那么，八进制格式将是`641`，因为：

+   **用户**：*读取 + 写入 = 6*

+   **组**：*读取 = 4*

+   **其他**：*执行 = 1*

最终的命令将是：`chmod 641 <file>`

# chown 命令

现在，要更改文件的所有者，请使用`chown`命令`chown user:group <file>`。要包括所有包含的文件，请添加选项`-R`（递归模式）。

# chroot 命令

`chroot`是一种用于将非根进程及其子进程与其他系统组件隔离的技术。这种隔离是设计在 Linux 操作系统中的，以确保当一个子系统被 compromise 时，不会影响整个系统。其思想是让进程认为它在根文件夹中运行，但实际上它将在管理员创建的一个目录中。因此，让我们来看看构建 chroot 监狱所需的步骤：

1.  首先，您需要创建一个新用户并命名它; 例如，`prisoner`：

![](img/00030.jpeg)

1.  将用户添加到 root 组`gpasswd -a prisoner root`

1.  您可以通过验证`/etc/group`来检查是否已添加新用户：

![](img/00031.jpeg)

1.  现在创建一个名为`chroot`的新目录，并进入它

1.  创建这些文件夹：`bin`，`dev`，`etc`，`home`，`home/prisoner`，`lib`，`var`，`usr`和`usr/bin`

1.  这里，至少需要`bin`和`lib`目录：

![](img/00032.jpeg)

1.  接下来，使用`cp`命令复制`bash`实用程序，`cp /bin/bash /chroot/bin`，包括所需的共享库：

![](img/00033.jpeg)

1.  最后，使用`chroot`命令构建监狱`chroot /chroot /bin/bash`：

![](img/00034.jpeg)

# find 命令的强大

在前一章中，我们发现了从大量数据中提取正确信息的重要性。当您处理 Linux 时，知道如何查找和提取信息将帮助您有效地使用时间。

`find`是一个非常有用的命令，可以帮助用户根据定义的条件定位任何文件。`find`命令的格式如下：

```
$ find <location> <criteria> <Target-file>
```

通配符是帮助用户的一个很好的附加能力。它们受到通配符术语的启发，该术语描述了为卡分配任何值的事实。例如，当您在命令中使用星号通配符（`*`）时，它表示`*`可以是任何值，例如在这里的示例中，列出目录中的所有文本文件：

```
ls *.txt 
```

以下截图说明了前面命令的输出：

![](img/00035.jpeg)

问号（`?`）和方括号（`[xyz]`）也是通配符的一种类型。因此，问号表示只有一个值，而方括号表示其中任何一个值。还有一些其他表示，例如`[:digit:]`：所有数字，`[:upper:]`：所有大写字母等。

以下是 Linux 利用的 find 命令用法的一些其他示例：

+   显示当前用户的 bash 历史记录：

```
cat ~/.bash_history
```

+   查找根 SUIDs：

```
find / -uid 0 -perm -4000 -type f 2>/dev/null
```

+   要显示`/var/log`中的文件，请使用`ls /var/log`命令：

```
find /var/log -type f -exec ls -la {} ; 2>/dev/null
```

![](img/00036.jpeg)

# 作业，cron 和 crontab

自动化是 Linux 操作系统的一个重要方面。对于系统管理员和渗透测试人员来说，自动化许多任务以避免重复是很重要的。如前一章所讨论的，渗透测试是一个有时间限制的任务。因此，良好的时间管理是每个成功的渗透测试人员所需的技能。Linux 为用户提供了在特定时间和可重复的方式运行命令或脚本的调度能力。cron 实用程序是实现这一点的关键。Cron 使您能够在定义的时间作为例行工作运行后台作业。以下是 cron 命令的格式：

`<星期几> <月份> <月份中的日期> <小时> <分钟> <命令>`

所有 cron 作业都可以使用`crontab -l`列出。它们也可以在`/etc/crontab`中找到：

![](img/00037.jpeg)

# 安全模型

安全模型是用逻辑方式表示安全策略的特定机制。这些模型基于**可信计算基础**（**TCB**），该基础在美国国防部标准 5200.28 中描述。这个标准也被称为橙皮书。它将 TCB 呈现为负责对任何系统进行访问控制的可信系统组件。TCB 受到称为*安全边界*的虚构边界的限制。TCB 与其他子系统之间的每个连接应该使用安全通道，有时被称为*安全路径*。安全模型存在是为了防止未经授权的信息流动。换句话说，它们断言信息是从低级安全级别流向高级别，而不是相反。还有其他称为*非干扰模型*的模型，它们关注于每个主体上执行的行为，而不是信息流。以下是一些知名的安全模型：

+   **贝尔-拉帕杜拉模型**：该模型基于对象的保密性。它规定了不读取上行政策和不写入下行（第一个被称为*简单安全属性*，第二个属性被称为*星级安全属性*）。

+   **Biba 模型**：这是一个集中在对象完整性的分层系统。它有两个属性：*简单完整性公理*规定了不下行读取策略，*星级完整性公理*规定了不上行写入策略。

+   **克拉克-威尔逊模型**：规定只有授权用户才能改变数据的完整性。

# 安全控制

在探索访问控制之前，让我们了解安全控制中的一些重要术语。根据定义，名词控制意味着根据标准进行检查的实体。安全控制分为三个主要类别：

+   **管理安全控制**：这些使用管理技术和计划来减少以下风险：

+   漏洞分析

+   渗透测试

+   风险分析

+   **技术安全控制**：也被称为**运营安全控制**。它们使用技术和意识作为保障。以下是一些例子：

+   防火墙

+   加密

+   入侵检测系统

+   防病毒软件

+   培训

+   **物理安全控制**：这些是用于保护以下数据的物理保障：

+   摄像头

+   门

+   生物识别技术

+   传感器

![](img/00038.jpeg)

# 访问控制模型

访问控制是技术安全控制的一种形式。主体和对象是两个重要的术语。主体是一个主动实体，例如一个动作（例如修改或访问文件）。对象是一个静态系统实体，例如文本文件或数据库。基本上，有三种访问控制模型，描述如下：

+   **强制访问控制（MAC）**：系统检查主体的身份和其权限与对象权限。因此，通常主体和对象都使用排名系统（绝密，机密等）进行标记。

+   **自主访问控制（DAC）**：对象所有者被允许为用户设置权限。密码是 DAC 的一种形式。

+   **基于角色的访问控制（RBAC）**：顾名思义，访问是基于分配的角色。

# Linux 攻击向量

攻击是威胁代理对信息系统资产的实际行为。用于攻击目标的路径称为**攻击向量**。有三种主要类型的攻击向量和威胁：

+   **网络威胁**：指对组织网络的威胁

+   **主机威胁**：这些是针对主机的威胁，包括硬件和操作系统

+   **应用程序威胁**：这指的是针对系统程序的威胁

# 使用 LinEnum 进行 Linux 枚举

枚举是每次成功攻击的关键。这是黑客系统的关键阶段，也是信息收集的重要部分。在此阶段，攻击者在本地或远程之间建立连接以收集尽可能多的信息，以决定攻击向量。要枚举 Linux 主机，您可以使用一个名为**LinEnum**的实用程序，并从[`github.com/rebootuser/LinEnum`](https://github.com/rebootuser/LinEnum)下载它。

它是一个有用的 shell 脚本，使用至少 65 个项目的清单收集有关 Linux 主机的信息，例如内核和敏感用户信息，以便找到升级点：

![](img/00039.jpeg)

以下屏幕截图显示了有关已登录用户和系统组的信息（清单的两个项目）：

![](img/00040.jpeg)

# 使用 Nmap 进行 OS 检测

第一步是检查主机是否存活。要验证机器的状态，请键入`nmap -sP <目标>`；目标可以是 IP 地址或一系列地址：

![](img/00041.jpeg)

基本上，检查是使用 ICMP 请求，因此，许多网络管理员由于防火墙和入侵检测系统而阻止此协议请求。因此，渗透测试人员可以使用 TCP 或 UDP 请求（不用担心；我们将在下一章节中详细介绍网络方面和协议）。要实现这一点，您可以使用 nping 实用程序：

![](img/00042.jpeg)

Nmap 具有检测操作系统的强大能力，这要归功于其基于 TCP 和 UDP 数据包的足迹数据库。要检测操作系统，只需使用`-O` Nmap 选项，`nmap -O <目标>`：

![](img/00043.jpeg)

检测操作系统和服务，使用`nmap -n -A -T5 <目标>`。它基于端口检测活动服务。以下是一些带有端口的服务：

| **服务** | **端口** |
| --- | --- |
| `telnet` | `23` |
| `ftp` | `21` |
| `http` | `80` |
| `pop3` | `110` |
| `https` | `443` |
| `ntp` | `123` |
| `ldap` | `389` |
| `postfix` | `25` |
| `Imap` | `143` |

作为渗透测试人员，每一步都应该记录下来；这就是为什么 Nmap 提供了输出选项来导出扫描结果。只需使用`-oN`选项（您可以在文本（N）、可搜索（G）或 XML（X）之间进行选择）：`nmap -n -A -T5 <目标> -oN report.txt`。

# 权限提升

**权限提升**是试图获得未经授权的高权限的过程，大多数情况下是尝试获取 root 权限。它是从用户帐户到 root 帐户的转移。为了获得管理权限，攻击者利用系统的弱点（编程错误，配置错误等）。权限提升有两种类型：垂直和水平。当攻击者从较低权限移动到较高权限时，它是垂直提升。如果他从一个帐户移动到另一个帐户并具有相同的权限，则是水平提升。为了在 Linux 环境中获得 root 权限，攻击者使用许多技术：

+   **利用 Linux 服务**：如前所述，攻击者试图找到漏洞来提升权限。Linux 服务和配置是每个黑客和渗透测试人员的良好入口点。我们有以下示例：

+   **X11 服务**：X11 是 Linux 环境的图形引擎。许多界面可以在其上运行，例如 Gnome 和 KDE。X11 服务基本上在 6000-60063 端口上运行。如前所述，您可以使用 Nmap 枚举主机以获取活动的 X11 服务。X11 的一个弱点是攻击者可以使用 xspy 工具记录每个输入的信息。这里的图像描述了 Linux XServer 环境：

![](img/00044.jpeg)

+   +   **Linux 蓝牙堆栈（BlueZ）信息泄漏漏洞的案例研究– CVE-2017-1000250**：这个漏洞是一个用户空间和内核空间的组合，用于泄露信息，包括蓝牙通信中的加密密钥。内核用户漏洞是最低蓝牙堆栈 L2CAP 中的一个弱点。这对许多蓝牙设备构成了巨大威胁，包括运行 Linux BlueZ 的设备：移动设备和物联网设备。要在安卓手机上测试漏洞，可以从 GitHub 存储库[`github.com/ojasookert/CVE-2017-0785`](https://github.com/ojasookert/CVE-2017-0785)下载并运行 Python 脚本：`./CVE-2017-0785.py TARGET=XX:XX:XX:XX:XX:XX`。在此之前，请确保已经使用`pip`工具安装了所需的 Python 库`pybluez`和`pwntools`，如下截图所示：

```
 pip install <python_library>
```

![](img/00045.jpeg)

+   **通配符**：它们可能是致命的武器。研究人员（回到未来：Unix 通配符失控– Leon Juranic）表明通配符可以用于注入任意命令。

+   **SUID 滥用**：这可以通过需要以 root 权限运行系统上其他命令的程序（如 Nmap）来实现。

+   ****Linux 内核利用****：这是最危险的技术。如果攻击者能够利用内核，他将完全控制受损系统。

# Linux 特权检查器

Linux 特权检查器是一个具有特权升级检查功能的枚举工具。要尝试它，可以从[`www.securitysift.com/download/linuxprivchecker.py`](http://www.securitysift.com/download/linuxprivchecker.py)下载。可以使用`wget`命令进行下载，如下所示：

```
wget http://www.securitysift.com/download/linuxprivchecker.py
```

![](img/00046.gif)

您可以在系统上运行它，输入**`./linuxprivchecker.py`**或**`python linuxprivchecker.py`**。

![](img/00047.gif)

另一个用于 Unix 和 Linux 操作系统的工具称为 unix-privesc-checker。它可以在[`pentestmonkey.net/tools/audit/unix-privesc-check`](http://pentestmonkey.net/tools/audit/unix-privesc-check)上找到。

# Linux 内核利用

有许多黑客动机，但没有什么可以与完全控制系统的兴奋相比。这可以通过利用 Linux 内核来实现。攻击系统核心将使黑客感到世界之巅；这就是为什么内核对每个黑客来说都是一个高优先级目标。

# 用户空间与内核空间

大多数操作系统依赖于环保护模型。该模型代表从高特权到低特权的重叠概念环。有四个从 0 到 3 编号的层：

+   **Ring 3**：这一层是通常的交互层，用户通常处于用户模式。

+   **Ring 2**：这一层包含低特权操作。

+   **Ring 1**：这是输入/输出操作的层。

+   **Ring 0**：这是最敏感的层。内核位于此层。

![](img/00048.jpeg)

像许多最近的操作系统一样，Linux 并不完全依赖于环保护机制，而是在两层模式下工作：用户模式和内核模式。内存分为两个部分和空间：用户空间和内核空间。第一个被正常程序使用，因此该空间中的进程使用有限的内存。第二部分使用所有内存，并运行最受信任的代码。

# 系统调用

系统调用，或*syscalls*，是**用户空间**和**内核空间**之间的接口。它在不同的架构中有所不同；例如，在旧处理器中，中断用于两个空间之间的交易。现在，在新架构中，使用了优化指令：

![](img/00049.jpeg)

# Linux 内核子系统

Linux 内核由许多组件组成：

+   **内存管理器**：这负责访问内存

+   **进程调度器**：这负责管理进程

+   **虚拟文件系统**：这代表了对各种设备的常见文件接口

+   **网络接口**：这管理网络标准和网络设备

+   **进程间通信**：这管理单个系统中许多进程之间的通信

+   **设备驱动程序**：这些存在是为了使设备硬件可用

![](img/00050.jpeg)

# 进程

进程是程序的一个实例。当程序加载到内存中时，它被称为**进程**。进程可以处于不同的状态：新建、运行、等待、就绪和终止。在 Linux 中，每个进程都有一个名为`PID`的标识。您可以使用`ps`命令来检查它们：

![](img/00051.jpeg)

# 线程

线程类似于进程。虽然进程在单独的内存空间运行，线程在共享内存上运行。它们可以被调度执行。

# 安全增强型 Linux

**安全增强型 Linux**（**SELinux**）是由美国国家安全局（NSA）开发的安全项目。它是集成在 Linux 内核中的**Linux 安全模块**（**LSM**），从 2.6.0 内核版本开始。它实现了强制访问控制（MAC）系统以保护环境。它指定了用户如何与系统交互的策略。当一个主体（如一个进程）想要从一个文件请求操作时，SELinux 安全服务器会通过**访问向量缓存**（**AVC**）检查访问权限，这要归功于安全策略数据库。它是在普通 Linux 系统之上的额外安全层。以下是 SELinux 流程的示例：

![](img/00052.jpeg)

您可以在`/etc/selinux`目录下检查 SELinux 的全局配置文件：

![](img/00053.jpeg)

# 内存模型和地址空间

内存管理是每个操作系统的重要能力。它也集成到 Linux 内核中。Linux 以虚拟方式管理内存。换句话说，物理内存地址与程序使用和看到的地址之间没有对应关系。这种技术给用户和开发人员带来了灵活性。Linux 处理以下五种类型的地址：

+   **用户虚拟地址**

+   **物理地址**

+   **总线地址**

+   **内核逻辑地址**

+   **内核虚拟地址**

内存被划分为 4096 字节的内存块，称为页面，以便进行内部处理。最低有效位是偏移量；其余部分是页号。在最近的 x86 架构上，Linux 内核将虚拟空间（通常为 4GB）划分为 3GB 用于用户空间，1GB 用于内核空间。这个操作被称为**分段**。内核使用页表来对应物理和虚拟地址。为了管理内存的不同区域，它使用**虚拟内存区域**（**VMA**）：

![](img/00054.jpeg)

要显示进程的内存映射，可以使用`cat`命令显示`/proc/1/maps`文件：

![](img/00055.jpeg)

# Linux 内核漏洞

Linux 内核是 Linux 基础设施中最关键的组件。因此，控制它将授予对系统和敏感信息的访问权限。如果黑客甚至获得硬件的根访问权限，他们将无法阻止损坏系统或窃取关键信息。根据攻击面（内存、指针、逻辑等），有许多内核漏洞被分类。

# 空指针解引用

空指针解引用是一种可用性漏洞。通常是由空指针错误引起的，导致`NullPointerException`。当指针指向一个值为 NULL 的地址时，指向有效内存空间时，会引发此异常。为了避免这种类型的攻击，您只需要调用异常处理程序：

![](img/00056.gif)

# 任意内核读/写

任意内核读/写是通过向内核传递数据来完成的关键攻击。

# 案例研究 CVE-2016-2443 高通 MSM 调试 fs 内核任意写

这个漏洞利用是使用了一个名为 MSM 的安卓高通 SoC 的 Linux 分支。它是高危且关键的。它针对的是调试文件系统，也被称为`debugfs`，这是一个基于 RAM 的文件系统，通常用于调试目的，通过使信息对用户空间可用。这就是为什么它是一个很好的入口，可以向 Linux 内核注入一些信息。这个漏洞利用使你能够通过 echo 命令向内核传递数据，导致内核恐慌：`echo "41414141 42424242" > /sys/kernel/debug/mddi/reg`。

因此，这将导致信息泄漏。

# 内存损坏漏洞

内存管理是 Linux 内核的一个重要组成部分。因此，这是一个重要的攻击面。对内核和 Linux 基础设施构成威胁的两个主要内存损坏漏洞是内核栈和内核堆漏洞：

![](img/00057.jpeg),

# 内核栈漏洞

栈是一个特殊的内存空间。在编程中，它是一个抽象数据类型，用于使用 push 和 pop 两种操作来收集元素。这个部分会自动增长，但当它接近另一个内存部分时，会导致问题和对系统的混淆。这就是为什么攻击者使用这种技术来混淆系统与其他内存区域。

# 内核堆漏洞

堆用于动态内存分配。它和栈一样存在于 RAM 中，但速度较慢。内核堆使用以下三种分配器：

+   **SLAB**：这是一个缓存友好的分配器。

+   **简单块列表**（**SLOB**）：这是在小型系统中使用的分配器。它使用首次适配算法。

+   **SLUB**：这是默认的 Linux 分配器。

内核堆漏洞利用是危险的，因为在大多数情况下，攻击者不需要准备 Linux 模块调试环境。

# 竞争条件

在使用线程进行编程时，调度并不是一件容易的任务。当许多线程竞争更改相同的数据结构时发生的错误被称为**竞争条件**。换句话说，当两个线程试图执行相同的任务时就会发生。为了避免竞争条件，需要原子操作。因此，当一个操作开始时，它不能被停止或中断。Linux 提供了一个名为*Mutex*的解决方案，它是 mutual exclusion object 的缩写。正如其名称所示，mutexes 是用来防止线程同时执行的锁。Dirty Cow（CVE-2016-5195）是基于竞争条件的 Linux 内核特权升级漏洞利用。要下载这个漏洞利用，你可以在这个 GitHub 仓库中查看：[`github.com/dirtycow/dirtycow.github.io/wiki/PoCs`](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)。

以下截图描述了 Dirty Cow（CVE-2016-5195）的 C 语言漏洞利用版本的步骤：

![](img/00058.jpeg)

# 逻辑和硬件相关的漏洞

逻辑和硬件相关的漏洞利用是非常危险的。想象一下，一个攻击者不仅可以 compromise 操作系统，还可以完全控制硬件本身。这可能是一场灾难。接下来，我们将看一下相关的硬件漏洞，允许攻击者攻击 Linux 硬件基础设施。

# 案例研究 CVE-2016-4484 - Cryptsetup Initrd root Shell

这个漏洞利用是在 2016 年维也纳的 Deepsec 深度安全会议上展示的。演讲的标题是*滥用 LUKS 来黑客系统*。在会议期间，研究人员展示了一种危险的方法，利用 Cryptsetup 中的漏洞来解密主机分区。这个漏洞利用使你能够获得对被攻击机器的 root 访问权限，并能够对磁盘进行任何操作。这个漏洞是由于密码检查的处理不当引起的。因此，当用户尝试输入密码超过三次时，系统会正常进行引导序列：

![](img/00059.jpeg)

# Linux Exploit Suggester

Linux Exploit Suggester 是由**PenturaLabs**开发的一个简单脚本，用于帮助渗透测试人员搜索 Linux 漏洞。让我们从 GitHub 下载该工具：

`#git clone https://github.com/mzet-/linux-exploit-suggester`

![](img/00060.gif)

该工具使用`uname -r`命令来收集有关 Linux 操作系统发布版本的信息，然后为您提供该特定版本的特权升级漏洞列表。如果您已经知道发布版本，可以直接使用`-k`选项输入，如下面的屏幕截图所示：

![](img/00061.gif)

之后，您可以使用网站，如[`www.cvedetails.com `](https://www.cvedetails.com)搜索更多关于发现的漏洞的信息。

![](img/00062.jpeg)

# 缓冲区溢出预防技术

有许多实施的技术来避免缓冲区溢出攻击。在接下来的部分中，我们将介绍一些众所周知的机制。

# 地址空间布局随机化

**地址空间布局随机化**（**ASLR**）是由 Pax 项目开发的一种防御机制，用于防范缓冲区溢出攻击。这种内存保护过程在加载到内存中时随机化可执行位置。因为，正如我们在前面的部分中所学到的，如果位置是可预测的，那么系统的利用将会很容易。它最初是作为 Linux 的补丁在 2001 年推出的，但后来被集成到许多其他操作系统中。可以使用以下技术来打败 ASLR：

+   暴力破解所有可能的 256 个地址，直到利用程序起作用

+   生成 NOP 块，直到获得合法的内存

# 堆栈哨兵

堆栈哨兵用于在发生缓冲区溢出攻击之前检测它们。它们并不是确切地防止它们，而是由编译器实施的，通过在潜在易受攻击的函数中使用哨兵来使利用更加困难。函数序言将一个值放入哨兵位置，而尾声则检查确保该值未被更改。

![](img/00063.jpeg)

# 不可执行堆栈

**不可执行堆栈**（**NX**）是一种虚拟内存保护机制，通过限制特定内存并实施 NX 位来阻止堆栈上的 shell 代码注入执行。但是，这种技术对于返回到 lib 攻击并不真正值得，尽管它们不需要可执行堆栈。

# Linux 返回导向编程

**返回导向编程**（**ROP**）是一种众所周知的技术，可以绕过大多数讨论过的保护机制。它是通过找到我们所谓的 ROP 小工具（代码片段）并跳转到它们来完成的。在这种技术中，攻击者劫持和操纵程序控制流，并执行驻留在内存中的一系列指令来执行攻击。这被称为 ROP 链接。

# Linux 加固

在前面的部分中，我们发现了攻击 Linux 基础设施所需的方法和工具。现在是时候部署保障措施，并学习如何防御这些攻击并保护您的基础设施了。要加固您的 Linux 系统，您需要执行以下操作：

+   更新 Linux 内核和应用程序

+   避免使用不安全的服务，如 FTP 和 telnet，改用 SFTP 和 OpenSSH

+   通过仅使用所需的应用程序和服务来最小化攻击面

+   如果可能，使用 SELinux

+   使用强密码策略

+   密切关注 faillog 记录

+   加固`/etc/sysctl.conf`

+   使用认证服务器

**互联网安全中心**（**CIS**）为各种操作系统提供了许多加固指南，包括 Linux。强烈建议访问：[`www.cisecurity.org/`](https://www.cisecurity.org/)。

![](img/00064.jpeg)

现在，从此链接[`www.cisecurity.org/cis-benchmarks/`](https://www.cisecurity.org/cis-benchmarks/)下载您的 Linux 发行版的基准。以下是 Debian 加固指南：

![](img/00065.jpeg)

# 总结

本章总结了 Linux 基础设施的不同攻击面，从基本的 Linux 命令开始，特别是那些用于执行系统足迹和枚举的命令。在后面的部分，我们不仅有机会学习最新的 Linux 利用技术，还有真实案例研究，还能理解每个 Linux 安全层背后的理论和概念。我们并没有止步于此；作为渗透测试人员，我们有机会发现如何利用 Linux 基础设施的内核。在本章结束时，我们获得了操作和保护 Linux 基础设施的技能，既从攻击者的角度，也从防御者的角度。下一章将拓宽你的视野，让你清楚地了解如何渗透大型企业网络和数据库，从网络基础术语到获取渗透大型网络公司所需的技能。
