- en: Pentesting SQL and XSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL和XSS渗透测试
- en: 'In this chapter, we will discuss some serious attacks on a web application.
    You must have heard about incidents such as data theft, the cracking of usernames
    and passwords, the defacement of websites, and so on. These are known to occur
    mainly due to the vulnerabilities that exist in web applications, which are usually
    performed with SQL injection and XSS attacks. In [Chapter 7](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml),
    *Foot Printing a Web Server and a Web Application*, you learned how to see which
    database software is being used and which OS is running on the web server. Now,
    we will proceed with our attacks one by one. In this chapter, we will cover the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些对Web应用程序的严重攻击。你一定听说过数据窃取、用户名和密码破解、网站篡改等事件。这些主要是由于Web应用程序中存在的漏洞造成的，通常是通过SQL注入和XSS攻击来实现的。在[第7章](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml)中，*对Web服务器和Web应用程序进行足迹扫描*，你学会了如何查看正在使用的数据库软件和Web服务器上正在运行的操作系统。现在，我们将逐个进行攻击。在本章中，我们将涵盖以下主题：
- en: The SQL injection attack
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: Types of SQL injection attacks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入攻击的类型
- en: An SQL injection attack by Python script
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python脚本的SQL注入攻击
- en: A cross-site scripting attack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: Types of XSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XSS的类型
- en: An XSS attack by Python script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python脚本的XSS攻击
- en: Introducing the SQL injection attack
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍SQL注入攻击
- en: 'SQL injection is a technique, or you could say, an expert technique, that is
    used to steal data by taking advantage of a nonvalidated input vulnerability.
    The method by which a web application works can be seen in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是一种技术，或者你可以说，是一种专家技术，用来利用未经验证的输入漏洞来窃取数据。Web应用程序的工作方法可以在下面的截图中看到：
- en: '![](img/f55d0252-f3f7-486f-ac45-48329533f0c1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f55d0252-f3f7-486f-ac45-48329533f0c1.png)'
- en: The method by which a web application works
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的工作方法
- en: If our query were not validated, then it would go to the database for execution,
    and then it might reveal sensitive data or delete data. How data-driven websites
    work is shown in the preceding screenshot. In this screenshot, we are shown that
    the client opens the web page on a local computer. The host is connected to a
    web server via the internet. The preceding screenshot clearly shows the method
    by which the web application interacts with the database of a web server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的查询没有经过验证，那么它将进入数据库执行，然后可能会泄露敏感数据或删除数据。数据驱动的网站工作方式如前面的截图所示。在这个截图中，我们看到客户端在本地计算机上打开网页。主机通过互联网连接到Web服务器。前面的截图清楚地显示了Web应用程序与Web服务器数据库交互的方法。
- en: Types of SQL injections
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入的类型
- en: 'SQL injection attacks can be categorized into the following two types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击可以分为以下两种类型：
- en: Simple SQL injection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的SQL注入
- en: Blind SQL injection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盲目的SQL注入
- en: Simple SQL injection
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的SQL注入
- en: A simple SQL injection attack contains tautology. In tautology, injecting statements
    are always `true`. A union select statement returns the union of the intended
    data with the targeted data. We will look at SQL injection in detail in the following
    section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的SQL注入攻击包含重言。在重言中，注入语句总是`true`。联合选择语句返回预期数据与目标数据的联合。我们将在下一节详细讨论SQL注入。
- en: Blind SQL injection
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盲目的SQL注入
- en: In this attack, the attacker takes advantage of the error messages generated
    by the database server after performing an SQL injection attack. The attacker
    gleans data by asking a series of true or false questions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种攻击中，攻击者利用数据库服务器在执行SQL注入攻击后生成的错误消息。攻击者通过一系列真假问题来获取数据。
- en: Understanding the SQL injection attack by a Python script
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Python脚本理解SQL注入攻击
- en: All SQL injection attacks can be carried out manually. However, you can use
    Python programming to automate the attack. If you are a good pentester and know
    how to perform attacks manually, then you can make your own program check this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的SQL注入攻击都可以手动进行。但是，你可以使用Python编程来自动化攻击。如果你是一个优秀的渗透测试人员，并且知道如何手动执行攻击，那么你可以自己编写程序来检查这一点。
- en: In order to obtain the username and password of a website, we must have the
    URL of the admin or login console page. The client does not provide the link to
    the admin console page on the website.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取网站的用户名和密码，我们必须拥有管理员或登录控制台页面的URL。客户端没有提供网站上管理员控制台页面的链接。
- en: Here, Google fails to provide the login page for a particular website. Our first
    step is to find the admin console page. I remembered that, years ago, I used the
    URLs `http://192.168.0.4/login.php` and `http://192.168.0.4/login.html`. Now,
    web developers have become smart, and they use different names to hide the login
    page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，谷歌未能提供特定网站的登录页面。我们的第一步是找到管理员控制台页面。我记得，多年前，我使用了URL `http://192.168.0.4/login.php`
    和 `http://192.168.0.4/login.html`。现在，Web开发人员变得聪明了，他们使用不同的名称来隐藏登录页面。
- en: Let's say that I have more than 300 links to try. If I try doing this manually,
    it would take around one to two days to obtain the web page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有300多个链接要尝试。如果我手动尝试，可能需要一到两天的时间才能获取网页。
- en: 'Let''s take a look at a small program, `login1.py`, to find the login page
    for PHP websites:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个小程序`login1.py`，来找到PHP网站的登录页面：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For a better understanding, assume that the preceding code is an empty pistol.
    The `mohit.raj` file is like the magazine of a pistol, and `data_handle.py` is
    like a machine that can be used to put bullets in the magazine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，假设前面的代码是一把空手枪。`mohit.raj`文件就像手枪的弹夹，`data_handle.py`就像可以用来把子弹放进弹夹的机器。
- en: I have written this code for a PHP-driven website. Here, I imported `httplib`
    and `shelve`. The `url` variable stores the URL of the website entered by the
    user. The `url2` variable stores only the domain name or IP address. The `s =
    shelve.open("mohit.raj",writeback=True)` statement opens the `mohit.raj` file
    that contains a list of the expected login page names that I entered (the expected
    login page) in the file, based on my experience. The `s['php']` variable means
    that `php` is the key name of the list, and `s['php']` is the list saved in the
    shelve file (`mohit.raj`) using the name `'php'`. The `for` loop extracts the
    login page names one by one, and `url_n = url2+a+u` will show the URL for testing.
    An `HTTPConnection` instance represents one transaction with an HTTP server. The
    `http_r = httplib.HTTPConnection(url2)` statement only needs the domain name;
    this is why only the `url2` variable has been passed as an argument and, by default,
    it uses port `80` and stores the result in the `http_r` variable. The `http_r.request("GET",u)`
    statement makes the network request, and the `http_r.getresponse()` statement
    extracts the response.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一个PHP驱动的网站编写了这段代码。在这里，我导入了`httplib`和`shelve`。`url`变量存储用户输入的网站的URL。`url2`变量仅存储域名或IP地址。`s
    = shelve.open("mohit.raj",writeback=True)`语句打开包含我输入的预期登录页面名称（文件中的预期登录页面）的`mohit.raj`文件，根据我的经验。`s['php']`变量意味着`php`是列表的键名，`s['php']`是使用名称`'php'`保存在shelve文件（`mohit.raj`）中的列表。`for`循环逐个提取登录页面名称，`url_n
    = url2+a+u`将显示用于测试的URL。`HTTPConnection`实例表示与HTTP服务器的一次交易。`http_r = httplib.HTTPConnection(url2)`语句只需要域名；这就是为什么只传递了`url2`变量作为参数，并且默认使用端口`80`并将结果存储在`http_r`变量中。`http_r.request("GET",u)`语句发出网络请求，`http_r.getresponse()`语句提取响应。
- en: If the return code is `200`, it means that we have succeeded. It will print
    the current URL. If, after this first success, you still want to find more pages,
    you could press the *C* key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回代码是`200`，这意味着我们成功了。它将打印当前的URL。如果在第一次成功之后，您仍然想要找到更多页面，您可以按*C*键。
- en: You might be wondering why I used the `httplib` library and not the `urllib`
    library. If you are, then you are thinking along the right lines. Actually, what
    happens is that many websites use redirection for error handling. The `urllib`
    library supports redirection, but `httplib` does not support redirection. Consider
    that when we hit a URL that does not exist, the website (which has custom error
    handling) redirects the request to another page that contains a message such as
    `Page not found` or `Page does not exist`, that is, a custom 404 page. In this
    case, the HTTP status return code is `200`. In our code, we used `httplib`; this
    doesn't support redirection, so the HTTP status return code, `200`, will not produce.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我使用了`httplib`库而不是`urllib`库。如果是的话，那么你的想法是正确的。实际上，许多网站使用重定向来处理错误。`urllib`库支持重定向，但`httplib`不支持重定向。考虑到当我们访问一个不存在的URL时，网站（具有自定义错误处理）会将请求重定向到另一个包含消息的页面，例如`页面未找到`或`页面不存在`，即自定义的404页面。在这种情况下，HTTP状态返回代码是`200`。在我们的代码中，我们使用了`httplib`；它不支持重定向，因此HTTP状态返回代码`200`将不会产生。
- en: In order to manage the `mohit.raj` database file, I made a Python program, `data_handler.py`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理`mohit.raj`数据库文件，我编写了一个Python程序`data_handler.py`。
- en: 'Now, it is time to see the output in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在以下截图中看输出了：
- en: '![](img/57f91848-73a8-42ac-b1fe-54b136736f87.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f91848-73a8-42ac-b1fe-54b136736f87.png)'
- en: The login.py program showing the login page
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 显示登录页面的login.py程序
- en: Here, the login pages are `http://192.168.0.6/admin` and `http://192.168.0.6/admin/index.php`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，登录页面是`http://192.168.0.6/admin`和`http://192.168.0.6/admin/index.php`。
- en: Let's check the `data_handler.py` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`data_handler.py`文件。
- en: 'Now, let''s write the code as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按以下方式编写代码：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I hope you remember the port scanner program in which we used a database file
    that stored the port number with the port description. Here, a list named `php`
    is used and the output can be seen in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你还记得我们使用数据库文件存储端口号和端口描述的端口扫描程序。这里使用了一个名为`php`的列表，输出可以在以下截图中看到：
- en: '![](img/1116c28a-e909-4fea-aa5e-2ea04a3434a8.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1116c28a-e909-4fea-aa5e-2ea04a3434a8.png)'
- en: Showing mohit.raj by data_handler.py
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过data_handler.py显示mohit.raj
- en: The previous program is for PHP. We can also make programs for different web
    server languages such as ASP.NET.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序是为PHP编写的。我们还可以为不同的Web服务器语言编写程序，例如ASP.NET。
- en: Now, it's time to perform an SQL injection attack that is tautology based. Tautology-based
    SQL injection is usually used to bypass user authentication.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候执行基于重言的SQL注入攻击了。基于重言的SQL注入通常用于绕过用户身份验证。
- en: 'For example, assume that the database contains usernames and passwords. In
    this case, the web application programming code would be as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设数据库包含用户名和密码。在这种情况下，Web应用程序编程代码将如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `$uname` variable stores the username, and the `$pass` variable stores
    the password. If a user enters a valid username and password, then `count(*)`
    will contain one record. If `count(*) > 0`, then the user can access their account.
    If an attacker enters `1" or "1"="1` in the username and password fields, then
    the query will be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`$uname`变量存储用户名，`$pass`变量存储密码。如果用户输入有效的用户名和密码，那么`count(*)`将包含一条记录。如果`count(*)
    > 0`，则用户可以访问他们的帐户。如果攻击者在用户名和密码字段中输入`1" or "1"="1`，那么查询将如下所示：'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `User` and `Pass` fields will remain `true`, and the `count(*)` field will
    automatically become `count(*)> 0`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`和`Pass`字段将保持`true`，`count(*)`字段将自动变为`count(*)> 0`。'
- en: 'Let''s write the `sql_form6.py` code and analyze it line by line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`sql_form6.py`代码并逐行分析它：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should be able to understand the program up until the `for` loop. The `pass_exp`
    variable represents the list that contains the password attacks based on tautology.
    The `user1` and `pass1` variables ask the user to enter the username and password
    field as shown by form. The `flag=0` variable makes the `while` loop continue,
    and the `p` variable initializes as `0`. Inside the `while` loop, which is the
    `br.select_form(nr=0)` statement, select the HTML form one. Actually, this code
    is based on the assumption that, when you go to the login screen, it will contain
    the login username and password fields in the first HTML form. The `br.form[user1]
    = ''admin''` statement stores the username; actually, I used it to make the code
    simple and understandable. The `br.form[pass1] = pass_exp[p]` statement shows
    the element of the `pass_exp` list passing to `br.form[pass1]`. Next, the `for`
    loop section converts the output into string format. How do we know if the password
    has been accepted successfully? You have seen that, after successfully logging
    in to the page, you will find a logout or sign out option on the page. I stored
    different combinations of the logout and sign out options in a list named `list`.
    The `data1 = data.lower()` statement changes all of the data to lowercase. This
    will make it easy to find the logout or sign out terms in the data. Now, let''s
    look at the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够理解程序直到`for`循环。`pass_exp`变量表示基于逻辑的密码攻击列表。`user1`和`pass1`变量要求用户输入用户名和密码字段，如表单所示。`flag=0`变量使`while`循环继续，`p`变量初始化为`0`。在`while`循环内，即`br.select_form(nr=0)`语句，选择HTML表单一。实际上，这段代码是基于这样的假设，即当您转到登录屏幕时，它将在第一个HTML表单中包含登录用户名和密码字段。`br.form[user1]
    = 'admin'`语句存储用户名；实际上，我使用它使代码简单易懂。`br.form[pass1] = pass_exp[p]`语句显示将`pass_exp`列表的元素传递给`br.form[pass1]`。接下来，`for`循环部分将输出转换为字符串格式。我们如何知道密码是否已成功接受？您已经看到，成功登录到页面后，您将在页面上找到注销或退出选项。我在名为`list`的列表中存储了不同的注销和退出选项的组合。`data1
    = data.lower()`语句将所有数据更改为小写。这将使在数据中查找注销或退出术语变得容易。现在，让我们看看代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding piece of code will find any value of the `list` in `data1`. If
    a match is found, then `flag` becomes `1`; this will break the `while` loop. Next,
    the `if flag ==1` statement will show successful attempts. Let''s look at the
    next line of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在`data1`中找到`list`的任何值。如果找到匹配项，则`flag`变为`1`；这将打破`while`循环。接下来，`if flag ==1`语句将显示成功的尝试。让我们看看代码的下一行：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding piece of code shows that if all of the values of the `pass_exp`
    list are over, then the `while` loop will break.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，如果`pass_exp`列表的所有值都用完了，那么`while`循环将中断。
- en: 'Now, let''s check the output of the code in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查以下屏幕截图中代码的输出：
- en: '![](img/28f33c91-bf6d-417a-b141-d36043aad1ab.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28f33c91-bf6d-417a-b141-d36043aad1ab.png)'
- en: A SQL injection attack
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: The preceding screenshot shows the output of the code. This is very basic code
    to clear the logic of the program. Now, I want you to modify the code and make
    a new code in which you can provide list values to the password as well as to
    the username.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图显示了代码的输出。这是一个非常基本的代码，用于澄清程序的逻辑。现在，我希望您修改代码，并制作一个新代码，其中您可以为用户名和密码提供列表值。
- en: 'We can write different code (`sql_form7.py`) for the username that contains
    `user_exp = [''admin" --'', "admin'' --", ''admin" #'', "admin'' #" ]` and fill
    in anything in the password field. The logic behind this list is that after the
    admin strings `–` or `#` make a comment, the rest of the line is in the SQL statement:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以为包含`user_exp = [''admin" --'', "admin'' --", ''admin" #'', "admin'' #"
    ]`的用户名编写不同的代码（`sql_form7.py`），并在密码字段中填入任何内容。此列表背后的逻辑是，在管理员字符串`–`或`#`后进行注释，行的其余部分就在SQL语句中了：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we used one more variable, `form`; in the output, you
    have to select the form name. In the `sql_form6.py` code, I assumed that the username
    and password are contained in the form number `1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了一个额外的变量`form`；在输出中，您必须选择表单名称。在`sql_form6.py`代码中，我假设用户名和密码包含在表单编号`1`中。
- en: 'The output of the previous code is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/19af076d-d080-46c5-857b-e5cd0670cc36.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19af076d-d080-46c5-857b-e5cd0670cc36.png)'
- en: The SQL injection username query exploitation
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入用户名查询利用
- en: Now, we can merge both the `sql_form6.py` and `sql_from7.py` code and make one
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以合并`sql_form6.py`和`sql_from7.py`代码，并制作一个代码。
- en: 'In order to mitigate the preceding SQL injection attack, you have to set a
    filter program that filters the input string entered by the user. In PHP, the `mysql_real_escape_string()` function
    is used to filter. The following screenshot shows us how to use this function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻前面的SQL注入攻击，您必须设置一个过滤程序，过滤用户输入的输入字符串。在PHP中，使用`mysql_real_escape_string()`函数进行过滤。以下屏幕截图显示了如何使用此函数：
- en: '![](img/eb29908b-a891-4d3d-bcc6-71308962fd9a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb29908b-a891-4d3d-bcc6-71308962fd9a.png)'
- en: The SQL injection filter in PHP
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的SQL注入过滤
- en: 'So far, you have got the idea of how to carry out a SQL injection attack. In
    a SQL injection attack, we have to do a lot of things manually, because there
    are a lot of SQL injection attacks, such as time-based, SQL query-based contained
    order by, union-based, and so on. Every pentester should know how to craft queries
    manually. For one type of attack, you can make a program, but now, different website
    developers use different methods to display data from the database. Some developers
    use HTML forms to display data, and some use simple HTML statements to display
    data. A Python tool called *sqlmap* can do many things. However, sometimes, a
    web application firewall, such as mod security, is present; this does not allow
    queries such as *union* and *order by*. In this situation, you have to craft queries
    manually, as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了如何进行SQL注入攻击。在SQL注入攻击中，我们必须手动完成很多事情，因为有很多SQL注入攻击，例如基于时间的、基于SQL查询的包含order
    by的、基于联合的等等。每个渗透测试人员都应该知道如何手动制作查询。对于一种类型的攻击，您可以制作一个程序，但现在，不同的网站开发人员使用不同的方法来显示来自数据库的数据。一些开发人员使用HTML表单来显示数据，而一些使用简单的HTML语句来显示数据。一个名为*sqlmap*的Python工具可以做很多事情。然而，有时会存在Web应用程序防火墙，例如mod
    security；这不允许*union*和*order by*等查询。在这种情况下，您必须手动制作查询，如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can make a list of crafted queries. When simple queries do not work, you
    can check the behavior of the website. Based on the behavior, you can decide whether
    the query is successful or not. In this instance, Python programming is very helpful.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以制作一个制作的查询列表。当简单查询不起作用时，您可以检查网站的行为。根据行为，您可以决定查询是否成功。在这种情况下，Python编程非常有帮助。
- en: 'Now, let''s look at the following steps to make a Python program for a firewall-based
    website:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下步骤，为基于防火墙的网站制作Python程序：
- en: Make a list of all of the crafted queries
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作所有制作的查询的列表
- en: Apply a simple query to a website and observe the response of the website
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向网站应用一个简单的查询，并观察网站的响应
- en: Use this `attempt not successful` response to unsuccessful attempts
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`尝试不成功`的响应来回应不成功的尝试
- en: Apply the listed queries one by one and match the response by the program
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐一应用列出的查询，并通过程序匹配响应
- en: If the response is not matched, then check the query manually
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应不匹配，则手动检查查询
- en: If it appeared to be successful, then stop the program
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果看起来成功了，那么停止程序
- en: The preceding steps are used to show only whether the crafted query is successful
    or not. The desired result can be found only by viewing the website.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤仅用于显示制作的查询是否成功。只有通过查看网站才能找到所需的结果。
- en: Learning about cross-site scripting
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习跨站脚本
- en: In this section, we will discuss the **Cross-Site Scripting** (**XSS**) attack.
    XSS attacks exploit vulnerabilities in dynamically-generated web pages, and this
    happens when invalidated input data is included in the dynamic content that is
    sent to the user's browser for rendering.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论**跨站脚本攻击**（**XSS**）。XSS攻击利用动态生成的网页中的漏洞，当未经验证的输入数据包含在发送到用户浏览器以进行渲染的动态内容中时，就会发生这种情况。
- en: 'Cross-site attacks are of the following two types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站攻击有以下两种类型：
- en: Persistent or stored XSS
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性或存储型XSS
- en: Nonpersistent or reflected XSS
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非持久性或反射型XSS
- en: Persistent or stored XSS
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性或存储型XSS
- en: In this type of attack, the attacker's input is stored in the web server. In
    several websites, you will have seen comment fields and a message box where you
    can write your comments. After submitting the comment, your comment is shown on
    the display page. Try to think of one instance where your comment becomes part
    of the HTML page of the web server; this means that you have the ability to change
    the web page. If proper validations are not there, then your malicious code can
    be stored in the database, and when it is reflected back on the web page, it produces
    an undesirable effect. It is stored permanently in the database server, and that's
    why it is known as being persistent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的攻击中，攻击者的输入被存储在Web服务器中。在一些网站上，您会看到评论字段和消息框，您可以在其中写下您的评论。提交评论后，您的评论会显示在显示页面上。试着想象一种情况，您的评论成为Web服务器的HTML页面的一部分；这意味着您有能力更改网页。如果没有适当的验证，那么您的恶意代码可以存储在数据库中，当它反映回网页时，会产生不良影响。它被永久存储在数据库服务器中，这就是为什么它被称为持久性。
- en: Nonpersistent or reflected XSS
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非持久性或反射型XSS
- en: In this type of attack, the input of the attacker is not stored in the database
    server. The response is returned in the form of an error message. The input is
    given with the URL or in the search field. In this chapter, we will work on stored
    XSS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的攻击中，攻击者的输入不会存储在数据库服务器中。响应以错误消息的形式返回。输入是通过URL或搜索字段给出的。在本章中，我们将处理存储型XSS。
- en: 'Now, let''s look at the code for the XSS attack. The logic of the code is to
    send an exploit to a website. In the following code, we will attack one field
    of a form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下XSS攻击的代码。代码的逻辑是向网站发送一个利用。在以下代码中，我们将攻击表单的一个字段：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code has been written for a website that uses the name and comment fields.
    This small piece of code will give you an idea of how to accomplish the XSS attack.
    Sometimes, when you submit a comment, the website will redirect to the display
    page. That's why we make a comment using the `br.set_handle_redirect(False)` statement.
    In the code, we stored the exploit code in the `mohit.xss` shelve file. The statement
    for the form in `br.forms():` will print the form. By viewing the form, you can
    select the form field which you want to attack. Setting the `flag = 'y'` variable
    makes the `while` loop execute at least once. The interesting thing is that, when
    we used the `br.open(url)` statement, it opened the URL of the website every time
    because, in my dummy website, I used redirection; this means that after submitting
    the form, it will redirect to the display page, which displays the old comments.
    The `br.form[non] = 'aaaaaaa'` statement just fills the `aaaaaa` string in the
    input field. The `br.form[att] = s['xss'][p]` statement shows that the selected
    field will be filled by the XSS exploit string. The `ch = raw_input("Do you continue
    press y ")` statement asks for user input for the next exploit. If a user enters
    `y` or `Y`, `ch.lower()` makes it `y`, keeping the `while` loop alive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是为一个使用名称和评论字段的网站编写的。这小段代码将给你一个关于如何进行XSS攻击的想法。有时，当你提交评论时，网站会重定向到显示页面。这就是为什么我们使用`br.set_handle_redirect(False)`语句来进行评论。在代码中，我们将利用代码存储在`mohit.xss`
    shelve文件中。`br.forms()`中的表单语句将打印出表单。通过查看表单，你可以选择要攻击的表单字段。设置`flag = 'y'`变量使`while`循环至少执行一次。有趣的是，当我们使用`br.open(url)`语句时，它每次都会打开网站的URL，因为在我的虚拟网站中，我使用了重定向；这意味着在提交表单后，它会重定向到显示页面，显示旧的评论。`br.form[non]
    = 'aaaaaaa'`语句只是在输入字段中填充`aaaaaa`字符串。`br.form[att] = s['xss'][p]`语句显示所选字段将被XSS攻击字符串填充。`ch
    = raw_input("Do you continue press y ")`语句要求用户输入下一个攻击。如果用户输入`y`或`Y`，`ch.lower()`将其变为`y`，保持`while`循环活动。
- en: 'Now, it''s time for the output. The following screenshot shows the Index page
    of `192.168.0.5`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看输出了。下面的截图显示了`192.168.0.5`的首页：
- en: '![](img/5916f5a3-1575-4f97-a56c-b00cc712e959.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5916f5a3-1575-4f97-a56c-b00cc712e959.png)'
- en: The Index page of the website
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的首页
- en: 'Now, it''s time to see the code''s output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看代码的输出了：
- en: '![](img/e03ccebe-7cd9-4ad8-9a7e-3595379b560f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e03ccebe-7cd9-4ad8-9a7e-3595379b560f.png)'
- en: The output of the code
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出
- en: You can see the output of the code in the preceding screenshot. When I press
    the *y* key, the code sends the XSS exploit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的截图中看到代码的输出。当我按下*y*键时，代码发送了XSS攻击。
- en: 'Now, let''s look at the output of the website:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看网站的输出：
- en: '![](img/83e5f7e2-45c0-492a-bf07-10d5f1d35d1c.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83e5f7e2-45c0-492a-bf07-10d5f1d35d1c.png)'
- en: The output of the website
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的输出
- en: 'You can see that the code is successfully sending the output to the website.
    However, this field is not affected by the XSS attack because of the secure coding
    in PHP. At the end of the chapter, you will see the secure coding of the Comment
    field. Now, run the code and check the name field:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到代码成功地将输出发送到网站。然而，由于PHP中的安全编码，这个字段不受XSS攻击的影响。在本章的最后，你将看到评论字段的安全编码。现在，运行代码并检查名称字段：
- en: '![](img/7f13b0f3-0988-4508-9b2d-b84767fa2772.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f13b0f3-0988-4508-9b2d-b84767fa2772.png)'
- en: A successful attack on the name field
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 名称字段的成功攻击
- en: 'Now, let''s take a look at the code of `xss_data_handler.py`, from which you
    can update `mohit.xss`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`xss_data_handler.py`的代码，从中你可以更新`mohit.xss`：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I hope that you are familiar with the preceding code. Now, look at the output
    of the preceding code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你熟悉前面的代码。现在，看看前面代码的输出：
- en: '![](img/4f10eadf-1cad-4681-99ed-93cea687ba03.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f10eadf-1cad-4681-99ed-93cea687ba03.png)'
- en: The output of xss_data_handler.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: xss_data_handler.py的输出
- en: The preceding screenshot shows the contents of the `mohit.xss` file; the `xss.py`
    file is limited to two fields. However, now let's look at the code that is not
    limited to two fields.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`mohit.xss`文件的内容；`xss.py`文件限制为两个字段。然而，现在让我们看看不限于两个字段的代码。
- en: 'The `xss_list.py` file is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`xss_list.py`文件如下：'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code has the ability to attack multiple fields or a single field.
    In this code, we used two lists, `list_a` and `list_n`. The `list_a` list contains
    the field(s) name on which you want to send XSS exploits, and `list_n` contains
    the field(s) name on which you don't want to send XSS exploits.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码能够攻击多个字段或单个字段。在这段代码中，我们使用了两个列表，`list_a`和`list_n`。`list_a`列表包含你想要发送XSS攻击的字段名称，`list_n`包含你不想要发送XSS攻击的字段名称。
- en: 'Now, let''s look at the program. If you understood the `xss.py` program, you
    would have noticed that we made an amendment to `xss.py` to create `xss_list.py`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看程序。如果你理解了`xss.py`程序，你会注意到我们对`xss.py`进行了修改，以创建`xss_list.py`：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I have already explained the significance of `list_a[]` and `list_n[]`. The
    variable field asks the user to enter the total number of form fields in the form
    that is not read-only. The `for i in xrange(0,field):` statement defines for loop
    from 0 to field, running field times, means the total number of field present
    in the form. The `na` variable asks the user to enter the field name, and the
    `ch` variable asks the user, `Do you attack on this field`? This means, if you
    press *y* or *Y*, the entered field would go to `list_a`; otherwise, it would
    go to `list_n`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经解释了`list_a[]`和`list_n[]`的重要性。变量字段要求用户输入表单中非只读字段的总数。`for i in xrange(0,field):`语句定义了从0到字段的循环，运行字段次数，意味着表单中存在的字段总数。`na`变量要求用户输入字段名称，`ch`变量要求用户输入“你要攻击这个字段吗”？这意味着，如果你按下*y*或*Y*，输入的字段将进入`list_a`；否则，它将进入`list_n`：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding piece of code is very easy to understand. Two `for` loops for
    two lists are iterated and fill in the form fields.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常容易理解。两个`for`循环用于两个列表，用于填写表单字段。
- en: 'The output of the code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![](img/7715e22d-362c-4cb7-a710-7c566fd8f98c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7715e22d-362c-4cb7-a710-7c566fd8f98c.png)'
- en: Form filling to check list_n
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单以检查list_n
- en: 'The preceding screenshot shows that the number of form fields is two. The user
    entered the form fields'' names and made them nonattack fields. This simply checks
    the working of the code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示表单字段的数量为两个。用户输入了表单字段的名称并使它们成为非攻击字段。这只是检查代码的工作方式：
- en: '![](img/638f24e0-0c72-43f3-8fce-a679aa9deb98.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/638f24e0-0c72-43f3-8fce-a679aa9deb98.png)'
- en: Form filling to check the list_a list
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单以检查list_a列表
- en: The preceding screenshot shows that the user entered the form field and made
    it attack fields.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示用户输入了表单字段并使其攻击字段。
- en: 'Now, check the response of the website, which is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查网站的响应，如下所示：
- en: '![](img/c397eb86-585b-4bab-8286-7e3a640f1a36.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c397eb86-585b-4bab-8286-7e3a640f1a36.png)'
- en: Form fields filled successfully
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段成功填写
- en: 'The preceding screenshot shows that the code is working fine; the first two
    rows have been filled with the ordinary `aaaaaaa` string. The third and fourth
    rows have been filled by XSS attacks. So far, you have learned how to automate
    the XSS attack. By proper validation and filtration, web developers can protect
    their websites. In the PHP function, the `htmlspecialchars()` string can protect
    your website from an XSS attack. In the preceding screenshot, you can see that
    the Comment field is not affected by an XSS attack. The following screenshot shows
    the coding part of the Comment field:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示代码运行正常；前两行已填入普通的`aaaaaaa`字符串。第三行和第四行已被XSS攻击填充。到目前为止，您已经学会了如何自动化XSS攻击。通过适当的验证和过滤，Web开发人员可以保护他们的网站。在PHP函数中，`htmlspecialchars()`字符串可以保护您的网站免受XSS攻击。在前面的屏幕截图中，您可以看到评论字段没有受到XSS攻击的影响。以下屏幕截图显示了评论字段的编码部分：
- en: '![](img/bba3501b-f423-4f0c-a492-32b4c05715e6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bba3501b-f423-4f0c-a492-32b4c05715e6.png)'
- en: Figure showing the htmlspecialchars() function
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显示htmlspecialchars()函数的图表
- en: When you see the view source of the display page, it looks like `&lt;script&gt;alert(1)&lt;/script&gt`;
    the special character `<` is converted into `&lt`, and `>` is converted into `&gt`.
    This conversion is called HTML encoding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看显示页面的源代码时，它看起来像`&lt;script&gt;alert(1)&lt;/script&gt`;特殊字符`<`被转换为`&lt`，`>`被转换为`&gt`。这种转换称为HTML编码。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about two major types of web attacks, SQL injection,
    and XSS. In SQL injection, you learned how to find the admin login page using
    Python script. There are lots of different queries for SQL injection and, in this
    chapter, you learned how to crack usernames and passwords based on a tautology.
    In another attack of SQL injection, you learned how to make a comment after a
    valid username. In the XSS, you saw how to apply XSS exploits to the form field,
    and in the `mohit.xss` file, you saw how to add more exploits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了两种主要类型的Web攻击，SQL注入和XSS。在SQL注入中，您学习了如何使用Python脚本找到管理员登录页面。有许多不同的SQL注入查询，在本章中，您学习了如何基于逻辑学研究法破解用户名和密码。在SQL注入的另一种攻击中，您学习了如何在有效用户名之后发表评论。在XSS中，您看到了如何将XSS利用应用到表单字段中，在`mohit.xss`文件中，您看到了如何添加更多的利用。
