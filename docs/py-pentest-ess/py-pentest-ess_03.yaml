- en: Sniffing and Penetration Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗅探和渗透测试
- en: When I was pursuing my Master of engineering (M.E) degree, I used to sniff the
    networks in my friends' hostel with my favorite tool, *Cain and Abel*. My friends
    would usually surf e-commerce websites. The next day, when I told them that the
    shoes they were shopping for were good, they would be amazed. They always wondered
    how I got this information. Well, this is all due to sniffing the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我攻读工程硕士（M.E）学位时，我经常使用我的最爱工具*Cain and Abel*在朋友的宿舍中嗅探网络。我的朋友们通常会上电子商务网站。第二天，当我告诉他们他们购物的鞋子很好时，他们会感到惊讶。他们总是想知道我是如何得到这些信息的。嗯，这都是因为嗅探网络。
- en: 'In this chapter, we will study sniffing a network, and will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习嗅探网络，并涵盖以下主题：
- en: The concept of a sniffer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嗅探的概念
- en: The types of network sniffing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络嗅探的类型
- en: Network sniffing using Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行网络嗅探
- en: Packet crafting using Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行数据包制作
- en: The ARP spoofing concept and implementation by Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP欺骗的概念和Python实现
- en: Testing security by custom-packet crafting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义数据包制作来测试安全性
- en: Introducing a network sniffer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入网络嗅探
- en: 'Sniffing is a process of monitoring and capturing all data packets that pass
    through a given network using software (an application) or a hardware device.
    Sniffing is usually done by a network administrator. However, an attacker might
    use a sniffer to capture data, and this data, at times, might contain sensitive
    information, such as a username and password. Network admins use a switch `SPAN`
    port. The switch sends one copy of the traffic to the `SPAN` port. The admin uses
    this `SPAN` port to analyze the traffic. If you are a hacker, you must have used
    the *Wireshark* tool. Sniffing can only be done within a subnet. In this chapter,
    we will learn about sniffing using Python. However, before this, we need to know
    that there are two sniffing methods. They are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 嗅探是通过软件（应用程序）或硬件设备监视和捕获通过给定网络的所有数据包的过程。嗅探通常由网络管理员执行。但是，攻击者可能使用嗅探器来捕获数据，而这些数据有时可能包含敏感信息，例如用户名和密码。网络管理员使用交换机`SPAN`端口。交换机将流量的一个副本发送到`SPAN`端口。管理员使用此`SPAN`端口来分析流量。如果您是黑客，您一定使用过*Wireshark*工具。嗅探只能在子网内进行。在本章中，我们将学习使用Python进行嗅探。但是，在此之前，我们需要知道有两种嗅探方法。它们如下：
- en: Passive sniffing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动嗅探
- en: Active sniffing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主动嗅探
- en: Passive sniffing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被动嗅探
- en: Passive sniffing refers to sniffing from a hub-based network. By placing a packet
    sniffer on a network in the promiscuous mode, a hacker can capture the packets
    within a subnet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 被动嗅探是指从基于集线器的网络中嗅探。通过将数据包嗅探器放置在混杂模式下的网络中，黑客可以捕获子网内的数据包。
- en: Active sniffing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动嗅探
- en: This type of sniffing is conducted on a switch-based network. A switch is smarter
    than a hub. It sends packets to the computer after checking in a MAC table. Active
    sniffing is carried out by using ARP spoofing, which will be explained further
    in the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的嗅探是在基于交换机的网络上进行的。交换机比集线器更智能。它在MAC表中检查后将数据包发送到计算机。主动嗅探是通过使用ARP欺骗来实现的，这将在本章中进一步解释。
- en: Implementing a network sniffer using Python
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python实现网络嗅探
- en: 'Before learning about the implementation of a network sniffer, let''s learn
    about a particular `struct` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习网络嗅探的实现之前，让我们了解一个特定的`struct`方法：
- en: '`struct.pack(fmt, v1, v2, ...)`: This method returns a string that contains
    the values `v1`, `v2`, and so on, packed according to the given format'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct.pack(fmt, v1, v2, ...)`: 此方法返回一个包含根据给定格式打包的值`v1`、`v2`等的字符串'
- en: '`struct.unpack(fmt, string)`: This method unpacks the string according to the
    given format'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct.unpack(fmt, string)`: 此方法根据给定的格式解包字符串'
- en: 'Let''s discuss the code in the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论以下代码片段中的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, import the `struct` module, and then pack the `1`, `2`, and `3` integers
    in the `hhl` format. The packed values are like machine code. Values are unpacked
    using the same `hhl` format; here, `h` means a short integer and `l` means a long
    integer. More details are provided in the subsequent sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入`struct`模块，然后以`hhl`格式打包`1`、`2`和`3`整数。打包的值就像机器码一样。使用相同的`hhl`格式解包值；这里，`h`表示短整数，`l`表示长整数。更多细节将在后续章节中提供。
- en: Consider the situation of the client-server model; let's illustrate it by means
    of an example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑客户端-服务器模型的情况；让我们通过一个例子来说明。
- en: 'Run the `struct1.py`. file. The server-side code is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`struct1.py`文件。服务器端代码如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The entire code is the same as we saw previously, with `msz= struct.pack('hhl',
    1, 2, 3)` packing the message and `conn.send(msz)` sending the message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码与我们之前看到的一样，使用`msz= struct.pack('hhl', 1, 2, 3)`打包消息和`conn.send(msz)`发送消息。
- en: 'Run the `unstruc.py` file. The client-side code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`unstruc.py`文件。客户端代码如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The client-side code accepts the message and unpacks it in the given format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码接受消息并按给定格式解包。
- en: 'The output for the client-side code is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码的输出如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the server-side code is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码的输出如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you should have a decent idea of how to pack and unpack the data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对如何打包和解包数据有一个相当好的理解。
- en: Format characters
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式字符
- en: 'We have seen the format in the pack and unpack methods. In the following table,
    we have **C-type** and **Python-type** columns. It denotes the conversion between
    C and Python types. The **Standard size** column refers to the size of the packed
    value in bytes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在打包和解包方法中看到了格式。在下表中，我们有**C类型**和**Python类型**列。它表示C和Python类型之间的转换。**标准大小**列指的是以字节为单位的打包值的大小：
- en: '| **Format** | **C type** | **Python type** | **Standard size** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **格式** | **C类型** | **Python类型** | **标准大小** |'
- en: '| x | pad byte | no value |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| x | 填充字节 | 无值 |  |'
- en: '| c | char | string of length 1 | 1 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| c | 字符 | 长度为1的字符串 | 1 |'
- en: '| b | signed char | integer | 1 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| b | 有符号字符 | 整数 | 1 |'
- en: '| B | unsigned char | integer | 1 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| B | 无符号字符 | 整数 | 1 |'
- en: '| ? | _Bool | bool | 1 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| ? | _Bool | bool | 1 |'
- en: '| h | short | integer | 2 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| h | short | integer | 2 |'
- en: '| H | unsigned short | integer | 2 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| H | unsigned short | integer | 2 |'
- en: '| i | int | integer | 4 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| i | int | integer | 4 |'
- en: '| I | unsigned int | integer | 4 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| I | unsigned int | integer | 4 |'
- en: '| l | long | integer | 4 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| l | long | integer | 4 |'
- en: '| L | unsigned long | integer | 4 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| L | unsigned long | integer | 4 |'
- en: '| q | long long | integer | 8 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| q | long long | integer | 8 |'
- en: '| Q | unsigned long long | integer | 8 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Q | unsigned long long | integer | 8 |'
- en: '| f | float | float | 4 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| f | float | float | 4 |'
- en: '| d | double | float | 8 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| d | double | float | 8 |'
- en: '| s | char[] | string |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| s | char[] | string |  |'
- en: '| p | char[] | string |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| p | char[] | string |  |'
- en: '| P | void * | integer |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| P | void * | integer |  |'
- en: 'Let''s check what will happen when one value is packed in different formats:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看当一个值以不同格式打包时会发生什么：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We packed the number `2` in three different formats. From the preceding table,
    we know that *b* and *B* are one byte each, which means that they are the same
    size. However, `*h*` is two bytes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用三种不同的格式打包了数字`2`。从前表中我们知道，*b*和*B*各自占用一个字节，这意味着它们的大小相同。然而，`*h*`占用两个字节。
- en: 'Now, let''s use the long `int`, which is eight bytes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用长整型，即八个字节：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we work on a network, `!` should be used in the following format. `!` is
    used to avoid the confusion of whether network bytes are little-endian or big-endian.
    For more information on big-endian and little-endian, you can refer to the Wikipedia
    page on Endianness:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网络上工作，应该在以下格式中使用`!`。`!`用于避免网络字节是小端还是大端的混淆。有关大端和小端的更多信息，您可以参考维基百科关于字节顺序的页面。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see the difference when using `!` in the format.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式中使用`!`时，您可以看到差异。
- en: 'Before proceeding to sniffing, you should be aware of the following definitions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行嗅探之前，您应该了解以下定义：
- en: '**PF_PACKET**: It operates at the device-driver layer. The `pcap` library for
    Linux uses `PF_PACKET` sockets. To run this, you must be logged in as a root.
    If you want to send and receive messages at the most basic level, below the internet
    protocol layer, then you need to use `PF_PACKET`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PF_PACKET**：它在设备驱动程序层运行。Linux的`pcap`库使用`PF_PACKET`套接字。要运行此程序，您必须以root用户身份登录。如果您想在互联网协议层以下的最基本级别上发送和接收消息，那么您需要使用`PF_PACKET`。'
- en: '**Raw socket**: It does not care about the network layer stack and provides
    a shortcut to send and receive packets directly with the application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始套接字**：它不关心网络层堆栈，并提供了一种快捷方式，可以直接与应用程序发送和接收数据包。'
- en: 'The following socket methods are used for byte-order conversion:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下套接字方法用于字节顺序转换：
- en: '`socket.ntohl(x)`: This is the network to host long. It converts a 32-bit positive
    integer from the network to host the byte order.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.ntohl(x)`: 这是网络到主机的长整型。它将网络中的32位正整数转换为主机的字节顺序。'
- en: '`socket.ntohs(x)`: This is the network to host short. It converts a 16-bit
    positive integer from the network to host the byte order.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.ntohs(x)`: 这是网络到主机的短整型。它将网络中的16位正整数转换为主机的字节顺序。'
- en: '`socket.htonl(x)`: This is the host to network long. It converts a 32-bit positive
    integer from the host to the network byte order.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.htonl(x)`: 这是主机到网络的长整型。它将主机中的32位正整数转换为网络的字节顺序。'
- en: '`socket.htons(x)`: This is the host to network short. It converts a 16-bit
    positive integer from the host to the network byte order.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.htons(x)`: 这是主机到网络的短整型。它将主机中的16位正整数转换为网络的字节顺序。'
- en: So, what is the significance of the preceding four methods?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，前面四种方法的意义是什么？
- en: Consider a 16-bit number, 0000000000000011\. When you send this number from
    one computer to another, its order might get changed. The receiving computer might
    receive it in another form, such as 1100000000000000\. These methods convert from
    your native byte order to the network byte order and back again. Now, let's look
    at the code to implement a network sniffer, which will work on three layers of
    the TCP/IP, that is, the physical layer (Ethernet), the network layer (IP), and
    the TCP layer (port).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个16位数字，0000000000000011。当您将这个数字从一台计算机发送到另一台计算机时，它的顺序可能会改变。接收计算机可能会以另一种形式接收它，比如1100000000000000。这些方法将从您的本机字节顺序转换为网络字节顺序，然后再转换回来。现在，让我们看一下实现网络嗅探器的代码，它将在TCP/IP的三层上工作，即物理层（以太网）、网络层（IP）和TCP层（端口）。
- en: 'Before we look at the code, you should know about the headers of all three
    layers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之前，您应该了解所有三层的头部：
- en: '**The physical layer**: This layer deals with the Ethernet frame, as shown
    in the following image:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理层**：该层处理以太网帧，如下图所示：'
- en: '![](img/8b41b288-afb2-42e6-9ee1-66278654c99c.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b41b288-afb2-42e6-9ee1-66278654c99c.png)'
- en: The structure of the Ethernet frame IEEE 802.3
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网帧IEEE 802.3的结构
- en: 'The explanation for the preceding diagram is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上图的解释如下：
- en: The **Preamble** consists of seven bytes, all of the form 10101010, and is used
    by the receiver to allow it to establish bit synchronization
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前导码**由七个字节组成，全部为10101010的形式，接收器用它来建立位同步'
- en: The **Start frame delimiter** consists of a single byte, 10101011, which is
    a frame flag that indicates the start of a frame
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始帧定界符**由一个字节组成，10101011，它是一个帧标志，表示帧的开始'
- en: The destination and source addresses are the Ethernet addresses usually quoted
    as a sequence of six bytes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地和源地址通常被引用为六个字节的以太网地址序列
- en: We are interested only in the source address and destination address. The data
    part contains the IP and TCP headers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对源地址和目的地址感兴趣。数据部分包含IP和TCP头部。
- en: One thing that you should always remember is that when the frame comes to our
    program buffer, it does not contain the **Preamble** and **Start frame delimiter**
    fields.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该永远记住的一件事是，当帧到达我们的程序缓冲区时，它不包含**前导码**和**起始帧定界符**字段。
- en: MAC addresses, such as `AA:BB:CC:56:78:45`, contain 12 hexadecimal characters,
    and each byte contains two hexadecimal values. To store MAC addresses, we will
    use six bytes of memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MAC地址，如`AA:BB:CC:56:78:45`，包含12个十六进制字符，每个字节包含两个十六进制值。为了存储MAC地址，我们将使用六个字节的内存。
- en: '**The network or IP layer**: In this layer, we are interested in the IP address
    of the source and destination.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络或IP层**：在这一层，我们对源和目的地的IP地址感兴趣。'
- en: 'Now, let''s move on to our IPv4 header, as shown in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看下面的IPv4头部图表：
- en: '![](img/f167844a-aed1-4d01-836c-ed9d0f5f9fa5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f167844a-aed1-4d01-836c-ed9d0f5f9fa5.png)'
- en: The IPv4 header
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部
- en: 'The IPv4 packet header consists of 14 fields, of which only 13 are required.
    The 14th field is optional. This header is 20 bytes long. The last eight bytes
    contain our source IP address and destination IP address. The bytes from 12 to
    16 contain the source IP address, and the bytes from 17 to 20 contain the destination
    IP address:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包头由14个字段组成，其中只有13个是必需的。第14个字段是可选的。该头部长度为20字节。最后8个字节包含我们的源IP地址和目标IP地址。从第12到16个字节包含源IP地址，从第17到20个字节包含目标IP地址：
- en: '**The TCP header**: In this header, we are interested in the source port and
    the destination port address. If you note the TCP header, you will realize that
    it too is 20 bytes long, and the header''s starting two bytes provide the source
    port and the next two bytes provide the destination port address. You can see
    the TCP header in the following diagram:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP头部**：在这个头部中，我们对源端口和目的端口地址感兴趣。如果注意TCP头部，您会意识到它也是20字节长，头部的起始两个字节提供了源端口，接下来的两个字节提供了目的端口地址。您可以在下图中看到TCP头部：'
- en: '![](img/48d8e2b8-f201-4128-84c9-bb60fa6f0a6e.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48d8e2b8-f201-4128-84c9-bb60fa6f0a6e.png)'
- en: The TCP header
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部
- en: 'Now, start the promiscuous mode of the interface card and give the command
    as superuser. So, what is the promiscuous or promisc mode? In computer networking,
    the promiscuous mode allows the network interface card to read packets that arrive
    in its subnet. For example, in a hub environment, when a packet arrives at one
    port, it is copied to the other ports and only the intended user reads that packet.
    However, if other network devices are working in promiscuous mode, that device
    can also read that packet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动接口卡的混杂模式，并以超级用户的身份给出命令。那么，什么是混杂模式？在计算机网络中，混杂模式允许网络接口卡读取到达其子网的数据包。例如，在集线器环境中，当数据包到达一个端口时，它会被复制到其他端口，只有预期的用户才能读取该数据包。但是，如果其他网络设备也在混杂模式下工作，那么该设备也可以读取该数据包：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check the effect of the preceding command, as shown in the following screenshot,
    by typing the `ifconfig` command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的命令的效果，如下截图所示，通过输入`ifconfig`命令：
- en: '![](img/80d8f576-8d9b-4761-8c40-cb4d6486e756.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d8f576-8d9b-4761-8c40-cb4d6486e756.png)'
- en: Showing the promiscuous mode
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显示混杂模式
- en: The preceding screenshot shows the `eth0` network card and that it is working
    in promiscuous mode.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`eth0`网络卡，并且它正在混杂模式下工作。
- en: Some cards cannot be set to the promiscuous mode because of their drivers, kernel
    support, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其驱动程序、内核支持等原因，有些网卡无法设置为混杂模式。
- en: 'Now, it''s time to code. First, let''s look at the following snippet in its
    entirety and then understand it line by line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编码了。首先，让我们完整地看一下以下代码片段，然后逐行理解它：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have already defined the `socket.PF_PACKET, socket.SOCK_RAW` lines. The
    `socket.htons(0x0800)` syntax shows the protocol of interest. The `0x0800` code
    defines the `ETH_P_IP` protocol. You can find all the code in the `if_ether.h`
    file located in `/usr/include/linux`. The `pkt = s.recvfrom(2048)` statement creates
    a buffer of 2,048\. Incoming frames are stored in the `pkt` variable. If you print
    this `pkt`, it shows the tuples, but our valuable information resides in the first
    tuple. The `ethhead = pkt[0][0:14]` statement takes the first 14 bytes from the
    `pkt`. The Ethernet frame is 14 bytes long, and it comes first, as shown in the
    following diagram, and that''s why we use the first 14 bytes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`socket.PF_PACKET, socket.SOCK_RAW`行。`socket.htons(0x0800)`语法显示了感兴趣的协议。`0x0800`代码定义了`ETH_P_IP`协议。您可以在`/usr/include/linux`中的`if_ether.h`文件中找到所有代码。`pkt
    = s.recvfrom(2048)`语句创建了一个2048的缓冲区。传入的帧存储在`pkt`变量中。如果打印这个`pkt`，它会显示元组，但我们宝贵的信息位于第一个元组中。`ethhead
    = pkt[0][0:14]`语句从`pkt`中取出前14个字节。以太网帧长度为14字节，它首先出现在下图中，这就是为什么我们使用前14个字节：
- en: '![](img/d6a4895e-4ca3-4853-80b2-058b75a93041.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6a4895e-4ca3-4853-80b2-058b75a93041.png)'
- en: Configuration of headers
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 头部的配置
- en: In the `eth = struct.unpack("!6s6s2s",ethhead)` statement, `!` shows network
    bytes, and `6s` shows six bytes, as we discussed earlier. The `binascii.hexlify(eth[0])`
    statement returns the hexadecimal representation of the binary data. Every byte
    of `eth[0]` is converted into the corresponding two-digit hex representation.
    The `ip_length = (int(num)%10)*4` syntax tells us the size of the IPv4 header.
    The `ipheader = pkt[0][14:ip_last_range]` statement extracts the data between
    the range. Next is the IP header and the `ip_hdr =struct.unpack("!12s4s4s",ipheader)`
    statement, which unpacks the data into three parts, out of which our destination
    and source IP addresses reside in the second and third parts, respectively. The
    `socket.inet_ntoa(ip_hdr[3])` statement converts a 32-bit packed IPv4 address
    (a string that is four characters in length) to its standard dotted-quad string
    representation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eth = struct.unpack("!6s6s2s",ethhead)`语句中，`!`表示网络字节，`6s`表示六个字节，正如我们之前讨论的那样。`binascii.hexlify(eth[0])`语句返回了二进制数据的十六进制表示。`ip_length
    = (int(num)%10)*4`语法告诉我们IPv4头部的大小。`ipheader = pkt[0][14:ip_last_range]`语句提取了范围内的数据。接下来是IP头部和`ip_hdr
    =struct.unpack("!12s4s4s",ipheader)`语句，它将数据解包成三部分，其中我们的目标和源IP地址分别位于第二部分和第三部分。`socket.inet_ntoa(ip_hdr[3])`语句将32位打包的IPv4地址（一个长度为四个字符的字符串）转换为其标准的点分十进制字符串表示形式。
- en: The `tcpheader **=** pkt[0][ip_last_range:ip_last_range+20]` statement extracts
    the next 20 bytes of data. The `tcp_hdr = struct.unpack("!HH9sB6s",tcpheader)`
    statement is divided into five parts, that is, `HH9sB6s` first, and then the source
    and destination port number. The fourth part, B, represents the flag value. The `str1
    = bin(flags)[2:].zfill(8)`syntax is used to convert the flag int value to a binary
    value of eight bits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpheader **=** pkt[0][ip_last_range:ip_last_range+20]`语句提取了接下来的20个字节数据。`tcp_hdr
    = struct.unpack("!HH9sB6s",tcpheader)`语句分为五部分，即`HH9sB6s`首先，然后是源端口和目的端口号。第四部分B表示标志值。使用`str1
    = bin(flags)[2:].zfill(8)`语法将标志int值转换为八位二进制值。'
- en: 'The output of `sniffer_new.py` is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sniffer_new.py`的输出如下：'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our sniffer is now working fine. Let''s discuss the outcomes of the output.
    The Ethernet frame shows the destination MAC and the source MAC. The IP header
    tells the source IP where the packet is arriving from, and the destination IP
    is another operating system that is running on our subnet. The TCP header shows
    the `Source port`, the `Destination port`, and the `Flag`. The source port is
    `443`, which shows that someone is browsing a website. Now that we have an IP
    address, let''s check which website is running on `91.198.174.192`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的sniffer现在运行正常。让我们讨论输出的结果。以太网帧显示了目的MAC和源MAC。IP头告诉源IP数据包来自何处，目的IP是运行在我们子网上的另一个操作系统。TCP头显示了`源端口`，`目的端口`和`标志`。源端口是`443`，这表明有人正在浏览网站。既然我们有了IP地址，让我们看看`91.198.174.192`上运行着哪个网站：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding results show the `text-lb.esams.wikimedia.org`[ ](http://text-lb.esams.wikimedia.org)website.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果显示了`text-lb.esams.wikimedia.org`[ ](http://text-lb.esams.wikimedia.org)网站。
- en: 'In the output, two packets are shown. If you print`tcp_hdr[3]`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，显示了两个数据包。如果打印`tcp_hdr[3]`：
- en: '![](img/b42e4674-f2e5-425f-99d0-5dc9d080f4cf.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b42e4674-f2e5-425f-99d0-5dc9d080f4cf.png)'
- en: Flags values
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 标志值
- en: If `16` comes, then the `bin(flag1)[2:].zfill(8**)**` syntax will return `00010000`,
    which means the ACK bit is on. The integer 25 means 00011001, which indicates
    the **Ack**, **Push**, and **Fin** bits are on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现`16`，那么`bin(flag1)[2:].zfill(8)`语法将返回`00010000`，这意味着ACK位已打开。整数25表示00011001，这表示**Ack**，**Push**和**Fin**位已打开。
- en: 'Now, let''s make some amendments to the code. Add one more line at the end
    of the code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对代码进行一些修改。在代码的末尾添加一行：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s check how the output is changed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出如何改变：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At times, we are interested in TTL, which is a part of the IP header. This
    means we''ll have to change the unpack function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们对TTL感兴趣，这是IP头的一部分。这意味着我们将不得不更改解包函数：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s check the output of `sniffer_ttl.py`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查`sniffer_ttl.py`的输出：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `TTL` value is `128`. So how does it work? It's very simple; we have unpacked
    the value in the format 8sB3s4s4s, and our TTL field comes at the ninth byte.
    After 8s means, after the eighth byte, we get the TTL field in the form of B.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTL`值为`128`。那它是如何工作的呢？非常简单；我们以8sB3s4s4s的格式解包了值，我们的TTL字段出现在第九个字节。8s之后意味着在第八个字节之后，我们以B的形式得到TTL字段。'
- en: Learning about packet crafting
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解数据包构造
- en: This is a technique by which a hacker or pentester can create customized packets.
    By using a customized packet, a hacker can perform many tasks, such as probing
    firewall rule sets, port scans, and the behavior of the operating system. Lots
    of tools are available for packet crafting, such as Hping and Colasoft packet
    builder. Packet crafting is a skill. You can perform it with no tools, as you
    have Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是黑客或渗透测试人员可以创建定制数据包的技术。通过使用定制数据包，黑客可以执行许多任务，如探测防火墙规则集、端口扫描和操作系统的行为。有许多工具可用于数据包构造，如Hping和Colasoft数据包生成器。数据包构造是一种技能。您可以在没有工具的情况下执行它，因为您有Python。
- en: 'First, we create Ethernet packets and then send them to the victim. Let''s
    take a look at the entire code of `eth.py` and then understand it line by line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建以太网数据包，然后将它们发送给受害者。让我们看看`eth.py`的整个代码，然后逐行理解它：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You've already seen `s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))` in
    the packet sniffer. Now, decide on the network interface. We choose the eth0 interface
    to send the packet. The `s.bind(("eth0",socket.htons(0x0800)))` statement binds
    the eth0 interface with the protocol value. The next two lines define the source
    and destination MAC addresses. The `code ='x08x00'` statement shows the protocol
    of interest. This is the code of the IP protocol. The `eth = des+sor+code` statement
    is used to assemble the packet. The next line, `s.send(eth)`, sends the packet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在数据包嗅探器中看到了`s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))`。现在，决定网络接口。我们选择eth0接口发送数据包。`s.bind(("eth0",socket.htons(0x0800)))`语句将eth0接口与协议值绑定。接下来的两行定义了源MAC地址和目的MAC地址。`code
    ='x08x00'`语句显示了感兴趣的协议。这是IP协议的代码。`eth = des+sor+code`语句用于组装数据包。下一行`s.send(eth)`发送数据包。
- en: Introducing ARP spoofing and implementing it using Python
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ARP欺骗并使用Python实现
- en: '**ARP** (**Address Resolution Protocol**) is used to convert the IP address
    to its corresponding Ethernet (MAC) address. When a packet comes to the network
    layer (OSI), it has an IP address and a data-link layer packet that needs the
    MAC address of the destination device. In this case, the sender uses the ARP.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARP**（**地址解析协议**）用于将IP地址转换为其对应的以太网（MAC）地址。当数据包到达网络层（OSI）时，它具有目的设备的IP地址和数据链路层数据包，需要目的设备的MAC地址。在这种情况下，发送方使用ARP。'
- en: 'The term **address resolution** refers to the process of finding the MAC address
    of a computer in a network. The following are the two types of ARP messages that
    might be sent by the ARP:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**地址解析**指的是在网络中查找计算机的MAC地址的过程。以下是ARP可能发送的两种类型的ARP消息：
- en: The ARP request
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP请求
- en: The ARP reply
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP回复
- en: The ARP request
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP请求
- en: A host machine might want to send a message to another machine in the same subnet.
    The host machine only knows the IP address, while the MAC address is required
    to send the message at the data-link layer. In this situation, the host machine
    broadcasts the ARP request. All machines in the subnet receive the message. The
    Ethernet-protocol type of the value is `0x806`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主机可能想要向同一子网中的另一台机器发送消息。主机只知道IP地址，而在数据链路层发送消息需要MAC地址。在这种情况下，主机广播ARP请求。子网中的所有机器都会收到消息。值的以太网协议类型是`0x806`。
- en: The ARP reply
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP回复
- en: The intended user responds with their MAC address. This reply is unicast and
    is known as the ARP reply.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的用户将以他们的MAC地址做出回应。这个回复是单播的，称为ARP回复。
- en: The ARP cache
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP缓存
- en: 'To reduce the number of address resolution requests, a client normally caches
    the resolved addresses for a short period of time. The ARP cache is a finite size.
    When any device wants to send data to another target device in a subnet, it must
    first determine the MAC address of that target even though the sender knows the
    receiver''s IP address. These IP to MAC address mappings are derived from an ARP
    cache maintained on each device. An unused entry is deleted, which frees some
    space in the cache. Use the `arp –a` command to see the ARP cache, as shown in
    the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少地址解析请求的数量，客户端通常会缓存解析的地址一段时间。ARP缓存是有限大小的。当任何设备想要向子网中的另一个目标设备发送数据时，它必须首先确定该目标的MAC地址，即使发送方知道接收方的IP地址。这些IP到MAC地址映射来自每个设备上维护的ARP缓存。未使用的条目将被删除，这样可以释放缓存中的一些空间。使用`arp
    -a`命令查看ARP缓存，如下屏幕截图所示：
- en: '![](img/79a028ae-7eff-40e2-a4e1-9323e982c44b.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/79a028ae-7eff-40e2-a4e1-9323e982c44b.png)
- en: The ARP cache
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ARP缓存
- en: ARP spoofing, also known as ARP cache poisoning, is a type of attack where the
    MAC address of the victim machine, in the ARP cache of the gateway, along with
    the MAC address of the gateway, in the ARP cache of the victim machine, is changed
    by the attacker. This technique is used to attack the local area networks. The
    attacker can sniff the data frame over the LAN. In ARP spoofing, the attacker
    sends a fake reply to the gateway as well as to the victim. The aim is to associate
    the attacker's MAC address with the IP address of another host (such as the default
    gateway). ARP spoofing is used for active sniffing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ARP欺骗，也称为ARP缓存中毒，是一种攻击类型，攻击者通过改变受害者机器的MAC地址，在网关的ARP缓存中，以及改变网关的MAC地址，在受害者机器的ARP缓存中。这种技术用于攻击局域网。攻击者可以在局域网上嗅探数据帧。在ARP欺骗中，攻击者向网关和受害者发送虚假回复。目的是将攻击者的MAC地址与另一个主机的IP地址（如默认网关）关联起来。ARP欺骗用于主动嗅探。
- en: Now, we are going to use an example to demonstrate ARP spoofing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个示例来演示ARP欺骗。
- en: 'The IP address and MAC address of all the machines in the network are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中所有机器的IP地址和MAC地址如下：
- en: '| **Machine''s name** | **IP address** | **MAC address** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **机器名称** | **IP地址** | **MAC地址** |'
- en: '| Windows XP (victim) | `192.168.0.11` | `00:0C:29:2E:84:7A` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Windows XP（受害者）| `192.168.0.11` | `00:0C:29:2E:84:7A` |'
- en: '| Linux (attacker) | `192.168.0.10` | `00:0C:29:4F:8E:35` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Linux（攻击者）| `192.168.0.10` | `00:0C:29:4F:8E:35` |'
- en: '| Windows 7 (gateway) | `192.168.0.1` | `00:50:56:C0:00:08` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Windows 7（网关）| `192.168.0.1` | `00:50:56:C0:00:08` |'
- en: 'Let''s take a look at the ARP protocol header, as shown in the following diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的图中显示的ARP协议头部：
- en: '![](img/3021d565-f923-4660-880d-3016357b854d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3021d565-f923-4660-880d-3016357b854d.png)
- en: The ARP header
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ARP头部
- en: 'Let''s go through the code to implement ARP spoofing and discuss it line by
    line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码来实现ARP欺骗并讨论它：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the packet-crafting section explained previously, you created the Ethernet
    frame. In this code, we have used three MAC addresses, which are also shown in
    the preceding table. Here, we used `code ='x08x06'`, which is the code of the
    ARP protocol. The two Ethernet packets crafted are `eth1` and `eth2`. The next
    line, `htype = 'x00x01'`, denotes the Ethernet. Everything is in order as shown
    in the ARP header, `protype = 'x08x00'`, which indicates the protocol type; `hsize
    = 'x06'` shows the hardware address size; `psize = 'x04'` gives the IP address
    length; and `opcode = 'x00x02'` shows it is a reply packet. The `gate_ip = '192.168.0.1'`
    and `victim_ip = '192.168.0.11'` statements are the IP addresses of the gateway
    and victim, respectively. The `socket.inet_aton ( gate_ip )` method converts the
    IP address to a hexadecimal format. In the end, we assemble the entire code according
    to the ARP header. The `s.send()` method also puts the packets on the cable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的数据包制作部分，您创建了以太网帧。在这段代码中，我们使用了三个MAC地址，这些地址也显示在前面的表中。在这里，我们使用了`code ='x08x06'`，这是ARP协议的代码。制作的两个以太网数据包是`eth1`和`eth2`。下一行，`htype
    ='x00x01'`，表示以太网。一切都按照ARP头部中显示的顺序进行，`protype ='x08x00'`表示协议类型；`hsize ='x06'`显示硬件地址大小；`psize
    ='x04'`给出IP地址长度；`opcode ='x00x02'`显示这是一个回复数据包。`gate_ip ='192.168.0.1'`和`victim_ip
    ='192.168.0.11'`语句分别是网关和受害者的IP地址。`socket.inet_aton（gate_ip）`方法将IP地址转换为十六进制格式。最后，我们根据ARP头部组装整个代码。`s.send()`方法也将数据包放在了电缆上。
- en: Now, it's time to see the output. Run the `arpsp.py` file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看输出了。运行`arpsp.py`文件。
- en: 'Let''s check the victim''s ARP cache:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下受害者的ARP缓存：
- en: '![](img/c97cc4e2-236b-4234-8e37-6c55fef80370.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c97cc4e2-236b-4234-8e37-6c55fef80370.png)
- en: The ARP cache of the victim
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者的ARP缓存
- en: The preceding screenshot shows the ARP cache before and after the ARP spoofing
    attack. It is clear from the screenshot that the MAC address of the gateway's
    IP has been changed. Our code is working fine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了ARP欺骗攻击之前和之后的ARP缓存。从屏幕截图中可以清楚地看出网关IP的MAC地址已经改变。我们的代码运行正常。
- en: 'Let''s check the gateway''s ARP cache:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下网关的ARP缓存：
- en: '![](img/a3f826fc-2fee-43ee-8667-548dd7de270e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/a3f826fc-2fee-43ee-8667-548dd7de270e.png)
- en: The gateway's ARP cache
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网关的ARP缓存
- en: The preceding screenshot shows that our code has run successfully. The victim
    and the attacker's IPs have the same MAC address. Now, all the packets intended
    for the gateway will go through the attacker's system, and the attacker can effectively
    read the packets that travel back and forth between the gateway and the victim's
    computer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示我们的代码已经成功运行。受害者和攻击者的IP具有相同的MAC地址。现在，所有发送到网关的数据包都将通过攻击者的系统，并且攻击者可以有效地读取网关和受害者计算机之间来回传输的数据包。
- en: In pentesting, you have to attack (ARP spoofing) the gateway to investigate
    whether it is vulnerable to ARP spoofing or not.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，你必须攻击（ARP欺骗）网关，以调查它是否容易受到ARP欺骗的影响。
- en: Testing the security system using custom packet crafting
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义数据包构造测试安全系统
- en: In this section, we will see some special types of scans. In [chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml), *Scanning
    Pentesting*, you saw the port scanner, which works based on the TCP connect scan.
    A three-way handshake is the underlying concept of the TCP connect scan.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些特殊类型的扫描。在[第2章](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml)中，*扫描渗透*，你看到了基于TCP连接扫描的端口扫描器。三次握手是TCP连接扫描的基本概念。
- en: A half-open scan
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半开放扫描
- en: The half-open scan or stealth scan, as the name suggests, is a special type
    of scanning. Stealth-scanning techniques are used to bypass firewall rules and
    avoid being detected by logging systems. However, it is a special type of scan
    that is done by using packet crafting, which was explained earlier in the chapter.
    If you want to make an IP or TCP packet, then you have to mention each section.
    I know this is very painful and you will be thinking about *Hping*. However, Python's
    library will make it simple.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 半开放扫描或隐形扫描，顾名思义，是一种特殊类型的扫描。隐形扫描技术用于绕过防火墙规则，并避免被日志系统检测到。然而，这是一种特殊类型的扫描，通过数据包构造来实现，这在本章前面已经解释过。如果你想制作IP或TCP数据包，那么你必须提到每个部分。我知道这很痛苦，你可能会想到*Hping*。然而，Python的库会让它变得简单。
- en: Now, let's take a look at using scapy. Scapy is a third-party library that allows
    you to make custom-made packets. We will write a simple and short code so that
    you can understand scapy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何使用scapy。Scapy是一个第三方库，允许你制作定制的数据包。我们将编写一个简单而简短的代码，以便你能够理解scapy。
- en: 'Before writing the code, let''s understand the concept of the half-open scan.
    The following steps define the stealth scan:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，让我们了解一下半开放扫描的概念。以下步骤定义了隐形扫描：
- en: The client sends a SYN packet to the server on the intended port
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向目标端口发送一个SYN数据包
- en: If the port is open, then the server responds with the `SYN`/`ACK` packet
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果端口是打开的，服务器会用`SYN`/`ACK`数据包进行响应
- en: If the server responds with an `RST` packet, it means the port is closed
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器用`RST`数据包进行响应，这意味着端口是关闭的
- en: The client sends the `RST` to close the initiation
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送`RST`来关闭初始化
- en: 'Now, let''s go through the code, which will also be explained, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下代码，接下来也会进行解释：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line imports all the modules of scapy. The next line, `ip1 = IP(src="img/192.168.0.10",
    dst ="192.168.0.3" )`, defines the IP packet. The name of the IP packet is `ip1`,
    which contains the source and destination address. The `tcp1 = TCP(sport =1024,
    dport=80, flags="S", seq=12345)` statement defines a `TCP` packet named `tcp1`,
    and this packet contains the source port and destination port. We are interested
    in port `80` as we have defined the previous steps of the stealth scan. For the
    first step, the client sends a `SYN` packet to the server. In our `tcp1` packet,
    the `SYN` flag has been set as shown in the packet, and seq is given randomly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了scapy的所有模块。下一行，`ip1 = IP(src="img/192.168.0.10", dst ="192.168.0.3" )`，定义了IP数据包。IP数据包的名称是`ip1`，其中包含了源地址和目的地址。`tcp1
    = TCP(sport =1024, dport=80, flags="S", seq=12345)`语句定义了名为`tcp1`的`TCP`数据包，该数据包包含了源端口和目的端口。我们对端口`80`感兴趣，因为我们已经定义了隐形扫描的前几步。在第一步中，客户端向服务器发送一个`SYN`数据包。在我们的`tcp1`数据包中，`SYN`标志已经设置如数据包所示，并且seq是随机给定的。
- en: The next line, `packet= ip1/tcp1`, arranges the IP first and then the `TCP`.
    The `p =sr1(packet, inter=1)` statement receives the packet. The `sr1()` function
    uses the sent and received packets but it only receives one answered packet, `inter=
    1`, which indicates an interval of one second because we want a gap of one second
    to be present between two packets. The next line, `p.show()`, gives the hierarchical
    view of the received packet. The `rs1 = TCP(sport =1024, dport=80, flags="R",
    seq=12347)` statement will send the packet with the `RST` flag set. The lines
    following this line are easy to understand. Here, `p1.show` is not needed because
    we are not accepting any responses from the server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，`packet= ip1/tcp1`，首先安排IP，然后是`TCP`。`p =sr1(packet, inter=1)`语句接收数据包。`sr1()`函数使用发送和接收的数据包，但它只接收一个应答数据包，`inter=
    1`，这表示一个间隔为一秒，因为我们希望两个数据包之间有一秒的间隔。下一行，`p.show()`，给出了接收数据包的分层视图。`rs1 = TCP(sport
    =1024, dport=80, flags="R", seq=12347)`语句将发送带有`RST`标志的数据包。接下来的几行很容易理解。在这里，不需要`p1.show`，因为我们不接受服务器的任何响应。
- en: 'The output is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So we have received our answered packet. The source and destination seem fine.
    Take a look at the `TCP` field and note the flag''s value. We have SA, which denotes
    the `SYN` and `ACK` flag. As we discussed earlier, if the server responds with
    a `SYN` and `ACK` flag, it means that the port is open. *Wireshark* also captures
    the response, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们收到了我们的应答数据包。源和目的地看起来都很好。看一下`TCP`字段，注意标志的值。我们有SA，表示`SYN`和`ACK`标志。正如我们之前讨论的，如果服务器响应带有`SYN`和`ACK`标志，这意味着端口是打开的。*Wireshark*也捕获了响应，如下面的屏幕截图所示：
- en: '![](img/e98f4962-63b4-4a9f-8079-19212937f167.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e98f4962-63b4-4a9f-8079-19212937f167.png)'
- en: The Wireshark output
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark输出
- en: 'Now, let''s do it again but, this time, the destination will be different.
    From the output, you will know what the destination address was:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再做一次，但是这次目的地将不同。从输出中，你将知道目的地地址是什么：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, it returns the `RA` flag, which means `RST` and `ACK`. This means
    that the port is closed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，它返回了`RA`标志，意味着`RST`和`ACK`。这意味着端口是关闭的。
- en: The FIN scan
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIN扫描
- en: Sometimes firewalls and **Intrusion Detection Systems** (**IDS**) are configured
    to detect `SYN` scans. In a FIN scan attack, a `TCP` packet is sent to the remote
    host with only the FIN flag set. If no response comes from the host, it means
    that the port is open. If a response is received, it contains the `RST`/`ACK`
    flag, which means that the port is closed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时防火墙和**入侵检测系统**（**IDS**）被配置为检测`SYN`扫描。在FIN扫描攻击中，向远程主机发送一个只有FIN标志的`TCP`数据包。如果主机没有响应，这意味着端口是开放的。如果收到响应，其中包含`RST`/`ACK`标志，这意味着端口是关闭的。
- en: 'The following is the code for the FIN scan:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是FIN扫描的代码：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The packet is the same as the previous one, with only the FIN flag set. Now,
    check the response from different machines:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包与之前的相同，只有FIN标志设置。现在，检查来自不同机器的响应：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The incoming packet contains the `RST`/`ACK` flag, which means that the port
    is closed. Now, we will change the destination to `192.168.0.3` and check the
    response:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的数据包包含`RST`/`ACK`标志，这意味着端口是关闭的。现在，我们将目的地更改为`192.168.0.3`并检查响应：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: No response was received from the destination, which means that the port is
    open.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从目的地没有收到响应，这意味着端口是开放的。
- en: ACK flag scanning
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACK标志扫描
- en: The `ACK` scanning method is used to determine whether the host is protected
    by some kind of filtering system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACK`扫描方法用于确定主机是否受到某种过滤系统的保护。'
- en: In this scanning method, the attacker sends an `ACK` probe packet with a random
    sequence number where no response means that the port is filtered (a stateful
    inspection firewall is present in this case); if an RST response comes back, this
    means the port is closed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种扫描方法中，攻击者发送带有随机序列号的`ACK`探测数据包，没有响应意味着端口被过滤（在这种情况下存在有状态检查防火墙）；如果收到RST响应，这意味着端口是关闭的。
- en: 'Now, let''s go through this code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们浏览一下这段代码：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the flag has been set to `ACK`, and the destination port
    is `137`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，标志已设置为`ACK`，目的地端口为`137`。
- en: 'Now, check the output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查输出：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The packet has been sent but no response was received. You do not need to worry
    as we have our Python sniffer to detect the response. So run the sniffer, there
    is no need to run it in promiscuous mode, and send the `ACK` packet again:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包已发送，但没有收到响应。您不需要担心，因为我们有我们的Python嗅探器来检测响应。因此运行嗅探器，无需以混杂模式运行它，并重新发送`ACK`数据包：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The return packet shows `Flag 04`, which means `RST`. It means that the port
    is not filtered.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据包显示`Flag 04`，意味着`RST`。这意味着端口没有被过滤。
- en: 'Let''s set up a firewall and check the response of the `ACK` packet again.
    Now that the firewall is set, let''s send the packet again. The output will be
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置防火墙，再次检查`ACK`数据包的响应。现在防火墙已设置好，让我们再次发送数据包。输出将如下所示：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output of the sniffer shows nothing, which means that the firewall is present.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 嗅探器的输出显示没有任何内容，这意味着防火墙存在。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the beginning of this chapter, we learned about the concept of a sniffer,
    and the use of a sniffer over the network, which at times might reveal big secrets,
    such as passwords and chats. In today's world, switches are mostly used, so you
    should know how to perform active sniffing. We also learned how to make up a layer-4
    sniffer. Then we learned how to perform ARP spoofing. You should test the network
    by ARP spoofing and write your findings in the report. Then, we looked at the
    topic of testing the network by using custom packets. The network disassociation
    attack is similar to the ARP cache poisoning attack, which was also explained.
    Half-open, FIN scan, and `ACK` flag scans are special types of scanning that we
    touched upon too. Lastly, ping of death, which is related to the DDOS attack,
    was explained.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们学习了嗅探器的概念，以及在网络上使用嗅探器，有时可能会揭示密码和聊天等重要信息。在今天的世界中，大多数情况下使用交换机，因此您应该知道如何执行主动嗅探。我们还学习了如何制作一个第4层嗅探器。然后我们学习了如何执行ARP欺骗。您应该通过ARP欺骗测试网络，并将您的发现写入报告。然后，我们研究了使用自定义数据包测试网络的主题。网络脱离攻击类似于ARP缓存中毒攻击，这也有所解释。半开放、FIN扫描和`ACK`标志扫描是我们也涉及到的特殊类型的扫描。最后，解释了与DDOS攻击相关的死亡之针。
- en: In [Chapter 4](ffe663be-bc5c-4b4a-a11d-ed029eadd7f4.xhtml), *Network Attacks
    and Prevention*, we will learn the network attacks and prevention of network attacks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ffe663be-bc5c-4b4a-a11d-ed029eadd7f4.xhtml)中，*网络攻击和防范*，我们将学习网络攻击和防范网络攻击。
