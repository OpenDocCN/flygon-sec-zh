["```py\n      import socket\n      import struct\n      import binascii\n      import Queue\n      import threading\n      import sys\n```", "```py\n      mysocket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, \n      socket.ntohs(0x0806))\n      mysocket_s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, \n      socket.ntohs(0x0806))\n      mysocket_s.bind(('eth0',socket.htons(0x0806)))\n\n      Q = Queue.Queue()\n```", "```py\n      def arp_receiver():\n        while True:\n          pkt = mysocket.recvfrom(1024)\n          ethhead = pkt[0][0:14]\n          eth = struct.unpack(\"!6s6s2s\",ethhead)\n          binascii.hexlify(eth[2])\n          arp_h = pkt[0][14:42]\n          arp_l = struct.unpack(\"!2s2sss2s6s4s6s4s\",arp_h)\n          if arp_l[4] == '\\x00\\x01':\n            Q.put([eth,arp_l])\n```", "```py\n         def arp_sender():\n            while True:\n             main_list = Q.get()\n             eth_header = main_list[0]\n             arp_packet = main_list[1]\n             mac_sender = sys.argv[1].decode('hex')\n             eth1 = eth_header[1]+mac_sender+eth_header[-1]\n             arp1 = \"\".join(arp_packet[0:4])\n             arp1 = arp1+'\\x00\\x02'+mac_sender+   \n             arp_packet[-1]+arp_packet[5]+arp_packet[6]\n             target_packet = eth1+arp1\n             mysocket_s.send(target_packet)\n```", "```py\n      r = threading.Thread(target=arp_receiver)\n      s = threading.Thread(target=arp_sender)\n      r.start()\n      s.start()\n```", "```py\niptables -A OUTPUT -o eth0 -j DROP\n```", "```py\npython arp_reply.py <mac of machine>\n```", "```py\npython arp_reply.py 000c29436fc7\n```", "```py\n      import socket\n      import struct\n      import binascii\n      import ping\n      import Queue\n      import threading\n      import sys\n      import random\n      import my_logger\n```", "```py\n      Q = Queue.Queue()\n      IP_address = 0\n      my_socket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, \n      socket.ntohs(0x0800))\n      my_socket_s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, \n      socket.ntohs(0x0800))\n      my_socket_s.bind(('eth0',socket.htons(0x0800)))\n```", "```py\n      def calculate_checksum(source_string):\n        countTo = (int(len(source_string) / 2)) * 2\n        sum = 0\n        count = 0\n        # Handle bytes in pairs (decoding as short ints)\n        loByte = 0\n        hiByte = 0\n        while count < countTo:\n          if (sys.byteorder == \"little\"):\n            loByte = source_string[count]\n            hiByte = source_string[count + 1]\n          else:\n            loByte = source_string[count + 1]\n            hiByte = source_string[count]\n          sum = sum + (ord(hiByte) * 256 + ord(loByte))\n          count += 2\n\n        # Handle last byte if applicable (odd-number of bytes)\n        # Endianness should be irrelevant in this case\n        if countTo < len(source_string): # Check for odd length\n          loByte = source_string[len(source_string) - 1]\n          sum += ord(loByte)\n\n        sum &= 0xffffffff # Truncate sum to 32 bits (a variance from \n        ping.c, which # uses signed ints, but overflow is unlikely in \n        ping)\n   sum = (sum >> 16) + (sum & 0xffff) # Add high 16 bits to low 16 bits\n   sum += (sum >> 16) # Add carry from above (if any)\n   answer = ~sum & 0xffff # Invert and truncate to 16 bits\n   answer = socket.htons(answer)\n\n   return answer\n```", "```py\n      def ip_checksum(ip_header, size):\n        cksum = 0\n        pointer = 0\n        while size > 1:\n          cksum += int((ip_header[pointer] + ip_header[pointer+1]),16)\n          size -= 2\n          pointer += 2\n        if size: #This accounts for a situation where the header is odd\n          cksum += ip_header[pointer]\n\n        cksum = (cksum >> 16) + (cksum & 0xffff)\n        cksum += (cksum >>16)\n\n        check_sum1= (~cksum) & 0xFFFF\n        check_sum1 = \"%x\" % (check_sum1,)\n        return check_sum1\n```", "```py\n      def ipv4_creator(ipv4_header):\n        try:\n          global IP_address\n          field1,ip_id,field2,ttl,protocol,checksum,ip1,ip2\n          =struct.unpack(\"!4s2s2sss2s4s4s\", ipv4_header)\n          num = str(random.randint(1000,9999))\n          ip_id = num.decode('hex')\n          checksum = '\\x00\\x00'\n          ipv4_new_header =   \n          field1+ip_id+field2+'40'.decode('hex')+protocol+ip2+ip1\n          raw_tuple =   \n          struct.unpack(\"!ssssssssssssssssss\",ipv4_new_header) \n          # for checksum\n          header_list= [each.encode('hex') for each in raw_tuple]\n          check_sum= str(ip_checksum(header_list, len(header_list)))\n          ipv4_new_header =   \n          field1+ip_id+field2+'40'.decode('hex')+protocol\n          +check_sum.decode('hex')+ip2+ip1\n          if IP_address != ip1:\n          my_logger.logger.info(socket.inet_ntoa(ip1))\n\n          IP_address = ip1\n          return ipv4_new_header\n        except Exception as e :\n          my_logger.logger.error(e)\n```", "```py\n      def icmp_creator(icmp_header,icmp_data):\n      try:\n       dest_addr=\"\"\n       ICMP_REPLY = 0\n       seq_number = 0\n       identifier =0\n       header_size = 8\n       packet_size = 64\n       type1, code, checksum, packet_id, seq_number =  \n       struct.unpack(\"!BBHHH\", icmp_header)\n       cal_checksum = 0\n       header = struct.pack(\"!BBHHH\", ICMP_REPLY, 0, cal_checksum, \n       packet_id ,seq_number )\n       cal_checksum = calculate_checksum(header +icmp_data)\n       header = struct.pack(\"!BBHHH\", ICMP_REPLY, 0, cal_checksum, \n       packet_id, seq_number )\n       packet = header + icmp_data\n       return packet\n        except Exception as e :\n          my_logger.logger.error(e)\n```", "```py\n      def ethernet_creator(eth_header):\n        eth1,eth2,field1 = struct.unpack(\"!6s6s2s\",eth_header)\n        eth_header = eth2+eth1+field1\n        return eth_header\n```", "```py\n      def receiver_icmp():\n        while True:\n          try:\n            received_packet, addr = my_socket.recvfrom(1024)\n            protocol_type = received_packet[23] \n            icmp_type = received_packet[34]\n            protocol_type=struct.unpack(\"!B\",protocol_type)[0]\n            icmp_type = struct.unpack(\"!B\",icmp_type)[0]\n            if protocol_type==1 and icmp_type==8:\n              eth_header = received_packet[0:14]\n              ipv4_header = received_packet[14:34]\n              icmpHeader = received_packet[34:42]\n              icmp_data = received_packet[42:]\n        data_tuple1 = (eth_header, ipv4_header, icmpHeader,icmp_data)\n        Q.put(data_tuple1)\n             except Exception as e :\n               my_logger.logger.error(e)\n\n```", "```py\n      def sender_icmp():\n        while True:\n          try:\n            data_tuple1 = Q.get()\n            icmp_packet = icmp_creator(data_tuple1[2],data_tuple1[3])\n            ipv4_packet = ipv4_creator(data_tuple1[1])\n            eth_packet = ethernet_creator(data_tuple1[0])\n            frame = eth_packet+ipv4_packet+icmp_packet\n            my_socket_s.send(frame)\n          except Exception as e :\n            my_logger.logger.error(e)\n```", "```py\n      r = threading.Thread(target=receiver_icmp)\n      s = threading.Thread(target=sender_icmp)\n      r.start()\n      s.start()\n```", "```py\n      import socket\n      import struct\n      import binascii\n      import Queue\n      from scapy.all import *\n      import threading\n```", "```py\n      my_socket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, 8)\n      Q = Queue.Queue()\n```", "```py\n      def receiver():\n        while True:\n        try:\n         pkt = my_socket.recvfrom(2048)\n         num=pkt[0][14].encode('hex')\n         ip_length = (int(num)%10)*4\n         ip_last_range = 14+ip_length\n         ipheader = pkt[0][14:ip_last_range]\n         ip_hdr = struct.unpack(\"!8sBB2s4s4s\",ipheader)\n         S_ip =socket.inet_ntoa(ip_hdr[4])\n         D_ip =socket.inet_ntoa(ip_hdr[5])\n         tcpheader = pkt[0][ip_last_range:ip_last_range+20]\n         tcp_hdr = struct.unpack(\"!HHL4sBB6s\",tcpheader)\n         S_port = tcp_hdr[0]\n         D_port = tcp_hdr[1]\n         SQN = tcp_hdr[2]\n         flags = tcp_hdr[5]\n            if (D_port==445 or D_port==135 or D_port==80):\n              tuple1 = (S_ip,D_ip,S_port,D_port,SQN,flags)\n              Q.put(tuple1)\n\n          except Exception as e:\n            print e\n```", "```py\n      def sender(): \n      while True:\n        d_ip,s_ip,d_port,s_port,SQN,flag = Q.get()\n\n        if (s_port==445 or s_port==135) and (flag==2):\n        SQN= SQN+1\n        print flag,\"*\"*100\n        packet  \n        =IP(dst=d_ip,src=s_ip)/TCP(dport=d_port,sport=s_port,\n        ack=SQN,flags=\"SA\",window=64240, \n            options=[('MSS',1460),(\"WScale\",3)])\n            #packet \n        =IP(dst=d_ip,src=s_ip)/TCP(dport=d_port,sport=s_port,\n        ack=SQN,flags=\"SA\")\n          else :\n            SQN= SQN+1\n            packet \n        =IP(dst=d_ip,src=s_ip)/TCP(dport=d_port,sport=s_port,\n        ack=SQN,seq=SQN,flags=\"RA\",window=0) \n          send(packet) \n```", "```py\n      r = threading.Thread(target=receiver)\n      r.start()\n\n      for each in xrange(3):\n        s = threading.Thread(target=sender)\n        s.start()\n```", "```py\n   from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\n   import logger1\n```", "```py\n      class fakewebserver(BaseHTTPRequestHandler):\n\n      def send_response(self, code, message=None): #overriding\n\n        self.log_request(code)\n        if message is None:\n            if code in self.responses:\n                message = self.responses[code][0]\n            else:\n                message = ''\n        if self.request_version != 'HTTP/0.9':\n            self.wfile.write(\"%s %d %s\\r\\n\" %\n                             (self.protocol_version, code, message))\n\n        self.send_header('Server', \"mohit raj\")\n        self.send_header('Tip',\"Stay away\")\n        self.send_header('Date', self.date_time_string())\n        str1 = self.client_address[0]+\" -- \n        \"+self.log_date_time_string()\n        logger1.logger.info(str1)\n```", "```py\n    def _set_headers(self):\n        self.send_response(200)\n        self.end_headers()\n```", "```py\n    def do_GET(self):\n        self._set_headers()\n        self.wfile.write(\"<html><body><h1>hi!</h1></body></html>\")\n```", "```py\n    def do_HEAD(self):\n        self._set_headers()\n```", "```py\n    def do_POST(self):\n        self._set_headers()\n        self.wfile.write(\"<html><body><h1>POST!</h1></body></html>\")\n```", "```py\n      def start(port=80):\n          server_address = ('', port)\n          httpd = HTTPServer(server_address, fakewebserver)\n          print 'Starting Server...'\n          httpd.serve_forever()\n```", "```py\nimport logging\nlogger = logging.getLogger(\"honeypot\")\nlogger.setLevel(logging.INFO)\nfh = logging.FileHandler(\"live1.log\")\nformatter = logging.Formatter('%(levelname)s - %(message)s')\nfh.setFormatter(formatter)\nlogger.addHandler(fh)\n```"]