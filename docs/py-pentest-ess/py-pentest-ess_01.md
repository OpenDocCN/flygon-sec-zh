# Python 与渗透测试和网络

渗透测试员和黑客是类似的术语。不同之处在于渗透测试员为组织工作以防止黑客攻击，而黑客则出于名誉、出售漏洞以获取金钱，或者利用个人仇恨的目的进行攻击。

许多训练有素的黑客通过侵入系统然后通知受害者他们的安全漏洞，从而在信息安全领域找到了工作。

当黑客为组织或公司保护其系统时，他被称为渗透测试员。渗透测试员在获得客户的合法批准后，对网络进行黑客攻击，并提交他们的发现报告。要成为渗透测试的专家，一个人应该对技术的概念有深入的了解。在本章中，我们将涵盖以下主题：

+   渗透测试的范围

+   渗透测试的必要性

+   需要测试的组件

+   优秀渗透测试员的素质

+   渗透测试的方法

+   了解你需要的测试和工具

+   网络套接字

+   服务器套接字方法

+   客户端套接字方法

+   一般的套接字方法

+   套接字的实际例子

+   套接字异常

+   有用的套接字方法

# 介绍渗透测试的范围

简而言之，渗透测试用于测试公司的信息安全措施。信息安全措施包括公司的网络、数据库、网站、面向公众的服务器、安全策略以及客户指定的其他一切。在一天结束时，渗透测试员必须提交一份详细的报告，报告中包括公司基础设施的弱点、漏洞以及特定漏洞的风险水平，并在可能的情况下提供解决方案。

# 渗透测试的必要性

有几点描述了渗透测试的重要性：

+   渗透测试识别可能暴露组织机密性的威胁

+   专家级的渗透测试为组织提供了对组织安全的全面和详细的评估

+   渗透测试通过产生大量的流量来评估网络的效率，并审查防火墙、路由器和交换机等设备的安全性

+   更改或升级现有的软件、硬件或网络设计基础设施可能导致渗透测试发现的漏洞

+   在当今世界，潜在威胁显著增加；渗透测试是一种积极的行为，以最小化被利用的机会

+   渗透测试确保是否遵循适当的安全策略

考虑一个声誉良好的电子商务公司的例子，他们通过在线业务赚钱。黑客或一群黑客在公司的网站上发现了一个漏洞并进行了攻击。公司将不得不承受巨大的损失。

# 需要测试的组件

组织在进行渗透测试之前应进行风险评估操作；这将有助于识别主要威胁，如错误配置或漏洞：

+   路由器、交换机或网关

+   面向公众的系统；网站、DMZ、电子邮件服务器和远程系统

+   DNS、防火墙、代理服务器、FTP 和 Web 服务器

应对网络安全系统的所有硬件和软件组件进行测试。

# 优秀渗透测试员的素质

以下几点描述了一个优秀的渗透测试员的素质。他们应该：

+   选择一套平衡成本和效益的测试和工具

+   遵循适当的程序，进行适当的规划和文档记录

+   为每次渗透测试建立范围，如目标、限制和程序的合理性

+   准备好展示如何利用他们发现的漏洞

+   在最终报告中清楚地说明潜在风险和发现，并在可能的情况下提供减轻风险的方法

+   始终保持更新，因为技术在迅速发展

渗透测试员使用手动技术或相关工具测试网络。市面上有很多工具可用。其中一些是开源的，一些则非常昂贵。通过编程，程序员可以制作自己的工具。通过创建自己的工具，你可以澄清自己的概念，也可以进行更多的研究和开发。如果你对渗透测试感兴趣并想制作自己的工具，那么 Python 编程语言是最好的选择，因为 Python 中有大量免费的渗透测试包，除了编程的简易性。这种简易性，再加上第三方库如 scapy 和 mechanize，可以减少代码量。在 Python 中，要编写程序，你不需要像 Java 那样定义大的类。用 Python 编写代码比用 C 更高效，而且高级库几乎可以满足任何想象得到的任务。

如果你懂一些 Python 编程并对渗透测试感兴趣，这本书非常适合你。

# 定义渗透测试的范围

在我们开始渗透测试之前，应该定义渗透测试的范围。在定义范围时应考虑以下几点：

+   你应该通过与客户协商来制定项目的范围。例如，如果 Bob（客户）想要测试组织的整个网络基础设施，那么渗透测试员 Alice 将考虑这个网络来定义渗透测试的范围。Alice 将与 Bob 商议是否应该包括任何敏感或受限制的区域。

+   你应该考虑时间、人员和金钱。

+   你应该根据渗透测试员和客户签署的协议来界定测试边界。

+   业务实践的变化可能会影响范围。例如，子网的添加，新系统组件的安装，添加或修改 Web 服务器等，可能会改变渗透测试的范围。

渗透测试的范围分为两种测试类型：

+   **非破坏性测试**：这种测试仅限于发现和执行测试，没有潜在风险。它执行以下操作：

+   扫描和识别远程系统的潜在漏洞

+   调查和验证发现

+   将漏洞与适当的利用进行映射

+   以适当的注意力利用远程系统，以避免中断

+   提供概念的证明

+   不要尝试**拒绝服务**（**DoS**）攻击

+   **破坏性测试**：这种测试可能会产生风险。它执行以下操作：

+   尝试 DoS 攻击和缓冲区溢出攻击，这可能会导致系统崩溃

# 渗透测试的方法

有三种渗透测试的方法：

+   黑盒渗透测试遵循非确定性测试的方法：

+   你将只会得到一个公司名字

+   这就像是具有外部攻击者知识的黑客

+   你不需要对系统有任何先验知识

+   这需要时间

+   白盒渗透测试遵循确定性测试的方法：

+   你将获得需要测试的基础设施的完整知识

+   这就像是作为对公司基础设施有充分了解的恶意员工在工作

+   你将获得有关公司基础设施、网络类型、公司政策、行为准则、IP 地址和 IPS/IDS 防火墙的信息

+   灰盒渗透测试遵循黑盒和白盒测试的混合方法：

+   测试人员通常只能获得客户提供的目标网络/系统的有限信息，以降低成本并减少渗透测试人员的试错。

+   它在内部执行安全评估和测试

# 介绍 Python 脚本

在你开始阅读这本书之前，你应该了解 Python 编程的基础知识，比如基本语法、变量类型、数据类型元组、列表字典、函数、字符串和方法。在[python.org/downloads/](http://python.org/downloads/)上有两个版本，3.4 和 2.7.8。

在这本书中，所有的实验和演示都是在 Python 2.7.8 版本中完成的。如果你使用 Kali 或 BackTrack 等 Linux 操作系统，那就没有问题，因为许多程序，比如无线嗅探，在 Windows 平台上无法工作。Kali Linux 也使用 2.7 版本。如果你喜欢在 Red Hat 或 CentOS 上工作，那么这个版本适合你。

大多数黑客选择这个职业是因为他们不想做编程。他们想使用工具。然而，没有编程，黑客无法提高自己的技能。每一次，他们都不得不在互联网上搜索工具。相信我，看到它的简单性之后，你会喜欢这种语言的。

# 理解你需要的测试和工具

正如你所看到的，这本书分为九章。要进行扫描和嗅探渗透测试，你将需要一个连接设备的小型网络。如果你没有实验室，你可以在你的计算机上创建虚拟机。对于无线流量分析，你应该有一个无线网络。进行网络攻击，你将需要在 Linux 平台上运行的 Apache 服务器。最好使用 CentOS 或 Red Hat 版本 5 或 6 作为 Web 服务器，因为这包含了 Apache 和 PHP 的 RPM。对于 Python 脚本，我们将使用 Wireshark 工具，这是开源的，可以在 Windows 和 Linux 平台上运行。

# 学习使用 Python 的常见测试平台

现在你将进行一些渗透测试；我希望你对网络基础知识非常熟悉，比如 IP 地址、类别子网划分、无类别子网划分、端口的含义、网络地址和广播地址。渗透测试人员必须对网络基础知识以及至少一种操作系统有所了解；如果你打算使用 Linux，那么你走对了路。在这本书中，我们将在 Windows 和 Linux 上执行我们的程序。在这本书中，将使用 Windows、CentOS 和 Kali Linux。

黑客总是喜欢在 Linux 系统上工作。因为它是免费和开源的，Kali Linux 标志着 BackTrack 的重生，就像一个黑客工具的武库。Kali Linux NetHunter 是第一个为 Nexus 设备提供的开源 Android 渗透测试平台。然而，一些工具在 Linux 和 Windows 上都可以工作，但在 Windows 上，你必须安装这些工具。我希望你对 Linux 有所了解。现在，是时候在 Python 上进行网络工作了。

# 网络套接字

网络套接字地址包含 IP 地址和端口号。简单地说，套接字是与其他计算机通信的一种方式。通过套接字，一个进程可以通过网络与另一个进程通信。

为了创建一个套接字，使用套接字模块中可用的`socket.socket()`。套接字函数的一般语法如下：

```py
s = socket.socket (socket_family, socket_type, protocol=0)
```

以下是参数的描述：

```py
socket_family: socket.AF_INET, PF_PACKET
```

`AF_INET`是 IPv4 的地址族。`PF_PACKET`在设备驱动程序层操作。Linux 的 pcap 库使用`PF_PACKET`。你将在第三章中看到更多关于`PF_PACKET`的细节，*嗅探和渗透测试*。这些参数代表传输层的地址族和协议：

```py
Socket_type : socket.SOCK_DGRAM, socket.SOCK_RAW,socket.SOCK_STREAM
```

`socket.SOCK_DGRAM`参数表示 UDP 是不可靠和无连接的，`socket.SOCK_STREAM`表示 TCP 是可靠的和双向的，基于连接的服务。我们将在第三章中讨论`socket.SOCK_RAW`，*嗅探和渗透测试*：

```py
protocol
```

通常，我们会留下这个参数；如果未指定，它将为 0。我们将在第三章中看到这个参数的用法，*嗅探和渗透测试*。

# 服务器套接字方法

在客户端-服务器架构中，有一个提供服务的集中服务器，许多客户端从集中服务器请求和接收服务。以下是您需要了解的一些方法：

+   `socket.bind(address)`: 该方法用于将地址（IP 地址，端口号）连接到套接字。在连接到地址之前，套接字必须是打开的。

+   `socket.listen(q)`: 该方法启动 TCP 监听器。`q`参数定义了最大排队连接数。

+   `socket.accept()`: 使用此方法是为了接受来自客户端的连接。在使用此方法之前，必须使用`socket.bind(address)`和`socket.listen(q)`方法。`socket.accept()`方法返回两个值，`client_socket`和`address`，其中`client_socket`是一个新的套接字对象，用于在连接上发送和接收数据，`address`是客户端的地址。稍后将看到这个的例子。

# 客户端套接字方法

专门用于客户端的方法只有以下一个：

+   `socket.connect(address)`: 该方法将客户端连接到服务器。`address`参数是服务器的地址。

# 一般的套接字方法

一般的套接字方法如下：

+   `socket.recv(bufsize)`: 该方法从套接字接收 TCP 消息。`bufsize`参数定义了它可以一次接收的最大数据量。

+   `socket.recvfrom(bufsize)`: 该方法从套接字接收数据。该方法返回一对值，第一个值给出接收到的数据，第二个值给出发送数据的套接字的地址。

+   `socket.recv_into(buffer)`: 该方法接收小于或等于`buffer`的数据。`buffer`参数由`bytearray()`方法创建。稍后我们将在示例中讨论这一点。

+   `socket.recvfrom_into(buffer)`: 该方法从套接字获取数据并将其写入缓冲区。返回值是一对（nbytes，address），其中 nbytes 是接收到的字节数，address 是发送数据的套接字的地址。

在旧版本的 Python 中使用`socket.recvfrom_into(buffer)`方法时要小心。在该方法中发现了缓冲区溢出漏洞。该漏洞的名称是 CVE-2014-1912，其漏洞于 2014 年 2 月 27 日发布。在 Python 2.5 之前的 2.7.7，3.x 之前的 3.3.4 和 3.4.x 之前的 3.4rc1 中的`Modules/socketmodule.c`中的`socket.recvfrom_into`函数中存在缓冲区溢出，允许远程攻击者通过精心制作的字符串执行任意代码。

+   `socket.send(bytes)`: 该方法用于向套接字发送数据。在发送数据之前，请确保套接字已连接到远程机器。它返回发送的字节数。

+   `socket.sendto(data, address)`: 该方法用于向套接字发送数据。通常，我们在 UDP 中使用此方法。UDP 是一种无连接的协议；因此，套接字不应连接到远程机器，地址参数指定远程机器的地址。返回值告诉我们发送的字节数。

+   `socket.sendall(data)`: 正如其名称所示，该方法将所有数据发送到套接字。在发送数据之前，请确保套接字已连接到远程机器。此方法不断传输数据，直到出现错误。如果出现错误，将引发异常，并且`socket.close()`将关闭套接字。

现在，是实践的时候了；不再是平凡的理论。

# 继续实践

首先，我们将制作一个服务器端程序，为客户端提供连接并向客户端发送消息。运行`server1.py`：

```py
import socket
host = "192.168.0.1" #Server address
port = 12345  #Port of Server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host,port)) #bind server 
s.listen(2) 
conn, addr = s.accept()  
print addr, "Now Connected"
conn.send("Thank you for connecting")
conn.close()
```

前面的代码非常简单；这是服务器端的最小代码。

首先导入 socket 模块并定义主机和端口号，`192.168.0.1`是服务器的 IP 地址。`Socket.AF_INET`定义了 IPv4 协议的族。`Socket.SOCK_STREAM`定义了 TCP 连接。`s.bind((host,port))`语句只接受一个参数。它将套接字绑定到主机和端口号。`s.listen(2)`语句监听连接并等待客户端。`conn, addr = s.accept()`语句返回两个值：`conn`和`addr`。`conn`套接字是客户端套接字，正如我们之前讨论的那样。`conn.send()`函数将消息发送给客户端。最后，`conn.close()`关闭套接字。通过以下示例和截图，您将更好地理解`conn`。

这是`server1.py`程序的输出：

```py
  G:PythonNetworking>python server1.py
```

现在，服务器处于监听模式，并且正在等待客户端。

让我们看看客户端代码。运行`client1.py`：

```py
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "192.168.0.1"  # server address
port =12345  #server port 
s.connect((host,port)) 
print s.recv(1024)
s.send("Hello Server")
s.close()
```

在上面的代码中，有两个新方法，`s.connect((host,port))`，它将客户端连接到服务器，以及`s.recv(1024)`，它接收服务器发送的字符串。

`client.py`的输出和服务器的响应如下截图所示：

![](img/14f05721-e8ce-4b8f-bb26-5894fa0c874e.png)

上面输出的截图显示服务器接受了来自`192.168.0.11`的连接。不要被看到端口`1789`所困惑；这是客户端的随机端口。当服务器向客户端发送消息时，它使用前面提到的`conn`套接字，这个`conn`套接字包含客户端的 IP 地址和端口号。

以下图表显示了客户端如何接受来自服务器的连接。服务器处于监听模式，客户端连接到服务器。当再次运行服务器和客户端程序时，随机端口会发生变化。对于客户端，服务器端口**12345**是目标端口，对于服务器，客户端随机端口**1789**是目标端口：

![](img/fd35ccc8-43e5-4dd8-9331-43fd588bcc09.png)

TCP 通信

您可以使用`while`循环扩展服务器的功能，如下面的程序所示。运行`server2.py`程序：

```py
import socket 
host = "192.168.0.1"
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host,port))
s.listen(2)
while True:
  conn, addr = s.accept()
  print addr, "Now Connected"
  conn.send("Thank you for connecting")
  conn.close()
```

上面的代码与前一个代码相同，只是添加了无限的`while`循环。

运行`server2.py`程序，并从客户端运行`client1.py`。

`server2.py`的输出如下所示：

![](img/6b8299e5-1db4-489c-8c82-f858eb2cbc01.png)

一个服务器可以为多个客户端提供服务。`while`循环使服务器程序保持运行，并且不允许代码结束。您可以为`while`循环设置连接限制；例如，设置`while i>10`并且每次连接增加`i`。

在继续下一个例子之前，应该理解`bytearray`的概念。`bytearray`数组是一个可变的无符号整数序列，范围在 0 到 255 之间。您可以删除、插入或替换任意值或切片。可以通过调用内置的`bytearray`数组来创建`bytearray`数组的对象。

`bytearray`的一般语法如下：

```py
bytearray([source[, encoding[, errors]]])
```

让我们用一个例子来说明这一点：

```py
>>> m = bytearray("Mohit Mohit")
>>> m[1]
111
>>> m[0]
77
>>> m[:5]= "Hello"
>>> m
bytearray(b'Hello Mohit')
>>>
```

这是对`bytearray`的切片的一个例子。

现在，让我们看看`bytearray()`上的`split`操作：

```py
>>> m = bytearray("Hello Mohit")
>>> m
bytearray(b'Hello Mohit')
>>> m.split()
[bytearray(b'Hello'), bytearray(b'Mohit')]
```

以下是`bytearray()`上的`append`操作：

```py
>>> m.append(33)
>>> m
bytearray(b'Hello Mohit!')
>>> bytearray(b'Hello World!')
```

下一个例子是`s.recv_into(buff)`。在这个例子中，我们将使用`bytearray()`来创建一个缓冲区来存储数据。

首先运行服务器端代码。运行`server3.py`：

```py
import socket
host = "192.168.0.1"
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host, port))
s.listen(1)
conn, addr = s.accept()
print "connected by", addr
conn.send("Thanks")
conn.close()
```

上面的程序与前一个程序相同。在这个程序中，服务器发送`Thanks`；六个字符。

让我们运行客户端程序。运行`client3.py`：

```py
import socket
host = "192.168.0.1"
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))
buf = bytearray("-" * 30) # buffer created
print "Number of Bytes ",s.recv_into(buf) 
print buf
s.close
```

在上面的程序中，使用`bytearray()`创建了一个`buf`参数。`s.recv_into(buf)`语句给出了接收到的字节数。`buf`参数给出了接收到的字符串。

`client3.py`和`server3.py`的输出如下所示：

![](img/3632eaee-6f83-42d3-8263-8ba308f07af7.png)

我们的客户端程序成功接收了字符串`Thanks`的 6 个字节。到目前为止，您应该对`bytearray()`有所了解。我希望您会记得它。

这次，我将创建一个 UDP 套接字。

运行`udp1.py`，我们将逐行讨论代码：

```py
import socket
host = "192.168.0.1"
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((host,port))
data, addr = s.recvfrom(1024)
print "received from ",addr
print "obtained ", data
s.close()
```

`socket.SOCK_DGRAM`创建了一个 UDP 套接字，而`data, addr = s.recvfrom(1024)`返回了两个东西，第一个是数据，第二个是源地址。

现在，看看客户端的准备工作。运行`udp2.py`：

```py
import socket
host = "192.168.0.1"
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
print s.sendto("hello all",(host,port))
s.close()
```

在这里，我使用了 UDP 套接字和`s.sendto()`方法，如您在`socket.sendto()`的定义中所看到的。您将知道 UDP 是一种无连接协议，因此这里不需要建立连接。

以下截图显示了`udp1.py`（UDP 服务器）和`udp2.py`（UDP 客户端）的输出：

![](img/77906a5b-5ba5-43ef-ad49-5b516fde9a16.png)

服务器程序成功接收了数据。

假设服务器正在运行，并且没有客户端开始连接，并且服务器将一直在监听。因此，为了避免这种情况，使用`socket.settimeout(value)`。

通常，我们给一个整数值；如果我给`5`作为值，这意味着等待五秒钟。如果操作在五秒钟内没有完成，那么将引发超时异常。您也可以提供非负浮点值。

例如，让我们看看以下代码：

```py
import socket
host = "192.168.0.1"
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((host,port))
s.settimeout(5)
data, addr = s.recvfrom(1024)
print "recevied from ",addr
print "obtained ", data
s.close()
```

我添加了一行额外的代码，即`s.settimeout(5)`。程序等待五秒钟；只有在那之后才会给我们一个错误消息。运行`udptime1.py`。

输出如下截图所示：

![](img/ff7e8798-e580-437c-bdc4-e4666fb5b71a.png)

程序显示了一个错误；但是，如果它给出一个错误消息，那就不好看了。程序应该处理异常。

# 套接字异常

为了处理异常，我们将使用 try 和 except 块。以下示例将告诉您如何处理异常。运行`udptime2.py`：

```py
import socket
host = "192.168.0.1"
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
try:

  s.bind((host,port))
  s.settimeout(5)
  data, addr = s.recvfrom(1024)
  print "recevied from ",addr
  print "obtained ", data
  s.close()

except socket.timeout :
  print "Client not connected"
  s.close()
```

输出如下截图所示：

![](img/2ea24b23-fc29-47b0-b990-9c728967aec7.png)

在 try 块中，我放置了我的代码，从 except 块中，如果发生任何异常，将打印一个自定义消息。

Python 的套接字库定义了不同类型的异常，用于不同的错误。这些异常在这里描述：

+   `exception socket.herror`：此块捕获与地址相关的错误。

+   `exception socket.timeout`：此块捕获套接字启用`settimeout()`的超时发生时的异常。在前面的例子中，您可以看到我们使用了`socket.timeout`。

+   `exception socket.gaierror`：此块捕获由`getaddrinfo()`和`getnameinfo()`引发的任何异常。

+   `exception socket.error`：此块捕获任何与套接字相关的错误。如果您对任何异常不确定，可以使用此功能。换句话说，您可以说它是一个通用块，可以捕获任何类型的异常。

下载示例代码

您可以从[`www.packtpub.com`](http://www.packtpub.com)的帐户中下载示例代码文件，以获取您购买的所有 Packt Publishing 图书。如果您在其他地方购买了本书，可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。

# 有用的套接字方法

到目前为止，您已经了解了套接字和客户端-服务器架构。在这个级别上，您可以制作一个小型的网络程序。但是，本书的目的是测试网络并收集信息。Python 提供了非常美丽和有用的方法来收集信息。首先，导入套接字，然后使用这些方法：

+   `socket.gethostbyname(hostname)`：此方法将主机名转换为 IPv4 地址格式。IPv4 地址以字符串形式返回。这是一个例子：

```py
 >>> import socket>>>   
       socket.gethostbyname('thapar.edu')'220.227.15.55'>>>>>>   
       socket.gethostbyname('google.com')'173.194.126.64'>>>
```

我知道您正在考虑`nslookup`命令。稍后，您将看到更多的魔法。

+   `socket.gethostbyname_ex(name)`：此方法将主机名转换为 IPv4 地址模式。然而，与前一种方法相比的优势在于它给出了域名的所有 IP 地址。它返回一个元组（主机名，规范名称和 IP_addrlist），其中主机名由我们给出，规范名称是服务器的规范主机名（可能为空）的列表，IP_addrlist 是同一主机名的所有可用 IP 地址的列表。通常，一个域名托管在许多 IP 地址上，以平衡服务器的负载。不幸的是，这种方法不适用于 IPv6。我希望你对元组、列表和字典很熟悉。让我们看一个例子：

```py
 >>> socket.gethostbyname_ex('thapar.edu')('thapar.edu', [],  
       ['14.139.242.100', '220.227.15.55'])>>> 
       socket.gethostbyname_ex('google.com')>>>('google.com', [], 
       ['173.194.36.64', '173.194.36.71', '173.194.36.73',   
       '173.194.36.70', 
       '173.194.36.78', '173.194.36.66', '173.194.36.65', 
       '173.194.36.68', 
       '173.194.36.69', '173.194.36.72', '173.194.36.67'])>>>
```

它为一个域名返回许多 IP 地址。这意味着一个域名如`thapar.edu`或`google.com`在多个 IP 上运行。

+   `socket.gethostname()`：返回 Python 解释器当前运行的系统的主机名：

```py
 >>> socket.gethostname()'eXtreme'
```

使用套接字模块来获取当前机器的 IP 地址，可以使用以下技巧：`gethostbyname(gethostname())`：

```py
 >>> socket.gethostbyname(socket.gethostname())'192.168.10.1'>>>
```

您知道我们的计算机有许多接口。如果您想知道所有接口的 IP 地址，可以使用扩展接口：。

```py
 >>> socket.gethostbyname_ex(socket.gethostname())('eXtreme', [], 
 ['10.0.0.10', '192.168.10.1', '192.168.0.1'])>>>
```

它返回一个包含三个元素的元组，第一个是机器名，第二个是主机名的别名列表（在这种情况下为空），第三个是接口的 IP 地址列表。

+   `socket.getfqdn([name])`：如果可用，用于查找完全合格的域名。完全合格的域名由主机名和域名组成；例如，`beta`可能是主机名，`example.com`可能是域名。**完全合格的域名**（**FQDN**）变成了`beta.example.com`：

```py
 >>> socket.getfqdn('facebook.com')'edge-star-shv-12- 
 frc3.facebook.com'
```

在前面的例子中，`edge-star-shv-12-frc3`是主机名，`facebook.com`是域名。在下面的例子中，`thapar.edu`的 FQDN 不可用：

```py
 >>> socket.getfqdn('thapar.edu')'thapar.edu'
```

如果名称参数为空，它将返回当前机器的名称：

```py
 >>> socket.getfqdn()'eXtreme'>>>
```

+   `socket.gethostbyaddr(ip_address)`：这就像是对名称的*反向*查找。它返回一个元组（主机名，规范名称和 IP_addrlist），其中主机名是响应给定`ip_address`的主机名，规范名称是同一地址的规范名称（可能为空）的列表，IP_addrlist 是同一主机上同一网络接口的 IP 地址列表：

```py
 >>> socket.gethostbyaddr('173.194.36.71')('del01s06-in-
      f7.1e100.net', [], ['173.194.36.71'])>>>    
      socket.gethostbyaddr('119.18.50.66')Traceback (most recent call   
      last):  File "<pyshell#9>", line 1, in <module>    
      socket.gethostbyaddr('119.18.50.66')herror: [Errno 11004] host 
      not found
```

它显示了最后一个查询中的错误，因为没有反向 DNS 查找。

+   `socket.getservbyname(servicename[, protocol_name])`：这将任何协议名称转换为相应的端口号。协议名称是可选的，可以是 TCP 或 UDP。例如，DNS 服务使用 TCP 和 UDP 连接。如果没有给出协议名称，任何协议都可以匹配：

```py
 >>> import socket>>> socket.getservbyname('http')80>>>   
      socket.getservbyname('smtp','tcp')25>>>
```

+   `socket.getservbyport(port[, protocol_name])`：这将互联网端口号转换为相应的服务名称。协议名称是可选的，可以是 TCP 或 UDP：

```py
 >>> socket.getservbyport(80)'http'>>>    
      socket.getservbyport(23)'telnet'>>>    
      socket.getservbyport(445)'microsoft-ds'>>>
```

+   `socket.connect_ex(address)`：此方法返回一个错误指示器。如果成功，它返回`0`；否则，它返回`errno`变量。您可以利用这个函数来扫描端口。运行`connect_ex.py`程序：

```py
      import socket
      rmip ='127.0.0.1'
      portlist = [22,23,80,912,135,445,20]

      for port in portlist:
      sock= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
      result = sock.connect_ex((rmip,port))
      print port,":", result
      sock.close()
```

输出如下截图所示：

![](img/3dbc81c8-458a-4fb5-bed1-9981140d834d.png)

前面的程序输出显示端口`80`，`912`，`135`和`445`是开放的。这是一个基本的端口扫描程序。程序正在使用 IP 地址`127.0.0.1`；这是一个环回地址，所以不可能有任何连接问题。然而，当您遇到问题时，在另一台设备上执行此操作，并使用一个大的端口列表。这时，您将需要使用`socket.settimeout(value)`：

```py
socket.getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])
```

这个套接字方法将主机和端口参数转换为五元组的序列。

让我们看下面的例子：

```py
   >>> import socket
   >>> socket.getaddrinfo('www.thapar.edu', 'http')
   [(2, 1, 0, '', ('220.227.15.47', 80)), (2, 1, 0, '',  
   ('14.139.242.100', 80))]
   >>>
```

输出`2`表示家族，`1`表示套接字类型，`0`表示协议，`''`表示规范名称，`('220.227.15.47', 80)`表示`2`套接字地址。然而，这个数字很难理解。打开套接字的目录。

使用以下代码以可读的形式找到结果：

```py
import socket
def get_protnumber(prefix):
  return dict( (getattr(socket, a), a)
    for a in dir(socket)
      if a.startswith(prefix))

proto_fam = get_protnumber('AF_')
types = get_protnumber('SOCK_')
protocols = get_protnumber('IPPROTO_')

for res in socket.getaddrinfo('www.thapar.edu', 'http'):

  family, socktype, proto, canonname, sockaddr = res

  print 'Family        :', proto_fam[family]
  print 'Type          :', types[socktype]
  print 'Protocol      :', protocols[proto]
  print 'Canonical name:', canonname
  print 'Socket address:', sockaddr
```

代码的输出显示在以下截图中：

![](img/b23fe0ab-be34-4f13-ba4e-06051b364ca5.png)

上部分使用`AF_`、`SOCK_`和`IPPROTO_`前缀创建了一个字典，将协议号映射到它们的名称。这个字典是通过列表推导技术形成的。

代码的上部分有时可能会令人困惑，但我们可以分别执行代码如下：

```py
  >>> dict(( getattr(socket,n),n) for n in dir(socket) if 
  n.startswith('AF_'))
  {0: 'AF_UNSPEC', 2: 'AF_INET', 6: 'AF_IPX', 11: 'AF_SNA', 12:  
  'AF_DECnet', 16: 'AF_APPLETALK', 23: 'AF_INET6', 26: 'AF_IRDA'}
```

现在，这很容易理解。这段代码通常用于获取协议号：

```py
for res in socket.getaddrinfo('www.thapar.edu', 'http'):
```

代码的前一行返回了五个值，如定义中所讨论的。然后将这些值与其相应的字典进行匹配。

# 总结

通过阅读本章，您已经了解了 Python 中的网络。本章的目的是完成即将到来的章节的先决条件。从一开始，您就学会了渗透测试的必要性。渗透测试是为了识别组织中的威胁和漏洞。应该测试什么？这在协议中有规定；不要尝试测试协议中未提及的任何内容。协议是您的免责条款。渗透测试人员应该了解最新的技术，并且在阅读本书之前应该对 Python 有一些了解。为了运行 Python 脚本，您应该有一个实验室设置，一个用于测试实时系统的计算机网络，以及在 Apache 服务器上运行的虚拟网站。

本章还讨论了套接字及其方法。服务器套接字方法定义了如何创建一个简单的服务器。服务器将自己的地址和端口绑定到监听连接。知道服务器地址和端口号的客户端连接到服务器以获取服务。一些套接字方法，如`socket.recv(bufsize)`、`socket.recvfrom(bufsize)`、`socket.recv_into(buffer)`、`socket.send(bytes)`等对服务器和客户端都很有用。您学会了如何处理不同类型的异常。在*有用的套接字方法*部分，您了解了如何获取机器的 IP 地址和主机名，如何从域名中获取 IP 地址，反之亦然。

在下一章中，我们将研究扫描渗透测试，其中包括 IP 地址扫描以检测活动主机。进行 IP 扫描时，使用 ping 扫描和 TCP 扫描。您将学习如何使用端口扫描器检测远程主机上运行的服务。
