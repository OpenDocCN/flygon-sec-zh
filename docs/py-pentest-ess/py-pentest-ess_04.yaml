- en: Network Attacks and Prevention
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络攻击和预防
- en: In previous chapters, you learned about network scanning and network sniffing.
    In this chapter, you will see different types of network attacks and how to prevent
    them. This chapter will be helpful for network admins and network pentesters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了网络扫描和网络嗅探。在本章中，您将看到不同类型的网络攻击以及如何防范它们。本章对网络管理员和网络渗透测试人员很有帮助。
- en: In this chapter, we will cover the following topics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题。
- en: '**DHCP** (**Dynamic Host Configuration Protocol**) starvation attack'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DHCP**（动态主机配置协议）饥饿攻击'
- en: Switch MAC flooding attack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换机MAC洪泛攻击
- en: Gateway disassociation by RAW socket
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过原始套接字进行网关分离
- en: Torrent detection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Torrent检测
- en: So far, you have seen the implementation of ARP spoofing. Now, let's learn about
    an attack called the network disassociation attack. Its concept is the same as
    ARP cache poisoning.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了ARP欺骗的实现。现在，让我们了解一种称为网络分离攻击的攻击。它的概念与ARP缓存中毒相同。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Python 2.7.x installed on a system. Finally, to
    use the Git repository of this book, the user needs to install Git.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装Python 2.7.x。最后，要使用本书的Git存储库，用户需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[https://goo.gl/oWt8A3](https://goo.gl/oWt8A3)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/oWt8A3](https://goo.gl/oWt8A3)'
- en: DHCP starvation attack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DHCP饥饿攻击
- en: 'Before we jump to the attack, let''s see how the DHCP server works. When you
    connect to a network via a switch (access point), your machine automatically gets
    the IP address of the network. You might be wondering where your machine got the
    IP from. These configurations come from the DHCP server, configured for the network.
    The DHCP server gives four things: the IP address, subnet mask, gateway address,
    and DNS server address. But if you analyze carefully, the DHCP server also gives
    you lease for allocate IP address. Type the `ipconfig/all` command in the Windows
    Command Prompt. Lease obtained and the lease expires are highlighted in the following
    screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳转到攻击之前，让我们看看DHCP服务器是如何工作的。当您通过交换机（接入点）连接到网络时，您的计算机会自动获取网络的IP地址。您可能想知道您的计算机从哪里获取了IP。这些配置来自为网络配置的DHCP服务器。DHCP服务器提供四个东西：IP地址、子网掩码、网关地址和DNS服务器地址。但是如果您仔细分析，DHCP服务器还为您分配IP地址提供了租约。在Windows命令提示符中键入`ipconfig/all`命令。租约获取和租约到期在以下截图中突出显示：
- en: '![](img/5719dcd6-f1df-497f-a46a-0d1fd9a9f27c.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5719dcd6-f1df-497f-a46a-0d1fd9a9f27c.jpg)'
- en: 'You can see DHCP lease in the rectangle. In this attack, we will send a fake
    request to the DHCP server. The DHCP server allocates the IPs with a `Lease` to
    the fake request. In this way, we will finish the pool of IPs of the DHCP server
    until the lease expires. In order to perform the attack, we need two machines:
    an attacker machine, which must be Linux with Scapy and Python installed, and
    a Linux machine with DHCP configured. Both must be connected. You can use Kali
    as the attack and CentOS as the DHCP server. You can configure the DHCP server
    from [http://l4wisdom.com/linux-with-networking/dhcp-server.php](http://l4wisdom.com/linux-with-networking/dhcp-server.php).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在矩形中看到DHCP租约。在这种攻击中，我们将向DHCP服务器发送一个虚假请求。DHCP服务器为虚假请求分配带有`租约`的IP。这样，我们将在租约到期之前完成DHCP服务器的IP地址池。为了执行这次攻击，我们需要两台机器：一台攻击者机器，必须安装有Scapy和Python的Linux，以及一台配置了DHCP的Linux机器。两者必须连接。您可以使用Kali作为攻击机，CentOS作为DHCP服务器。您可以从[http://l4wisdom.com/linux-with-networking/dhcp-server.php](http://l4wisdom.com/linux-with-networking/dhcp-server.php)配置DHCP服务器。
- en: 'Before learning the code and attack, you must understand how the DHCP server
    works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习代码和攻击之前，您必须了解DHCP服务器的工作原理：
- en: . ![](img/caf7a05d-031f-4e30-9fb9-e85a7d715339.jpg)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: . ![](img/caf7a05d-031f-4e30-9fb9-e85a7d715339.jpg)
- en: 'From the preceding diagram, we can the understand the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，我们可以理解以下内容：
- en: The client broadcasts the **DHCP Discover** request asking for DHCP configuration
    information
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端广播**DHCP发现**请求，请求DHCP配置信息
- en: The **DHCP server** responds with a **DHCP Offer** message containing an IP
    address and configuration information for lease to the client
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DHCP服务器**响应包含IP地址和租约配置信息的**DHCP提供**消息'
- en: The client accepts the offer by selecting the offered address. In response,
    the client broadcasts a **DHCP Request** message
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通过选择提供的地址来接受提供。作为回应，客户端广播**DHCP请求**消息
- en: 'The **DHCP server** sends a unicast DHCP ACK/reply message to the client with
    the following IP config and information:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DHCP服务器**向客户端发送单播DHCP ACK/回复消息，其中包含以下IP配置和信息：'
- en: 'IP address: `192.168.0.120`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址：`192.168.0.120`
- en: 'Subnet mask: `255.255.255.0`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网掩码：`255.255.255.0`
- en: 'Default gateway: `192.168.0.1`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认网关：`192.168.0.1`
- en: DNS server: `192.168.0.2`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS服务器：`192.168.0.2`
- en: 'Lease: One day'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 租约：一天
- en: 'For more clarification, see the following Wireshark screenshot, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更多澄清，请参阅以下Wireshark截图：
- en: '![](img/8e9fd748-0d6f-4f0b-a15b-4654dc3f36ce.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e9fd748-0d6f-4f0b-a15b-4654dc3f36ce.jpg)'
- en: In the preceding screenshot, Lease is shown as six hours.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图中，租约显示为六小时。
- en: 'Let''s see the code; it''s a little bit difficult to understand, so I have
    broken it into different parts and explained each part:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码；它有点难以理解，所以我把它分成不同的部分并解释了每一部分：
- en: 'Import the essential library and modules as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入必要的库和模块如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a raw socket to receive IP packets as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原始套接字以接收IP数据包如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the while loop to send packets continuously:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用while循环连续发送数据包：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create Ethernet and IP packets using Scapy as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy创建以太网和IP数据包如下：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create UDP and bootp packets using Scapy as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scapy创建UDP和bootp数据包如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create DHCP discover and DHCP request packets as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建DHCP发现和DHCP请求数据包如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just send the DHCP discover packet using Scapy and receive the response using
    a raw socket as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需使用Scapy发送DHCP发现数据包并使用原始套接字接收响应如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Form a DHCP request packet by using the parameters obtained from the previous
    steps as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从前面步骤获得的参数创建DHCP请求数据包如下：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Send the request packet and take a `0.5` second break to send next packets
    as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送请求数据包并间隔`0.5`秒发送下一个数据包如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code name is `dhcp_starvation.py`. The working of the code is divided into
    two parts. First the attacker machine sends the discover packet, then the DHCP
    server sends the DHCP offer packet with the given IP. In the next part, our code
    extracts the given IP and server IP, crafts new packets called DHCP requests with
    the given IP and server IP, and sends them to the DHCP server. Before running
    the program, check the DHCP lease file in the DHCP server, which is located at** `\var\lib\dhcpd\dhcpd.lease`**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码名称为`dhcp_starvation.py`。代码的工作分为两部分。首先，攻击者机器发送发现数据包，然后DHCP服务器发送具有给定IP的DHCP提供数据包。在下一部分中，我们的代码提取给定的IP和服务器IP，制作名为DHCP请求的新数据包，并将其发送到DHCP服务器。在运行程序之前，请检查DHCP服务器中的DHCP租约文件，该文件位于**`\var\lib\dhcpd\dhcpd.lease`**：
- en: '![](img/dc460ca4-3045-4bfc-a507-5483971ed578.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc460ca4-3045-4bfc-a507-5483971ed578.jpg)'
- en: 'You can see that the file is empty, which means no IP is allocated. After running
    the program, the file should be filled, as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到文件是空的，这意味着没有分配IP。运行程序后，文件应该被填满，如下面的屏幕截图所示：
- en: '![](img/756c460a-d41c-411b-843a-e5a277e7f81a.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/756c460a-d41c-411b-843a-e5a277e7f81a.jpg)'
- en: 'The preceding screenshot shows the IP obtained means step 2 of DHCP is working
    and has been completed. The program successfully sent the fake DHCP request. See
    the screenshot of the DHCP server lease file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示获得的IP意味着DHCP的第2步正在工作并已完成。程序成功发送了虚假的DHCP请求。请参阅DHCP服务器租约文件的屏幕截图：
- en: '![](img/d7ecb6df-0bc6-4326-930e-ed2f770b2529.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7ecb6df-0bc6-4326-930e-ed2f770b2529.jpg)'
- en: The preceding screenshot indicates that the program is running successfully.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图表明程序正在成功运行。
- en: The MAC flooding attack
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC flooding攻击
- en: MAC flooding entails flooding the switch with a large number of requests. **Content
    Addressable Memory** (**CAM**) separates a switch from a hub. It stores information,
    such as the MAC address of the connected devices with the physical port number.
    Every MAC in a CAM table is assigned a switch port number. With this information,
    the switch knows where to send Ethernet frames. The size of the CAM tables is
    fixed. You might wonder what happens when the CAM tables get a large number of
    requests. In such a case, the switch turns into a hub, and the incoming frames
    are flooded out on all ports, giving the attacker access to network communication.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MAC flooding涉及向交换机发送大量请求。**内容寻址存储器**（**CAM**）将交换机与集线器分开。它存储信息，例如连接设备的MAC地址和物理端口号。CAM表中的每个MAC都分配了一个交换机端口号。有了这些信息，交换机就知道在哪里发送以太网帧。CAM表的大小是固定的。您可能想知道当CAM表收到大量请求时会发生什么。在这种情况下，交换机将变成集线器，并且传入的帧将泛滥到所有端口，使攻击者能够访问网络通信。
- en: How the switch uses the CAM tables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换机如何使用CAM表
- en: 'The switch learns the MAC address of the connected device with its physical
    port, and writes that entry in the CAM table, as shown in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 交换机学习连接设备的MAC地址及其物理端口，并将该条目写入CAM表，如下图所示：
- en: '![](img/4f76d848-e99f-42e0-b0e0-38b7d139b0df.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f76d848-e99f-42e0-b0e0-38b7d139b0df.png)'
- en: CAM table learning activity
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CAM表学习活动
- en: The preceding diagram is divided into two parts. In the first part, the computer
    with **MAC A** sends the **ARP** packet to the computer with** MAC B**. The switch
    learns the packet, arrives from the physical port `1`, and makes an entry in the
    **CAM Table** such that MAC A is associated with port `1`. The switch sends the
    packet to all the connected devices because it does not have the CAM entry of MAC
    B. In the second part of the diagram, the computer with MAC B responds. The switch
    learns that it came from port `2`. Hence, the switch makes an entry stating that
    the MAC B computer is connected to port `2`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图分为两部分。在第一部分中，具有**MAC A**的计算机向具有**MAC B**的计算机发送**ARP**数据包。交换机学习数据包是从物理端口`1`到达的，并在**CAM表**中创建一个条目，使MAC
    A与端口`1`相关联。交换机将数据包发送到所有连接的设备，因为它没有**MAC B**的CAM条目。在图的第二部分中，具有**MAC B**的计算机做出响应。交换机学习它来自端口`2`。因此，交换机创建一个条目，指出**MAC
    B**计算机连接到端口`2`。
- en: The MAC flood logic
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC flood逻辑
- en: When we send a large number of requests, as shown in the preceding diagram,
    if host A sends fake ARP requests with a different MAC, then the switch will make
    a new entry for port `1` each time, such as `A—1`, `X—1`, and `Y—1`. With these
    fake entries, the CAM table will become full, and the switch will start behaving
    like a hub.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送大量请求时，如前图所示，如果主机A发送具有不同MAC的虚假ARP请求，那么交换机将每次为端口`1`创建一个新条目，例如`A—1`，`X—1`和`Y—1`。有了这些虚假条目，CAM表将变满，并且交换机将开始表现得像集线器。
- en: 'Now, let''s write the code as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码如下：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is very easy to understand. First, it asks for the number
    of packets you want to send. Then, for the interface, you can either choose a `WLAN` interface
    or the `eth` interface. The `eth_pkt` statement forms an Ethernet packet with
    a random MAC address. In the `arp_pkt` statement, an `arp` request packet is formed
    with the destination IP and destination MAC address. If you want to see the full
    packet field, you can use the `arp_pkt.show()` command in Scapy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常容易理解。首先，它要求您要发送的数据包数量。然后，对于接口，您可以选择`WLAN`接口或`eth`接口。`eth_pkt`语句使用随机MAC地址形成一个以太网数据包。在`arp_pkt`语句中，形成了一个带有目标IP和目标MAC地址的ARP请求数据包。如果要查看完整的数据包字段，可以使用Scapy中的`arp_pkt.show()`命令。
- en: 'The Wireshark output of `mac_flood.py` is as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_flood.py`的Wireshark输出如下截图所示：'
- en: '![](img/490deb01-6f40-43dc-ae9e-bed6359bf000.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/490deb01-6f40-43dc-ae9e-bed6359bf000.png)'
- en: Output of a MAC flooding attack
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MAC洪泛攻击的输出
- en: The aim of MAC flooding is to check the security of the switch. If the attack
    is successful, mark it successful in your reports. In order to mitigate the MAC
    flooding attack, use port security. Port security restricts incoming traffic to
    only a select set of MAC addresses or a limited number of MAC addresses and MAC
    flooding attacks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: MAC洪泛的目的是检查交换机的安全性。如果攻击成功，请在报告中标记为成功。为了减轻MAC洪泛攻击，使用端口安全。端口安全将入站流量限制为一组选择的MAC地址或有限数量的MAC地址和MAC洪泛攻击。
- en: Gateway disassociation by RAW socket
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过原始套接字断开网关
- en: In this attack, the victim will remain connected to the gateway but will not
    be able to communicate with the outer network. Put simply, the victim will remain
    connected to the router but will not be able to browse the internet. The principle
    of this attack is the same as ARP cache poisoning. The attack will send the ARP
    reply packet to the victim and that packet will change the MAC address of the
    gateway in the ARP cache of the victim with another MAC. The same thing is done
    in the gateway.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种攻击中，受害者将保持连接到网关，但将无法与外部网络通信。简单地说，受害者将保持连接到路由器，但将无法浏览互联网。这种攻击的原理与ARP缓存中毒相同。攻击将向受害者发送ARP回复数据包，该数据包将使用另一个MAC地址将受害者的ARP缓存中的网关的MAC地址更改为另一个MAC。在网关中也是同样的操作。
- en: 'The code is the same as that of ARP spoofing, except for some changes, which
    are explained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与ARP欺骗的代码相同，只是有一些更改，如下所述：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run `netdiss.py`. We can see that there is only one change in the code: `sor =
    'x48x41x43x4bx45x52'`. This is a random MAC as this MAC does not exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`netdiss.py`。我们可以看到代码中只有一个更改：`sor = 'x48x41x43x4bx45x52'`。这是一个随机的MAC，因为这个MAC不存在。
- en: In order to carry out the ARP cache poisoning attack, the victim should have
    a real entry of the gateway in the ARP cache.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行ARP缓存中毒攻击，受害者应该在ARP缓存中有网关的真实条目。
- en: You may wonder why we used the `'x48x41x43x4bx45x52'` MAC. Convert it into ASCII
    and you'll get your answer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们使用了`'x48x41x43x4bx45x52'`MAC。将其转换为ASCII，您将得到答案。
- en: Torrent detection
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子检测
- en: The major problem for a network admin is to stop the use of torrents on the
    user machine. Sometimes a small organization or start-up don't have enough funds
    to purchase a firewall to stop the use of a torrent. In an organization, a user
    uses the torrent to download movies, songs, and so on, which eats up a lot of
    bandwidth. In this section, we will see how to eradicate this problem using the
    Python program. Our program will detect the torrent when a torrent program is
    running.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员的主要问题是阻止用户机器上种子的使用。有时，小型组织或初创公司没有足够的资金购买防火墙来阻止种子的使用。在组织中，用户使用种子下载电影、歌曲等，这会占用大量带宽。在本节中，我们将看到如何使用Python程序消除这个问题。我们的程序将在种子程序运行时检测种子。
- en: The concept is based on the client-server architecture. The server code will
    be run on the admin machine and the client code will be run on the user's machine
    in hidden mode. When a user uses the torrent, the client code will notify the
    server machine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该概念基于客户端-服务器架构。服务器代码将在管理员机器上运行，客户端代码将在用户的机器上以隐藏模式运行。当用户使用种子时，客户端代码将通知服务器机器。
- en: 'First, look at the following server code and try to understand the code. The
    code name is `torrent_detection_server.py`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看以下服务器代码，并尝试理解代码。代码名称是`torrent_detection_server.py`：
- en: 'Import the essential libraries as follows:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式导入必要的库：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print the messages for the admin. Only use *Ctrl* + *C* to stop the program,
    because *Ctrl* + *C* is handled by the program itself and the socket will be automatically
    closed as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为管理员打印消息。只使用*Ctrl* + *C*来停止程序，因为*Ctrl* + *C*由程序本身处理，套接字将自动关闭如下：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a logger which logs the event in a file, as follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个记录事件的日志文件，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a list of the detected clients and define the server IP address and
    port on which the server will run as follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建检测到的客户端列表，并定义服务器将在其上运行的服务器IP地址和端口，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a UDP socket as follows:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UDP套接字，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a while loop to listen continuously. The following code block receives
    the message from the client and logs the event in the log file as follows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个循环以持续监听。以下代码块接收来自客户端的消息，并在日志文件中记录事件，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s see the code of the client machine. Open the `service.py` code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看客户机的代码。打开`service.py`代码：
- en: 'Import the essential libraries and modules as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式导入必要的库和模块：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the server IP and server port in order to make the socket as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义服务器IP和服务器端口，以便创建套接字，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use an infinite while loop so that the program remains live as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无限循环，使程序保持活动状态，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Look at the current task list and try to find the torrent in the task list.
    If the torrent is found, send the crafted message to the server as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看当前任务列表，并尝试在任务列表中找到种子。如果找到种子，向服务器发送精心制作的消息如下：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding program, I used `30` seconds for the next iteration to get
    a quick result. You can change the time to your convenience. If traffic is very
    high, you can use 15 minutes (`15*60`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我使用了`30`秒作为下一次迭代的时间，以获得快速结果。您可以根据自己的方便更改时间。如果流量很大，可以使用15分钟（`15*60`）。
- en: In order to run and test our program, we need at least two computers. One program
    will run on the server, handled by the network admin. The second program will
    run on the client machine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行和测试我们的程序，我们至少需要两台计算机。一个程序将在由网络管理员处理的服务器上运行。第二个程序将在客户机上运行。
- en: 'Let''s run the code one by one and study our test cases: when the torrent is
    running and when the torrent is not running. First, run the server program. You
    can run the server program on any operating system:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个运行代码并研究我们的测试用例：种子正在运行时和种子未运行时。首先运行服务器程序。你可以在任何操作系统上运行服务器程序：
- en: '![](img/af10a557-223e-486c-b19f-66fcef6dbfd0.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af10a557-223e-486c-b19f-66fcef6dbfd0.jpg)'
- en: 'The server program is running; let''s run the client-side code, `service.py`,
    as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器程序正在运行；让我们运行客户端代码`service.py`，如下面的截图所示：
- en: '![](img/09a6ecab-3a1e-4c65-b69c-97f55f209717.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a6ecab-3a1e-4c65-b69c-97f55f209717.jpg)'
- en: 'The preceding program shows nothing but running and continuously scanning current
    tasks. As we have defined 30 seconds in the program, it scans the current task
    after 30 seconds. See the following screenshot, which is the torrent service running
    in the Windows Task Manager:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序只是运行并不断扫描当前任务。由于我们在程序中定义了30秒，它会在30秒后扫描当前任务。看下面的截图，这是在Windows任务管理器中运行的种子服务：
- en: '![](img/8d8ad7ea-1cc7-4257-98ed-7031f50acccb.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d8ad7ea-1cc7-4257-98ed-7031f50acccb.jpg)'
- en: 'So uTorrent is running on the client machine. If client code finds a task containing
    a torrent name, then it sends the message to the server. So, in the client program,
    we are using the `response = os.popen(''tasklist'')` line, which runs the tasklist
    command in Command Prompt, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以uTorrent正在客户机上运行。如果客户端代码发现包含种子名称的任务，那么它会将消息发送到服务器。因此，在客户端程序中，我们使用了`response
    = os.popen('tasklist')`这一行，它在命令提示符中运行tasklist命令，如下面的截图所示：
- en: '![](img/20a9f8f5-4473-44a4-b8c8-4f802d5c4647.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20a9f8f5-4473-44a4-b8c8-4f802d5c4647.jpg)'
- en: The preceding screenshot shows that the torrent is running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了种子正在运行。
- en: 'If you run the torrent on the client machine, then the server would get the
    following message:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在客户机上运行种子文件，那么服务器会收到以下消息：
- en: '![](img/cfca23c4-37df-4c17-a613-be7432add28f.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfca23c4-37df-4c17-a613-be7432add28f.jpg)'
- en: Gotcha! One machine, hostname `Intel`, user `Mohit`, and IP address `192.168.0.129`,
    is using the torrent. The client sends us three messages, but we displayed only
    one. We are using UPD, which is a connectionless protocol. The server, as well
    as the client, will know nothing if the packet gets lost in traffic. That’s why
    the client sends three packets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定！一台名为`Intel`的机器，用户为`Mohit`，IP地址为`192.168.0.129`，正在使用种子。客户端发送了三条消息给我们，但我们只显示了一条。我们使用的是UDP，这是一种无连接的协议。如果数据包在传输中丢失，服务器和客户端都不会知道。这就是为什么客户端发送了三个数据包。
- en: Why UDP and not TCP? TCP is a connection-oriented protocol. If the server machine
    goes down, then the program on the client machine will start giving an error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用UDP而不是TCP？TCP是一种面向连接的协议。如果服务器机器宕机，那么客户机上的程序将开始报错。
- en: 'If you lost the output on the screen, you can check the output in the log file.
    Open `torrent_dection.log`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上丢失了输出，你可以在日志文件中检查输出。打开`torrent_dection.log`：
- en: '![](img/4131ffb5-50f9-4131-a52b-aa9857f8669a.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4131ffb5-50f9-4131-a52b-aa9857f8669a.jpg)'
- en: Now you should better understand torrent detection. But our work is not finished
    yet. If a user on a client machine knows some kind of detection program is running,
    they might stop the program. We will have to get the client code to run in hidden
    mode.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该更好地理解了种子检测。但我们的工作还没有完成。如果客户机上的用户知道某种检测程序正在运行，他们可能会停止程序。我们必须让客户端代码以隐藏模式运行。
- en: Running the program in hidden mode
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以隐藏模式运行程序
- en: First, we have to change the `service.py` program to a Windows-executable file.
    In order to convert a Python program to Windows-executable, we are going to use
    Pyinstaller.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将`service.py`程序更改为Windows可执行文件。为了将Python程序转换为Windows可执行文件，我们将使用Pyinstaller。
- en: Let's change the file into a Windows-executable file. Copy the `service.py` code
    file in the `C:\PyInstaller-2.1` folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将文件改为Windows可执行文件。将`service.py`代码文件复制到`C:\PyInstaller-2.1`文件夹中。
- en: 'Open the Command Prompt, browse to the `C:\PyInstaller-2.1` folder, and run
    the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令提示符，浏览到`C:\PyInstaller-2.1`文件夹，并运行以下命令：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'See the following screenshot for more clarification:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的截图以获得更多解释：
- en: '![](img/7a1e0201-d7e3-41bb-840d-2bd1d1055163.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a1e0201-d7e3-41bb-840d-2bd1d1055163.jpg)'
- en: The preceding screenshot is self-explanatory. Now that the executable file has
    been created, it can be run by clicking on it. As you click, it will open the
    Command Prompt screen.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图是不言自明的。现在可执行文件已经创建，可以通过点击来运行。当你点击时，它会打开命令提示符屏幕。
- en: Now run the executable program in hidden mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以隐藏模式运行可执行程序。
- en: 'Create a `service.vbs` file and write the following lines in the file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`service.vbs`文件，并在文件中写入以下行：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding file, I used `%WINDIR%`, which means `Windows` folder; as I
    have installed Windows in the `C:` drive, `%WINDIR%` becomes `C:\Windows`. Just
    click on `service.vbs`. The `service.exe` program will be run as a daemon, with
    no graphical screen, just background processing. Put `service.vbs` in the `Windows
    startup` folder so that the next time Windows gets booted, the `service.vbs` file
    will automatically get executed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的文件中，我使用了`%WINDIR%`，它表示`Windows`文件夹；因为我在`C:`驱动器上安装了Windows，`%WINDIR%`就变成了`C:\Windows`。只需点击`service.vbs`。`service.exe`程序将作为守护进程运行，没有图形界面，只有后台处理。将`service.vbs`放在`Windows启动`文件夹中，这样下次Windows启动时，`service.vbs`文件将自动执行。
- en: I hope you enjoyed this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢这一章。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about network attacks; the DHCP starvation attack
    can be performed efficiently by using our Python code. The Python code can be
    used for illegal DHCP servers. The MAC flooding attack can turn a switch into
    a hub. Port security must be enabled to mitigate the attack. The gateway disassociation
    attack is very easy to perform; the attacker can annoy a user by using this attack.
    The static entries of the gateway in the ARP cache can be a possible solution
    for the attack. Although torrenting is banned, it is still a big problem for small
    organizations. The solution presented in this chapter can be very effective against
    the torrenting. In next chapter, you will learn about the wireless traffic monitoring.
    You will learn Wireless frame, capturing of frames and Wireless attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了网络攻击；DHCP饥饿攻击可以通过使用我们的Python代码来高效地执行。Python代码可以用于非法的DHCP服务器。MAC洪泛攻击可以将交换机变成集线器。必须启用端口安全以减轻攻击。网关断开攻击非常容易执行；攻击者可以使用这种攻击来打扰用户。网关在ARP缓存中的静态条目可能是对抗攻击的一个可能解决方案。尽管下载种子被禁止，但对于小型组织来说仍然是一个大问题。本章介绍的解决方案对抗种子下载可能非常有效。在下一章中，您将学习关于无线流量监控的内容。您将学习无线帧、帧捕获和无线攻击。
