- en: Wireless Pentesting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线渗透测试
- en: 'The era of wireless connectivity has enabled flexibility and mobility, but
    it has also ushered in many security issues. With wired connectivity, the attacker
    needs physical access in order to connect and attack. In the case of wireless
    connectivity, an attacker just needs the availability of the signal to launch
    an attack. Before proceeding, you should be aware of the terminology used:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无线连接的时代已经实现了灵活性和移动性，但也带来了许多安全问题。在有线连接中，攻击者需要物理接触才能连接和攻击。而在无线连接的情况下，攻击者只需要信号的可用性就可以发动攻击。在继续之前，您应该了解使用的术语：
- en: '**Access Point** (**AP**): This is used to connect wireless devices to wired
    networks.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接入点**（**AP**）：用于将无线设备连接到有线网络。'
- en: '**Service Set Identifier** (**SSID**): This is a unique 0-32 alphanumeric identifier
    for a wireless LAN. It is human readable and simply put, it is the network name.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务集标识符**（**SSID**）：这是无线局域网的唯一的0-32个字母数字标识符。它是人类可读的，简单来说，就是网络名称。'
- en: '**Basic Service Set Identification** (**BSSID**): This is the MAC address of
    the wireless AP.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本服务集标识**（**BSSID**）：这是无线AP的MAC地址。'
- en: '**Channel number**: This represents the range of the radio frequency used by
    AP for transmission.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信道号**：这代表AP用于传输的无线电频率的范围。'
- en: The channel number might get changed due to the auto setting of AP, so, in this
    chapter, don't get confused. If you run the same program at a different time,
    the channel number might change.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AP的自动设置可能会改变信道号，所以在本章中不要感到困惑。如果您在不同的时间运行相同的程序，信道号可能会改变。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下概念：
- en: Finding wireless SSID
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找无线SSID
- en: Analyzing wireless traffic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析无线流量
- en: Detecting the clients of an AP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测AP的客户端
- en: The wireless deauth attack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线去认证攻击
- en: Detection of the deauth attack
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测去认证攻击
- en: Introduction to 802.11 frames
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 802.11帧简介
- en: '802.11 and 802.11x are defined as a family of wireless LAN technologies by
    IEEE. The following are the 802.11 specifications based on frequency and bandwidth:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE将802.11和802.11x定义为无线局域网技术家族。以下是基于频率和带宽的802.11规范：
- en: '`802.11`: This provides bandwidth up to 1-2 Mbps with a 2.4 GHz frequency band'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`802.11`：提供带宽高达1-2 Mbps，使用2.4 GHz频段'
- en: '`802.11.a`: This provides bandwidth up to 54 Mbps with a 5 GHz frequency band'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`802.11.a`：提供带宽高达54 Mbps，使用5 GHz频段'
- en: '`802.11.b` : This provides bandwidth up to 11 Mbps with a 2.4 GHz frequency
    band'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`802.11.b`：提供带宽高达11 Mbps，使用2.4 GHz频段'
- en: '`802.11g`: This provides bandwidth up to 54 Mbps with a 2.4 GHz frequency band'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`802.11g`：提供带宽高达54 Mbps，使用2.4 GHz频段'
- en: '`802.11n`: This provides bandwidth up to 300 Mbps with both frequency bands'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`802.11n`：提供带宽高达300 Mbps，使用两个频段'
- en: All components of `802.11` fall into either the **Media Access Control** (**MAC**)
    layer or the physical layer. The MAC layer is the subclass of the datalink layer.
    We have already covered the **Protocol Data Unit** (**PDU**) of the data link
    layer, which is called a frame, in [Chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml),
    *Scanning Pentesting*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`802.11`的组件都属于**媒体访问控制**（**MAC**）层或物理层。MAC层是数据链路层的子类。我们已经在[第2章](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml)中介绍了数据链路层的**协议数据单元**（**PDU**），也就是帧。
- en: 'First, however, let''s understand the `802.11` frame format. The three major
    types of frame that exist in `802.11` are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先让我们了解`802.11`帧格式。`802.11`中存在的三种主要类型的帧是：
- en: The data frame
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据帧
- en: The control frame
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制帧
- en: The management frame
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理帧
- en: 'These frames are assisted by the MAC layer. The following diagram depicts the
    format of the MAC layer:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些帧由MAC层辅助。下图显示了MAC层的格式：
- en: '![](img/ccb2c53a-f4d3-4e73-94ee-e5a8183d779e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccb2c53a-f4d3-4e73-94ee-e5a8183d779e.png)'
- en: 'In the preceding diagram, the three types of address are shown. **Address 1**,
    **Address 2**, and **Address 3** are the MAC addresses of the destination, AP,
    and source, respectively. This means **Address 2** is the BSSID of AP. In this
    chapter, our focus will be on the management frame, because we are interested
    in the subtypes of the management frame. Some common types of management frame
    are the authentication frame, the deauthentication frame, the association request
    frame, the disassociation frame, the probe request frame, and the probe response
    frame. The connection between the clients and APs is established by the exchange
    of various frames, as shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，显示了三种类型的地址。**地址1**、**地址2**和**地址3**分别是目的地、AP和源的MAC地址。这意味着**地址2**是AP的BSSID。在本章中，我们的重点将放在管理帧上，因为我们对管理帧的子类型感兴趣。一些常见的管理帧类型包括认证帧、去认证帧、关联请求帧、解除关联帧、探测请求帧和探测响应帧。客户端和AP之间的连接是通过各种帧的交换来建立的，如下图所示：
- en: '![](img/f8288cfe-bdc3-4db7-80e7-b3179b31e09b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8288cfe-bdc3-4db7-80e7-b3179b31e09b.png)'
- en: Frame exchange
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 帧交换
- en: 'The preceding diagram shows the exchange of frames. These frames are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了帧的交换。这些帧包括：
- en: '**The Beacon frame**: The AP periodically sends a Beacon frame to advertise
    its presence. The Beacon frame contains information such as SSID, channel number,
    and BSSID.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信标帧**：AP定期发送信标帧来宣传自己的存在。信标帧包含诸如SSID、信道号和BSSID等信息。'
- en: '**The Probe request**: The wireless device (client) sends out a probe request
    to determine which APs are in range. The probe request contains elements such
    as the SSID of the AP, supported rates, and vendor-specific info. The client sends
    the probe request and waits for the probe response.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探测请求**：无线设备（客户端）发送探测请求以确定范围内有哪些接入点。探测请求包含诸如AP的SSID、支持的速率和特定厂商信息等元素。客户端发送探测请求并等待探测响应。'
- en: '**The Probe response**: In response to the probe request, the corresponding
    AP will respond with a probe response frame that contains the capability information
    and supported data rates.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探测响应**：作为对探测请求的响应，相应的接入点将会回复一个包含能力信息和支持的数据速率的探测响应帧。'
- en: '**The Authentication request**: The client sends the authentication request
    frame that contains its identity.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证请求**：客户端发送包含其身份的认证请求帧。'
- en: '**The Authentication response**: The AP responds with an authentication, which
    indicates acceptance or rejection. If shared key authentication exists, such as
    WEP, then the AP sends a challenge text in the form of an authentication response.
    The client must send the encrypted form of the challenged text in an authentication
    frame back to the AP.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证响应**：AP响应认证，表示接受或拒绝。如果存在共享密钥认证，例如WEP，那么AP会以认证响应的形式发送挑战文本。客户端必须将受挑战文本的加密形式发送回AP。'
- en: '**The Association request**: After successful authentication, the client sends
    an association request that contains its characteristics, such as supported data
    rates and the SSID of the AP.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联请求**：成功认证后，客户端发送包含其特征的关联请求，例如支持的数据速率和AP的SSID。'
- en: '**The Association response**: The AP sends an association response that contains
    acceptance or rejection. In the case of acceptance, the AP will create an association
    ID for the client.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联响应**：AP发送包含接受或拒绝的关联响应。在接受的情况下，AP将为客户端创建关联ID。'
- en: Our forthcoming attacks will be based upon these frames.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将进行的攻击将基于这些帧。
- en: Now, it's time for a practical. In the following section, we will go through
    the rest of the theory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行实际操作了。在接下来的部分，我们将讨论理论的其余部分。
- en: Wireless SSID finding and wireless traffic analysis with Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行无线SSID查找和无线流量分析
- en: 'If you have done wireless testing with Back-Track or Kali Linux, then you will
    be familiar with the `airmon-ng` suite. The `airmon-ng` script is used to enable monitor
    mode on wireless interfaces. The Monitor mode allows a wireless device to capture
    frames without having to associate with an AP. We are going to run all our programs
    on Kali Linux. The following screenshot shows you how to set **mon0**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过Back-Track或Kali Linux进行无线测试，那么您将熟悉`airmon-ng`套件。`airmon-ng`脚本用于在无线接口上启用监视模式。监视模式允许无线设备捕获帧而无需与AP关联。我们将在Kali
    Linux上运行所有程序。以下截图显示了如何设置**mon0**：
- en: '![](img/30d14dcc-8380-4316-8e0c-59efb310e9bf.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30d14dcc-8380-4316-8e0c-59efb310e9bf.png)'
- en: Setting mon0
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 设置mon0
- en: When you run the `airmon-ng` script, it gives the wireless card a name, such
    as **wlan0**, as shown in the preceding screenshot. The `airmon-ng start wlan0`
    command will start **wlan0** in monitor mode, and **mon0** captures wireless packets.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`airmon-ng`脚本时，它会为无线网卡命名，例如**wlan0**，如前面的截图所示。`airmon-ng start wlan0`命令将在监视模式下启动**wlan0**，而**mon0**将捕获无线数据包。
- en: 'Now, let''s write our first program, which gives three values: SSID, BSSID,
    and the channel number. The program name is `ssid_finder_raw.py`. Let''s see the
    code and explanation as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的第一个程序，该程序提供三个值：SSID、BSSID和信道号。程序名称是`ssid_finder_raw.py`。让我们看看代码和解释如下：
- en: 'Import the essential libraries:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To enable the user to view the previously stored result, run the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用户能够查看先前存储的结果，请运行以下命令：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the user presses `Y`, then the program will open the `wireless_data.dat`
    file and fetch the information, such as SSID, BSSID, and channel number. If it
    is run the first time, the `wireless_data.dat` file will not be there:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户按下`Y`，则程序将打开`wireless_data.dat`文件并获取信息，例如SSID、BSSID和信道号。如果是第一次运行，`wireless_data.dat`文件将不存在：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code creates a socket to capture all frames and bind them to `mon0`. I
    hope you have read [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml), *Sniffing
    and Penetration Testing* carefully. The only new thing is `3`. The 3 argument
    represents the protocol number, which indicates `ETH_P_ALL`. It means we are interested
    in every packet:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该代码创建一个套接字来捕获所有帧并将它们绑定到`mon0`。希望您已经仔细阅读了[第3章](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml)，*嗅探和渗透测试*。唯一的新东西是`3`。3参数表示协议号，表示`ETH_P_ALL`。这意味着我们对每个数据包都感兴趣：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define an `ap_list` list, which will be used later. Open shelve files named
    `wireless_data.dat`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`ap_list`列表，稍后将使用。打开名为`wireless_data.dat`的shelve文件：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Receive Beacon frames, extract the `SSID`; `BSSID`, and channel number information;
    and save it in the `wireless_data.dat` file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收Beacon帧，提取`SSID`、`BSSID`和信道号信息，并将其保存在`wireless_data.dat`文件中。
- en: 'The `if fm[radio_tap_lenght] == "\x80"` syntax only allows Beacon frames. To
    understand the `radio_tap_lenght+4+6+6+6+2+12+1` syntax see in the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if fm[radio_tap_lenght] == "\x80"`语法只允许Beacon帧。要理解`radio_tap_lenght+4+6+6+6+2+12+1`语法，请参见以下内容：'
- en: '![](img/fd8873ef-ffe7-465b-8af0-78f9465b4d96.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd8873ef-ffe7-465b-8af0-78f9465b4d96.jpg)'
- en: By viewing the screenshot, you got the idea of numeric values used with `radio_tap_length`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看截图，您可以了解与`radio_tap_length`一起使用的数字值。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the obtained information in `wireless_data.dat`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取的信息保存在`wireless_data.dat`中：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to capture the frame using *Wireshark*, use `mon0` mode. The following
    frame is a Beacon frame:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用*Wireshark*捕获帧，请使用`mon0`模式。以下帧是Beacon帧：
- en: '![](img/c1b0864d-1feb-4f0d-9dac-1bb4e99271f2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1b0864d-1feb-4f0d-9dac-1bb4e99271f2.png)'
- en: The Wireshark representation of the Beacon frame
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Beacon帧的Wireshark表示
- en: The preceding screenshot will clearly finish your doubts. The screenshot is
    self-explanatory. You can channel number, SSID, and BSSID.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图将清楚地解决您的疑问。截图是不言自明的。您可以看到信道号、SSID和BSSID。
- en: 'I tested the code on two different wireless USB cards.  Here is the output
    of `ssid_finder_raw.py`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我在两张不同的无线USB卡上测试了代码。以下是`ssid_finder_raw.py`的输出：
- en: '![](img/64ce38c0-49e7-44a1-ad7d-5803b4521f37.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64ce38c0-49e7-44a1-ad7d-5803b4521f37.jpg)'
- en: Always press *Ctrl* + *C* to store the results.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 始终按下*Ctrl* + *C* 以存储结果。
- en: 'Now, let''s write the code to find the SSID and MAC address of the APs using
    Scapy. You must be thinking that we have already performed the same task in the
    raw packet analysis. Writing code by using scapy is easier than a raw socket,
    actually, for research purposes, you should know about raw packet analysis. If
    you want some information that Scapy does not know, raw packet analysis gives
    you the freedom to create the desired sniffer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码，使用Scapy找到AP的SSID和MAC地址。你可能会认为我们已经在原始数据包分析中执行了相同的任务。使用scapy编写代码比使用原始套接字更容易，实际上，出于研究目的，你应该了解原始数据包分析。如果你想要一些Scapy不知道的信息，原始数据包分析可以让你自由创建所需的嗅探器：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's go through the code from the start. The `scapy.all import *` statement
    imports all the modules of the Scapy library. The variable interface is set to
    `mon0`. An empty list named `ap_list` is declared. In the next line, the `info`
    function is defined and the `fm` argument is passed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始看代码。`scapy.all import *`语句导入了Scapy库的所有模块。变量接口设置为`mon0`。声明了一个名为`ap_list`的空列表。在下一行，定义了`info`函数并传递了`fm`参数。
- en: The `if fm.haslayer(Dot11):` statement is like a filter, which passes only `Dot11`
    traffic; `Dot11` indicates 802.11 traffic. The next `if((fm.type == 0) & (fm.subtype==8)):`
    statement is another filter, which passes traffic where the frame type is `0`
    and the frame subtype is `8`; type `0` represents the management frame and subtype
    `8` represents the Beacon frame. In the next line, the `if fm.addr2 not in ap_list:`
    statement is used to remove redundancy; if the AP's MAC address is not in `ap_list`,
    then it appends the list and adds the address to the list, as stated in the next
    line. The next line prints the output. The last `sniff(iface=interface,prn=info)`
    line sniffs the data with the interface, which is `mon0`, and invokes the `info()`
    function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`if fm.haslayer(Dot11):`语句就像一个过滤器，只传递`Dot11`流量；`Dot11`表示802.11流量。接下来的`if((fm.type
    == 0) & (fm.subtype==8)):`语句是另一个过滤器，它传递帧类型为`0`且帧子类型为`8`的流量；类型`0`表示管理帧，子类型`8`表示Beacon帧。在下一行，`if
    fm.addr2 not in ap_list:`语句用于去除冗余；如果AP的MAC地址不在`ap_list`中，那么它会将列表附加并将地址添加到列表中，如下一行所述。下一行打印输出。最后的`sniff(iface=interface,prn=info)`行使用接口`mon0`嗅探数据，并调用`info()`函数。'
- en: 'The following screenshot shows the output of the `ssid.py` program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`ssid.py`程序的输出：
- en: '![](img/ac8dc7b7-c08f-4990-bf4e-40e6e4af6362.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac8dc7b7-c08f-4990-bf4e-40e6e4af6362.png)'
- en: 'I hope you now understand the `ssid.py` program. Let''s try and figure out
    the channel number of the AP. We will have to make some amendments to the code.
    The modified code is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在理解了`ssid.py`程序。让我们试着找出AP的信道号。我们将不得不对代码进行一些修改。修改后的代码如下：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will notice that we have added one thing here, which is `ord(fm[Dot11Elt:3].info)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在这里添加了一件事，那就是`ord(fm[Dot11Elt:3].info)`。
- en: 'You might wonder what `Dot11Elt` is. If you open `Dot11Elt` in Scapy, you will
    get three things, `ID`, `len`, and `info`, as shown in the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`Dot11Elt`是什么。如果你在Scapy中打开`Dot11Elt`，你会得到三个东西，`ID`，`len`和`info`，如下面的输出所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'See the following class code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下类代码：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous class code, `DSset` gives information about the channel number,
    so the `DSset` number is `3`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类代码中，`DSset`提供了有关信道号的信息，因此`DSset`号是`3`。
- en: 'Let''s not make it complex and let''s simply capture a packet using scapy:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要把它搞得太复杂，让我们简单地使用scapy捕获一个数据包：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the following screenshot, you can see that there are lots of Dot11Elt in
    the `0th` frame. Let''s check the `0th` frame in detail:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到`0th`帧中有很多`Dot11Elt`。让我们详细检查`0th`帧：
- en: '![](img/2bdc7183-5495-4275-923a-eec0ff9196f1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bdc7183-5495-4275-923a-eec0ff9196f1.png)'
- en: Dot11Elt in the frame
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 帧中的Dot11Elt
- en: Now, you can see that there are several `<Dot11Elt`. Every `Dot11Elt` has three
    fields. `ord(fm[Dot11Elt:3].info)` gives the channel number, which resides in
    the fourth place (according to the class code), which is `<Dot11Elt ID=DSset len=1
    info='x04'`. I hope you understand `Dot11Elt` now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到有几个`<Dot11Elt`。每个`Dot11Elt`有三个字段。`ord(fm[Dot11Elt:3].info)`给出了信道号，它位于第四个位置（根据类代码），即`<Dot11Elt
    ID=DSset len=1 info='x04'`。我希望你现在理解了`Dot11Elt`。
- en: 'In Wireshark, we can see which outputs are represented by `Dot11Elt` in the
    following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Wireshark中，我们可以看到以下截图中由`Dot11Elt`表示的输出：
- en: '![](img/1be321c5-a233-46b0-8e5f-4ff1697d4338.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be321c5-a233-46b0-8e5f-4ff1697d4338.png)'
- en: Dot11Elt representation in Wireshark
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark中的Dot11Elt表示
- en: The tagged parameters in the preceding screenshot are represented by `Dot11Elt`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，标记的参数由`Dot11Elt`表示。
- en: 'The output of the `scapt_ssid.py` program is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`scapt_ssid.py`程序的输出如下：'
- en: '![](img/2ef3d028-6c82-40ea-bf27-824b5dcadca4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ef3d028-6c82-40ea-bf27-824b5dcadca4.png)'
- en: Output with channel
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与信道
- en: Detecting clients of an AP
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测AP的客户端
- en: You might want to obtain all the clients of a particular AP. In this situation,
    you have to capture the probe request frame. In scapy, this is called `Dot11ProbeReq`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要获取特定AP的所有客户端。在这种情况下，你必须捕获探测请求帧。在scapy中，这称为`Dot11ProbeReq`。
- en: 'Let''s check out the frame in Wireshark in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下截图中检查Wireshark中的帧：
- en: '![](img/d15778b2-85ee-46e3-a409-31e416595b92.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d15778b2-85ee-46e3-a409-31e416595b92.png)'
- en: The probe request frame
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 探测请求帧
- en: The probe request frame contains some interesting information, such as the source
    address and SSID, as highlighted in the preceding screenshot.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 探测请求帧包含一些有趣的信息，比如源地址和SSID，如前面的截图所示。
- en: 'Now, it''s time to see the code as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看以下代码了：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's look at the new things added in the preceding program. The user enters
    the AP's SSID of interest, which will be stored in the `ap_name` variable. The
    `if fm.haslayer(Dot11ProbeReq):` statement indicates that we are interested in
    the probe request frames. The `if client_name == ap_name:` statement is a filter
    and captures all requests that contain the SSID of interest. The `print "MAC ",
    fm.addr2` line prints the MAC address of the wireless device attached to the AP.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在前面的程序中添加的新内容。用户输入感兴趣的AP的SSID，将存储在`ap_name`变量中。`if fm.haslayer(Dot11ProbeReq):`语句表示我们对探测请求帧感兴趣。`if
    client_name == ap_name:`语句是一个过滤器，捕获所有包含感兴趣SSID的请求。`print "MAC ", fm.addr2`行打印连接到AP的无线设备的MAC地址。
- en: 'The output of the `probe_req.py` program is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe_req.py`程序的输出如下：'
- en: '![](img/e0c46329-8b26-4755-8168-ec337c65c4f4.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0c46329-8b26-4755-8168-ec337c65c4f4.png)'
- en: A list of wireless devices are attached to the ` CITY PG3`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列无线设备连接到`CITY PG3`。
- en: Wireless hidden SSID scanner
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线隐藏SSID扫描仪
- en: 'Sometimes, for security reasons, users hide their accesspoint SSID and configure
    their computer to detect the access point. When you hide the SSID access point,
    then Beacon frames stop broadcasting their SSID. In this scenario, we have to
    capture all Probe request, Probe response, Reassociation request, Association
    response, and Association request frames sent by an associated client of the AP.
    For the purpose of our experiment, I am hiding the SSID, and then running the `ssid_finder_raw.py` code
    is shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，出于安全原因，用户隐藏他们的接入点SSID，并配置他们的计算机以检测接入点。当您隐藏SSID接入点时，Beacon帧将停止广播它们的SSID。在这种情况下，我们必须捕获由AP的关联客户端发送的所有探测请求、探测响应、重新关联请求、关联响应和关联请求帧。为了我们的实验目的，我隐藏了SSID，然后运行`ssid_finder_raw.py`代码如下截图所示：
- en: '![](img/63ad8c2f-461b-4282-b1ff-5f17ab812e32.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63ad8c2f-461b-4282-b1ff-5f17ab812e32.jpg)'
- en: In the preceding screenshot, you can clearly see the SSID of the first AP is
    not being shown.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以清楚地看到第一个AP的SSID没有显示。
- en: 'Run the `hidden_ssid_finder.py` program, but before running the program, make
    sure monitor mode is on, We are using monitor mode `mon0`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`hidden_ssid_finder.py`程序，但在运行程序之前，请确保监视器模式已打开，我们正在使用监视器模式`mon0`：
- en: 'Import the essential modules:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a raw socket and bind it with the `mon0` interface:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个原始套接字，并将其绑定到`mon0`接口：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ask the user to enter the MAC address of the AP, and remove the colon from
    the MAC address:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求用户输入AP的MAC地址，并从MAC地址中删除冒号：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create lists and dictionaries:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建列表和字典：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Continuously receive the frames as defined in the `filter_type` dictionary:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续接收`filter_type`字典中定义的帧：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Find the associated clients of the AP:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找AP的关联客户端：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Find the probe request frame of the associated clients, and extract the SSID
    from the probe request frame:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找关联客户端的探测请求帧，并从探测请求帧中提取SSID：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To gracefully exit, press *Ctrl* + *C*:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优雅地退出，请按*Ctrl* + *C*：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s run the code. The client must be connected to the AP for the code logic
    to work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码。客户端必须连接到AP才能使代码逻辑正常工作：
- en: '![](img/6556d0d3-090c-4ad6-9279-dff10521b741.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6556d0d3-090c-4ad6-9279-dff10521b741.jpg)'
- en: The preceding output shows that only one client is connected to the AP.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示只有一个客户端连接到AP。
- en: Wireless attacks
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线攻击
- en: Up to this point, you have seen various sniffing techniques that gather information.
    In this section, you'll see how wireless attacks take place, which is a very important
    topic in pentesting.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了各种嗅探技术，以收集信息。在本节中，您将看到无线攻击是如何发生的，这是渗透测试中非常重要的主题。
- en: The deauthentication (deauth) attack
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去认证（deauth）攻击
- en: Deauthentication frames fall under the category of the management frames. When
    a client wishes to disconnect from the AP, the client sends the deauthentication
    frame. The AP also sends the deauthentication frame in the form of a reply. This
    is the normal process, but an attacker takes advantage of this process. The attacker
    spoofs the MAC address of the victim and sends the deauth frame to the AP on behalf
    of the victim; because of this, the connection to the client is dropped. The `aireplay-ng`
    program is the best tool to accomplish a deauth attack. In this section, you will
    learn how to carry out this attack using Python. But, you can take advantage of
    the output of the `ssid_finder_raw.py` code because the `ssid_finder_raw.py` program
    writes a file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 去认证帧属于管理帧的一种。当客户端希望与AP断开连接时，客户端发送去认证帧。AP也以回复的形式发送去认证帧。这是正常的过程，但攻击者利用这个过程。攻击者伪造受害者的MAC地址，并代表受害者向AP发送去认证帧；因此，与客户端的连接被断开。`aireplay-ng`程序是执行去认证攻击的最佳工具。在本节中，您将学习如何使用Python执行此攻击。但是，您可以利用`ssid_finder_raw.py`代码的输出，因为`ssid_finder_raw.py`程序会写入一个文件。
- en: 'Now, let''s look at the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下代码：
- en: 'Import the essential modules and libraries:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入必要的模块和库：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code opens the `wireless_data.dat` file, fetches the information,
    and displays it to the user:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码打开`wireless_data.dat`文件，获取信息，并显示给用户：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code asks the user to enter the AP sequence number. If the user
    wants to specify any victim, then the user can provide the MAC of the victim''s
    machine; otherwise, the code will pick the broadcast address:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码要求用户输入AP序列号。如果用户想指定任何受害者，那么用户可以提供受害者机器的MAC；否则，代码将选择广播地址：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The channel number is being used by a selected AP; the following piece of code
    sets the same channel number for `mon0`:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所选AP正在使用的信道号；以下代码段为`mon0`设置相同的信道号：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code is very easy to understand. The `frame= RadioTap()/ Dot11(addr1=victim_mac,addr2=BSSID,
    addr3=BSSID)/ Dot11Deauth()` statement creates the deauth packet. From the very
    first screenshot in this chapter, you can check these addresses:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码非常容易理解。`frame= RadioTap()/ Dot11(addr1=victim_mac,addr2=BSSID, addr3=BSSID)/
    Dot11Deauth()`语句创建去认证数据包。从本章的第一张截图中，您可以检查这些地址：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code tells the threads to attack the deauth attack:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码告诉线程攻击去攻击deauth攻击：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the last line, `sendp(frame,iface=interface, count= 1000, inter= .1)`, `count`
    gives the total number of packets sent, and `inter` indicates the interval between
    the two packets:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，`sendp(frame,iface=interface, count= 1000, inter= .1)`，`count`给出发送的数据包总数，`inter`表示两个数据包之间的间隔：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the `deauth.py` program is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`deauth.py`程序的输出如下：'
- en: '![](img/691a0ae7-cfca-4635-b748-94d0223e6e3d.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/691a0ae7-cfca-4635-b748-94d0223e6e3d.jpg)'
- en: The aim of this attack is not only to perform a deauth attack, but also to check
    the victim's security system. IDS should have the ability to detect the deauth
    attack. So far, there is no way of avoiding the attack, but it can be detected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的目的不仅是执行去认证攻击，还要检查受害者的安全系统。IDS应该有能力检测去认证攻击。到目前为止，还没有避免攻击的方法，但可以检测到攻击。
- en: Detecting the deauth attack
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测deauth攻击
- en: In this section, we will discuss how to detect a deauthentication attack. It
    is like a wireless IDS that detects the deauthentication attack. In this program,
    we will find which access points get deauth frames and how many. We will use the
    raw socket here to detect the attack.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何检测去认证攻击。这类似于一个无线IDS，它检测去认证攻击。在这个程序中，我们将找出哪些接入点收到去认证帧以及数量。我们将在这里使用原始套接字来检测攻击。
- en: 'Let''s discuss the `deauth_ids.py` program. Make sure the monitor is on; otherwise,
    the program will give an error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`deauth_ids.py`程序。确保监视器打开；否则，程序会报错：
- en: 'Import the essential module and library:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入必要的模块和库：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The queue and counter will be used later:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列和计数器将在以后使用：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code creates and binds the raw socket to `mon0`:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码创建并绑定原始套接字到`mon0`：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following function IDs receive the deauth frames, extract the BSSID, and
    put it in the global queue:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数IDs接收去认证帧，提取BSSID，并将其放入全局队列中：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following `insert_frame` function gets the deauth frame from the global
    queue and makes a counter to display it:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下的`insert_frame`函数从全局队列中获取deauth帧并制作一个计数器来显示它：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code creates two threads that start the `ids()` and `insert_frame` functions:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码创建了两个线程，启动了`ids()`和`insert_frame`函数：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In order to perform both the attack and detection, we need two machines with
    Linux and one wireless access point. One machine will do the attack, and the second
    will run our `deauth_ids.py` detection program.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行攻击和检测，我们需要两台安装了Linux的机器和一个无线接入点。一台机器将进行攻击，第二台将运行我们的`deauth_ids.py`检测程序。
- en: 'Let''s discuss the output of the code. For testing purposes, run `deauth_ids.py`,
    and from the second machine, start the deauth attack:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论代码的输出。为了测试目的，运行`deauth_ids.py`，并从第二台机器开始deauth攻击：
- en: '![](img/60a44e84-dbbd-4df6-9c9f-424dd39a4237.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a44e84-dbbd-4df6-9c9f-424dd39a4237.jpg)'
- en: 'You can see it is continuously displaying the victim BSSID, and its counter
    shows the number of frames received. Let''s see another screenshot in the continuation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它不断地显示受害者BSSID，并且它的计数器显示接收到的帧数。让我们在下文中看另一个截图：
- en: '![](img/5653fa54-b845-41b6-8513-d1b2d4302397.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5653fa54-b845-41b6-8513-d1b2d4302397.jpg)'
- en: As you can see, if the attacker changes target, our program can detect the attack
    on multiple access points.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果攻击者改变目标，我们的程序可以检测到多个接入点上的攻击。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about wireless frames and how to obtain information,
    such as SSID, BSSID, and the channel number, from the wireless frame using the
    Python script and the scapy library. We also learned how to connect a wireless
    device to the AP. After information gathering, we moved on to wireless attacks.
    The first attack we discussed was the deauth attack, which is similar to a Wi-Fi
    jammer. In this attack, you have to attack the wireless device and see the reaction
    of the AP or the intrusion detection system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于无线帧以及如何使用Python脚本和scapy库从无线帧中获取SSID、BSSID和信道号等信息。我们还学习了如何将无线设备连接到AP。在信息收集之后，我们转向了无线攻击。我们讨论的第一种攻击是deauth攻击，类似于Wi-Fi干扰器。在这种攻击中，你必须攻击无线设备并观察AP或入侵检测系统的反应。
- en: In [Chapter 6](2273f0c1-16dc-4c51-9d74-e51a70cbb900.xhtml), *Honeypot – Building
    Traps for Attackers*, you will learn how set traps for hacker, how to create fake
    reply or fake identities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](2273f0c1-16dc-4c51-9d74-e51a70cbb900.xhtml)中，*蜜罐-为攻击者设置陷阱*，您将学习如何为黑客设置陷阱，如何创建虚假回复或虚假身份。
