# 移动安全最佳实践

在本章中，我们将涵盖以下内容：

+   安全存储数据

+   实施身份验证控件

+   保护传输中的数据

+   安全使用 Android 和 iOS 平台组件

+   保护第三方代码和组件

+   采用反向工程保护

# 介绍

移动应用程序通常是控制消费者物联网的关键。无论是智能家居设备还是连接的车辆，移动应用程序都是攻击和保持安全的理想目标。在第五章中，*利用物联网移动应用程序*，从攻击者的角度讨论了移动应用程序的利用。本章将提供用于保护常见攻击向量的移动应用程序安全防御控件。需要注意的是，本章在移动安全最佳实践方面并不是详尽无遗的，因为关于这个主题的完整书籍都是专门写的。鼓励参考补充阅读，以更深入地了解本章描述的某些控件和最佳实践。在适当的情况下，将在整个配方中提供 Android 和 iOS 的示例。根据 OWASP 的移动安全项目([`www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls`](https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls))，前 10 个移动控件包括：

1.  识别和保护敏感数据。

1.  保护身份验证凭据。

1.  保护传输中的数据。

1.  正确实施用户身份验证，授权和会话管理。

1.  保持后端 API（服务）和平台（服务器）的安全。

1.  确保与第三方服务和应用程序的数据集成安全。

1.  特别关注收集和存储用户数据收集和使用的同意。

1.  实施控件以防止未经授权访问付费资源。

1.  确保移动应用程序的安全分发/配置。

1.  仔细检查任何代码的运行时解释是否存在错误。

本章将讨论与常见物联网应用程序用例相关的几个早期提到的移动安全控件。

# 安全存储数据

移动应用程序中的敏感数据取决于物联网设备的性质。许多设备可能在移动设备上存储个人数据，收集个人数据，患者健康信息（PHI），信用卡信息，并存储用于对物联网设备进行身份验证的帐户凭据。泄露的凭据或长期的会话令牌可能对智能门锁和连接的车辆产生重大影响。这些敏感数据必须通过控件和验证来进行保护。许多时候，敏感数据会无意中暴露给在移动设备上运行的第三方应用程序，用于操作系统的进程间通信（IPC）。此外，丢失移动设备，或在旅行时被盗或被扣押也并非罕见。在这些情况下，应用程序必须采用适当的安全控件来保护敏感数据，并使获取数据变得更加困难。在本章中，我们将讨论安全存储敏感数据的方法。

# 准备就绪

在这个配方中，将使用 SQLCipher 来演示安全数据库存储的方法。

SQLCipher 可以从以下网页下载：

[`www.zetetic.net/sqlcipher/`](https://www.zetetic.net/sqlcipher/)

# 如何做...

Android 和 iOS 平台都有本地方法来安全存储敏感数据。对于 Android，敏感数据可以存储在 KeyStore 中。对于 iOS，敏感数据可以存储在 Keychain 中。重要的是要注意，如果设备被 root 或越狱，Android 的 KeyStore 和 iOS 的 Keychain 内容可以被转储。但是，如果 Android 设备具有**可信执行环境**（**TEE**）或**安全元素**（**SE**），则 KeyStore 对操作系统不可直接访问，保存的数据也将无法访问。除了本地平台 API 可用于安全存储数据外，还有第三方库可用于加密磁盘上的数据或整个 SQLite 数据库，如 SQLCipher。SQLCipher 适用于 Android 和 iOS，如果 SQLite 数据库用于 IoT 设备，则应该用于安全存储数据。

1.  要在 Android 应用程序中使用 SQLCipher，我们需要创建一个活动，初始化 SQLCipher 数据库，并将数据保存在适当的数据库表和列中，如下例所示：

```
public class SQLCipherExampleActivity extends Activity { 
    @Override 
    public void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.main); 
        InitSQLCipher(); 
    } 

    private void InitSQLCipher() { 
        SQLiteDatabase.loadLibs(this); 
        File databaseFile = getDatabasePath("EncStorage.db"); 
        databaseFile.mkdirs(); 
        databaseFile.delete(); 
        SQLiteDatabase secureDatabase = SQLiteDatabase.openOrCreateDatabase(databaseFile, "PacktDB", null); 
        secureDatabase.execSQL("CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,Password VARCHAR);"); 
        secureDatabase.execSQL("INSERT INTO Accounts VALUES('PacktUser','EncPassword');"); 
         secureDatabase.close();    
   } 
}
```

1.  在之前的示例中没有包括的一个重要步骤是建立 PRAGMA 密钥。这个 PRAGMA 密钥是 SQLCipher 数据库的加密密钥，应该在每个用户和设备的应用程序初始化期间动态生成。PRAGMA 密钥应该具有足够的熵，并且不应该硬编码到应用程序中或存储在非硬件支持的存储位置（例如，安全元素）。

Android 常见的不安全存储位置是`SharedPreferences.xml`，开发人员经常用来存储设置和配置。存储在`SharedPreferences.xml`中的数据是明文可读的，除非使用第三方包装器来加密偏好设置的值。

对于 iOS，数据不应存储在应用程序容器内的文件中，也不应存储在明文 plist 文件中。Keychain 应该用于所有凭据和令牌数据，并根据应用程序运行的上下文使用适当的 Keychain API 属性。例如，如果应用程序不在后台运行，则使用最严格的属性，如`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`，这可以防止 Keychain 项目被 iTunes 备份，或者使用`kSecAttrAccessibleWhenUnlocked`。如果应用程序需要在前台运行，则使用`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`属性。

1.  在存储数据时，有几个适用于 Android 和 iOS 的最佳实践需要遵循。常见的最佳实践包括：

1. 尽量不要存储敏感数据。

2. 只存储应用程序功能所需的数据。

3. 避免将敏感数据存储在缓存、外部存储器（SD 卡）或临时文件中。

4. 不要将敏感数据记录到磁盘或控制台。

5. 禁用对敏感输入字段的键盘缓存。

6. 限制应用程序数据的备份。

7. 如果敏感数据存储在磁盘上，加密其内容并将数据存储在防篡改的位置，如安全元素。

8. 确保应用程序在使用后和不再需要时从内存中擦除敏感数据。

9. 确保对敏感文本字段禁用剪贴板。

有时，平台安全 API（如 KeyStore 和 Keychain）可能不足以确保敏感数据的保密性和完整性。在这些情况下，建议使用应用级加密来增强保护，然后将加密数据存储在平台的安全存储位置中。

# 另请参阅

+   有关 Keychain 的更多信息，请参阅*苹果的 Keychain 服务编程指南*（[`developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#/`](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html%23/)）。

+   有关 Keychain 的更多信息，请参阅*Android 的开发者*文档（[`developer.android.com/training/articles/keystore.html`](https://developer.android.com/training/articles/keystore.html)）。

+   有关使用 SQLCipher 的更多信息，请参阅*SQLCipher 的 API 开发者*文档（[`www.zetetic.net/sqlcipher/sqlcipher-api/`](https://www.zetetic.net/sqlcipher/sqlcipher-api/)）。

# 实施身份验证控制

移动应用程序的身份验证可以同时发生在服务器端和客户端。IoT 移动应用程序可以利用这两种设计模式，尽管在生产中实施时每种都有自己的风险考虑。本节将讨论一些这些风险以及服务器端和客户端身份验证的最佳实践设计实施。

# 如何做到...

安全地验证用户的一般应用程序原则也适用于移动应用程序。一个很好的参考是 OWASP 的*身份验证备忘单*（[`www.owasp.org/index.php/Authentication_Cheat_Sheet`](https://www.owasp.org/index.php/Authentication_Cheat_Sheet)）。常见的身份验证控件和最佳实践包括：

+   适当的密码强度控制

+   密码长度

+   10 个或更多字符

+   密码复杂性策略

+   1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符，并且不允许连续 2 个字符，如 222

+   强制密码历史记录

+   禁止使用过的最后三个密码（密码重用）

+   仅通过加密通信（TLS）传输凭据

+   通过`HTTP POST`主体发送凭据

+   重新验证用户以使用敏感功能

+   更改密码

+   更改帐户 PIN

+   更改安全问题

+   共享摄像头视频

+   解锁车辆

+   确保身份验证错误消息不会透露潜在的敏感信息

+   正确的错误响应如下，无效的用户名和/或密码

+   确保记录身份验证功能以检测登录失败

+   防止自动暴力攻击

+   使用 CAPTCHA 或类似功能

+   限制可疑登录尝试的速率

+   在给定阈值后暂时锁定帐户并发送电子邮件到帐户地址

+   确保多因素身份验证存在并在登录时执行，以及在使用逐步身份验证访问资源时执行。双因素方法包括：

+   除密码外，还有用户已知的值

+   通过电子邮件或短信发送的一次性密码（OTP）或代码

+   除用户密码外，还有一个 OTP 的物理令牌

前述项目适用于 Web 应用程序、混合移动应用程序，甚至本机移动应用程序。以下项目是特定于移动设备的身份验证最佳实践，可实施到应用程序中：

+   如果使用生物识别技术，请确保使用 KeyStore 和 Keychain 而不是基于事件的方法

+   会话在服务器端被使无效

+   应用程序列出最后的登录活动并允许用户阻止设备

+   避免使用设备 UUID、IP 地址、MAC 地址和 IMEI 进行身份验证或授权目的

+   在移动应用程序之外使用第三方 OTP 应用程序（例如 Google 或 Salesforce 认证器）

Android 特定的身份验证实践如下所示：

+   使用 Android 的 FingerprintManager 类（[`developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html`](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html)），使用`KeyGenerator`类与非对称密钥对。有关使用非对称密钥对的示例，请参见[`github.com/googlesamples/android-AsymmetricFingerprintDialog`](https://github.com/googlesamples/android-AsymmetricFingerprintDialog)。

+   在 Android Nougat API 24 中引入，使用`setInvalidatedByBiometricEnrollment`（`boolean invalidateKey`）方法来使新的指纹无法从移动设备上检索密钥。

+   应用程序应利用 SafetyNet reCAPTCHA API 来保护免受基于机器人的暴力攻击的身份验证。

要使用 SafteyNet reCAPTCHA API，必须执行以下步骤：

1.  通过[`www.google.com/recaptcha/admin#androidsignup`](https://www.google.com/recaptcha/admin%23androidsignup)注册 reCAPCTHA 密钥对：

![](img/018e9535-f65e-46ef-946c-7ecc3e5aa292.png)

1.  如果尚未配置，必须添加 SafetyNet API 依赖项和 Google Play 服务。例如，在项目构建 gradle 文件中包括`com.google.android.gms:play-services-safetynet:11.4.2`，如下所示：

```
apply plugin: 'com.android.application' 

android { 
    compileSdkVersion 23 
    buildToolsVersion '25.0.0' 

    defaultConfig { 
        applicationId "jakhar.aseem.diva" 
        minSdkVersion 15 
        targetSdkVersion 23 
        versionCode 1 
        versionName "1.0" 
    } 
    buildTypes { 
        release { 
            minifyEnabled enabled 
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' 
        } 
    } 
    sourceSets { 
        main { 
            jni.srcDirs = [] 
        } 
    } 
} 

dependencies { 
    compile fileTree(dir: 'libs', include: ['*.jar']) 
    testCompile 'junit:junit:4.12' 
    compile 'com.android.support:appcompat-v7:23.1.0' 
    compile 'com.android.support:design:23.1.0' 
    compile 'com.google.android.gms:play-services-safetynet:11.4.2' 
}
```

1.  必须通过`verifyWithRecaptcha()`（[`developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String)`](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String))）发出调用验证请求的请求。此请求必须包含 API 站点密钥作为参数，并且必须覆盖`onSuccess()`和`onFailure()`方法。以下代码片段显示了如何调用此方法，提供了 Android 的开发人员指南（[`developer.android.com/training/safetynet/recaptcha.html#send-request`](https://developer.android.com/training/safetynet/recaptcha.html%23send-request)）：

```
public void onClick(View v) { 
    SafetyNet.getClient(this).verifyWithRecaptcha(YOUR_API_SITE_KEY) 
        .addOnSuccessListener((Executor) this, 
            new OnSuccessListener<SafetyNetApi.RecaptchaTokenResponse>() { 
                @Override 
                public void onSuccess(SafetyNetApi.RecaptchaTokenResponse response) { 
                    // Indicates communication with reCAPTCHA service was 
                    // successful. 
                    String userResponseToken = response.getTokenResult(); 
                    if (!userResponseToken.isEmpty()) { 
                        // Validate the user response token using the 
                        // reCAPTCHA siteverify API. 
                    } 
                } 
        }) 
        .addOnFailureListener((Executor) this, new OnFailureListener() { 
                @Override 
                public void onFailure(@NonNull Exception e) { 
                    if (e instanceof ApiException) { 
                        // An error occurred when communicating with the 
                        // reCAPTCHA service. Refer to the status code to 
                        // handle the error appropriately. 
                        ApiException apiException = (ApiException) e; 
                        int statusCode = apiException.getStatusCode(); 
                        Log.d(TAG, "Error: " + CommonStatusCodes 
                                .getStatusCodeString(statusCode)); 
                    } else { 
                        // A different, unknown type of error occurred. 
                        Log.d(TAG, "Error: " + e.getMessage()); 
                    } 
                } 
        }); 
} 
```

1.  通过`SafetyNetApi.RecaptchaTokenResult.getTokenResult()`验证响应令牌。JSON HTTP 响应的示例如下：

```
{ 
  "success": true|false, 
  "challenge_ts": timestamp,  // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ) 
  "apk_package_name": string, // the package name of the app where the reCAPTCHA was solved 
  "error-codes": [...]        // optional 
} 
```

1.  接下来，必须添加逻辑来处理失败和错误。SafetyNet reCAPTCHA API 使用七个状态代码：

1\. `RECAPTCHA_INVALID_SITEKEY`

2\. `RECAPTCHA_INVALID_KEYTYPE`

3\. `RECAPTCHA_INVALID_PACKAGE_NAME`

4\. `UNSUPPORTED_SDK_VERSION`

5\. `TIMEOUT`

6\. `NETWORK_ERROR`

7\. `ERROR`

有关每个状态代码的详细信息，请参阅以下参考页面：

[`developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes.`](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes)

接下来列出了特定于 iOS 的身份验证实践：

+   将应用程序的秘密存储在受访问控制的钥匙串列表中以供特定应用程序使用。可以在苹果的开发人员文档中找到使用钥匙串和 Touch ID 的示例代码片段，网址为[`developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html`](https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html)。

+   确保应用程序从`LAContext.evaluatedPolicyDomainState`中读取，以检查`evaluatedPolicyDomainState`值是否已更改，指示已注册的 Touch ID 指纹是否已更改。

+   除非应用程序需要，否则禁止钥匙串通过`kSecAttrSynchronizable`与 iCloud 同步。

Touch ID 是一种常见的用户身份验证方法；但是，有几种方法和工具可以绕过仅使用本地身份验证框架的应用程序。如前所述，使用钥匙串 ACL 可以防止攻击者在运行时覆盖`LAContextevaluatePolicy:localizedReason:reply`方法或对应用程序本身进行打补丁。

# 另请参阅

+   有关 iOS 钥匙串服务的更多信息，请参阅*钥匙串服务编程指南*（[`developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html`](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html)）

+   有关使用指纹 API 对远程服务器进行身份验证的更多信息，请访问 Android 的开发者博客（[`android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html`](https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html)）

+   查看安卓开发者页面上关于 SafetyNet reCAPTCHA API 的信息（[`developer.android.com/training/safetynet/recaptcha.html`](https://developer.android.com/training/safetynet/recaptcha.html)）

# 保护数据在传输中

保护物联网移动应用的端到端通信一直是一个难题。通常，数据会通过明文协议泄露，比如 HTTP 或 UDP（SIP）用于音频传输到移动应用。偶尔，物联网制造商被发现向第三方泄露数据，这些第三方只通过 HTTP 通信或者使用较不安全的加密配置进行内容识别或崩溃报告分析服务。保护数据在传输中的目标是确保移动应用、物联网设备和 API 端点之间交换的数据的机密性和完整性。移动应用必须使用 TLS 建立安全加密通道进行网络通信，并配置适当的密码套件。对于智能锁或连接车辆等设备，这是必须的。本文将介绍保护物联网移动应用中传输数据的最佳实践。

# 如何做...

保护移动应用中传输数据有共同的要求和最佳实践。保护传输数据的最佳实践包括但不限于以下内容：

+   使用平台支持的最新 TLS 和密码套件配置

+   验证服务器 X.509 证书

+   验证证书主机名

+   只接受由受信任的证书颁发机构签名的证书，其中包括公共 CA 以及内部受信任的 CA

+   禁止使用自签名证书

+   将连接固定到受信任的证书和/或公钥

实现在安卓和 iOS 之间有所不同。两个平台都有本地的加密 API；但是，也有第三方封装库可用，但可能没有证书固定等功能。

# 安卓

在上面的示例中，一个安卓应用程序创建了一个包含 CA（受信任证书）的 KeyStore，初始化了 TrustManager，其工作是仅验证 KeyStore 中的证书：

1.  创建线程安全的`KeyPinStore`类（public static synchronized）：

```
public class KeyPinStore { 

    private static KeyPinStore instance = null; 
    private SSLContext sslContext = SSLContext.getInstance("TLS"); 

    public static synchronized KeyPinStore getInstance() throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException{ 
        if (instance == null){ 
            instance = new KeyPinStore(); 
        } 
        return instance; 
    } 
```

1.  加载应用程序资产目录中的 CA：

```
private KeyPinStore() throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException{ 
        CertificateFactory cf = CertificateFactory.getInstance("X.509"); 
        // randomCA.crt should be in the Assets directory 
        InputStream caInput = new BufferedInputStream(MainActivity.context.getAssets().open("TrustedCompanyCA.crt")); 
        Certificate ca; 
        try { 
            ca = cf.generateCertificate(caInput); 
            System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN()); 
        } finally { 
            caInput.close(); 
        }
```

1.  创建包含我们指定的受信任 CA 的 KeyStore：

```
String keyStoreType = KeyStore.getDefaultType(); 
KeyStore keyStore = KeyStore.getInstance(keyStoreType); 
keyStore.load(null, null); 
keyStore.setCertificateEntry("ca", ca); 
```

1.  创建 TrustManager 以验证我们 KeyStore 中的 CA：

```
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); 
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); 
tmf.init(keyStore); 
```

1.  创建使用我们的 TrustManager 的 SSLContent：

```
sslContext.init(null, tmf.getTrustManagers(), null); 
    } 

    public SSLContext getContext(){ 
        return sslContext; 
    } 
} 
```

1.  告诉 URLConnection 在与应用程序的 API 端点通信时使用来自我们的 SSLContext 的 SocketFactory：

```
URL url = new URL("https://example.com/rest/apiEndpoint"); 
HttpsURLConnection urlConnection = 
    (HttpsURLConnection)url.openConnection(); 
urlConnection.setSSLSocketFactory(context.getSocketFactory()); 
InputStream in = urlConnection.getInputStream(); 
copyInputStreamToOutputStream(in, System.out); 
```

一个可以帮助确保正确的 TLS/SSL 配置的工具是 Google 发布的 nogotofail。nogotofail 不仅检查配置，还确保不使用易受攻击的 TLS/SSL 协议，以及通过 MITM 技术查看从客户端设备发送的数据。要了解有关 nogotofail 的更多信息，请访问项目的 GitHub 页面[`github.com/google/nogotofail`](https://github.com/google/nogotofail)。

# iOS

类似的操作可以用于在 iOS 中将证书和/或证书的公钥指纹固定。固定是通过`NSURLConnectionDelegate`执行的，其中必须在`connection:didReceiveAuthenticationChallenge:`中实现`connection:canAuthenticateAgainstProtectionSpace:`和`connection:didReceiveAuthenticationChallenge:`，并调用`SecTrustEvaluate`执行 X509 验证检查。在部署此类检查时，可以使用 OWASP 提供的 iOS 固定应用程序示例作为参考。可以通过以下链接下载示例程序：

[`www.owasp.org/images/9/9a/Pubkey-pin-ios.zip`](https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip)

除了所有应用程序在使用 TLS 时应遵循的一般最佳实践外，iOS 还有一个新功能，开发人员可以利用，并且在将来提交到苹果的 App Store 时将被要求（[`developer.apple.com/news/?id=12212016b`](https://developer.apple.com/news/?id=12212016b)）。这个功能被称为**应用传输安全**（**ATS**），在 iOS 9 中引入，并默认启用。ATS 要求应用程序使用 TLSv1.2 进行 HTTPS 通信，使用**完美前向保密**（**PFS**）以及特定的密码套件。如果应用程序不符合最低要求，将不允许连接到 iOS 应用程序。这对所有物联网设备都是很好的；然而，有方法可以绕过 ATS。具体来说，开发人员可以通过在`Info.plist`文件中使用`NSAllowsArbitraryLoads`配置来完全禁用 ATS，如下面的屏幕截图所示：

![](img/923236c5-0e58-41f1-89e5-0814cdd7ef0c.png)

不幸的是，由于缺乏加密和/或 PKI 知识，这在物联网应用程序中非常普遍。ATS 还可以提供针对每个域或全局的异常，而不是完全禁用 ATS。以下是可以应用于以下配置的非详尽列表的异常：

+   禁用 PFS（`NSExceptionRequiresForwardSecrecy`）

+   为媒体禁用 ATS（`NSAllowsArbitraryLoadsForMedia`）

+   允许通过 HTTP 进行不安全连接（`NSExceptionAllowsInsecureHTTPLoads`）

+   降低最低 TLS 版本（`NSExceptionMinimumTLSVersion`）

+   允许连接到本地域名（`NSAllowsLocalNetworking`）

苹果提供了一个检查应用传输安全问题的工具，名为 nscurl。可以通过执行以下命令来使用 nscurl：

```
$ nscurl --ats-diagnostics https://www.packtpub.com  
```

苹果正在做出有希望的改变，以影响开发人员确保数据在传输中得到安全保护。如前所述，所有提交到 App Store 的应用程序将被要求在未来支持 ATS，具体时间由苹果宣布。

# 另请参阅

+   OWASP 提供的一个示例 Android 公钥固定应用程序可以通过以下 URL 下载：

[`www.owasp.org/images/1/1f/Pubkey-pin-android.zip`](https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip)

+   请参阅以下苹果开发人员指南，了解有关 ATS 要求的更多信息：

[`developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW57`](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html%23/apple_ref/doc/uid/TP40009251-SW57)

# 安全地使用 Android 和 iOS 平台组件

当物联网移动应用程序执行或检索来自第三方应用程序的命令时，内部平台 API 用于**进程间通信**（**IPC**）。IPC 可用于集成应用程序，使其调用费用跟踪应用程序、IFTTT 等第三方服务应用程序，或亚马逊的 Alexa 等个人助手。Android 等平台提供了丰富的 IPC 功能，而 iOS 只提供了几个选项。大多数物联网应用程序使用平台和硬件功能与物理世界进行交互，这反过来会在对手成功利用漏洞时产生更大的影响。在本教程中，我们将讨论如何在 IPC 周围应用安全控制以及如何安全地使用平台 API。

# 如何做到…

与源自应用程序的命令在移动平台上进行交互是一种强大的能力。如果没有得到适当的保护，未经授权的应用程序可能会劫持命令并访问本不应被未经意的第三方接收的数据。在使用平台 API 时，应考虑以下做法：

+   除非这些机制得到适当保护，否则不要通过 IPC 导出敏感功能。

+   来自外部来源和用户的输入应该在必要时进行验证和清理。这包括通过用户界面、IPC 机制（如意图、自定义 URL 处理程序）和网络来源接收的数据。

+   WebViews 应该配置为仅允许加载所需的最小协议处理程序，如 HTTPS，并禁用其他危险的处理程序，如`file://`、`tel://`、`sms://`和`app-id://`。

+   将 IPC 调用限制为受信任应用程序的白名单。

+   将 Web 页面和 URL 处理程序列入白名单，以便本地或远程加载。

+   仅请求应用程序功能所需的最小权限集。

+   通过 WebViews 公开的本地方法应该验证，只有应用程序沙盒内的 JavaScript 才能被渲染。

+   除非明确需要，否则 WebViews 应该禁用 JavaScript。

+   序列化应该只使用安全的序列化 API，并进行加密签名。

大多数列出的做法都可以应用于 Android 和 iOS 平台；但是，根据应用程序的功能，应该审查特定的考虑因素，如 Android 权限、自定义权限和保护级别。

以下是一个名为`IOT_COOKBOOK_ACTIVITY`的自定义权限的示例，当启动`MAIN_ACTIVITY``Activity`时需要该权限。

1.  第一个代码块使用标签定义了新的权限，并描述了`Activity`。接下来，根据权限类型设置了保护级别。一旦权限被定义，就可以通过在应用程序的`AndroidManifest.xml`文件中指定`uses-permission`来强制执行该组件上的权限。在下面的示例中，第二个块是我们将使用我们定义的权限来限制的组件。可以通过添加`android:permission`属性来强制执行：

```
<permission android:name="com.packtpub.cookbook.permission.IOT_COOKBOOK_ACTIVITY" 
        android:label="Start main Activity in packtpub" 
        android:description="Allow only apps signed with the same certificate to launch this Activity." 
        android:protectionLevel="signature" /> 

<activity android:name="MAIN_ACTIVITY" 
    android:permission="com.packtpub.cookbook.permission.IOT_COOKBOOK_ACTIVITY"> 
    <intent-filter> 
        <action android:name="android.intent.action.MAIN" /> 
        <category android:name="android.intent.category.LAUNCHER"/> 
     </intent-filter> 
</activity> 
```

1.  现在创建了新的权限`IOT_COOKBOOK_ACTIVTY`，应用程序可以在`AndroidManifest.xml`文件中使用`uses-permission`标签请求该权限。在这种情况下，必须是使用相同证书签名的应用程序才能启动`MAIN_ACTIVITY`：

```
<uses-permission android:name="com.example.myapp.permission.IOT_COOKBOOK_ACTIVITY"/> 
```

在引入自定义权限和保护级别时，始终参考 Android 的开发者文档是一个好主意。所有 Android 权限都可以在 Android 开发者文档中找到：[`developer.android.com/guide/topics/permissions/requesting.html`](https://developer.android.com/guide/topics/permissions/requesting.html)。

在 iOS 应用程序中，由于 iOS 的封闭生态系统，权限不适用。但是，iOS 和 Android 共享 WebViews，这使得可以在应用程序内加载网页。与 Web 应用程序类似，恶意代码可以在 WebViews 中执行。在减少 IoT 应用程序的攻击面时，这一点很重要。

1.  以下代码片段说明了如何在 iOS 应用程序中禁用 WKWebViews 中的 JavaScript：

```
#import "ViewController.h" 
#import <WebKit/WebKit.h> 
@interface ViewController ()<WKNavigationDelegate,WKUIDelegate> 
@property(strong,nonatomic) WKWebView *webView; 
@end 

@implementation ViewController 

- (void)viewDidLoad { 

    NSURL *url = [NSURL URLWithString:@"https://www.packtpub.com/"]; 
    NSURLRequest *request = [NSURLRequest requestWithURL:url]; 
    WKPreferences *pref = [[WKPreferences alloc] init]; 

    [pref setJavaScriptEnabled:NO]; 
    [pref setJavaScriptCanOpenWindowsAutomatically:NO]; 

    WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init]; 
    [conf setPreferences:pref]; 
    _webView = [[WKWebView alloc]initWithFrame:CGRectMake(self.view.frame.origin.x,85, self.view.frame.size.width, self.view.frame.size.height-85) configuration:conf] ; 
    [_webView loadRequest:request]; 
    [self.view addSubview:_webView]; 

}
```

1.  对于 Android 应用程序，禁用 JavaScript 是通过配置 WebView 的`WebSettings`来完成的，如下所示。还应该配置其他设置，如禁用文件系统访问、关闭插件和关闭地理位置信息（如果不需要）：

```
WebView webview = new WebView(this); 
WebSettings webSettings = webview.getSettings(); 
webSettings.setJavaScriptEnabled(false); 
webView.getSettings().setPluginState(WebSettings.PluginState.OFF); 
webView.getSettings().setAllowFileAccess(false); 
webView.getSettings().setGeolocationEnabled(false); 
setContentView(webview); 
webview.loadUrl("https://www.packetpub.com/"); 
```

在考虑最小权限和深度安全原则的情况下，应用程序应该只利用和暴露平台组件以满足所需的业务功能。作为一个经验法则，从第三方应用程序发送和检索的任何数据都应该被视为不可信，并进行适当的验证。

# 保护第三方代码和组件

与所有软件一样，移动应用程序大量使用第三方库和包装器来执行诸如发出 HTTP 请求或加密对象之类的功能。这些库也可能会给应用程序引入弱点，暴露机密信息或影响应用程序本身的完整性。因此，应该审查第三方代码以发现漏洞，并在适用的情况下进行更新和测试。对于依赖第三方混合框架和库来发送、接收和保存数据的混合应用程序来说，这一点尤为重要。本文将讨论确保第三方代码不会给物联网应用程序引入漏洞的方法。

# 操作方法...

在第八章中，*固件安全最佳实践*，讨论了使用 NSP 和 Retire.js 扫描 JavaScript 库的方法，这些方法仍然适用于移动应用程序。为确保第三方代码不会给移动应用程序引入安全漏洞，应考虑以下建议：

+   使用工具如 nsp、Retirejs 和 dependency-check ([`github.com/jeremylong/DependencyCheck`](https://github.com/jeremylong/DependencyCheck)) 连续记录库和框架的版本及其依赖关系

+   为移动应用程序中使用的所有组件和第三方软件创建清单

+   通过分析工具连续监视 NVD 等漏洞数据库，以自动化流程

+   分析第三方库以确保它们在运行时被调用，并删除应用功能不需要的函数

+   确保混合框架使用最新版本。

+   监视混合框架的发布和博客，以确保没有已知的带有漏洞的组件在使用中

+   在框架开发者没有合并上游库的情况下，修补易受攻击的库

+   监视使用的开源代码库以发现安全问题和关注点

+   确保混合框架插件在使用前已经审查过安全漏洞

+   利用更新的安卓版本 API 来利用新引入的功能（苹果强制 iOS 更新）

+   审查安卓和 iOS 的安全公告以发现平台漏洞和新的安全功能

最常见的移动混合框架之一是 Apache 的 Cordova。Cordova 可以通过以下命令更新到 iOS 和安卓：

```
cordova platform update ios
cordova platform update android@<version number>

```

Cordova 以受到研究人员的关注而闻名，并且通常在新版本中包含了针对安卓和 iOS 的安全更新。Cordova 的发布说明可以在他们的博客中找到，位于 [`cordova.apache.org/blog/`](https://cordova.apache.org/blog/)。一个寻找尚未发布的错误的好地方是框架的错误跟踪系统，比如 Cordova 的 ([`issues.apache.org/jira/projects/CB/summary`](https://issues.apache.org/jira/projects/CB/summary))。你会惊讶地看到修复、报告和关闭的错误数量。例如，另一个常用的混合框架是 Xamarin。Xamarin 的凭证管理器在 2014 年 4 月至 2016 年底之间使用了一个硬编码的安卓密钥库密码，使得账户凭证面临被妥协的风险，直到后来修复了这个问题。这可以在项目的 GitHub 仓库中找到 [`github.com/xamarin/Xamarin.Auth/issues/55`](https://github.com/xamarin/Xamarin.Auth/issues/55)。

# 另请参阅

+   谷歌对在 Google Play 中使用的设备进行快照，并将这些数据发布到仪表板上，以帮助支持不同设备的优先级排序 ([`developer.android.com/about/dashboards/index.html`](https://developer.android.com/about/dashboards/index.html))

+   每个月，谷歌都会发布 Android 安全公告，列出公告、CVE 漏洞、严重程度和缓解措施。Android 安全公告可以在[`source.android.com/security/bulletin/`](https://source.android.com/security/bulletin/)找到。

+   苹果每年都会发布一份 iOS 安全指南，详细介绍平台安全功能和新的 iOS 版本的安全控制能力。iOS 安全指南可以在[`www.apple.com/business/docs/iOS_Security_Guide.pdf`](https://www.apple.com/business/docs/iOS_Security_Guide.pdf)找到。

# 采用反向工程保护

当存在内部和外包团队的代码库用于用户体验（UX）、特定功能集（例如在应用启动期间查找设备、确保规则设置正确执行等）时，编写安全代码可能会很困难，还有其他一些功能，例如确保应用更新不会对网络中的物联网设备产生负面影响。对于一个应用来说，存在这样的复杂性，错误很可能会被发现，并且安全控制可能会被攻击者绕过。是的，这对于任何软件来说都是不可避免的，尽管有技术可用于使反向工程对攻击者更加困难，以便攻击者不会妥协应用程序并窃取公司的知识产权（IP）。

这些技术可以内置到应用程序逻辑中，以防止运行时修改，通过对应用程序类进行混淆来进行应用程序二进制文件的静态分析，并对数据进行分段以准备潜在的妥协。重要的是要注意，应用程序仍然需要在应用程序中构建安全控制，而不是用第三方软件保护替换控制。本文将介绍使应用程序更具抵抗力的做法。这些做法不仅会使应用程序更具抵抗力，还将作为应用程序反滥用系统的一部分，为应用程序提供深度防御。

# 如何做…

在实施应用程序反向工程控制和代码修改技术时，应遵循以下做法：

+   应用程序应该检测并响应已越狱或越狱设备，可以通过警告用户或终止应用程序来实现

+   通过混淆类和方法来阻碍动态分析对构建的影响

+   在可能的情况下，首选硬件支持的进程隔离，而不是混淆

+   应用程序应该防止调试并阻止调试器的连接

+   应用程序应该检测反向工程工具和框架的存在

+   应用程序应该检测是否在模拟环境中运行，并做出适当的响应

+   生产版本应该剥离符号

+   生产版本不应包含调试代码或可调试功能，例如`android:debuggable="false"`

+   Android 应用程序可以使用 SafetyNet Attestation API 兼容性检查来确保应用程序未被未知来源修改

+   应该使用 SafetyNet Verify Apps API 来检查设备上是否安装了任何潜在有害的应用程序（[`developer.android.com/training/safetynet/verify-apps.html`](https://developer.android.com/training/safetynet/verify-apps.html)）

iOS 应用程序可以寻找常见的越狱基于文件的检查，例如以下列表（[`github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md`](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md)）：

```
/Applications/Cydia.app
/Applications/FakeCarrier.app
/Applications/Icy.app
/Applications/IntelliScreen.app
/Applications/MxTube.app
/Applications/RockApp.app
/Applications/SBSettings.app
/Applications/WinterBoard.app
/Applications/blackra1n.app
/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist
/Library/MobileSubstrate/DynamicLibraries/Veency.plist
/Library/MobileSubstrate/MobileSubstrate.dylib
/System/Library/LaunchDaemons/com.ikey.bbot.plist
/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist
/bin/bash
/bin/sh
/etc/apt
/etc/ssh/sshd_config
/private/var/lib/apt
/private/var/lib/cydia
/private/var/mobile/Library/SBSettings/Themes
/private/var/stash
/private/var/tmp/cydia.log
/usr/bin/sshd
/usr/libexec/sftp-server
/usr/libexec/ssh-keysign
/usr/sbin/sshd
/var/cache/apt
/var/lib/apt
/var/lib/cydia  
```

此外，iOS 应用程序可以尝试执行根级系统 API 调用或通过向应用程序沙盒之外的文件写入数据来检测设备是否已越狱。

安卓应用程序可以使用类似的方法来检查常见的已 root 设备文件，并尝试以 root 身份执行命令。常见的已 root 文件和应用程序列表如下所示（[`github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md`](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md)）：

```
    /system/xbin/busybox
    /sbin/su
    /system/bin/su
    /system/xbin/su
    /data/local/su
    /data/local/xbin/su
    com.thirdparty.superuser
    eu.chainfire.supersu
    com.noshufou.android.su
    com.koushikdutta.superuser
    com.zachspong.temprootremovejb
    com.ramdroid.appquarantine

```

此外，检查自定义的 Android ROM 版本可以指示已 root 设备，尽管这不是一个确定的方法。

应该使用多种检查和防御方法来确保弹性。总体目标是确保攻击者无法篡改、修改代码、执行运行时修改和逆向工程应用程序包以防止滥用。前述实践中的一些可以在应用程序启动时和整个运行时引入到应用程序逻辑中。商业解决方案可用于执行一些早期列出的实践以及更多内容；但是，在集成到应用程序之前，应该经过审查。

# 还有更多...

要了解移动应用程序逆向工程和未经授权的代码修改的风险，请参考 OWASP 的逆向工程和代码修改预防项目[`www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project`](https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project)。该项目非常好地描述了技术和业务风险用例，并提供了补充的缓解建议。

# 另请参阅

+   有关通过 SafetyNet API 请求兼容性检查的更多信息，请参阅以下 Android 开发者页面（[`developer.android.com/training/safetynet/attestation.html#cts-check`](https://developer.android.com/training/safetynet/attestation.html#cts-check)）。
