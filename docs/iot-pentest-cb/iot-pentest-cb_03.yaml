- en: Analyzing and Exploiting Firmware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析和利用固件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Defining firmware analysis methodology
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义固件分析方法
- en: Obtaining firmware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取固件
- en: Analyzing firmware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析固件
- en: Analyzing file system contents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析文件系统内容
- en: Emulating firmware for dynamic analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟固件进行动态分析
- en: Getting started with ARM and MIPS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用ARM和MIPS
- en: Exploiting MIPS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用MIPS
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have covered the basics of what an IoT ecosystem consists of and
    identifying threats with their respective risks via threat modeling to assist
    with our testing. Some vulnerabilities and threats may be simpler to identify
    purely through reconnaissance of the technology in use. In this chapter, we will
    focus our efforts purely on reverse engineering firmware to analyze its contents
    for manipulation during its runtime. We will roll up our sleeves, so to speak,
    and discuss how to disassemble firmware, how to analyze firmware contents, its
    architecture, using common firmware tools, and how to modify firmware for malicious
    purposes. Similar to other software reverse engineering methodologies, analyzing
    firmware is definitely an art in itself. You will learn that a number of tools
    will assist us in looking for common flaws; however, analyzing the security of
    a firmware binary image is very much a manual process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了物联网生态系统的基础知识，并通过威胁建模识别了其相应的风险，以帮助我们的测试。一些漏洞和威胁可能更容易通过对正在使用的技术进行侦察来识别。在本章中，我们将把精力完全集中在逆向工程固件上，以分析其内容以在运行时进行操纵。我们将讨论如何分解固件，如何分析固件内容，其架构，使用常见固件工具，以及如何修改固件以进行恶意用途。与其他软件逆向工程方法一样，分析固件绝对是一门艺术。您将了解到一些工具将帮助我们寻找常见的缺陷；然而，分析固件二进制镜像的安全性在很大程度上是一个手动过程。
- en: Before we begin analyzing firmware, it is important to discuss the general methodology
    of obtaining firmware as well as frame what pieces of data are important to us.
    This step may have been completed in a light threat model exercise of the firmware
    beforehand but let us begin with discussing the goals of firmware analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始分析固件之前，重要的是讨论获取固件的一般方法以及哪些数据对我们来说是重要的。这一步可能已经在之前对固件进行轻量级威胁建模的过程中完成，但让我们从讨论固件分析的目标开始。
- en: Defining firmware analysis methodology
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义固件分析方法
- en: 'Firmware is the center of controlling IoT devices, which is why we may want
    to start analyzing its contents before other pieces of the device''s components.
    Depending on the industry your IoT device is manufactured for, obtaining a firmware
    image and disassembling its contents may be trivial. Similarly, some industry
    verticals require certain safeguards that may make reverse engineering more difficult
    and/or time-consuming. Nevertheless, there are common patterns we will look for
    when analyzing firmware. Usually, the most common goals of an assessor will be
    to locate the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 固件是控制物联网设备的中心，这就是为什么我们可能希望在分析设备的其他部件之前先分析其内容。根据您的物联网设备所制造的行业，获取固件镜像并分解其内容可能是微不足道的。同样，一些行业领域需要特定的保障措施，这可能会使逆向工程变得更加困难和/或耗时。然而，在分析固件时，我们将寻找一些常见的模式。通常，评估者的最常见目标是定位以下内容：
- en: Passwords
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: API tokens
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API令牌
- en: API endpoints (URLs)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API端点（URL）
- en: Vulnerable services
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易受攻击的服务
- en: Backdoor accounts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后门账户
- en: Configuration files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: Source code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码
- en: Private keys
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥
- en: How data is stored
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储方式
- en: Throughout the following recipes, we will have the same goals when analyzing
    firmware. This recipe will show you the overview methodology of firmware analysis
    and reverse engineering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们在分析固件时将有相同的目标。本篇将向您展示固件分析和逆向工程的概述方法。
- en: 'The following is a list of the basic methodologies for analyzing IoT firmware:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是分析物联网固件的基本方法论列表：
- en: Obtaining firmware
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取固件
- en: Analyzing firmware
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析固件
- en: Extracting the filesystem
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取文件系统
- en: Mounting filesystems
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: Analyzing filesystem contents
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析文件系统内容
- en: Emulating firmware for dynamic analysis
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟固件进行动态分析
- en: Obtaining firmware
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取固件
- en: In order to start reviewing firmware contents, we first have to get hold of
    a firmware binary file. This section goes through the various techniques in which
    firmware can be obtained for a given target.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始审查固件内容，我们首先必须获取固件二进制文件。本节将介绍获取给定目标的固件的各种技术。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For obtaining firmware, there are some tools we will need to install. We will
    be using Kali Linux which has most of the tools we need installed by default.
    Here are the tools you will need:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取固件，我们需要安装一些工具。我们将使用Kali Linux，默认情况下已安装了大部分我们需要的工具。以下是您需要的工具：
- en: '**Kali Linux**: Kali Linux is available for download via their site at [https://www.kali.org/downloads/](https://www.kali.org/downloads/).
    It is recommended to use the Kali virtual images if you use VMware or VirtualBox,
    which can be found here [https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kali Linux**：Kali Linux可以通过他们的网站[https://www.kali.org/downloads/](https://www.kali.org/downloads/)下载。建议在使用VMware或VirtualBox时使用Kali虚拟镜像，可以在这里找到[https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/)。'
- en: '**Ettercap**: Although Kali Linux has Ettercap installed by default, it is
    also available for download via [https://ettercap.github.io/ettercap/downloads.html](https://ettercap.github.io/ettercap/downloads.html).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ettercap**：虽然Kali Linux默认安装了Ettercap，但也可以通过[https://ettercap.github.io/ettercap/downloads.html](https://ettercap.github.io/ettercap/downloads.html)下载。'
- en: '**Wireshark**: Wireshark is included in Kali Linux by default and is also available
    for download at [http://www.wireshark.org](http://www.wireshark.org).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wireshark**：Wireshark默认包含在Kali Linux中，也可以在[http://www.wireshark.org](http://www.wireshark.org)下载。'
- en: '**SSLstrip**: SSLstrip is included in Kali Linux by default and is also available
    for download at [https://github.com/moxie0/sslstrip](https://github.com/moxie0/sslstrip).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSLstrip**：SSLstrip默认包含在Kali Linux中，也可以通过[https://github.com/moxie0/sslstrip](https://github.com/moxie0/sslstrip)下载。'
- en: '**Flashrom**: Flashrom is not included in Kali Linux by default but we can
    easily install the tool using the following command:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flashrom**：Flashrom默认情况下不包含在Kali Linux中，但我们可以使用以下命令轻松安装该工具：'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, flashrom is available for download via [https://www.flashrom.org/Downloads](https://www.flashrom.org/Downloads).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，可以通过[https://www.flashrom.org/Downloads](https://www.flashrom.org/Downloads)下载flashrom。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are several methods to obtain firmware from an IoT device. We will cover
    most of the methods in this recipe. Firmware images can be obtained via the following
    approaches:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从物联网设备获取固件。我们将在本教程中介绍大多数方法。固件图像可以通过以下方法获取：
- en: Downloading from the vendor's website
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从供应商的网站下载
- en: Proxying or mirroring traffic during device updates
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备更新期间代理或镜像流量
- en: Dumping firmware directly from the device
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从设备中转储固件
- en: Googling/researching
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌/研究
- en: Decompiling associated mobile apps
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反编译相关移动应用程序
- en: Downloading from the vendor's website
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从供应商的网站下载
- en: The easiest way to obtain firmware is via the vendor's website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 获取固件的最简单方法是通过供应商的网站。
- en: 'The following screenshots demonstrate how to obtain a firmware image off of
    a vendor website:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了如何从供应商网站获取固件图像：
- en: Navigate to the target vendor's website.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目标供应商的网站。
- en: 'Enter the target device in the search bar:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中输入目标设备：
- en: '![](img/e8a1430a-7e62-47b7-a30b-9d64f284e2e0.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8a1430a-7e62-47b7-a30b-9d64f284e2e0.png)'
- en: 'Select the Support tab:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“支持”选项卡：
- en: '![](img/a9b1b1f4-23c2-4e87-998e-3263c68bcdd9.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9b1b1f4-23c2-4e87-998e-3263c68bcdd9.png)'
- en: 'Select the Drivers & Tools button:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“驱动程序和工具”按钮：
- en: '![](img/41c21cf6-3d0f-46d2-b3e7-71c04db66105.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41c21cf6-3d0f-46d2-b3e7-71c04db66105.png)'
- en: 'Click on the download link:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击下载链接：
- en: '![](img/6a9845e4-2f91-4372-94a7-eec51b7943ee.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a9845e4-2f91-4372-94a7-eec51b7943ee.png)'
- en: 'Optionally, you can choose to copy the link address to download the file on
    your test machine via `wget` (`wget <http://URL.com>`):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以选择复制链接地址，通过`wget`在测试机器上下载文件（`wget <http://URL.com>`）：
- en: '![](img/6a7ed2cc-206e-4bc7-a1a7-a768cd7ef365.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7ed2cc-206e-4bc7-a1a7-a768cd7ef365.png)'
- en: Proxying or mirroring traffic during device updates
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在设备更新期间代理或镜像流量
- en: Sometimes acquiring firmware via a vendor's site may not be an option and you
    will have to perform step 2, proxying traffic during device updates, or step 3,
    dumping the firmware directly from the device itself. In order to proxy traffic
    during device updates, you must be **man-in-the-middle** (**MITM**) or mirror
    the device traffic during an update function. Alternatively, the web or mobile
    application can also be proxied in order to grab the URL for the firmware download.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过供应商的网站获取固件可能不是一个选择，您将不得不执行步骤2，在设备更新期间代理流量，或步骤3，直接从设备中转储固件。为了在设备更新期间代理流量，您必须是**中间人**（**MITM**）或在更新功能期间镜像设备流量。另外，也可以代理Web或移动应用程序，以便获取固件下载的URL。
- en: 'You may have to adjust the user-agent header as well since vendors have been
    known to verify this value for firmware downloads. The following are the basic
    steps that can be taken to perform MITM on a device to monitor traffic using Kali
    Linux, Ettercap, Wireshark, and SSLstrip. Kali Linux has all the required tools
    needed for this recipe:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要调整用户代理标头，因为供应商已知会验证固件下载的这个值。以下是在Kali Linux、Ettercap、Wireshark和SSLstrip上执行设备MITM的基本步骤：
- en: There are several methods and tools that can be utilized to MITM traffic to
    and from the target device. The example below is just one way to accomplishing
    capturing device traffic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法和工具可以用于MITM流量到目标设备和从目标设备。下面的示例只是一种捕获设备流量的方法。
- en: 'Enable IP forwarding:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用IP转发：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Configure `iptables` to redirect traffic from destination port `80` to port
    `1000`, which is what SSLstrip listens on:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`iptables`将目标端口`80`的流量重定向到SSLstrip监听的端口`1000`：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start SSLstrip:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动SSLstrip：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start up Ettercap GUI:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Ettercap GUI：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following figure shows our current steps taken:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图显示了我们当前的步骤：
- en: '![](img/a034a581-0b20-4757-9824-da8e98af6627.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a034a581-0b20-4757-9824-da8e98af6627.png)'
- en: 'Click on the Sniff menu and the Unified sniffing... option:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“嗅探”菜单和“统一嗅探...”选项：
- en: '![](img/2295f7bb-cae1-4183-9d73-3def839532ee.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2295f7bb-cae1-4183-9d73-3def839532ee.png)'
- en: 'Select the interface:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择接口：
- en: '![](img/0ffb4360-b7b8-42f8-832b-2ac0de78881d.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ffb4360-b7b8-42f8-832b-2ac0de78881d.png)'
- en: 'Select Scan for hosts:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择扫描主机：
- en: '![](img/91334e90-83ed-4478-8014-1e2c80c38cfc.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91334e90-83ed-4478-8014-1e2c80c38cfc.png)'
- en: 'Open up Wireshark to view traffic:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Wireshark查看流量：
- en: '![](img/487ff5b0-8f22-4b5f-b5b4-180f64ec9a53.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/487ff5b0-8f22-4b5f-b5b4-180f64ec9a53.png)'
- en: 'Start capturing traffic from the target device by clicking on Start capturing
    packets:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击“开始捕获数据包”来从目标设备捕获流量：
- en: '![](img/52da8dfb-c021-4fc6-b4d6-4e9c40c5e0eb.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52da8dfb-c021-4fc6-b4d6-4e9c40c5e0eb.png)'
- en: 'Filter traffic as needed; in this case, `192.168.1.137` is the target device:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要过滤流量；在本例中，“192.168.1.137”是目标设备：
- en: '![](img/f6338392-0cc3-45b8-a202-718f5e13ccc8.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6338392-0cc3-45b8-a202-718f5e13ccc8.png)'
- en: Dumping firmware directly from the device
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接从设备中转储固件
- en: 'If we cannot obtain firmware via the vendor site or proxying its traffic, we
    can start dumping the device firmware via UART, SPI, or JTAG. Dumping firmware
    directly requires access to a device and disassembling the device to find its
    flash storage. Once the flash storage chip is located, you can either connect
    your UART pins directly or use an 8-pin SOIC chip-clip to dump the firmware using
    flashrom and an SPI-enabled hardware board such as a Shikra. The following is
    how an SOIC clip and a Shikra would be connected to a device:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法通过供应商网站或代理其流量获取固件，我们可以开始通过UART、SPI或JTAG转储设备固件。直接转储固件需要访问设备并拆卸设备以找到其闪存存储器。一旦找到闪存存储芯片，您可以直接连接您的UART引脚，或者使用8引脚SOIC芯片夹通过flashrom和SPI启用的硬件板（如Shikra）转储固件。以下是SOIC夹和Shikra如何连接到设备的方法：
- en: '>![](img/2da9bdbd-c7ca-41fb-85d3-399a2e8e2ecf.png)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/2da9bdbd-c7ca-41fb-85d3-399a2e8e2ecf.png)'
- en: 'Image Source: [http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562](http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562](http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562)
- en: 'The command used to dump firmware contents to a bin file would look like the
    following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将固件内容转储到bin文件的命令如下：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we have acquired a device's firmware using flashrom or any of the previous
    methods described, we now have to analyze the firmware binary file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用flashrom或之前描述的任何方法获取了设备的固件，现在我们需要分析固件二进制文件。
- en: Googling
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌搜索
- en: If we cannot acquire a firmware image via the previous listed methods for some
    reason, our last option is turning to Google. This may not be our last option
    if we want to rely on someone else's work or check whether our device has been
    researched before. There is also a possibility that a current or ex-employee may
    have uploaded firmware files to their personal repositories or web servers. In
    any case, we can use Google dorking techniques to narrow down our search for our
    given target device. We can also leverage the Google Hacking Database to search
    for firmware or devices via the link [https://www.exploit-db.com/google-hacking-database](https://www.exploit-db.com/google-hacking-database).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们无法通过之前列出的方法获取固件映像，我们的最后选择是求助于谷歌。如果我们想依赖他人的工作或检查我们的设备是否被研究过，这可能不是我们的最后选择。还有可能是当前或前员工可能已经将固件文件上传到他们的个人存储库或Web服务器。无论如何，我们可以使用谷歌搜索技术来缩小我们对给定目标设备的搜索范围。我们还可以利用谷歌黑客数据库来搜索固件或设备，网址为[https://www.exploit-db.com/google-hacking-database](https://www.exploit-db.com/google-hacking-database)。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we walked through obtaining a firmware image via a vendor's
    website as well as setting up an MITM testbed to capture device traffic, dumping
    firmware directly from the device and Googling as a last resort. Here, I'll break
    down why we obtain firmware via these methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们通过从供应商的网站获取固件映像以及设置MITM测试平台来捕获设备流量，直接从设备中转储固件以及作为最后手段进行谷歌搜索。在这里，我将解释为什么我们要通过这些方法获取固件。
- en: When downloading firmware files from vendors, you can typically find what you
    need via their support website, file share, or community forums. Sometimes the
    vendor will require a password in order to download the file or have the firmware
    password protected in a ZIP file. If this is the case, we will more than likely
    skip to the next steps of obtaining firmware in the interest of time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当从供应商那里下载固件文件时，您通常可以通过他们的支持网站、文件共享或社区论坛找到所需的内容。有时供应商会要求输入密码才能下载文件，或者将固件密码保护在ZIP文件中。如果是这种情况，出于时间考虑，我们很可能会直接跳过获取固件的下一步。
- en: Next, we walked through how to set up a MITM testbed using Kali Linux, SSLstrip,
    Ettercap, and Wireshark to capture device traffic during device updates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何使用Kali Linux、SSLstrip、Ettercap和Wireshark设置MITM测试平台，以捕获设备更新期间的设备流量。
- en: Analyzing firmware
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析固件
- en: Once we have the firmware with us, the main step now is to analyze the firmware.
    This involves looking inside the firmware and trying to identify as many security
    issues possible, which is what we will be doing in this section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了固件，现在的主要步骤是分析固件。这涉及查看固件内部并尝试识别尽可能多的安全问题，这就是我们将在本节中进行的工作。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this section, we will understand how to analyze firmware once we have access
    to the firmware binary package. There exist several different techniques in which
    we can look at firmware and identify security issues in it and we will be covering
    how to get started and identifying some common security issues in this section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解一旦获得固件二进制包，如何分析固件。我们可以使用几种不同的技术来查看固件并识别其中的安全问题，我们将在本节中介绍如何入门并识别一些常见的安全问题。
- en: As mentioned earlier, firmware holds many interesting things for a pen tester,
    including API keys, private certificates, hardcoded credentials, backdoors, and
    more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，固件对于渗透测试人员来说包含许多有趣的东西，包括API密钥、私人证书、硬编码凭据、后门等。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: To analyze firmware, we will have to reverse engineer it to look at its internal
    components. The internal components of firmware involve things such as bootloader,
    kernel, filesystem, and additional resources. Out of these, we are most interested
    in the filesystem as that is what will hold all the secrets for us. Obviously,
    you could play around with the bootloader and look at what it holds or modify
    it and create new firmware (which we will discuss in the upcoming sections), but
    at this point in time, we will be only concerned with how to reverse engineer
    firmware and extract the filesystem from inside it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析固件，我们必须对其进行逆向工程，以查看其内部组件。固件的内部组件涉及引导加载程序、内核、文件系统和其他资源等内容。在这些内容中，我们最感兴趣的是文件系统，因为这将为我们保存所有的秘密。显然，你可以玩弄引导加载程序并查看它所保存的内容，或者修改它并创建新的固件（我们将在接下来的部分讨论），但在这个时候，我们只关心如何对固件进行逆向工程并从中提取文件系统。
- en: 'Firmware, as we know, is a binary file package and the filesystem is just one
    of the components which could be stored at a specific offset in the binary and
    with a specific size. However, at this point of time we don''t yet know any information
    of the file system inside the firmware, including the offset and size. To find
    these out, we would need to use a tool such as `hexdump` and `grep` for the signatures
    of the various contents we are looking for. The following is an example of the
    Squashfs filesystem:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 固件，正如我们所知，是一个二进制文件包，文件系统只是可以存储在二进制文件中特定偏移量处并具有特定大小的组件之一。但是，此时我们尚不知道固件内部文件系统的任何信息，包括偏移量和大小。要找出这些信息，我们需要使用诸如`hexdump`和`grep`之类的工具来查找我们正在寻找的各种内容的签名。以下是Squashfs文件系统的示例：
- en: 'If we want to look for the Squashfs filesystem, we can `grep` the `hexdump`
    output for `shsq` (which is the magic byte for any Squashfs filesystem) in reverse
    order as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要查找Squashfs文件系统，我们可以在逆序中使用`hexdump`输出来`grep` `shsq`（这是任何Squashfs文件系统的魔术字节）如下所示：
- en: '![](img/a691594b-1525-4a6e-8ee1-9f123fe6f293.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a691594b-1525-4a6e-8ee1-9f123fe6f293.png)'
- en: 'As you can see, we are able to identify that the Squashfs filesystem begins
    from the address `0x000e20c0`. Once we have this information, we can use the `dd`
    utility to dump contents starting from this location till the end, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们能够确定Squashfs文件系统从地址`0x000e20c0`开始。一旦我们获得了这些信息，我们就可以使用`dd`实用程序从此位置开始转储内容直到结束，如下所示：
- en: '![](img/22a1830b-2db7-4e45-a0b2-173203883026.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22a1830b-2db7-4e45-a0b2-173203883026.png)'
- en: Once we have the Squashfs content carved out from the firmware binary, we can
    then simply run a utility such as `unsquashfs` to look at the entire filesystem.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们从固件二进制文件中切割出Squashfs内容，我们就可以简单地运行诸如`unsquashfs`之类的实用程序来查看整个文件系统。
- en: 'Let''s go ahead and run `unsquashfs` and see if we can look at the entire filesystem:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行`unsquashfs`，看看我们是否可以查看整个文件系统：
- en: '![](img/231b08e9-cd93-4731-b035-9215369f9e13.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/231b08e9-cd93-4731-b035-9215369f9e13.png)'
- en: 'As we can see from the preceding screenshot, we are able to extract the Squashfs
    filesystem image. Ignore the warnings and errors in the above image as it''s simply
    complaining about us not running the command as a root user. Once we have extracted
    it, we can navigate to the various directories and look at individual files in
    order to identify vulnerabilities. The following is a screenshot of how the entire
    filesystem looks:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上面的屏幕截图中可以看出，我们能够提取Squashfs文件系统映像。请忽略上图中的警告和错误，因为它只是在抱怨我们没有以root用户身份运行命令。一旦我们提取了它，我们就可以转到各个目录并查看各个文件，以识别漏洞。以下是整个文件系统的屏幕截图：
- en: '![](img/9f5d8de3-ba20-43e7-82a6-4fe6735ac1e3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f5d8de3-ba20-43e7-82a6-4fe6735ac1e3.png)'
- en: This is how we reverse engineer firmware and extract the filesystem from the
    firmware binary image. We can also perform all of the steps mentioned earlier
    automatically with a tool such as Binwalk. Written by *Craig Heffner*, it allows
    us to extract filesystems from a firmware binary image with just a single command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何反向工程固件并从固件二进制映像中提取文件系统。我们还可以使用Binwalk等工具自动执行前面提到的所有步骤。由*Craig Heffner*编写，它允许我们仅使用一个命令从固件二进制映像中提取文件系统。
- en: 'To install Binwalk, simply clone Binwalk''s GitHub repository located at [https://github.com/devttys0/binwalk.git](https://github.com/devttys0/binwalk.git)
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Binwalk，只需克隆位于[https://github.com/devttys0/binwalk.git](https://github.com/devttys0/binwalk.git)的Binwalk的GitHub存储库，如下所示：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run `./deps.sh` in order to install all the required dependencies and binaries.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`./deps.sh`以安装所有必需的依赖项和二进制文件。
- en: 'Once you have installed Binwalk successfully, you can confirm it by simply
    typing in `binwalk` and hitting *Enter*. This should show the Binwalk''s help
    menu:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Binwalk成功后，您可以通过简单输入`binwalk`并按*Enter*来确认。这应该显示Binwalk的帮助菜单：
- en: '![](img/3664de5c-7156-4dd7-bf4d-940aa37bf7d3.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3664de5c-7156-4dd7-bf4d-940aa37bf7d3.png)'
- en: 'Let''s go ahead and perform a filesystem extraction from the same firmware
    using Binwalk. To do this, we will use the `-e` flag, which will perform the extraction:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用Binwalk从相同的固件中执行文件系统提取。为此，我们将使用`-e`标志进行提取：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will show us the various sections present in the firmware as well as extract
    the contents for us:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向我们展示固件中存在的各个部分，并为我们提取内容：
- en: '![](img/0dd734fb-9074-4629-b4e5-1073c269d496.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dd734fb-9074-4629-b4e5-1073c269d496.png)'
- en: 'The `t` and `vv` flags simply allow us to print the output in a more readable
    and verbose format. After the Binwalk execution, we can go to the directory with
    the name `_[firmwarename].extracted`, which will hold the entire filesystem for
    us as shown in the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`t`和`vv`标志只是允许我们以更易读和详细的格式打印输出。Binwalk执行后，我们可以转到名为`_[firmwarename].extracted`的目录，其中将保存整个文件系统，如下面的屏幕截图所示：'
- en: '![](img/f854a40f-4dd9-49e5-a998-392ab5701b61.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f854a40f-4dd9-49e5-a998-392ab5701b61.png)'
- en: That is how we extract the filesystem from a firmware binary both manually and
    automatically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何从固件二进制文件中手动和自动提取文件系统。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The filesystem extraction in this case uses the same approach that we performed
    earlier. It detects the filesystem and other component offsets using the magic
    bytes and the header signature characters - such as `sqsh` for Squashfs and so
    on. The number of filesystems detected by Binwalk can be found at this URL: [https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems](https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件系统提取使用了我们之前执行的相同方法。它使用魔术字节和头部签名字符（例如Squashfs的`sqsh`等）来检测文件系统和其他组件的偏移量。Binwalk检测到的文件系统数量可以在此URL找到：[https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems](https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems)。
- en: You can also manually add more signatures to your Binwalk instance and compile
    it to detect those additional filesystems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以手动向Binwalk实例添加更多签名并编译它以检测这些额外的文件系统。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also additionally use Binwalk for performing a number of other operations,
    such as detecting the entropy of a given firmware image. This can help you identify
    whether a firmware image is compressed or encrypted. In order to perform entropy
    analysis, run `binwalk` with the `-E` flag followed by the firmware name as shown
    in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Binwalk执行许多其他操作，例如检测给定固件映像的熵。这可以帮助您确定固件映像是否被压缩或加密。为了执行熵分析，请像下面的截图中所示，使用带有`-E`标志的`binwalk`，后跟固件名称：
- en: '![](img/7932f99a-c60d-49cd-abd1-106af4aa45ef.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7932f99a-c60d-49cd-abd1-106af4aa45ef.png)'
- en: As you can see in the preceding screenshot, this particular firmware does not
    appear to be encrypted because of a lack of large variations which you would find
    in encrypted firmware images.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的截图中所看到的，这个特定的固件似乎没有加密，因为在加密固件映像中会找到的大量变化缺失。
- en: See also
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For additional information on firmware analysis and reverse engineering, the
    blog by the author of Binwalk, *Craig Heffner*, is extremely useful. It will also
    help you understand how different firmware images vary and are vulnerable. The
    blog is located at [http://www.devttys0.com/](http://www.devttys0.com/).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关固件分析和逆向工程的其他信息，Binwalk的作者*Craig Heffner*的博客非常有用。它还将帮助您了解不同的固件映像是如何变化和易受攻击的。该博客位于[http://www.devttys0.com/](http://www.devttys0.com/)。
- en: Analyzing filesystem contents
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析文件系统内容
- en: Now that we know how to reverse engineer firmware and extract the filesystem
    from it, in this section, we will look at the filesystem contents and perform
    additional vulnerability analyses on it. This will help us gain a deeper understanding
    of how to find security issues in firmware images, using which, we will be able
    to compromise an IoT device.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何对固件进行逆向工程并从中提取文件系统，本节中我们将查看文件系统内容，并对其进行额外的漏洞分析。这将帮助我们更深入地了解如何在固件映像中找到安全问题，借此我们将能够破坏物联网设备。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two approaches to analyzing filesystem contents:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种分析文件系统内容的方法：
- en: Manual analysis.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动分析。
- en: Automated tools and scripts.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化工具和脚本。
- en: Manual analysis
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动分析
- en: In this approach of hunting for vulnerabilities within the firmware filesystem
    content, we perform analysis of the various files and folders present in the filesystem.
    This could range anywhere from looking at the configuration files, web directories,
    password files, hunting for backdoors, and so on. This is an ideal way of discovering
    vulnerabilities in the given firmware, and will be our focus for this section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在固件文件系统内容中寻找漏洞的方法中，我们对文件系统中存在的各种文件和文件夹进行分析。这可能涉及查看配置文件、web目录、密码文件、寻找后门等。这是发现给定固件中漏洞的理想方式，也是我们本节的重点。
- en: Automated tools and scripts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化工具和脚本
- en: As of the date of publishing of this book, apart from a couple of scripts, a
    full suite framework or a tool which could help us find vulnerabilities in firmware
    does not exist. So, if you are familiar with web application security or network
    security, there are no tools similar to Arachni, w3af, Metasploit, or similar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书的日期之前，除了一些脚本外，没有一个完整的套件框架或工具可以帮助我们发现固件中的漏洞。因此，如果您熟悉Web应用程序安全或网络安全，就没有类似于Arachni、w3af、Metasploit或类似工具。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get started with analyzing firmware and seeing whether we are able to
    identify any of the sensitive information or a backdoor for that matter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始分析固件，看看我们是否能够识别出任何敏感信息或后门。
- en: 'The firmware that we will use for this exercise is a D-Link DWR 932B with the
    version `DWR-932_fw_revB_2_02_eu_en_20150709`. These following vulnerabilities
    have been discovered by security researchers, namely *Gianni Carabelli* and *Pierre
    Kim*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于此练习的固件是版本为`DWR-932_fw_revB_2_02_eu_en_20150709`的D-Link DWR 932B。这些漏洞是由安全研究人员*Gianni
    Carabelli*和*Pierre Kim*发现的：
- en: 'The first step would be to extract the filesystem from the firmware. However,
    the firmware in this case comes as a ZIP file which is protected by a password.
    The password in this case could be cracked by a utility such as fcrackzip and
    the password was found to be UT9Z. This is also shown in the following screenshot:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从固件中提取文件系统。但是，在这种情况下，固件是一个受密码保护的ZIP文件。这种情况下，可以使用fcrackzip等实用程序来破解密码，密码被发现是UT9Z。这也显示在下面的截图中：
- en: '![](img/eef7ca24-c6fb-4a96-908b-3c5a62efd6fe.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef7ca24-c6fb-4a96-908b-3c5a62efd6fe.png)'
- en: Once we have the firmware image, we can use Binwalk to extract the yaffs2 filesystem
    present within the firmware ZIP file. You can use yaffs2-specific tools to unpack
    the filesystem or simply using Binwalk will also do the job.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了固件映像，我们可以使用Binwalk来提取固件ZIP文件中存在的yaffs2文件系统。您可以使用yaffs2特定工具来解压文件系统，或者简单地使用Binwalk也可以完成任务。
- en: 'Inside the `yaffs2-root` folder, we will have the entire filesystem as shown
    in the following screenshot:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`yaffs2-root`文件夹中，我们将看到整个文件系统，如下面的截图所示：
- en: '![](img/0102900b-ed0e-4f1a-8fc1-fc88c4353b05.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0102900b-ed0e-4f1a-8fc1-fc88c4353b05.png)'
- en: 'From here on, we can start navigating inside various directories and look at
    files which look interesting from a security point of view. One of the first things
    we could do is look for all the configuration files by running a `find` query
    for all the `.conf` files, as shown in the following screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以开始浏览各个目录，并查看从安全角度看起来有趣的文件。我们可以首先运行一个`find`查询，查找所有`.conf`文件，如下面的截图所示：
- en: '![](img/f410244b-8d4e-4cd0-a4f0-31e9554e5a83.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f410244b-8d4e-4cd0-a4f0-31e9554e5a83.png)'
- en: 'For instance, this is what is present inside the `wpa-supplicant.conf` file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，这是`wpa-supplicant.conf`文件中的内容：
- en: '![](img/8d9c7042-7d31-438a-9767-6c98cd1cee9c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d9c7042-7d31-438a-9767-6c98cd1cee9c.png)'
- en: 'Let''s look at other files such as `inadyn-mt.conf`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看其他文件，比如`inadyn-mt.conf`：
- en: '![](img/f68a1e86-4bc6-4f1f-9e7a-8915dcef2aa7.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f68a1e86-4bc6-4f1f-9e7a-8915dcef2aa7.png)'
- en: Surprisingly, this file has highly sensitive information which in no way should
    have been able to be accessed. As we can see from the preceding screenshot, this
    file stores the no-IP configuration for the router, including the username and
    password combination which is used for the [https://www.no-ip.com](https://www.no-ip.com)
    access.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这个文件包含了高度敏感的信息，根本不应该被访问。正如我们从前面的屏幕截图中所看到的，这个文件存储了路由器的no-IP配置，包括用于[https://www.no-ip.com](https://www.no-ip.com)访问的用户名和密码组合。
- en: This is how we can find sensitive information hidden in firmware. You can obviously
    look around more and identify more sensitive information within the firmware's
    filesystem.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在固件中找到隐藏的敏感信息。您显然可以继续寻找更多，并在固件文件系统中识别更多敏感信息。
- en: Now that we know how to perform manual analysis on firmware, we will move on
    to identifying flaws through an automated approach. For this, we will use a tool
    called Firmwalker, written by *Craig Smith*, which helps identify some of the
    common sensitive information in a firmware through static analysis.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何对固件进行手动分析后，我们将继续通过自动化方法来识别漏洞。为此，我们将使用一个名为Firmwalker的工具，这个工具是由*Craig
    Smith*编写的，它通过静态分析帮助识别固件中一些常见的敏感信息。
- en: 'To set it up, we simply need to clone Firmwalker''s GitHub repo as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置它，我们只需要克隆Firmwalker的GitHub存储库，如下所示：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have cloned the Firmwalker GitHub repo, we just need to run the `./firmwalker.sh`
    script followed by the extracted filesystem location as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们克隆了Firmwalker的GitHub存储库，我们只需要运行`./firmwalker.sh`脚本，然后跟随提取的文件系统位置，如下所示：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Firmwalker script identifies a number of different things for us, including
    additional binary files, certificates, IP addresses, private keys, and so on.
    It also stores the output in a file called `firmwalker.txt` (unless a different
    file is specified by the user) which looks as shown in the following screenshot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Firmwalker脚本为我们识别了许多不同的内容，包括额外的二进制文件、证书、IP地址、私钥等。它还将输出存储在一个名为`firmwalker.txt`的文件中（除非用户指定了不同的文件），其外观如下所示：
- en: '![](img/61028b37-9e0b-4a02-a297-525c56bd217f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61028b37-9e0b-4a02-a297-525c56bd217f.png)'
- en: Once we have the report generated by Firmwalker, we can look at all the different
    files individually and analyze them further. In some cases, you will also need
    to reverse engineer ARM and MIPS-based binaries to understand them more and identify
    vulnerabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了Firmwalker生成的报告，我们可以逐个查看所有不同的文件并进一步分析它们。在某些情况下，您还需要对ARM和MIPS架构的二进制文件进行逆向工程，以更好地理解它们并识别漏洞。
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Analyzing and understanding a filesystem and its internal contents is all about
    your manual assessment skills. This is how you will be able to identify vulnerabilities.
    Even while working with various tools, you will realize that, in the end, it comes
    down to analyzing that binary or file manually and figuring out the vulnerability.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分析和理解文件系统及其内部内容完全取决于您的手动评估技能。这就是您能够识别漏洞的方法。即使在使用各种工具时，您也会意识到，最终归根结底是手动分析二进制文件或文件，并找出其中的漏洞。
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To analyze firmware filesystem contents on a deeper level, you could also use
    techniques such as firmware diffing, with which you could compare one firmware
    with its previous version and look at the differences. This would enable you to
    understand the security fixes and modifications which have been made in the new
    version and identify even undisclosed security issues in the previous ones.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地分析固件文件系统内容，您还可以使用固件差异技术，通过它您可以比较一个固件与其先前版本，并查看其中的差异。这将使您能够了解新版本中进行的安全修复和修改，并识别以前版本中甚至未公开的安全问题。
- en: Another thing which we could do with firmware filesystem content is look at
    the various libraries and components which have been used and see whether those
    components are outdated versions with vulnerabilities in them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对固件文件系统内容进行的另一项操作是查看已使用的各种库和组件，看看这些组件是否是带有漏洞的过时版本。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For analyzing firmware filesystem content, it's good to also read more about
    binary analysis and reverse engineering. Get yourself familiar with Linux binary
    analysis, debugging, and disassembling on platforms such as ARM and MIPS.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分析固件文件系统内容，还可以阅读更多关于二进制分析和逆向工程的内容。熟悉Linux二进制分析、调试和在ARM和MIPS等平台上的反汇编。
- en: Emulating firmware for dynamic analysis
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于动态分析的固件模拟
- en: Often, while working with IoT devices, one of the limitations is we are not
    able to perform a lot of tests and exploitation without having access to the actual
    device. However, in this section, we will discuss a way in which you can emulate
    your firmware and interact with the emulated device as if it were an actual device
    sitting on your network.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用物联网设备时，其中一个限制是我们无法在没有实际设备访问权限的情况下进行大量测试和利用。然而，在本节中，我们将讨论一种方法，您可以模拟您的固件，并与模拟设备进行交互，就像它是实际放置在您的网络上的设备一样。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In order to emulate firmware, we will be using a script called **Firmware Analysis
    Toolkit** (**FAT**) written by the authors of this book. FAT uses Firmadyne in
    order to perform the emulation of firmware images.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟固件，我们将使用一种名为**固件分析工具包**（**FAT**）的脚本，这个脚本是由本书的作者编写的。FAT使用Firmadyne来执行固件映像的模拟。
- en: The underlying utility used in Firmadyne is QEMU, which allows users to emulate
    the entire system architecture and run content on top of it. It also takes advantage
    of additional scripts written by the tool authors, such as the NVRAM emulator
    located at [https://github.com/firmadyne/libnvram](https://github.com/firmadyne/libnvram).
    It also uses tools such as Binwalk, which we discussed earlier, to extract a filesystem
    from firmware which is then emulated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Firmadyne使用的基础实用程序是QEMU，它允许用户模拟整个系统架构并在其上运行内容。它还利用了工具作者编写的其他脚本，例如位于[https://github.com/firmadyne/libnvram](https://github.com/firmadyne/libnvram)的NVRAM模拟器。它还使用我们之前讨论过的Binwalk等工具，从固件中提取文件系统，然后进行模拟。
- en: Let's go ahead and clone the FAT GitHub repo and set it up to make the lab ready
    for emulation. It is highly recommended to perform this on an Ubuntu-based system
    to avoid any issues during emulation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续克隆FAT GitHub存储库并设置它，使实验室准备好进行模拟。强烈建议在基于Ubuntu的系统上执行此操作，以避免在模拟过程中出现任何问题。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following are the steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤：
- en: 'We will start the setup by cloning the FAT repo from the link [https://github.com/attify/firmware-analysis-toolkit/](https://github.com/attify/firmware-analysis-toolkit/)
    as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过以下链接[https://github.com/attify/firmware-analysis-toolkit/](https://github.com/attify/firmware-analysis-toolkit/)开始克隆FAT存储库的设置：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will also set up the database used by Firmadyne to store information about
    the firmware and for management in future. The password for the database will
    be set to `firmadyne`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将设置Firmadyne用于存储有关固件的信息和将来管理的数据库。数据库的密码将设置为`firmadyne`。
- en: Once you have everything set up, it's time for us to pick firmware and emulate
    it and see what we are able to perform with the emulated firmware.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置好了一切，就该是我们选择固件并模拟它，看看我们能够用模拟的固件执行什么了。
- en: For this exercise, we will use firmware DWP2360b, which is firmware by D-Link
    for its Wireless PoE Access Point.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用D-Link为其无线PoE接入点提供的固件DWP2360b。
- en: 'The first thing that we will need to do is run `./fat.py`, which will then
    ask you for the firmware name and the brand of the firmware image. This firmware
    brand image is purely meant for database purposes so that we can later look in
    the database if needed and see which brand''s firmware we have emulated. Once
    you run it, it will look as shown in the following screenshot:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是运行`./fat.py`，然后它会要求您输入固件名称和固件镜像的品牌。这个固件品牌镜像纯粹是为了数据库目的，这样我们以后如果需要的话就可以在数据库中查看我们模拟了哪个品牌的固件。运行后，它将显示如下截图所示：
- en: '![](img/c7a7bac4-badb-42c8-9ce0-57fe89b8cf5a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7a7bac4-badb-42c8-9ce0-57fe89b8cf5a.png)'
- en: 'It will ask you for the password of the database a couple of times, which we
    have set to `firmadyne`. Once it finishes the initial processing, creating an
    image, setting up networking, and getting an IP address, it will show that FAT
    shows you the IP address and mentions that the firmware is now emulated, as shown
    in the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会几次要求您输入数据库密码，我们已将其设置为`firmadyne`。一旦完成初始处理，创建图像，设置网络并获取IP地址，它将显示FAT向您显示IP地址并提到固件现在已经被模拟，如下截图所示：
- en: '![](img/41b28add-4f71-4fc8-a1ae-c7f515a06b9e.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41b28add-4f71-4fc8-a1ae-c7f515a06b9e.png)'
- en: 'Once we have the IP address, we can simply open this up in our browser and
    we will be presented with the router login page as shown in the following screenshot:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了IP地址，我们可以简单地在浏览器中打开它，我们将看到路由器登录页面，如下截图所示：
- en: '![](img/edb94a5b-10f3-40d8-9b2a-4206b23a881c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edb94a5b-10f3-40d8-9b2a-4206b23a881c.png)'
- en: This is how we could emulate firmware using the help of the FAT even without
    having access to the device.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在没有访问设备的情况下使用FAT来模拟固件。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The preceding emulation works on the basis of the QEMU and NVRAM emulator. NVRAM
    is a component which firmware accesses in order to get information from the device.
    However, since there is no physical device present, it will result in an error
    or crashing of the service making the call. This is where the NVRAM emulator comes
    into the picture. The Firmadyne toolkit also modifies the firmware for debugging
    purposes to give the user access to the console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模拟是基于QEMU和NVRAM模拟器的。NVRAM是固件访问以获取设备信息的组件。然而，由于没有物理设备存在，这将导致错误或服务崩溃。这就是NVRAM模拟器发挥作用的地方。Firmadyne工具包还修改固件以进行调试，以便用户访问控制台。
- en: 'The following is what is happening in the FAT script:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是FAT脚本中正在发生的事情：
- en: Extracts the filesystem from the firmware.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从固件中提取文件系统。
- en: Gets the architecture of the firmware.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取固件的架构。
- en: Makes the required image.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作所需的镜像。
- en: Sets up the networking.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置网络。
- en: Emulates the image.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟镜像。
- en: All of these steps can be performed manually, but having a script such as FAT
    helps speed up things.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都可以手动执行，但是拥有像FAT这样的脚本可以加快速度。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another way to perform emulation would be to manually download Debian images
    for the appropriate architecture and copy the files from the firmware to the newly
    created Debian instance, and then run the web server (or the component you are
    testing) using Chroot. You can download existing Debian images from [https://people.debian.org/~aurel32/qemu/](https://people.debian.org/~aurel32/qemu/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 进行模拟的另一种方法是手动下载适当架构的Debian镜像，并将文件从固件复制到新创建的Debian实例中，然后使用Chroot运行Web服务器（或正在测试的组件）。您可以从[https://people.debian.org/~aurel32/qemu/](https://people.debian.org/~aurel32/qemu/)下载现有的Debian镜像。
- en: Getting started with ARM and MIPS
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用ARM和MIPS
- en: Now that we know how to emulate firmware and perform basic analysis, you will
    often find yourself coming across various binaries which will require additional
    analysis. It is impossible for us to cover all the various architectures possible
    for an embedded device in a single book, we will focus on two popular architectures
    - ARM and MIPS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何模拟固件并进行基本分析，您经常会发现自己遇到需要进行额外分析的各种二进制文件。在一本书中不可能涵盖嵌入式设备可能的所有不同架构，我们将专注于两种流行的架构-ARM和MIPS。
- en: We will, however, only look at exploitation of MIPS and look a bit into ARM
    reverse engineering. From an exploitation perspective, ARM and MIPS are quite
    similar and learning one architecture would give you a head start and basic understanding
    for the other.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只会研究MIPS的利用，并稍微了解ARM的逆向工程。从利用的角度来看，ARM和MIPS非常相似，学习一种架构将为您提供另一种架构的基础知识和基本理解。
- en: Getting Ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start our binary analysis journey with a very basic analysis of a backdoor
    found in D-Link firmware. This backdoor was found by *Pierre Kim*. To identify
    this backdoor, one would require a basic reverse engineering idea of ARM-based
    binaries. Even though we won't be going in-depth into registers and the architecture
    over here (since we are going to cover those in the MIPS architecture), this section
    will help you understand the process of analyzing a binary and identifying low-hanging
    vulnerabilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对D-Link固件中发现的后门进行非常基本的分析开始我们的二进制分析之旅。这个后门是由*Pierre Kim*发现的。要识别这个后门，需要对基于ARM的二进制文件有一个基本的逆向工程概念。尽管我们不会深入讨论寄存器和体系结构（因为我们将在MIPS体系结构中进行讨论），但这一部分将帮助您了解分析二进制文件并识别低悬漏洞的过程。
- en: The firmware that we are going to use in this case is of the device, D-Link
    DWR 932B. Once we extract this firmware using Binwalk, we notice that there is
    a binary called appmgr, which is what we are interested in.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用D-Link DWR 932B设备的固件。一旦我们使用Binwalk提取了这个固件，我们注意到有一个名为appmgr的二进制文件，这就是我们感兴趣的内容。
- en: We can use any disassembler which you might be familiar with - Radare2, IDA,
    Hopper, and so on. In this case, we will use Hopper to reverse engineer the appmgr
    binary, which is an ARM Little Endian binary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用您熟悉的任何反汇编器 - Radare2、IDA、Hopper等。在这种情况下，我们将使用Hopper来反向工程appmgr二进制文件，这是一个ARM
    Little Endian二进制文件。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will be using the pseudo code generation functionality of Hopper in order
    to understand it better. The following are the steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Hopper的伪代码生成功能来更好地理解它。以下是步骤：
- en: Let's load up the binary in Hopper for analysis:</li>
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载二进制文件到Hopper进行分析：</li>
- en: '![](img/25f7b2fd-5c59-42fb-8565-44589dba8e7e.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25f7b2fd-5c59-42fb-8565-44589dba8e7e.png)'
- en: 'Once we have the binary loaded, we can search for the `telnet` string and we
    will be able to see `telnet` mentioned somewhere in the code sample:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们加载了二进制文件，我们就可以搜索`telnet`字符串，然后就能在代码示例中的某个地方看到`telnet`的提及：
- en: '![](img/d31c904e-953f-4f75-857c-d5f465e0a42a.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d31c904e-953f-4f75-857c-d5f465e0a42a.png)'
- en: Finding telnet instance in the strings
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中查找telnet实例
- en: 'To figure out where it is being called from, we can right-click on the string
    and select References to address, which will show us the locations and instructions
    from where it is being called. In this case, if we do References to address, we
    find that it is being called from `0x13048` as shown in the following screenshot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找出它是从哪里调用的，我们可以右键单击字符串，然后选择引用地址，这将显示调用它的位置和指令。在这种情况下，如果我们引用地址，我们发现它是从`0x13048`调用的，如下面的截图所示：
- en: '![](img/f8e566bb-1585-4bbf-9ee2-9e1a652d0e1e.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8e566bb-1585-4bbf-9ee2-9e1a652d0e1e.png)'
- en: 'Double-clicking on the address will take us to the address mentioned, in this
    case, `0x13048`. Once we are at the address, we can see the entire disassembly,
    as well as generate pseudo code by clicking on the button saying Pseudo-code mode.
    This is also shown in the following screenshot:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击地址将带我们到所提到的地址，这种情况下是`0x13048`。一旦我们到达地址，我们可以看到整个反汇编，以及通过点击“伪代码模式”按钮生成伪代码。这也显示在下面的截图中：
- en: '![](img/4f94c593-3dbd-49ec-b969-364bdc0d2605.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f94c593-3dbd-49ec-b969-364bdc0d2605.png)'
- en: Accessing Pseudo-code from the disassembly
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从反汇编中访问伪代码
- en: 'Pseudo-code functionality is extremely useful for us, as it lets us see the
    disassembly as a logical program which makes more sense to us, if we are not extremely
    familiar with the disassembly. In this case, the following is what the Pseudo-code
    says:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伪代码功能对我们非常有用，因为它让我们将反汇编视为一个逻辑程序，这样对我们来说更有意义，如果我们对反汇编不是非常熟悉的话。在这种情况下，伪代码的内容如下：
- en: '![](img/b60d7347-bc03-4420-9aad-952a0373edde.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60d7347-bc03-4420-9aad-952a0373edde.png)'
- en: As we can see from the preceding screenshot, it does a `strncmp` for the string
    `HELODBG`. As you will probably already know, `strncmp` is used for string comparison,
    which in this case is checking for the string which is required by the binary
    to launch Telnet as it is evident from the highlighted boxes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中所看到的，它对字符串`HELODBG`进行了`strncmp`。您可能已经知道，`strncmp`用于字符串比较，在这种情况下是检查二进制文件所需的字符串，以启动Telnet，这一点从高亮的框中可以看出。
- en: Thus, we can confidently say that the appmgr backdoor looks for the string `HELODBG`
    and as soon as receives the string, it launches Telnet with `bin/sh` shell.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以自信地说，appmgr后门寻找字符串`HELODBG`，一旦接收到该字符串，就会启动带有`bin/sh` shell的Telnet。
- en: This is how we perform a very basic analysis of an ARM binary which could be
    used to find both sensitive information or vulnerabilities, and a backdoor.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对ARM二进制文件进行非常基本分析的方式，可以用来查找敏感信息或漏洞，以及后门。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that you know how to perform a basic analysis of ARM binaries, we would
    also recommend you read more about ARM assembly and its architecture. The knowledge
    and understanding of assembly instructions and underlying architecture will help
    you understand the disassembly in a much better way, even in cases where Pseudo-code
    is not helpful.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何对ARM二进制文件进行基本分析，我们还建议您阅读更多关于ARM汇编和其体系结构的内容。对汇编指令和底层体系结构的知识和理解将帮助您更好地理解反汇编，即使在伪代码无法帮助的情况下也是如此。
- en: Exploiting MIPS
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用MIPS
- en: Now that we have basic information about how to reverse engineer binaries, it's
    time we get into a bit of depth on exploitation and understanding the architecture
    of the platforms on which IoT devices are mostly based. For getting a basic understanding,
    we will only focus on MIPS now, but it is highly recommended that you use the
    same concepts and perform exploitation on ARM-based architectures as well.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何反向工程二进制文件有了基本的了解，是时候深入了解利用和理解大多数IoT设备所基于的平台的体系结构了。为了获得基本的理解，我们现在只关注MIPS，但强烈建议您使用相同的概念并在基于ARM的体系结构上进行利用。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To perform MIPS exploitation, we would primarily do it using the QEMU and chroot
    technique which we glossed over earlier in this chapter. We will look into things
    such as how to perform buffer overflow exploitation on MIPS binaries and subvert
    the program execution flow to what we want it to be instead of what the binary
    is supposed to perform. We won't go into concepts such as **Return Oriented Programming**
    (**ROP**) for now and keep things simple.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 进行MIPS利用，我们主要会使用QEMU和chroot技术，这是我们在本章前面简要介绍过的。我们将研究如何在MIPS二进制文件上执行缓冲区溢出利用，并改变程序执行流程，使其执行我们想要的操作，而不是二进制文件原本应该执行的操作。目前我们不会涉及**返回导向编程**（**ROP**）等概念，保持简单。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this exercise, we will require and use the following tools and utilities:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将需要并使用以下工具和实用程序：
- en: '**Damn Vulnerable Router Firmware** (**DVRF**) - downloadable from the GitHub
    URL'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可恶的易受攻击路由器固件**（**DVRF**）-可从GitHub URL下载'
- en: GDB-Multiarch
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB-Multiarch
- en: '**GDB Enhanced Features **(**GEF**)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GDB增强功能**（**GEF**）'
- en: QEMU
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU
- en: chroot
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: chroot
- en: IDA Pro/Radare2 (optional)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDA Pro/Radare2（可选）
- en: 'Let''s go through each of them one by one and see how to set them up. Let''s
    go ahead and download the DVRF firmware from the following URL: [https://github.com/praetorian-inc/DVRF/tree/master/Firmware](https://github.com/praetorian-inc/DVRF/tree/master/Firmware).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个了解它们，并看看如何设置它们。让我们从以下URL下载DVRF固件：[https://github.com/praetorian-inc/DVRF/tree/master/Firmware](https://github.com/praetorian-inc/DVRF/tree/master/Firmware)。
- en: 'DVRF is a firmware written by *b1ack0wl* with the firmware meant for the MIPS-based
    platforms. Even though the firmware is intended for Linksys E1550, it could be
    run in an emulated environment using QEMU which also includes performing of exploitation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: DVRF是由*b1ack0wl*编写的固件，适用于基于MIPS的平台。尽管该固件是为Linksys E1550设计的，但可以在使用QEMU的模拟环境中运行，也包括执行利用：
- en: 'Now that we have the firmware with us, let''s go ahead and install GDB (GNU
    Debugger) and GEF for our debugging purposes during exploitation:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了固件，让我们继续安装GDB（GNU调试器）和GEF，以便在利用过程中进行调试：
- en: '[PRE11]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also make sure that you have the required QEMU packages installed on your system.
    Now that we have everything in place, let's go ahead and run one of the binaries
    using binary emulation leveraging the functionality of QEMU.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保您的系统上安装了所需的QEMU软件包。现在我们已经准备就绪，让我们继续使用二进制仿真来运行其中一个二进制文件，利用QEMU的功能。
- en: 'To do this, we will need to first extract the filesystem from the firmware
    using Binwalk as shown in the following screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们需要首先使用Binwalk从固件中提取文件系统，如下截图所示：
- en: '![](img/29ca73c7-dc1e-45d5-88c4-50307da2536a.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29ca73c7-dc1e-45d5-88c4-50307da2536a.png)'
- en: 'Once we have the filesystem extracted, we can copy the QEMU binary for the
    corresponding architecture in our root folder, which in this case is the `squashfs-root`
    as shown as follows. But before doing that, let''s confirm that our target binary
    is a binary meant for the MIPS architecture:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们提取了文件系统，我们可以将相应架构的QEMU二进制文件复制到我们的根文件夹中，本例中是`squashfs-root`，如下所示。但在这之前，让我们确认一下我们的目标二进制文件是否是针对MIPS架构的二进制文件：
- en: '[PRE12]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see from the preceding screenshot, our binary is meant for the MIPS
    architecture Little Endian format.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们的二进制文件是针对MIPS架构的小端格式。
- en: '![](img/641cb935-8cb4-4238-9eb7-a8b85b7d568d.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/641cb935-8cb4-4238-9eb7-a8b85b7d568d.png)'
- en: 'Let''s now go ahead and copy the QEMU binary for MIPS Little Endian (mipsel)
    to our current squashfs-root folder:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续将MIPS小端（mipsel）的QEMU二进制文件复制到我们当前的squashfs-root文件夹中：
- en: '[PRE13]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have copied the `qemu-mipsel-static` to our current directory, we can
    then use the change root (`chroot`) utility along with QEMU to both emulate the
    binary and run it, and at the same time have the binary believe that its root
    folder is the current folder from where we are running the command. This can be
    done using the following command:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将`qemu-mipsel-static`复制到当前目录，我们就可以使用更改根（`chroot`）实用程序以及QEMU来仿真并运行二进制文件，同时让二进制文件相信它的根文件夹是我们运行命令的当前文件夹。可以使用以下命令实现：
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see from the following screenshot, we are able to run the binary
    even though it was originally meant for another architecture. This is possible
    with the emulation functionality of QEMU and with the change root functionality
    of `chroot`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，我们能够运行这个二进制文件，尽管它最初是为另一种架构设计的。这是通过QEMU的仿真功能和`chroot`的更改根功能实现的。
- en: '![](img/6d12f136-9c52-49f4-bbb4-12bc7c5c6438.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d12f136-9c52-49f4-bbb4-12bc7c5c6438.png)'
- en: 'As we can see from the output of the command (shown in the preceding screenshot),
    this binary expects arguments to run. Additionally, if we look at the source code
    of the binary, we find that this binary is vulnerable to a stack-based buffer
    overflow vulnerability. The following is the source code of the `stack_bof1` binary:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们从命令的输出中所见（如前面的截图所示），这个二进制文件需要参数才能运行。此外，如果我们查看二进制文件的源代码，我们会发现这个二进制文件容易受到基于堆栈的缓冲区溢出漏洞的影响。以下是`stack_bof1`二进制文件的源代码：
- en: '![](img/3967adf3-6e71-4e61-a766-aecd601750aa.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3967adf3-6e71-4e61-a766-aecd601750aa.png)'
- en: As you can see from the preceding screenshot, the `buf` buffer is vulnerable
    to buffer overflow, and our goal with the overflow is to modify the program flow
    to point it to the address of `dat_shell` so that we get a shell from exploiting
    this vulnerability.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，`buf`缓冲区容易受到缓冲区溢出的影响，我们的溢出目标是修改程序流程，使其指向`dat_shell`的地址，以便从中利用此漏洞获得shell。
- en: 'Let''s start debugging this program by running it with QEMU and chroot, along
    with an additional flag of `-g` which will attach GDB to the process as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用QEMU和chroot以及附加的`-g`标志来调试这个程序，这将使GDB连接到进程，如下所示：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see from the following screenshot, the program execution has paused
    and it is now waiting for a debugger to connect:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您从以下截图中所见，程序执行已暂停，现在正在等待调试器连接：
- en: '![](img/4d1a23fe-2385-469e-ba1c-e20ae4028d12.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d1a23fe-2385-469e-ba1c-e20ae4028d12.png)'
- en: 'Now that the execution has paused, we can launch GDB and set up the target
    to remote along with the port which we have just assigned. Additionally, we will
    have to set the architecture to MIPS to be able to properly disassemble the binary
    if required:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行已经暂停，我们可以启动GDB并设置目标为远程以及我们刚刚分配的端口。此外，我们将不得不将架构设置为MIPS，以便在需要时能够正确地反汇编二进制文件：
- en: '![](img/9b7072b5-d229-48d0-9810-25ce3f9fa8e9.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b7072b5-d229-48d0-9810-25ce3f9fa8e9.png)'
- en: Once we have connected the target, you will find that the process has paused,
    which can be resumed by typing in `c` for continue.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一旦连接了目标，您会发现进程已暂停，可以通过输入`c`来恢复。 '
- en: 'We can also see the list of available functions in the binary by doing an `info
    functions` as follows, and identify the functions which could be interesting from
    our pen testing perspective:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过执行`info functions`来查看二进制文件中可用函数的列表，并从我们的渗透测试角度确定哪些函数可能是有趣的：
- en: '![](img/164ed18f-6f17-48c6-af4a-c559508756d1.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/164ed18f-6f17-48c6-af4a-c559508756d1.png)'
- en: Let's also go ahead and disassemble the `main` function and see how it looks.
    For this, we can simply do a `disass main`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续反汇编`main`函数并看看它的样子。为此，我们可以简单地执行`disass main`。
- en: 'As we can see from the following screenshot, we are able to see the disassembly
    of the `main` function:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们从下面的屏幕截图中看到的，我们能够看到`main`函数的反汇编：
- en: '![](img/4f2ec92c-46c9-4ad0-95fe-59c198e0edd1.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f2ec92c-46c9-4ad0-95fe-59c198e0edd1.png)'
- en: If you're familiar with some of the instructions, you will find the instructions
    useful. The disassembly is in the format of address, instruction, and operands.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉一些指令，您会发现这些指令很有用。反汇编以地址、指令和操作数的格式呈现。
- en: MIPS has a total of 32 general-purpose registers, including `$zero`, `$at`,
    `$v0-$v1`, `c`, `$t0-$t9`, `$s0-$s7`, `$k0`, `$k1`, `$gp`, `$ra`, `$fp`, and `$ra`.
    Out of all of these, `$a0-$a3` is meant for storing arguments to functions, `$t0-$t9`
    is for temporary data storage, `$gp` is the global area pointer (we try not to
    modify GP during exploitation), `$sp` is the stack pointer, `$fp` the frame pointer,
    and `$ra` is the return address. There is an additional special-purpose register
    called the **Program Counter** (**PC**) which stores the memory address of the
    next instruction, which is the instruction following the one which is currently
    being executed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS共有32个通用寄存器，包括`$zero`、`$at`、`$v0-$v1`、`c`、`$t0-$t9`、`$s0-$s7`、`$k0`、`$k1`、`$gp`、`$ra`、`$fp`和`$ra`。在所有这些寄存器中，`$a0-$a3`用于存储函数的参数，`$t0-$t9`用于临时数据存储，`$gp`是全局区指针（我们在利用过程中尽量不修改GP），`$sp`是堆栈指针，`$fp`是帧指针，`$ra`是返回地址。还有一个额外的特殊目的寄存器称为**程序计数器**（**PC**），它存储下一条指令的内存地址，即当前正在执行的指令的下一条指令。
- en: To take control of a MIPS-based binary program execution flow, we are only concerned
    with two registers - RA and PC. As you will realize while dealing with MIPS-based
    binaries, controlling PC is often tougher compared to RA. Thus, for this exercise,
    we will focus on taking control of RA.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制基于MIPS的二进制程序的执行流程，我们只关心两个寄存器 - RA和PC。当处理基于MIPS的二进制文件时，您会意识到控制PC通常比RA更困难。因此，在这个练习中，我们将专注于控制RA。
- en: 'Since we know that the current binary we are working with, `socket_bof`, is
    vulnerable to a stack-based buffer overflow, let''s run it with an extremely large
    argument. To generate the argument, we will use the pattern create functionality
    of GEF as shown in the following screenshot:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道我们正在处理的当前二进制文件`socket_bof`容易受到基于堆栈的缓冲区溢出的影响，让我们用一个极大的参数来运行它。为了生成参数，我们将使用GEF的模式创建功能，如下面的屏幕截图所示：
- en: '![](img/82bddf25-498c-4bd3-9b7b-29cad377e0fe.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82bddf25-498c-4bd3-9b7b-29cad377e0fe.png)'
- en: 'Once we have generated the pattern, we can run the `stack_bof_01` with the
    preceding generated argument and see whether we are able to overflow RA. The following
    screenshot shows running the program with the custom, 300-character-long argument
    generated from GEF:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们生成了模式，我们可以使用之前生成的参数运行`stack_bof_01`，并查看是否能够溢出RA。下面的屏幕截图显示了使用从GEF生成的自定义300字符长的参数运行程序：
- en: '![](img/0b82fc17-7a22-45a0-91b0-b797953262cf.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b82fc17-7a22-45a0-91b0-b797953262cf.png)'
- en: 'As expected, the binary execution state is paused and it is waiting for a debugger
    to attach to it because of the `-g` flag. Now open the GEF Terminal window and
    type in the `target` as shown in the following command and screenshot:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于`-g`标志，二进制执行状态已暂停，并且正在等待调试器连接。现在打开GEF终端窗口，输入`target`，如下面的命令和屏幕截图所示：
- en: '[PRE16]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/843e9d47-e5fc-44db-85c2-9993d6ceaa22.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/843e9d47-e5fc-44db-85c2-9993d6ceaa22.png)'
- en: 'Once you have the `target` set, you can hit `c`, which will continue the program
    till its completion or till it hits a breakpoint or exception. As we can see in
    the following screenshot, the program hits a `SIGSEGV` fault:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您设置了`target`，您可以按`c`，这将使程序继续执行，直到完成或遇到断点或异常为止。如下面的屏幕截图所示，程序遇到了`SIGSEGV`错误：
- en: '![](img/bf792834-36fc-4443-bfa6-41eadb08f11c.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf792834-36fc-4443-bfa6-41eadb08f11c.png)'
- en: GEF also shows us the entire state of the stack and registers at the time when
    it caught an exception. In our case, we can see that RA is overwritten with `0x63616162`,
    which simply is the hex for `baac`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: GEF还显示了在捕获异常时堆栈和寄存器的整个状态。在我们的情况下，我们可以看到RA被`0x63616162`覆盖，这只是`baac`的十六进制表示。
- en: Now we have the above information, let's use the pattern search function to
    find the offset of the bytes which overwrite RA. With this, we will be able to
    find out where we should place our malicious address and control the program execution
    flow.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了上述信息，让我们使用模式搜索功能来找到覆盖RA的字节的偏移量。有了这个，我们将能够找出我们应该放置恶意地址的位置，并控制程序的执行流程。
- en: 'To do this, we can use the command `pattern search RA-overflown-bytes-in-hex`
    as shown in the following screenshot:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用命令`pattern search RA-overflown-bytes-in-hex`，如下面的屏幕截图所示：
- en: '![](img/bfe00194-7601-4719-bc22-633919744bf2.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfe00194-7601-4719-bc22-633919744bf2.png)'
- en: As we can see from the preceding screenshot, we are able to find the offset
    of the characters which overflow the register RA, which in this case is `204`.
    This means we would need `204` bytes of junk to fill up everything before RA and
    the next `4` bytes would be the values with which RA is being overwritten with.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看到，我们能够找到溢出寄存器RA的字符的偏移量，在这种情况下是`204`。这意味着我们需要`204`字节的垃圾来填满RA之前的所有内容，接下来的`4`字节将是用来覆盖RA的值。
- en: 'If you remember our goal for this exercise was to modify the program execution
    flow and call the `dat_shell` function which would not have been called in the
    normal flow of the program. In order to find the address of `dat_shell`, we can
    either do a print `dat_shell` or we can disassemble and look at the starting address.
    This can be done by using the command `disass function-name` as shown in the following
    screenshot:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还记得我们这次练习的目标是修改程序执行流程并调用`dat_shell`函数，而这个函数在程序的正常流程中不会被调用。为了找到`dat_shell`的地址，我们可以打印`dat_shell`，或者我们可以反汇编并查看起始地址。这可以通过使用`disass
    function-name`命令来完成，如下面的屏幕截图所示：
- en: '![](img/28dcea40-224e-48d7-b1e2-80f606697a73.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28dcea40-224e-48d7-b1e2-80f606697a73.png)'
- en: As we can see from the preceding screenshot, the `dat_shell` function starts
    from the `0x00400950` address. However, the first three instructions work with
    **Global Pointer** (**GP**) which we don't want to play around with at this moment.
    This is the reason we will jump to `0x0040095c` instead of `0x00400950`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看到，`dat_shell`函数从`0x00400950`地址开始。然而，前三条指令使用了**全局指针**（**GP**），这不是我们此刻想要处理的。这就是为什么我们会跳转到`0x0040095c`而不是`0x00400950`的原因。
- en: 'So, let''s go ahead and run the binary with `204` characters of junk followed
    by the address `0x0040095c`. This time, we have also removed the `-g` flag and
    run it directly as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们继续运行带有`204`个字符的垃圾，后跟地址`0x0040095c`的二进制文件。这次，我们还删除了`-g`标志，并直接运行如下：
- en: '[PRE17]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/ac22f79f-9b17-4b15-a3b3-d300b6c56a43.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac22f79f-9b17-4b15-a3b3-d300b6c56a43.png)'
- en: As we can see from the preceding screenshot, the binary has now executed the
    `dat_shell` function as we wanted. This is how we perform a stack-based buffer
    overflow on a MIPS-based platform.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看到，二进制文件现在已经按我们的要求执行了`dat_shell`函数。这就是我们在基于MIPS的平台上执行基于堆栈的缓冲区溢出的方法。
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The entire underlying concept of buffer overflows is being able to put more
    characters in the buffer than what is intended to be entered, and in that way,
    controlling the registers which might be present on the stack. This can also be
    used to jump to a shellcode's location or to the system's `libc` library and executing
    additional payloads.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出的整个基本概念是能够在缓冲区中放入比预期输入更多的字符，并以这种方式控制可能存在于堆栈上的寄存器。这也可以用于跳转到shellcode的位置或系统的`libc`库，并执行额外的有效载荷。
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even though we could perform exploitation in this vulnerable binary, often in
    real-world situations, you would be presented with more complicated scenarios.
    One of them being the fact that interesting functions to jump to won't be located
    inside the binary and you would have to either jump to system to execute `bin/sh`
    or create a ROP chain to execute your shellcode.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在这个有漏洞的二进制文件中执行利用，但在现实世界的情况下，您可能会遇到更复杂的情况。其中之一是有趣的函数不会位于二进制文件内，您将不得不跳转到系统以执行`bin/sh`，或者创建一个ROP链来执行您的shellcode。
- en: Backdooring firmware with firmware-mod-kit (FMK)
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用固件修改工具（FMK）来设置后门
- en: One of the techniques that often come in useful during exploitation is the ability
    to modify firmware. This can be done by extracting the filesystem from the firmware,
    modifying the contents, and then repackaging it into new firmware. This new firmware
    could then be flashed to the device.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用过程中经常有用的技术之一是修改固件的能力。这可以通过从固件中提取文件系统，修改内容，然后将其重新打包成新的固件来实现。然后可以将这个新的固件刷入设备。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to modify firmware, we will use a tool called FMK written by *Jeremy
    Collake* and *Craig Heffner*. FMK utilizes Binwalk and additional tools to extract
    the filesystem from the firmware and also provides us with the ability to repackage
    the modified filesystem into a new firmware binary.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改固件，我们将使用一个名为FMK的工具，由*Jeremy Collake*和*Craig Heffner*编写。 FMK利用Binwalk和其他工具从固件中提取文件系统，并为我们提供重新打包修改后的文件系统到新固件二进制文件的能力。
- en: FMK can be downloaded from [https://github.com/brianpow/firmware-mod-kit/](https://github.com/brianpow/firmware-mod-kit/)
    or it might already be present in your system if you cloned the FAT tool earlier.
    Once you have downloaded it, we need firmware which we can try it out on. To keep
    things simple and so that everyone who is reading this book can replicate the
    following steps without investing in purchasing hardware, we will use firmware
    which can be emulated well using FAT.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: FMK可以从[https://github.com/brianpow/firmware-mod-kit/](https://github.com/brianpow/firmware-mod-kit/)下载，或者如果您之前克隆了FAT工具，它可能已经存在于您的系统中。下载完成后，我们需要固件来进行尝试。为了简化事情，以便阅读本书的每个人都可以在不购买硬件的情况下复制以下步骤，我们将使用可以在FAT中很好地模拟的固件。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following are the steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤：
- en: 'The firmware that we will use in this case is firmware by D-Link, the DIR-300
    router. In order to extract the filesystem from the firmware, instead of using
    Binwalk, we will use the `extract-firmware.sh` script located in the FMK directory,
    as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用D-Link的DIR-300路由器的固件。为了从固件中提取文件系统，我们将使用FMK目录中的`extract-firmware.sh`脚本，而不是使用Binwalk，如下所示：
- en: '[PRE18]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/8ce54461-9a12-4f50-81c5-5b12f5bddde9.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ce54461-9a12-4f50-81c5-5b12f5bddde9.png)'
- en: Once we have extracted the firmware, it will contain a new directory for us
    including the folders `rootfs`, `image_parts`, and `logs`. For most of our backdooring
    and firmware modification purposes, we will only be concerned with the `rootfs`
    folder.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了固件，它将为我们包含一个新目录，其中包括`rootfs`、`image_parts`和`logs`文件夹。对于大多数后门和固件修改目的，我们只关心`rootfs`文件夹。
- en: The `rootfs` folder contains the entire filesystem of the firmware. All we need
    to do is create a backdoor for the firmware's architecture and then find a way
    to invoke it automatically once the firmware starts.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`rootfs`文件夹包含固件的整个文件系统。我们所需要做的就是为固件的架构创建一个后门，然后找到一种在固件启动时自动调用它的方法。'
- en: 'Let''s first find out which architecture the firmware is meant for. We can
    find this out by doing a `readelf` on any of the firmware binaries, such as BusyBox,
    as shown in the following screenshot:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先找出固件是为哪种架构而设计的。我们可以通过对任何固件二进制文件（如BusyBox）进行`readelf`来找出这一点，如下截图所示：
- en: '![](img/0cecc090-c60e-40b6-bb9e-82196ef4834e.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cecc090-c60e-40b6-bb9e-82196ef4834e.png)'
- en: 'As we can see from the preceding screenshot, it is a MIPS-based Little Endian
    architecture. This means that we will need to create and compile a backdoor for
    the MIPS Little Endian format. The following is the backdoor we are going to use,
    written originally by *Osanda Malith*:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中看到的，它是基于MIPS Little Endian架构。这意味着我们需要为MIPS Little Endian格式创建和编译一个后门。以下是我们将要使用的后门，最初由*Osanda
    Malith*编写：
- en: '[PRE19]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once we have the code, we can use Buildroot for MIPSEL and compile it using
    a crosscompiler built using Buildroot. We won't go into the process of setting
    up Buildroot as the process is extremely straightforward and has been documented
    in the documentation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了代码，我们就可以使用Buildroot for MIPSEL，并使用使用Buildroot构建的交叉编译器进行编译。我们不会详细介绍设置Buildroot的过程，因为这个过程非常简单，并且已经在文档中有所记录。
- en: 'Once we have created our cross compiler for MIPSEL, we can compile the `bindshell.c`
    to `bindshell` binary which then could be placed in the extracted filesystem of
    the firmware:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们为MIPSEL创建了交叉编译器，我们就可以将`bindshell.c`编译为`bindshell`二进制文件，然后将其放置在固件的提取文件系统中：
- en: '[PRE20]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next step is to look for places where we could place this binary in the
    filesystem, and how we can make this autostart during boot up. This could be done
    by looking at one of the scripts which would be invoked automatically during boot
    up.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是寻找我们可以将这个二进制文件放置在文件系统中的位置，以及如何在启动时自动启动。这可以通过查看其中一个在启动时会自动调用的脚本来完成。
- en: 'Upon looking at the filesystem, we can add the binary in `etc/templates/` and
    can refer it from the script called `system.sh` located at `/etc/scripts/`, as
    shown in the following screenshot:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件系统后，我们可以将二进制文件添加到`etc/templates/`中，并可以从位于`/etc/scripts/`的名为`system.sh`的脚本中引用它，如下截图所示：
- en: '![](img/8e331f34-ed6f-4667-b80c-5c87907c098f.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e331f34-ed6f-4667-b80c-5c87907c098f.png)'
- en: 'Now, let''s go ahead and build new firmware based on this modification using
    the `build-firmware.sh` script as shown in the following screenshot:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续根据这个修改构建新的固件，使用`build-firmware.sh`脚本，如下截图所示：
- en: '![](img/c913fb64-af2c-4e09-8fb2-c8e2d654b37e.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c913fb64-af2c-4e09-8fb2-c8e2d654b37e.png)'
- en: Once it finishes the building process, it will create new firmware and place
    it in the location `firmware-name/` as a file called `new-firmware.bin`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成构建过程，它将创建新的固件，并将其放置在`firmware-name/`位置，命名为`new-firmware.bin`。
- en: 'Once we have the new firmware image, we can copy this firmware to our FAT directory
    and emulate it to verify that our added backdoor is working. This can be done
    using the same steps which we used earlier for emulation. This is also shown in
    the following screenshot:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了新的固件映像，我们就可以将这个固件复制到我们的FAT目录中，并进行仿真以验证我们添加的后门是否有效。这可以通过与我们之前用于仿真的相同步骤来完成。这也显示在以下截图中：
- en: '![](img/aac333e5-dc78-4677-adf0-ed215872c634.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aac333e5-dc78-4677-adf0-ed215872c634.png)'
- en: As we can see from the preceding screenshot, it gives us an IP address of `192.168.0.1`
    which we can now try to access. But more interestingly, let's see whether our
    backdoor bindshell which we placed in the firmware is active or not.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中看到的，它给了我们一个IP地址`192.168.0.1`，我们现在可以尝试访问。但更有趣的是，让我们看看我们放置在固件中的后门bindshell是否激活。
- en: 'Let''s try to run a Netcat to port `9999` on the preceding IP and see whether
    it works:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在前面的IP上运行一个连接到端口`9999`的Netcat，并看看它是否有效：
- en: '![](img/3cea80f6-a14b-4bd8-b90e-c556ff4847ac.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cea80f6-a14b-4bd8-b90e-c556ff4847ac.png)'
- en: Now we have a full root shell on the device because of a backdoor which we modified
    and placed in the firmware. From here, we can modify additional device configurations
    or simply use it to access any device running our modified malicious firmware
    remotely.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们修改并放置在固件中的后门，我们在设备上有了完整的root shell。从这里，我们可以修改其他设备配置，或者简单地使用它来远程访问运行我们修改后的恶意固件的任何设备。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ability to modify firmware is extremely powerful and useful for attackers.
    This enables the attackers to bypass protection mechanisms, remove security features,
    and do more. Due to tools such as FMK, it becomes extremely easy for attackers
    to add their own malware or backdoor to any IoT device firmware, which could then
    be used by a user located anywhere in the world.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 修改固件的能力对攻击者来说是非常强大和有用的。这使得攻击者能够绕过保护机制，移除安全功能等。由于诸如FMK之类的工具，攻击者可以非常容易地向任何物联网设备固件中添加自己的恶意软件或后门，然后用户可以在世界任何地方使用它。
- en: This is also one of the reasons why signature and checksum verification of firmware
    is extremely important to prevent attacks arising because of malicious or modified
    firmware.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是固件签名和校验和验证非常重要的原因之一，以防止因恶意或修改的固件而引起的攻击。
