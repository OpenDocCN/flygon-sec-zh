# 高级物联网利用和安全自动化

在本章中，我们将涵盖以下内容：

+   查找 ROP 小工具

+   链接 Web 安全漏洞

+   为固件配置持续集成测试

+   为 Web 应用程序配置持续集成测试

+   为移动应用程序配置持续集成测试

# 介绍

为了利用物联网的漏洞并能够保护自己免受攻击，需要自动化来开发武器化的概念证明，并为防御安全团队提供可扩展性。如果安全团队无法跟上代码推送和开发的速度，就会引入漏洞。此外，安全团队需要适应开发团队的速度，不要阻碍他们当前的安全测试和审查流程。本章将介绍高级物联网利用技术，以及以自动化方式发现和防止物联网漏洞的方法。

# 查找 ROP 小工具

在利用嵌入式设备的过程中，最重要的事情之一是能够利用易受攻击的二进制文件，使用**返回导向编程**（**ROP**）等技术，这正是我们将在本节中讨论的内容。

我们需要这种技术的原因是，在利用过程中，我们经常需要将最终结果作为 shell 或执行后门，这可以为我们提供额外的信息或访问敏感资源。

ROP 的概念在 ARM 和 MIPS（甚至 x86）中是相同的；然而，我们需要记住一些平台级别的差异。简单来说，ROP 涉及从各个位置拾取特定指令（小工具），并将它们链接在一起构建完整的 ROP 链，以执行特定任务。

# 准备工作

如前所述，要执行 ROP，我们需要能够识别可以链接在一起的有用 ROP 小工具。要找到这些特定的小工具，我们可以手动查看 libc 或其他库中的各个位置，或者使用自动化工具和脚本来帮助我们完成相同的工作。

为了简化问题，我们将以 ARM 上的易受攻击程序为例，并稍后查看一些其他示例，以帮助我们加深对基于 ROP 的利用的理解。

我们需要的一些组件如下：

+   **GDB-Multiarch**：各种架构的 GDB

+   **BuildRoot**：用于为 ARM 架构编译我们的易受攻击程序

+   **PwnDbg**：这是帮助利用的 GDB 插件

+   **Ropxx**：这是帮助我们组合 ROP 小工具并构建最终链的 Python 脚本

目前我们不打算使用任何自动化工具，而是专注于手动方法，以便理解基本原理。如果您以后想使用自动化工具（我建议这样做），您可以查看*另请参阅*部分，了解一些有用的链接。

# 操作步骤

在本节中，我们将看看如何开始利用 ARM 环境中的简单堆栈缓冲区溢出。

1.  在这种情况下，易受攻击的程序如下：

```

#include <stdio.h> 
#include <stdlib.h> 
void IShouldNeverBeCalled() 
{ 
puts("I should never be called\n"); 
exit(0); 
} 
void vulnerable(char *arg) 
{ 
char buff[10]; 
strcpy(buff,arg); 
} 
int main(int argc, char **argv) 
{ 
vulnerable(argv[1]); 
return(0); 
} 
```

正如您在前面的程序中所看到的，`main`函数接受用户提供的输入，然后将该参数传递给具有 10 字节缓冲区（名为 buff）的易受攻击函数。如预期的那样，如果输入参数的大小显着大于 buff 的大小，就会导致溢出。

一旦溢出了 buff，我们需要找到一种方法来覆盖`pc`或`lr`寄存器，以控制程序执行流。这可以通过在`strcpy`地址设置断点，然后分析复制前后的堆栈来完成。

1.  让我们首先使用 Qemu 仿真运行这个程序，用于 ARM 架构：

![](img/f923203f-f2e3-4220-af7f-082226249514.png)

我们还添加了`-g`参数，以便将调试器附加到运行的实例上，这里是端口`12345`，现在我们可以使用 GDB 连接，如下所示。

1.  我们将在这里使用 GDB-multiarch，然后指定 sysroot 和远程目标，如下面的屏幕截图所示：

![](img/a453c807-b295-4515-b153-58670f379b82.png)

让我们在 main 处设置一个断点（b main）并继续（c）程序。

现在来看寻找 gadgets 的有趣部分。要找到有用的 gadgets，我们需要寻找一些指令，这些指令允许我们设置某些值，我们可以跳转到这些值，比如说 system（在我们当前的情况下），同时在跳转时，将地址作为`/bin/sh`的参数，这将给我们提供 shell。

这意味着我们可能需要将`system`的地址放在`pc`或`lr`中，将`/bin/sh`的地址放在`r0`中，这是 ARM 中的第一个寄存器，也是作为被调用函数的参数。一旦我们找到了允许我们执行所有这些操作的指令，我们还需要确保在我们之前提到的有用指令之后的指令中有一个这些内容，即要么跳转到我们控制的地址，要么`pop {pc}`或`pop {lr}`。

1.  如果我们查看`libc`中存在的函数之一`erand48`的反汇编，我们可以看到它具有一组特定的有用指令，这些指令允许我们控制执行并设置寄存器的值。如下面的屏幕截图所示：

![](img/e8958a75-fe9e-4aba-9388-cd0f9f88596e.png)

以下是我们感兴趣的三条指令：

1.  1.  `lmd sp, {r0, r1}`：此指令从堆栈中加载`r0`和`r1`的值。这将用于控制`r0`，它作为我们即将跳转到的函数（system）的参数。

1.  `add sp, sp, #12`：此指令简单地将堆栈指针增加`12`。

1.  `pop {pc}`：此指令从堆栈中弹出值并将其放入`pc`，这意味着我们将能够控制程序的执行。

现在我们需要找到两件事，它们分别是：

1.  1.  `system`的地址。

1.  1.  `/bin/sh`的地址。

1.  我们可以使用`print`命令或使用`disass system`找到`system`的地址，如下面的屏幕截图所示：

![](img/b0a19344-b3eb-4fd8-83c1-c1d532ca99a3.png)

1.  现在，让我们生成一个 50 个字符的循环字符串，并看看我们如何溢出缓冲区以成功跳转到`errand48`：

![](img/790b6335-21ee-4418-badf-395aeb5805a6.png)

1.  让我们使用生成的字符串调试程序：

![](img/ff91c4d0-3d74-4b23-bdd3-97393858776d.png)

1.  现在我们将在易受攻击的函数处设置一个断点并继续执行。GDB 将触发断点，如下面的屏幕截图所示：

![](img/aade2565-8feb-42a0-9db2-2fdff0ec66dd.png)

1.  让我们也在易受攻击的函数的最后一条指令处设置一个断点：

![](img/895ce702-a883-4cd2-8984-872d25808228.png)

1.  一旦断点被触发，让我们分析一下堆栈：

![](img/9257c1d1-8390-4d32-821f-e5df160123c2.png)

突出显示的指令将从堆栈中弹出两个双字（double words），分别放入`fp`和`pc`。如果我们在这里查看堆栈中的第二个值，它是`0x61616165`（'eaaa'），这意味着这个值将放入`pc`。

1.  如果我们查看此值的偏移量，我们将能够找出如果我们想要用我们期望的地址覆盖`pc`，偏移量将是多少个字符。我们可以使用`cyclic` `-l 0x61616165`来找到这个值，如下面的屏幕截图所示：

![](img/55877aa0-d6e0-41af-8894-9b8413cb8ec8.png)

1.  这意味着我们需要以小端格式将我们期望的`pc`值（`erand48`的`ldm`指令）放在偏移量为 16 的位置。

我们可以使用以下 Python 代码生成新的字符串：

![](img/c955cc3e-b427-4da4-a652-6de82d8c106e.png)

1.  接下来，我们可以重新运行生成的字符串，如下面的屏幕截图所示：

![](img/b387db38-5b7f-4808-8411-347674db7c27.png)

1.  在这个阶段，像之前一样附加 GDB。在易受攻击的函数的最后一条指令的地址`0x84e0`上设置断点：

![](img/b98021d4-b4c9-467c-bcfb-f3ba13fa7a8f.png)

1.  这一次我们可以看到`pc`被加载到`erand48`指令的地址`0x4087b9dc`。让我们使用`ni`步进一条指令，达到`ldm`指令：

![](img/dacc9ae1-2b73-4594-bb4c-5852142711b9.png)

1.  正如我们在这一步看到的，寄存器`r0`加载了`0x61616161`，这是我们想要放置`/bin/sh`字符串地址的寄存器：

![](img/6d6a4fb1-9cb7-4831-9847-ff3afcf4fbf5.png)

1.  有效的偏移量将是*16 + 4 + 0 = 20*，如下所示：

```
 "A"*16 => 16 bytes 
 "\xdc\xb9\x87\x40" => 4 bytes
```

1.  因此，在偏移量 20 处，我们需要放置`/bin/sh`字符串的地址，然后将其作为参数传递给系统。通过两次步进，我们可以到达 pop，如下截图所示：

![](img/9fb9b1f6-50d0-49f7-aa33-cc8967718ff7.png)

1.  `pc`将获得值`0x61616164`，偏移量可以用与之前相同的方式计算：

![](img/2ff96be0-6be7-4173-835c-6681bc305cd7.png)

1.  因此，`pc`的有效偏移量将是：

*16 + 4 + 0 + 12 = 32*

这意味着在偏移量 32 处，我们需要放置系统的地址，这是我们之前找到的。

另外，让我们继续在偏移量 36 处放置`/bin/sh`的 ASCII 字符串，并在偏移量 20 处引用它。因此，栈上字符串的地址将是`0x407fff18`。

1.  我们可以使用`ropgen`模块来生成利用字符串，如下截图所示：

![](img/ab5e3be6-f1b0-47e9-844a-6c94bc0bbf5a.png)

1.  让我们再次调试并执行一遍：

![](img/69ceeee0-4890-42a4-8f3e-bdd7a60e7d03.png)

1.  如果我们现在查看栈，ASCII 字符串`/bin/sh`现在位于地址`0x407fff38`，这意味着我们需要调整我们的代码以反映这一点：

![](img/441da483-a57b-446f-a5c4-a5b15ced8af3.png)

1.  通过与之前相同的方式调试，我们可以看到这一次我们的 ASCII 字符串被加载到了正确的地址：

![](img/933b13f7-c07a-4b83-b103-d44cbb6965a5.png)

1.  我们可以再次步进到达`erand48`地址，如下截图所示：

![](img/2e5e9c80-8d99-40c4-9e36-8474fd966aa6.png)

1.  这一次寄存器`r0`存储了所需的 ASCII 字符串的地址。通过两次按**c**来到达函数的最后一条指令（pop pc），如下所示：

![](img/e911f0e7-93cf-4906-9c8c-0420d0cf539f.png)

1.  `pop {pc}`将从栈中加载系统的地址并将其放入`pc`，然后将带有我们`/bin/sh`字符串地址的`r0`传递给系统。我们可以查看 regs 来确认这一点：

![](img/51562d9d-cf40-4b10-927f-adc7a41b5cde.png)

1.  一旦我们按下`c`，我们将能够获得一个 shell，如下所示：

![](img/bfddccc7-2162-49bb-a85a-679fe0c5ad95.png)

因此，我们能够利用基于堆栈的缓冲区溢出，并使用 ROP 跳转到系统，并使用我们期望的字符串作为参数，利用`erand48`函数中的指令，最终获得一个 shell。

然而，这只是一个在基于 ARM 的架构上开始使用 ROP 的非常简单的例子。类似的技术可以应用于 MIPS 上的 ROP，如下所示。我们在这里展示的另一件事是如何解决缓存不一致的问题，这通常在利用过程中出现。

1.  我们在这种情况下寻找的易受攻击程序是来自 DVRF 固件的`socket_bof`。在这种情况下，我们将要跳转到的第一条指令是`sleep`，并提供我们想要休眠的时间作为参数。我们调用`sleep`来刷新缓存，然后稍后准备我们的小工具，以调用系统并将命令地址作为参数，如下所示。下面的截图显示了我们的第一个小工具的样子：

![](img/5d50b447-9879-4033-aceb-492f3f997d73.png)

正如我们所看到的，通过这个小工具，除了设置`$a0`之外，这是第一个寄存器（就像 ARM 中的`r0`一样），我们还能够控制**返回地址**（**RA**）和一些其他寄存器，比如`$fp`，`$s7`，`$s6`...`$s0`，最后跳转到`$ra`。

1.  在下一个小工具中，我们将准备使用已经设置的`$a0`值跳转到`sleep`。请注意，在这个小工具中，`$t9`正在从我们在前一个小工具中能够控制的`$s0`中获取值：

![](img/f08807eb-ef79-4436-b0f1-d23f24259a9e.png)

1.  一旦我们设置好这个小工具，下一个小工具将设置系统参数（我们要执行的字符串命令的地址），并允许我们跳转到系统。在这种情况下，参数是`$sp+24`，而`$t9`（我们要设置为系统地址）从`$s3`中获取其值，而我们在前面提到的第一个小工具中能够控制`$s3`。

![](img/78c5d533-c622-4599-a82d-a14c611d871d.png)

1.  一旦我们把所有的小工具都放好，下一步显然是计算各种偏移量，以确保我们的 ROP 链能够正常工作。整个 ROP 链看起来就像下面截图中所示的那样：

![](img/3b7c6f10-29f5-449f-8cd6-9b912d0e83ed.png)

1.  接下来，将各个参数放在正确的位置，运行二进制文件，并从`/proc/maps`中找出`libc`地址：

![](img/2cacb017-45cd-481d-a56a-c6f2a1d76709.png)

1.  一旦正确识别了`libc`地址并且程序运行起来，您应该能够看到我们的参数现在在运行时放在了正确的地址，可以使用 GDB 进行确认：

![](img/6e76df9c-cebc-4ad0-86bd-16a0b0beb754.png)

在上面的截图中，`id`就是我们想要执行的命令。

1.  总之，在这种情况下，我们的 ROP 链看起来是这样的：

![](img/52f3fe0b-b46e-4195-a08b-61663ed82c48.png)

这就是 ROP 利用的全部内容，我们将介绍 ARM 和 MIPS 的示例。在现实世界的场景中，应用是一样的——可能不仅仅是几条指令，你需要一些指令来形成你的 ROP 链。

# 另请参阅

您可以查看一些自动化工具，这些工具将帮助您在各种平台上进行基于 ROP 的利用过程。建议您查看的一些工具如下：

+   ROPGadget: [`github.com/JonathanSalwan/ROPgadget`](https://github.com/JonathanSalwan/ROPgadget)

+   MoneyShot: [`github.com/blasty/moneyshot`](https://github.com/blasty/moneyshot)

# 链接 Web 安全漏洞

当对手针对某种 IoT 设备时，通常会利用多个漏洞来武装攻击。这些漏洞本身可能在严重性上较低；然而，当结合在一起时，攻击的影响就会更大。多个低级漏洞组合成一个严重漏洞并不罕见。这在 IoT 设备方面尤为重要。在 IoT 设备中发现的一个严重漏洞可能会危及设备的完整性。本文将介绍如何将 Web 安全漏洞链接在一起，以在没有钥匙、车钥匙或凭据的情况下访问 Subaru 连接的车辆。

任何漏洞研究都必须在合法范围内进行。对 MySubaru 账户和 Subaru 服务器进行未经授权的测试是非法的。所有测试都应该在受控环境中进行，并且应该是合法拥有的。尽管 Subaru 远程服务不能控制发动机和传动系统功能，但测试结果是未知的。本文中的所有严重漏洞都已被 Subaru 报告并解决。

# 如何做到这一点...

进行任何评估的第一步是威胁建模；在这种情况下，从黑盒的角度对 2017 年 Subaru WRX STi 连接车辆进行威胁建模。首先确定车辆的入口点，这将提供一个已识别的攻击面，可以在此基础上构建。

# 步骤 1 - 确定资产和入口点

每辆车都不同，有些型号比其他型号拥有更多的功能。研究 Subaru 连接车辆和不同型号和年份之间的功能之间的公开资源。例如，我们知道连接车辆可以通过蜂窝 4G/LTE 连接访问互联网，但其他车辆可能通过手机连接或其他方式（如 Wi-Fi）获得互联网访问。让我们从这里开始，在执行任何主动攻击阶段之前记录我们对目标车辆的了解：

+   **蜂窝连接**：Subaru 连接车辆通过 AT&T 4G LTE 连接到互联网（[`about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html`](http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html)）。

+   **Wi-Fi**：目标 Subaru 车辆中没有 Wi-Fi。

+   **蓝牙**：车载娱乐系统通过蓝牙连接设备，以访问媒体、设备通讯录和消息。

+   **钥匙链**：要进入和启动这辆特定的车辆，需要钥匙链。钥匙链在 314.35-314.35 MHz 的频率范围内传输（[`fccid.io/HYQ14AHC`](https://fccid.io/HYQ14AHC)）。

+   **USB 连接**：车载娱乐系统使用 USB 连接设备的媒体以及 GPS 和车载娱乐系统本身的更新。

+   **SD 卡**：车载娱乐系统有一个 microSD 卡插槽用于 GPS 地图。

+   **OBD II**：用于访问 CAN 总线进行诊断，并可以在车辆上刷写 ECU 图像以进行调整或其他性能修改。

+   **CAN 总线**：每辆车都有一个或多个 CAN 总线用于车内通信。CAN 总线本身是容易受到攻击的，可以使用免费工具进行嗅探。

+   **移动应用程序**：Subaru 的 Starlink 车载技术连接到 MySubaru 应用程序，允许您远程锁定和解锁车辆，访问您的喇叭和灯光，查看车辆健康报告，并在地图上找到您的车辆。要使用这些功能，必须购买订阅。

+   **网络应用程序**：除了 MySubaru 移动应用程序外，Subaru 的 Starlink 车载技术连接到一个网络界面，允许您远程锁定和解锁车辆，访问您的喇叭和灯光，更改用户设置，安排服务，添加授权用户，并在地图上找到您的车辆。要使用这些功能，必须购买订阅。

现在我们已经列出了连接车辆的入口点，我们对首要攻击目标有了更好的了解。我们还可以根据我们的技能和舒适度来评估努力的程度。

# 步骤 2 - 找到最薄弱的环节

对车载娱乐系统和 CAN 总线的研究已经很多。在蓝牙、Wi-Fi 或钥匙链中发现的任何协议漏洞可能会变成一个零日漏洞，并需要相当长的时间。话虽如此，让我们把注意力转向 MySubaru 移动应用程序和网络应用程序。对于移动和网络应用程序，与车辆的接近并不是必要的。所需的只是一个 STARLINK Safety Plus 和 Security Plus 订阅，支持的车型和 MySubaru 账户的凭据。这很好，因为我们可以同时处理这三个应用程序。此外，Subaru 已经委托通过其移动和网络应用程序解锁、锁定、按喇叭和定位车辆。目标应用程序是 MySubaru Android 和 iOS 应用程序的 1.4.5 版本。发现的任何应用程序级别的漏洞可能会产生高级别的影响，也可能对 Subaru 车主构成安全问题。

# 步骤 3 - 侦察

由于我们将精力集中在应用程序上，我们需要对所有三个应用程序进行一定程度的侦察。让我们先从移动应用程序开始，然后再转向网络应用程序。

# 安卓应用程序

在执行动态测试之前，Android 应用程序很容易进行静态拆解和分析。反向 Android 应用程序需要一定程度的努力，但如果我们能发现低 hanging fruit，那么我们就能轻松获胜。我们首先需要通过第三方市场获取 MySubaru 应用程序，并确保它与 Google Play 版本相同。验证后，应采取以下步骤对 MySubaru Android 应用程序进行基线侦察：

+   使用 MobSF 或类似工具拆解 APK：

+   分析类和方法

+   识别第三方库

+   确定应用程序是原生的还是混合的

+   寻找硬编码的值

+   寻找潜在的秘密和环境

+   安装应用程序并监视 Android 组件

+   活动、服务和意图

+   分析数据存储

+   SD 卡使用

+   `SharedPreferences.xml`

+   缓存

+   SQLite 数据库

+   代理 Android 应用程序到车辆的所有 API 请求，使用 Burp Suite 或类似工具。

+   登录/注销

+   解锁/锁定

+   按喇叭

+   闪烁灯光

+   找到车辆

+   查看车辆健康报告

+   编辑车辆详细信息

确保为 Android 通信进行颜色编码的高亮显示和注释。这将有助于在编译用于识别 Android 漏洞的不同 API 调用时，以及其他 Subaru 应用程序时使用。

# iOS 应用程序

在反向 iOS 应用程序时，需要更多时间来获取 IPA 文件，解密它，将应用程序二进制文件传输到我们的主机计算机，然后努力找到漏洞。在这种情况下，我们必须通过 App Store 下载 MySubaru 应用程序，并执行解密和二进制传输到我们的主机计算机。完成后，应采取以下步骤对 iOS MySubaru 应用程序进行基线侦察：

+   使用 Hopper 或类似工具拆解 iOS 二进制文件：

+   分析类和方法（使用 Class-dump-z）

+   识别第三方库

+   确定应用程序是原生的还是混合的

+   寻找硬编码的值

+   寻找潜在的秘密和环境

+   安装应用程序并监视 iOS 组件：

+   通过 URL schemes 进行 IPC

+   分析数据存储：

+   Plists

+   SQLite 数据库

+   Cache.db

+   本地存储

+   代理 iOS 应用程序到车辆的所有 API 请求，使用 Burp Suite 或类似工具：

+   登录/注销

+   解锁/锁定

+   按喇叭

+   闪烁灯光

+   找到车辆

+   查看车辆健康报告

+   编辑车辆详细信息

应该注意 iOS 和 Android API 调用之间的差异。数据存储也应该注意，重点放在个人详细信息和凭据上。应根据对两个应用程序执行的侦察来确定潜在的障碍。例如，两个移动应用程序都通过`POST`请求发送远程服务调用，其中包含一个`sessionId`参数值，对于每个请求都是唯一的。

这可能会妨碍我们伪造远程服务请求的能力，因为这个值是唯一的，而不是硬编码的值。在 iOS 应用程序中发现的一个关键观察是将所有 HTTP 请求和响应缓存到`Cache.db` SQLite 数据库中。`Cache.db`中的所有数据都是明文，包括车辆详细信息、个人所有者详细信息、帐户令牌和 API 请求，攻击者可以在备份 iOS 设备或使用 iFunbox 等免费工具时提取这些数据。

以下截图显示了 URL 中带有`handoffToken`令牌的缓存请求：

![](img/67d4eb47-993a-4b9e-b148-443ab09c1158.png)

# 网络应用程序

接下来，我们将查看 MySubaru 网络应用程序，并检查所有 HTTP 请求和响应。MySubaru 网络应用程序包含移动应用程序没有的其他选项，例如添加授权用户或更改帐户 PIN 码。代理网络应用程序流量时，应确保点击和分析所有状态配置更改，例如以下列出的更改：

+   登录/注销

+   锁定/解锁

+   按喇叭

+   闪烁灯光

+   找到车辆

+   查看车辆健康报告

+   编辑车辆详细信息

+   添加车辆

+   添加和删除授权用户

+   更改 PIN

+   更改密码

+   更改安全问题

+   更改个人账户详情

应该注意网络应用程序和移动应用程序之间的所有差异。到目前为止，网络应用程序和移动应用程序之间的一个主要区别是远程服务 API 请求如何发送到 Subaru 服务器。API 端点对所有应用程序保持不变，如果我们发现漏洞可以利用，这将是有用的。

以下屏幕截图显示了 Burp Suite 中所有应用程序的 HTTP 历史记录，并进行了颜色编码：

![](img/42b354f1-a899-4f38-96b3-b7318530ac8c.png)

# 第 4 步 - 识别漏洞

在我们的 Web 代理中记录了所有应用程序功能和 API 调用后，我们现在可以开始识别设计中的漏洞，并测试逻辑缺陷以寻找漏洞。以下是观察到的漏洞列表：

1.  网络应用程序通过 URL 发送所有远程服务调用，作为`GET`请求，而移动应用程序则将远程服务调用作为`POST`发送，参数在请求体中。在网络应用程序中没有随机生成的`sessionIds`用于执行远程服务调用。

1.  移动应用程序没有强制证书固定和验证。

1.  iOS 应用程序的所有请求和响应都被缓存。

1.  账户配置更改，如编辑车辆详情或添加授权用户，不包含反 CSRF 令牌。

1.  当添加授权用户时，所有者不会收到通知。

1.  账户 PIN 的更新不需要知道先前设置的 PIN。

1.  安全问题的更新不需要重新身份验证，没有最小字符长度，并且可以都是相同的值，如 1。

1.  授权用户对 Subaru 远程服务拥有完全访问权限，并且没有添加限制。

1.  所有应用程序都没有并发登录策略。

以下是不需要身份验证或先前了解设置即可进行更改的 PIN 和安全问题更新配置部分的屏幕截图：

![](img/6c7f1627-47fb-466e-ada1-a326df8db7e9.png)

现在我们可以开始更改反映用户输入到屏幕的配置参数值。由于我们未被授权在此情况下发送恶意有效负载，所有努力将是手动的，并且参数将通过 Burp Suite 的重放器手动输入。考虑到这一点，我们可以尝试基本的 XSS 有效负载，并观察是否存在任何验证和/或编码。首先想到的反映我们参数值的位置是车辆昵称。似乎一个普通的`<script> alert(1)</script>`可以在浏览器中执行。

这现在是一个经过身份验证的**跨站脚本**（**XSS**）漏洞，可能对我们有用（漏洞＃10）。以下是 XSS 的屏幕截图：

![](img/40887edf-f1ec-44d2-a32c-cd236099b297.png)

接下来，我们可以检查其他 API 逻辑缺陷，例如是否执行了速率限制，或者 API 请求是否可以在不修改的情况下重放。这可以通过将 HTTP 请求发送到 Burp Suite 的重放器并重放请求来完成。我们将发现在进行远程服务调用时没有重放或速率限制安全控制（漏洞＃11）。尽管在 API 请求之间需要一个短暂的 5 秒间隔，以便车辆执行请求。

另一个要测试的逻辑缺陷是移动应用程序和 Subaru 服务器之间的登录过程。Subaru 通过`POST`主体传递用户凭据，然后在验证后将用户重定向到其帐户仪表板。在登录过程中，账户凭据成功验证后，将向 Subaru 的服务器发送一个`GET`请求，其中包括用户名、handoffToken 和其他参数。这是在 iOS 应用程序的`Cache.db`中找到的相同 HTTP 请求，但令牌值不同。这个`GET`请求可以被复制并粘贴到浏览器中，并且可以自动登录到 MySubaru 账户，而无需用户名或密码（漏洞＃12）。此外，handoffToken 永远不会过期，即使 MySubaru 用户注销了网络和移动应用程序，它仍然有效。即使更改密码也不会使此令牌过期。这是一个很好的发现，因为我们现在可以在车主不知情的情况下持久访问 MySubaru 账户。与 handoffToken 相关的另一个问题是为新设备和已授权用户创建新令牌，这些用户登录其 MySubaru 移动应用程序。例如，所有者使用两部 iPhone 和两部 Android 设备登录其 MySubaru 账户。现在有四个活动的 handoffToken。这也适用于已授权用户。例如，两个已授权用户（`carhackingemail@gmail.com`和`carhackingemail1@gmail.com`）使用三个设备登录其 MySubaru 移动应用程序。现在已授权用户有六个活动令牌，这扩大了对一个 MySubaru 账户的攻击面。以下是一个示例，显示了两个已授权用户账户`carhackingemail@gmail.com`和`carhackingemail1@gmail.com`，它们使用三个不同的移动设备并获得了不同的 handoffToken 值：

![](img/eb7d4b3d-7c46-45bc-bac5-bdcd343dfcdc.png)

# 第 5 步-利用-链接漏洞

通过被动和主动分析已经确定了至少 11 个漏洞。一些漏洞可以直接利用，而其他一些可能间接利用，因为应用程序的逻辑和设计。为了访问车辆而无需钥匙、车钥匙或凭据，我们应该有所需的东西。

通过查看已识别的安全漏洞，需要用户干预才能成功利用 MySubaru 所有者的账户和车辆。我们可以通过几种方式来做到这一点。我们可以尝试以下攻击场景，这依赖于一种社会工程学形式：

+   制作一个恶意页面，其中包含用于车辆昵称的 XSS 有效负载

+   获取 handoffToken 以获得有效的会话

+   通过 CSRF 添加已授权用户

+   通过 CSRF 伪造解锁远程服务调用目标 Subaru 车辆

+   更改安全问题

+   更改 PIN

+   赚钱$$

可以用于获得有效的`handoffToken`的其他攻击场景包括：

+   受害者使用攻击者设备登录，可以从缓存中提取令牌

+   受害者将移动设备（Android/iOS）备份到攻击者的计算机上，攻击者将受害者的备份还原到包含 handoffToken 的测试移动设备中

+   攻击者窃取已授权用户的令牌而不是车主

+   通过 Wi-Fi 热点或其他方式进行中间人攻击

+   通过 iFunBox 获取`Cache.db`（iOS）

+   审计日志通过`URL GET`请求泄漏 handoffToken，可以被 Subaru 的系统管理员、检查网络流量的企业网络管理员和无线热点获取

攻击者不仅可以未经授权地访问车辆，还可以跟踪车主并将其安全置于危险之中。还可以探索其他后利用场景，例如以下内容：

+   窃取车辆内的内容

+   破坏车辆的引擎

+   保持对 MySubaru 账户的持久性，该账户可能有多辆车辆

+   植入带外跟踪器

+   植入恶意 Wi-Fi 接入点 w/GSM，以远程连接来利用附近的接入点或车辆

+   重放远程服务请求，如锁定车辆以耗尽电池

您可能已经注意到，这些都是基本的网络安全漏洞，而不是突破性的零日漏洞利用。对于利用基本漏洞的影响，对于物联网连接的设备和车辆来说要高得多。

# 另请参阅

访问以下网页，阅读本配方中讨论的研究：

+   [`www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/`](https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/)

+   [`www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/`](https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/)

+   [`www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970`](http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970)

# 为固件配置持续集成测试

为 C/C++编写的固件构建可能对具有复杂 Makefile 的传统产品构成挑战。然而，在部署生产构建之前，所有源代码都应该进行静态分析，以检测安全漏洞。本配方将展示如何在持续集成环境中为固件配置基本的 C/C++静态分析。

# 准备工作

对于本配方，我们将使用以下应用程序和工具：

+   **Jenkins**：这是一个开源的构建自动化服务器，可以定制运行质量和安全代码分析。Jenkins 可以通过以下链接[`jenkins.io/download/`](https://jenkins.io/download/)下载。根据操作系统的不同，有各种安装 Jenkins 的方法。对于 Debian 和 Ubuntu，可以使用以下命令安装 Jenkins：

```
wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -

```

+   将以下行添加到`/etc/apt/sources.list`：

```
deb https://pkg.jenkins.io/debian-stable binary/
sudo apt-get update
sudo apt-get install jenkins

```

+   **Fuzzgoat**：这是一个易受攻击的 C 程序，可以通过以下 GitHub 存储库[`github.com/packttestaccount/fuzzgoat`](https://github.com/packttestaccount/fuzzgoat)下载。使用以下命令将 fuzzgoat 应用程序克隆到您的 Jenkins 构建服务器中：

```
 git clone https://github.com/packttestaccount/fuzzgoat.git

```

+   **Flawfinder**：这是一个简单的工具，用于分析 C/C++代码中的潜在安全漏洞。Flawfinder 可以通过以下链接[`www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz`](https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz)下载。

通过 pip 简单安装 Flawfinder 的方法如下：

```
pip install flawfinder

```

# 如何做…

要设置固件的持续集成测试，请使用以下步骤创建您的环境。

1.  安装了 Jenkins 后，登录并单击“新建项目”：

![](img/aba628cc-7a9d-4a5d-8a1a-3e7dda6226be.png)

确保您的`JAVA_HOME`环境变量已配置。如果使用了多个 Java 版本，请确保通过 Jenkins 的全局工具配置在`http://127.0.0.1:8080/configureTools/`中配置 JDK。

1.  输入名称并选择自由风格项目：

![](img/5648c9e9-2ea8-4210-8aae-c83954e4ae52.png)

1.  配置页面将出现。暂时不要输入任何设置，因为我们将在构建项目后加载一个本地项目到 Jenkins 将创建的工作空间中。构建将失败，这没关系，因为我们只是希望 Jenkins 创建目录，然后我们将把我们的 C 代码项目文件复制到工作空间中。这一步也将用于以下配方中创建工作空间：

![](img/def1200a-f377-42fb-8971-170b782f80de.png)

1.  单击保存按钮后，Jenkins 将重定向您到项目页面，我们将选择“立即构建”：

![](img/089dca88-628d-4283-a34e-9ed6a26bf8e2.png)

现在，Jenkins 已经构建了我们的工作空间，我们可以在其中传输我们的代码文件。目录结构因所使用的操作系统而异。对于 Ubuntu，工作空间文件位于`/var/lib/Jenkins/workspace/`，对于 OS X，工作空间文件位于`/Users/Shared/Jenkins/Home/workspace/`。将 fuzzgoat 文件传输到新创建的工作空间目录中，该目录以项目名称命名。在这种情况下，它是`/var/lib/Jenkins/workspace/PacktTestFirmware/`。

确保 Jenkins *Nix 用户具有适当的文件和文件夹权限，以扫描`workspace`目录中的任何内容。这还包括工具扫描相关目录的权限。

1.  现在 fuzzgoat 在 Jenkins 工作空间目录中，返回 Jenkins 构建项目并添加一个构建步骤来执行一个 shell 命令，该命令将在我们的`workspace`目录中执行`flawfinder`：

![](img/5cf6a9c6-356e-4ffd-9eea-900ee77c4577.png)![](img/4228b997-8122-4ad3-82d7-6a7814dbc73f.png)

1.  添加另一个构建步骤来执行另一个 shell 命令。这将在基于 fuzzgoat 提供给我们的 Makefile 的工作目录中执行`make`命令。之后单击保存：

![](img/dc55c928-9720-41f0-b89f-a42a27ab1622.png)

1.  在项目页面中选择立即构建选项。单击永久链接箭头，然后选择控制台输出，如下图所示：

![](img/c9fef50d-f8a2-4110-92f2-399fee2c3313.png)

1.  接下来的页面应该显示构建和`flawfinder`的结果：

![](img/6477d128-7fd5-44ce-befe-e6b47ac8c5f7.png)![](img/478cc1d4-8bec-4476-9263-7c90351f4105.png)

构建步骤可以定制以警报工程或安全经理根据结果执行操作。但是，并非所有来自`flawfinder`的命中都是漏洞，但应该对其进行审查，以确保没有引入软件安全漏洞。请记住，`flawfinder`是一个简单的工具，提供了最少量的 C/C++代码检查。它只是检查常见的缓冲区溢出问题和其他众所周知的问题，比如使用被禁止的函数。商业 SAST 工具包括依赖图以及调用图，以检查依赖软件漏洞和应用程序数据流。此外，许多商业 SAST 工具还包括 IDE 插件，用于实时检查软件安全漏洞。对于 C/C++，XCode 的 Clang 静态分析器有免费的 IDE 插件；但是，在 OS X 环境中编译此类代码需要自定义配置。Clang 不会分析无法编译的文件。在配置移动应用程序的持续集成测试部分，我们将讨论如何使用 IDE 插件来静态分析代码。

# 另请参阅

有关 Clang 静态分析器的更多信息，请访问以下链接：

+   [`clang-analyzer.llvm.org/`](https://clang-analyzer.llvm.org/)

+   [`help.apple.com/xcode/mac/9.0/#/devb7babe820`](https://help.apple.com/xcode/mac/9.0/#/devb7babe820)

有关各种编程语言的更多源代码分析工具列表，请参阅以下网址：

+   [`www.owasp.org/index.php/Source_Code_Analysis_Tools`](https://www.owasp.org/index.php/Source_Code_Analysis_Tools)

# 为 Web 应用程序配置持续集成测试

无论物联网设备使用 Web 应用程序还是 Web 服务进行消息传递，其代码都应该进行静态和动态分析，以查找软件安全漏洞。在这个示例中，我们将演示如何在生产部署之前配置 Web 应用程序构建的动态扫描。

# 准备工作

在这个示例中，我们将使用 Jenkins 作为我们的自动化构建服务器，OWASP ZAP 作为我们的动态扫描器。我们将使用 OWASP ZAP Jenkins 插件和可以通过以下链接下载的 OWASP ZAP 工具：

[`github.com/zaproxy/zaproxy/wiki/Downloads`](https://github.com/zaproxy/zaproxy/wiki/Downloads)。

# 如何做...

要为 Web 应用程序设置持续集成测试，请使用以下步骤创建您的环境。

1.  首先，我们需要下载 OWASP ZAP 插件，可以通过 Jenkin 的插件管理器完成，如下截图所示：

![](img/20926133-8feb-44e6-906c-9799e3cc9938.png)

OWASP ZAP 插件下载

1.  然后 Jenkins 将重新启动。重新登录 Jenkins，我们将致力于配置 ZAP。在 Jenkins 中使用 ZAP 有两种方法。一种是使用加载的会话运行 ZAP，另一种是设置 Selenium 来执行 ZAP 并在之后保持会话。我们将设置 ZAP 以加载会话来运行我们的目标构建。为此，我们首先需要通过`http://127.0.0.1:8080/`configure 配置 ZAP 设置和环境变量。在这种情况下，设置 ZAP 主机和端口号如下图所示：

![](img/26bd354b-cba8-4360-9e77-d850f2e52bc8.png)

可以配置多个 ZAP 主机以允许多个并发构建扫描。这可以在各个项目的构建步骤中配置，这将覆盖系统设置。

1.  根据正在使用的操作系统（[`github.com/zaproxy/zaproxy/wiki/FAQconfig`](https://github.com/zaproxy/zaproxy/wiki/FAQconfig)），插入 ZAP 的默认目录。以下是 ZAP 在 OS X 上使用的默认目录：

如果您使用 ZAP 的每周版本，请使用`/Users/<user>/Library/Application\ Support/ZAP_D/`。

![](img/411a6ca4-44f6-41e9-b74b-2c49d9b01221.png)

1.  现在，创建一个自由风格项目，就像我们在之前的配方中所做的那样，并适当命名它：

![](img/dc296661-1e1e-44aa-bc65-4766b586f6b4.png)

1.  保存项目并选择立即构建，以便 Jenkins 创建我们的项目工作空间，就像之前的配方一样。

由于我们将使用加载的会话执行 ZAP，我们必须创建一个会话并将其保存在项目工作空间目录中。为此，请导航到正在运行的目标应用程序构建，并通过浏览器将应用程序流量代理到 ZAP。确保点击所有链接，并爬行页面并执行应用程序功能。在以下示例中，我们正在使用在本地端口`8888`上运行的 The BodgeIT Store，并通过导航到文件|持久会话...将会话保存到项目工作空间中：

![](img/f3e60316-e57c-4099-ad7b-88586770bc04.png)

1.  在我们项目的 Jenkins 工作空间目录中保存会话。在这种情况下，如下截图所示，在工作空间项目目录中的 PacktZAPscan：

![](img/05038cb4-2588-458d-9ca6-254edd0c96b3.png)

PacktZAPscan 在工作空间项目目录中

1.  在 ZAP 中，让我们配置 ZAP 的 API 密钥。转到工具菜单并打开选项页面。在选项中，选择 API 部分，并插入由 Jenkins 插件提供的默认`ZAPROXY-PLUGIN`密钥，如下截图所示：

![](img/a8469828-810b-40d4-be41-b7dd2d4b872f.png)

请注意，此 API 密钥可以完全禁用，或者在创建构建步骤时通过 ZAP 插件命令行参数部分进行更改。如果 API 密钥与 Jenkins 插件 API 密钥值不匹配，则扫描将失败。

1.  有了我们在工作空间中保存的会话，返回到我们的项目并选择配置。根据应用程序架构，插入适当的源代码管理设置，构建环境和任何构建脚本。在构建部分，选择添加构建步骤|执行 ZAP：

![](img/df0020c4-d637-4f52-8684-2215312fb8ab.png)

1.  输入 ZAP 主机设置和主目录路径，以及保存的适当会话。如果会话未保存在项目工作空间文件夹中，则会话将不会出现在加载会话下拉菜单中：

![](img/0d23107f-f887-40e2-af83-572889c22b69.png)

1.  输入会话属性，如上下文和任何身份验证凭据。上下文指的是自动扫描的范围内和范围外的目标。上下文必须是唯一的，并且不能在加载的会话中。我们可以使用构建 ID 环境变量来迭代上下文编号，使它们是唯一的，如下面的屏幕截图所示：

![](img/a71cada9-19c3-483c-a4d5-e3f7a6b49324.png)

1.  接下来的部分是攻击模式部分。在这里，我们指定目标 URL、扫描设置和可能配置并保存到项目工作区的任何自定义扫描策略。在即将到来的示例中，测试 URL 是输入的，选择了蜘蛛，并配置了一个自定义的 XSS 扫描策略。当没有指定自定义扫描策略时，将使用默认策略。配置攻击设置后，命名生成的报告，选择格式和任何导出报告设置，然后点击保存：

![](img/8f88244a-3aeb-4db1-9b03-a434895f42ef.png)

确保权限设置正确，以便 Jenkins 和 ZAP 可以扫描您的工作区目录。

1.  然后您将被引导到项目页面。选择立即构建，然后点击构建的控制台输出。这将显示 ZAP 扫描的构建状态和进度：

![](img/e07979b7-96c9-45f9-8461-2974cce0b96d.png)

控制台输出应该类似于以下图像：

![](img/35e46e51-cf77-4fb3-8512-d6b93f70179d.png)

控制台输出

1.  构建和扫描完成后，在工作区项目目录下的`reports`文件夹中生成报告，如下面的屏幕截图所示：

![](img/4cd67bf2-8be2-4b83-90c7-3d15849b2eec.png)

1.  报告的 XML 和 HTML 版本可供查看：

![](img/fdbccdc0-28ec-4715-bea3-e10f1ae9d71d.png)

ZAP 扫描和报告的警报可以被大量定制，只报告中等和/或高严重性的发现。扫描应该根据应用程序的架构创建上下文细节和扫描策略。例如，如果一个应用程序在 Apache web 服务器、Apache Tomcat 应用服务器和 MySQL 数据库上运行，扫描策略应该被定制为针对相应的架构环境运行检查。不建议运行默认扫描策略，因为将使用不相关的攻击，导致扫描时间过长，甚至可能耗尽 ZAP 的内部数据库资源。扫描器的好坏取决于给定的配置、规则集和策略。 

自动化扫描非常适合捕捉低挂果和可扩展性，但它们不应该取代手动的 Web 应用程序安全评估。自动扫描程序无法执行上下文业务逻辑测试，也无法智能地捕捉手动评估可以发现的未报告的发现。应该使用自动化和手动测试的组合。

# 另请参阅

要了解有关 Jenkins OWASP ZAP 插件的更多信息，请参考以下链接：

[`wiki.jenkins.io/display/JENKINS/zap+plugin`](https://wiki.jenkins.io/display/JENKINS/zap+plugin)

[`wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP`](https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP)

# 为移动应用程序配置持续集成测试

在之前的示例中，自动化分析的趋势相同，这个示例将展示如何在生产部署之前配置 Android 应用程序构建的依赖扫描和动态分析。

# 准备工作

在这个示例中，我们将使用 Jenkins 自动化构建服务器和以下工具：

+   **移动安全框架**（**MobSF**）：这是一个开源的移动应用程序静态和动态分析工具。MobSF 正在积极地为移动安全社区进行修改和开发。MobSF 可以从以下链接下载：

[`github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip`](https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip)

+   **OWASP Dependency-Check**：这是一个工具，用于检测项目依赖项中公开披露的漏洞，适用于多种编程语言，如 Java、NodeJS、Python、Ruby 和 Swift 等。我们将使用 Jenkins OWASP Dependency-Check 插件，该插件可以通过 Jenkins 插件管理器下载，如下面的屏幕截图所示：

![](img/e9f24b72-1ff4-4c9a-8608-674fd00e4af5.png)

+   Dependency-Check 也可以作为一个独立的工具下载，使用以下链接中描述的方法：

[`github.com/jeremylong/DependencyCheck`](https://github.com/jeremylong/DependencyCheck)

# 如何做...

要为移动应用程序设置持续集成测试，请使用以下步骤创建您的环境。

1.  首先，让我们创建一个自由风格的项目，为应用程序构建选择一个合适的名称：

![](img/4894f823-9ec9-419c-a587-04491fac48e6.png)

1.  保存并构建项目，以便我们的工作空间被创建，就像我们在早期的简单示例中所做的那样。接下来，将 Android 项目文件复制到 Jenkins 为我们创建的新工作空间中，如下面的屏幕截图所示。

![](img/ff1796ad-6e49-4759-a432-510295872968.png)

在这种情况下，我们工作空间的路径是`/Users/Shared/Jenkins/Home/workspace/PacktTestAndroid`。

1.  接下来，打开项目的配置选项，并设置构建设置，如下面的屏幕截图所示：

![](img/7bd19abb-6f25-44d3-b0b5-570d96e31f01.png)

1.  为您的构建环境输入任何必要的构建脚本：

![](img/4307a089-e17e-4657-9610-3db10bd84a69.png)

如果这是一个现有的项目，您可能已经知道构建完成后输出 APK 将被放置的位置。对于新项目，请确保您的构建编译为 APK。知道在运行构建时 APK 存储的位置是扫描构建 APK 的下一步的关键。

1.  在一个单独的窗口中，打开一个终端并导航到 MobSF 安装的位置。一旦在 MobSF 的文件夹中，运行以下命令：

```
$ python manage.py runserver
```

1.  您的终端应该看起来像下面的屏幕截图：

![](img/1ca88dee-ff56-49a9-b0c6-65371dc2b077.png)

请注意 MobSF 的 API 密钥，因为我们需要它来从 Jenkins 构建服务器执行 REST API 调用。

当通过`clean.sh`脚本删除所有扫描和 MobSF 数据库信息时，API 密钥会更改。

1.  导航回到我们 Android 项目的 Jenkins 配置页面。添加一个构建步骤来执行一个 shell 命令：

![](img/bda9bc10-a42c-407a-a841-adf581cc6a05.png)

1.  在命令区域，我们将执行 REST API 调用来上传我们构建的 APK 到 MobSF。为此，您需要拥有您的 REST API 密钥以及构建后 APK 存储的位置。使用以下命令并插入您的 API 密钥以及 API 文件路径，就像下面显示的`curl`命令一样：

```
curl --fail --silent --show-error -F 'file=@/Users/Shared/Jenkins/Home/workspace/PacktTestAndroid/app/build/outputs/apk/app-debug.apk' http://localhost:8000/api/v1/upload -H "Authorization:61ecd74aec7b36f5a9fbf7ac77494932ab5fcf4e4661626d095b5ad449746998" | awk -F'[/"]' '{print $8}' >  hash.txt  
```

这个`curl`命令上传了我们的最新构建 APK 到我们的工作空间，然后将被扫描。MobSF 创建了上传二进制文件的哈希值，这是其他 API 调用中需要引用您特定二进制文件的内容。`awk`命令只是解析 JSON 响应数据，并将哈希值插入一个文件中，以便在以后的 MobSF API 请求中调用。

1.  上传了我们的 APK 后，添加另一个构建步骤来执行一个 shell 命令，并插入以下命令，包括您的 APK 名称和 API 密钥值以扫描构建：

```
curl --fail --silent --show-error -X POST --url http://localhost:8000/api/v1/scan --data "scan_type=apk&file_name=app-debug.apk&hash=$(cat hash.txt)" -H "Authorization:61ecd74aec7b36f5a9fbf7ac77494932ab5fcf4e4661626d095b5ad449746998"
```

1.  MobSF 扫描 APK 需要几分钟的时间，因此让我们创建另一个执行 shell 构建集，并插入以下`sleep`命令：

```
Sleep 180

```

`sleep`命令可以根据 MobSF 分析您特定应用程序所需的时间进行更改。在这种情况下，大约需要两分钟。请记住，如果您等待的时间不够长，MobSF 无法扫描 APK 并尝试下载报告，那么报告将是空的。

1.  接下来，创建另一个构建步骤来生成并下载刚才提到的 PDF。插入以下命令及您相应的 API 密钥：

```
curl --fail --silent --show-error  -K hash.txt -X POST --url http://localhost:8000/api/v1/download_pdf --data  "hash=$(cat hash.txt)&scan_type=apk" -H "Authorization:61ecd74aec7b36f5a9fbf7ac77494932ab5fcf4e4661626d095b5ad449746998" -o MobSF${BUILD_ID}.pdf
```

您可以选择任何您喜欢的名称来命名 MobSF 报告。为了使报告唯一，使用了构建 ID 环境变量。Jenkins 现在应该能够从我们构建的 APK 上传、扫描、生成和下载 MobSF 报告。

1.  我们还可以添加一个构建步骤来调用 Dependency-Check，扫描我们项目的依赖项以查找已知的漏洞：

![](img/90dc9351-907f-4714-aba9-da617647ad13.png)

1.  Dependency-Check 的扫描路径构建步骤应为空，因为工作空间目录中的项目文件将被扫描并用于在工作空间中输出结果：

![](img/597283b6-d819-4d11-95ee-8bdeea28b55f.png)

确保权限正确设置，以便 Jenkins 和 Dependency-Check 可以扫描您的工作空间目录。

1.  您的项目配置构建步骤应该类似于以下屏幕截图：

![](img/667cc64a-b858-4e55-9d59-b67ac1130115.png)

项目配置构建步骤

1.  保存项目配置并构建 Android 应用程序。查看 Android 应用程序项目的控制台输出以查看构建进度。第一个构建步骤是构建实际的应用程序 APK，然后执行 MobSF 扫描功能，最后使用 Dependency-Check 扫描项目的依赖项：

![](img/69441c78-d460-4b65-94d4-81e8a9644df2.png)

控制台输出

1.  以下屏幕截图显示了上传和扫描 APK 的第二和第三个构建步骤：

![](img/2724cfa3-0df8-4ea9-a304-7e3d02872dc7.png)

上传和扫描 APK 的构建步骤

1.  接下来是第四、第五和第六个构建步骤，分别执行`sleep`命令，生成 MobSF 扫描结果的 PDF，并扫描项目的依赖项：

![](img/3860df4a-7dbf-4804-9110-ca17a73e84fa.png)

1.  如果您检查项目工作空间，现在应该有一个 MobSF 报告以及一个 Dependency-Check 报告：

![](img/9c3080d7-2d34-4238-919f-19d8c820eaa2.png)

1.  单击 MobSF 和 Dependency-Check 报告应该打开其各自格式的扫描输出（MobSF 的 PDF 格式，Dependency-Check 的 HTML、JSON、XML 格式），如下图所示：

![](img/ad6e5830-b5b4-4658-a3ce-c356776f542f.png)

扫描结果的输出

1.  以下图片是 Dependency-Check 的 HTML 报告：

![](img/d781cf55-ea8b-48df-80e0-b5ed5dc312d5.png)

这些扫描报告可以配置为发送到集中的报告服务器，以及执行诸如发送电子邮件警报或 Jira 工单等操作，如果发现了某些严重性发现。Jenkins 具有比本章介绍的更高级功能更高度的可定制性。一个伟大的 OWASP 项目，可以帮助应用程序安全团队提高安全测试的速度和自动化程度，是 OWASP AppSec Pipeline 项目([`www.owasp.org/index.php/OWASP_AppSec_Pipeline`](https://www.owasp.org/index.php/OWASP_AppSec_Pipeline))。讨论了 AppSec 管道的各种工具和设计模式，以使小型安全团队在代码推送速度的情况下尽可能具有可扩展性和高效性。

# 另请参阅

+   Jenkins 插件 Dependency-Check 还配备了一个位置，用于存档多个应用程序依赖项以及跨应用程序使用的易受攻击组件，名为 OWASP Dependency-Track。这可以通过`http://JenkinsURL:8080/configure`在 OWASP Dependency-Track 部分进行配置。有关 OWASP Dependency-Track 的更多详细信息，请参见以下链接：

[`www.owasp.org/index.php/OWASP_Dependency_Track_Project`](https://www.owasp.org/index.php/OWASP_Dependency_Track_Project)。

+   有关 MobSF 的 REST API 的详细信息，请访问其文档页面[`github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation`](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation)。
