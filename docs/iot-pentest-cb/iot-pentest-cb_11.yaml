- en: Advanced IoT Exploitation and Security Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级物联网利用和安全自动化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Finding ROP gadgets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找ROP小工具
- en: Chaining web security vulnerabilities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接Web安全漏洞
- en: Configuring continuous integration testing for firmware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为固件配置持续集成测试
- en: Configuring continuous integration testing for web applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Web应用程序配置持续集成测试
- en: Configuring continuous integration testing for mobile applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动应用程序配置持续集成测试
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: To exploit IoT vulnerabilities and to be able to protect yourself from them,
    automation is needed to develop weaponized proof of concepts as well as provide
    scalability for defensive security teams. If security teams do not keep pace with
    how fast code is being pushed and developed, vulnerabilities are bound to be introduced.
    Additionally, security teams will need to adapt to the speed of dev teams and
    not hinder their current processes for security testing as well as review. This
    chapter will cover advanced IoT exploitation techniques as well as methods of
    discovering, and preventing IoT vulnerabilities in an automated manner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用物联网的漏洞并能够保护自己免受攻击，需要自动化来开发武器化的概念证明，并为防御安全团队提供可扩展性。如果安全团队无法跟上代码推送和开发的速度，就会引入漏洞。此外，安全团队需要适应开发团队的速度，不要阻碍他们当前的安全测试和审查流程。本章将介绍高级物联网利用技术，以及以自动化方式发现和防止物联网漏洞的方法。
- en: Finding ROP gadgets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找ROP小工具
- en: One of the most important things during exploitation of embedded devices is
    to have the ability to exploit vulnerable binaries using techniques such as **Return
    Oriented Programming** (**ROP**), which is what we are going to look at in this
    section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用嵌入式设备的过程中，最重要的事情之一是能够利用易受攻击的二进制文件，使用**返回导向编程**（**ROP**）等技术，这正是我们将在本节中讨论的内容。
- en: The reason why we require this technique is because during exploitation we often
    need our end result as a shell or execution of a backdoor, which could grant us
    additional information or access to sensitive resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这种技术的原因是，在利用过程中，我们经常需要将最终结果作为shell或执行后门，这可以为我们提供额外的信息或访问敏感资源。
- en: The concept of ROP is the same in both ARM and MIPS (and even x86); however,
    there are some platform-level differences which we will need to keep in mind.
    To explain ROP in extremely simple terminology, it involves picking up specific
    instructions (gadgets) from various locations and chaining them together to build
    a complete ROP chain which will perform a specific task.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ROP的概念在ARM和MIPS（甚至x86）中是相同的；然而，我们需要记住一些平台级别的差异。简单来说，ROP涉及从各个位置拾取特定指令（小工具），并将它们链接在一起构建完整的ROP链，以执行特定任务。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As mentioned earlier, to perform ROP, we need to be able to identify the useful
    ROP gadgets which can be chained together. To find these specific gadgets, we
    can look at various locations in the libc or other libraries manually, or even
    use automated tools and scripts which can help us do the same.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要执行ROP，我们需要能够识别可以链接在一起的有用ROP小工具。要找到这些特定的小工具，我们可以手动查看libc或其他库中的各个位置，或者使用自动化工具和脚本来帮助我们完成相同的工作。
- en: To keep things simple, we will take a very simple example with a vulnerable
    program on ARM and then also later look at some other examples which will help
    us deepen our understanding of ROP-based exploitation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将以ARM上的易受攻击程序为例，并稍后查看一些其他示例，以帮助我们加深对基于ROP的利用的理解。
- en: 'Some of the components that we will require for this are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的一些组件如下：
- en: '**GDB-Multiarch**: This is the GDB for various architectures'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GDB-Multiarch**：各种架构的GDB'
- en: '**BuildRoot**: This is used to compile our vulnerable program for ARM architecture'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BuildRoot**：用于为ARM架构编译我们的易受攻击程序'
- en: '**PwnDbg**: This is the GDB plugin that aids in exploitation'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PwnDbg**：这是帮助利用的GDB插件'
- en: '**Ropxx**: This is the Python script that helps us combine ROP gadgets and
    build our final chain'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ropxx**：这是帮助我们组合ROP小工具并构建最终链的Python脚本'
- en: We are not looking at any automated tools as of now, but are rather focusing
    on the manual approach so as to understand the fundamentals. If you would like
    to use an automated tool later (which I recommend), you can take a look at the
    *See also* section for some useful links.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不打算使用任何自动化工具，而是专注于手动方法，以便理解基本原理。如果您以后想使用自动化工具（我建议这样做），您可以查看*另请参阅*部分，了解一些有用的链接。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: In this section, we will look at how we can get started with exploiting a plain
    vanilla stack based buffer overflow on an ARM environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何开始利用ARM环境中的简单堆栈缓冲区溢出。
- en: 'The vulnerable program in this case is as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，易受攻击的程序如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding program, the `main` function takes a user-supplied
    input and then passes that argument to the vulnerable function which has a buffer,
    with the name buff, of 10 bytes. As expected, if the input argument size is significantly
    larger than the size of the buff, it will lead to an overflow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的程序中所看到的，`main`函数接受用户提供的输入，然后将该参数传递给具有10字节缓冲区（名为buff）的易受攻击函数。如预期的那样，如果输入参数的大小显着大于buff的大小，就会导致溢出。
- en: Once it overflows the buff, we will need to find a way to overwrite either `pc`
    or `lr` registers to take control of the program execution flow. This can be done
    by setting a breakpoint at the `strcpy` address and then analyzing the stack before
    and after the copy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦溢出了buff，我们需要找到一种方法来覆盖`pc`或`lr`寄存器，以控制程序执行流。这可以通过在`strcpy`地址设置断点，然后分析复制前后的堆栈来完成。
- en: 'Let''s first go ahead and run this program using Qemu emulation for ARM architecture:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用Qemu仿真运行这个程序，用于ARM架构：
- en: '![](img/f923203f-f2e3-4220-af7f-082226249514.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f923203f-f2e3-4220-af7f-082226249514.png)'
- en: We have also added the `-``g` parameter to attach a debugger to the running
    instance, in this case at port `12345`, which we can now connect with using GDB,
    as shown next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`-g`参数，以便将调试器附加到运行的实例上，这里是端口`12345`，现在我们可以使用GDB连接，如下所示。
- en: 'We will use GDB-multiarch here followed by specifying the sysroot and remote
    target, as shown in the following screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里使用GDB-multiarch，然后指定sysroot和远程目标，如下面的屏幕截图所示：
- en: '![](img/a453c807-b295-4515-b153-58670f379b82.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a453c807-b295-4515-b153-58670f379b82.png)'
- en: Let's set a breakpoint at main (b main) and continue (c) the program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在main处设置一个断点（b main）并继续（c）程序。
- en: Now here comes the interesting part of looking for gadgets. To find useful gadgets,
    we need to look for instructions which allow us to set certain values that we
    can jump to, let's say system (in our current scenario), as well as while jumping,
    have an argument as the address of `/bin/sh` which would give us the shell.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看寻找gadgets的有趣部分。要找到有用的gadgets，我们需要寻找一些指令，这些指令允许我们设置某些值，我们可以跳转到这些值，比如说system（在我们当前的情况下），同时在跳转时，将地址作为`/bin/sh`的参数，这将给我们提供shell。
- en: This means that we may need to place the address of the system in either `pc`
    or `lr`, and the address of `/bin/sh` in `r0`, which is the first register in
    ARM, and is also taken as an argument to the function that is being called. Once
    we have found the instructions that will allow us do all this, we also need to
    ensure that one of these things are present in the instructions following our
    useful instructions mentioned earlier, namely, either branch to an address, which
    we have control of, or `pop {pc}` or `pop {lr}`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可能需要将`system`的地址放在`pc`或`lr`中，将`/bin/sh`的地址放在`r0`中，这是ARM中的第一个寄存器，也是作为被调用函数的参数。一旦我们找到了允许我们执行所有这些操作的指令，我们还需要确保在我们之前提到的有用指令之后的指令中有一个这些内容，即要么跳转到我们控制的地址，要么`pop
    {pc}`或`pop {lr}`。
- en: 'If we look at the disassembly of `erand48`, which is one of the functions present
    in the `libc`, we can see that it has a specific set of useful instructions which
    allow us to take control of the execution as well as set the value of the registers.
    This is shown in the following screenshot:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看`libc`中存在的函数之一`erand48`的反汇编，我们可以看到它具有一组特定的有用指令，这些指令允许我们控制执行并设置寄存器的值。如下面的屏幕截图所示：
- en: '![](img/e8958a75-fe9e-4aba-9388-cd0f9f88596e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8958a75-fe9e-4aba-9388-cd0f9f88596e.png)'
- en: 'The following are three of the instructions that we are interested in:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们感兴趣的三条指令：
- en: '`lmd sp, {r0, r1}`: This instruction loads the value of `r0` and `r1` from the
    stack. This will be used to control the `r0`, which serves as an argument to the
    function we are about to jump to (system).'
  id: totrans-39
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lmd sp, {r0, r1}`：此指令从堆栈中加载`r0`和`r1`的值。这将用于控制`r0`，它作为我们即将跳转到的函数（system）的参数。'
- en: '`add sp, sp, #12`: This instruction simply increments the stack pointer by
    `12`.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add sp, sp, #12`：此指令简单地将堆栈指针增加`12`。'
- en: '`pop {pc}`: This instruction pops the value from the stack and puts it inside
    `pc`, which implies that we will be able to take control of the program execution.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pop {pc}`：此指令从堆栈中弹出值并将其放入`pc`，这意味着我们将能够控制程序的执行。'
- en: 'We need to find two things now, which are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到两件事，它们分别是：
- en: The address of the system.
  id: totrans-43
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`system`的地址。'
- en: The address of `/bin/sh`.
  id: totrans-44
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/bin/sh`的地址。'
- en: 'We can find the address of the system using the `print` command or using the
    disass system, as shown in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`print`命令或使用`disass system`找到`system`的地址，如下面的屏幕截图所示：
- en: '![](img/b0a19344-b3eb-4fd8-83c1-c1d532ca99a3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0a19344-b3eb-4fd8-83c1-c1d532ca99a3.png)'
- en: 'Now, let''s generate a cyclic string of 50 characters and see how we can overflow
    the buff to jump to `errand48` successfully:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们生成一个50个字符的循环字符串，并看看我们如何溢出缓冲区以成功跳转到`errand48`：
- en: '![](img/790b6335-21ee-4418-badf-395aeb5805a6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/790b6335-21ee-4418-badf-395aeb5805a6.png)'
- en: 'Let''s debug the program using the generated string:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用生成的字符串调试程序：
- en: '![](img/ff91c4d0-3d74-4b23-bdd3-97393858776d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff91c4d0-3d74-4b23-bdd3-97393858776d.png)'
- en: 'We will now set a breakpoint at the vulnerable function and continue our execution.
    GDB will hit the breakpoint, as shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在易受攻击的函数处设置一个断点并继续执行。GDB将触发断点，如下面的屏幕截图所示：
- en: '![](img/aade2565-8feb-42a0-9db2-2fdff0ec66dd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aade2565-8feb-42a0-9db2-2fdff0ec66dd.png)'
- en: 'Let''s also set a breakpoint at the last instruction of the vulnerable function:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也在易受攻击的函数的最后一条指令处设置一个断点：
- en: '![](img/895ce702-a883-4cd2-8984-872d25808228.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/895ce702-a883-4cd2-8984-872d25808228.png)'
- en: 'Once the breakpoint is hit, let''s analyze the stack:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦断点被触发，让我们分析一下堆栈：
- en: '![](img/9257c1d1-8390-4d32-821f-e5df160123c2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9257c1d1-8390-4d32-821f-e5df160123c2.png)'
- en: The highlighted instruction will pop two dwords (double words) from the stack
    to `fp` and `pc` respectively. If we look at the second value in the stack here,
    it is `0x61616165` ('eaaa'), which means that this is the value that would go
    in `pc`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的指令将从堆栈中弹出两个双字（double words），分别放入`fp`和`pc`。如果我们在这里查看堆栈中的第二个值，它是`0x61616165`（'eaaa'），这意味着这个值将放入`pc`。
- en: 'If we look at the offset of this value, we will be able to figure out how many
    characters the offset will be if we want to overwrite `pc` with our desired address.
    We can find this out by using `cyclic` `-``l 0x61616165`, as shown in the following
    screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看此值的偏移量，我们将能够找出如果我们想要用我们期望的地址覆盖`pc`，偏移量将是多少个字符。我们可以使用`cyclic` `-l 0x61616165`来找到这个值，如下面的屏幕截图所示：
- en: '![](img/55877aa0-d6e0-41af-8894-9b8413cb8ec8.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55877aa0-d6e0-41af-8894-9b8413cb8ec8.png)'
- en: This means that we need to place our desired value of `pc` (erand48 `ldm` instruction)
    at the offset of 16 in a Little Endian format.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我们需要以小端格式将我们期望的`pc`值（`erand48`的`ldm`指令）放在偏移量为16的位置。
- en: 'We can generate the new string using the following Python code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下Python代码生成新的字符串：
- en: '![](img/c955cc3e-b427-4da4-a652-6de82d8c106e.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c955cc3e-b427-4da4-a652-6de82d8c106e.png)'
- en: 'Next, we can rerun the generated string, as shown in the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以重新运行生成的字符串，如下面的屏幕截图所示：
- en: '![](img/b387db38-5b7f-4808-8411-347674db7c27.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b387db38-5b7f-4808-8411-347674db7c27.png)'
- en: 'At this stage, attach GDB as we did earlier. Set the breakpoint on the last
    instruction of the vulnerable function, which is at the address `0x84e0`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，像之前一样附加GDB。在易受攻击的函数的最后一条指令的地址`0x84e0`上设置断点：
- en: '![](img/b98021d4-b4c9-467c-bcfb-f3ba13fa7a8f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b98021d4-b4c9-467c-bcfb-f3ba13fa7a8f.png)'
- en: 'This time we can see that `pc` is being loaded with the address of `erand48`
    instruction located at `0x4087b9dc`. Let''s step one instruction using `ni` to
    reach the `ldm` instruction:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次我们可以看到`pc`被加载到`erand48`指令的地址`0x4087b9dc`。让我们使用`ni`步进一条指令，达到`ldm`指令：
- en: '![](img/dacc9ae1-2b73-4594-bb4c-5852142711b9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dacc9ae1-2b73-4594-bb4c-5852142711b9.png)'
- en: 'As we can see at this step, the register `r0` is loaded with `0x61616161`,
    which is the register we want to place the address of `/bin/sh string` in:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在这一步看到的，寄存器`r0`加载了`0x61616161`，这是我们想要放置`/bin/sh`字符串地址的寄存器：
- en: '![](img/6d6a4fb1-9cb7-4831-9847-ff3afcf4fbf5.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d6a4fb1-9cb7-4831-9847-ff3afcf4fbf5.png)'
- en: 'The effective offset will be *16 + 4 + 0 = 20*, which is presented as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效的偏移量将是*16 + 4 + 0 = 20*，如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Thus, at offset 20, we need to put the address of the string `/bin/sh`, which
    will then be passed to the system as an argument. Step two has more instructions
    to reach pop, as shown in the following screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在偏移量20处，我们需要放置`/bin/sh`字符串的地址，然后将其作为参数传递给系统。通过两次步进，我们可以到达pop，如下截图所示：
- en: '![](img/9fb9b1f6-50d0-49f7-aa33-cc8967718ff7.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fb9b1f6-50d0-49f7-aa33-cc8967718ff7.png)'
- en: 'The `pc` will get the value of `0x61616164` and the offset can be calculated
    in the same way as we did earlier:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pc`将获得值`0x61616164`，偏移量可以用与之前相同的方式计算：'
- en: '![](img/2ff96be0-6be7-4173-835c-6681bc305cd7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ff96be0-6be7-4173-835c-6681bc305cd7.png)'
- en: 'So the effective offset for `pc` will be:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，`pc`的有效偏移量将是：
- en: '*16 + 4 + 0 + 12 = 32*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*16 + 4 + 0 + 12 = 32*'
- en: This means at offset 32, we will need to put the address of the system, which
    we found earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在偏移量32处，我们需要放置系统的地址，这是我们之前找到的。
- en: Also, let's go ahead and put the `/bin/sh` ASCII string at offset 36 and refer
    to it at offset 20\. Thus, the address of the string on stack will be `0x407fff18`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们继续在偏移量36处放置`/bin/sh`的ASCII字符串，并在偏移量20处引用它。因此，栈上字符串的地址将是`0x407fff18`。
- en: 'We can use the `ropgen` module to generate the exploit string, as shown in
    the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ropgen`模块来生成利用字符串，如下截图所示：
- en: '![](img/ab5e3be6-f1b0-47e9-844a-6c94bc0bbf5a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab5e3be6-f1b0-47e9-844a-6c94bc0bbf5a.png)'
- en: 'Let''s debug and step through the execution once again:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次调试并执行一遍：
- en: '![](img/69ceeee0-4890-42a4-8f3e-bdd7a60e7d03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ceeee0-4890-42a4-8f3e-bdd7a60e7d03.png)'
- en: 'If we look at the stack now, the ASCII string `/bin/sh` is now at the address
    `0x407fff38`, which means that we need to adjust our code to reflect this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看栈，ASCII字符串`/bin/sh`现在位于地址`0x407fff38`，这意味着我们需要调整我们的代码以反映这一点：
- en: '![](img/441da483-a57b-446f-a5c4-a5b15ced8af3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/441da483-a57b-446f-a5c4-a5b15ced8af3.png)'
- en: 'Debugging the same way as we did earlier, we can see that our ASCII string
    is loaded at the correct address this time:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与之前相同的方式调试，我们可以看到这一次我们的ASCII字符串被加载到了正确的地址：
- en: '![](img/933b13f7-c07a-4b83-b103-d44cbb6965a5.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/933b13f7-c07a-4b83-b103-d44cbb6965a5.png)'
- en: 'We can step once again to reach the `erand48` address, as shown in the following
    screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次步进到达`erand48`地址，如下截图所示：
- en: '![](img/2e5e9c80-8d99-40c4-9e36-8474fd966aa6.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e5e9c80-8d99-40c4-9e36-8474fd966aa6.png)'
- en: 'Register `r0` this time stores the address of the ASCII string as desired.
    Step two times by hitting **c** to arrive at the last instruction of the function
    (pop pc) as shown in the following:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次寄存器`r0`存储了所需的ASCII字符串的地址。通过两次按**c**来到达函数的最后一条指令（pop pc），如下所示：
- en: '![](img/e911f0e7-93cf-4906-9c8c-0420d0cf539f.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e911f0e7-93cf-4906-9c8c-0420d0cf539f.png)'
- en: 'The `pop {pc}` will load the address of the system from the stack and put it
    inside `pc`, which will then go to the system with the argument located in `r0`,
    which we placed as the address of our `/bin/sh string`. We can look at regs to
    confirm this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pop {pc}`将从栈中加载系统的地址并将其放入`pc`，然后将带有我们`/bin/sh`字符串地址的`r0`传递给系统。我们可以查看regs来确认这一点：'
- en: '![](img/51562d9d-cf40-4b10-927f-adc7a41b5cde.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51562d9d-cf40-4b10-927f-adc7a41b5cde.png)'
- en: 'Once we hit `c`, we will be able to get a shell, as shown next:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们按下`c`，我们将能够获得一个shell，如下所示：
- en: '![](img/bfddccc7-2162-49bb-a85a-679fe0c5ad95.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfddccc7-2162-49bb-a85a-679fe0c5ad95.png)'
- en: Thus, we were able to exploit a stack-based buffer overflow and use ROP to jump
    to the system with our desired string as argument, taking advantage of the instructions
    located in the `erand48` function, finally giving us a shell.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够利用基于堆栈的缓冲区溢出，并使用ROP跳转到系统，并使用我们期望的字符串作为参数，利用`erand48`函数中的指令，最终获得一个shell。
- en: This, however, was a very simple example of getting started with ROP on ARM-based
    architectures. A similar technique can be applied for ROP on MIPS, as shown next
    very briefly. Another thing that we have shown here is how to get around the cache
    incoherency issue, which usually comes during exploitation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个在基于ARM的架构上开始使用ROP的非常简单的例子。类似的技术可以应用于MIPS上的ROP，如下所示。我们在这里展示的另一件事是如何解决缓存不一致的问题，这通常在利用过程中出现。
- en: 'The vulnerable program that we are looking for in this case is the `socket_bof`
    from the DVRF firmware. The first instruction that we will jump to in this case
    is sleep, providing it the argument of the time we want to sleep. We are calling
    sleep to flush the cache and then later preparing our gadgets to call the system
    with the command address as the argument, as shown next. The following screenshot
    shows what our first gadget will look like:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这种情况下寻找的易受攻击程序是来自DVRF固件的`socket_bof`。在这种情况下，我们将要跳转到的第一条指令是`sleep`，并提供我们想要休眠的时间作为参数。我们调用`sleep`来刷新缓存，然后稍后准备我们的小工具，以调用系统并将命令地址作为参数，如下所示。下面的截图显示了我们的第一个小工具的样子：
- en: '![](img/5d50b447-9879-4033-aceb-492f3f997d73.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d50b447-9879-4033-aceb-492f3f997d73.png)'
- en: As we can see, with this gadget, apart from setting the `$a0`, which is the
    first register (just like `r0` in ARM), we are also able to control the **Return
    Address** (**RA**) and a number of other registers, such as `$fp`, `$s7`, `$s6`...`$s0`,
    and finally jump to `$ra`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过这个小工具，除了设置`$a0`之外，这是第一个寄存器（就像ARM中的`r0`一样），我们还能够控制**返回地址**（**RA**）和一些其他寄存器，比如`$fp`，`$s7`，`$s6`...`$s0`，最后跳转到`$ra`。
- en: 'In the next gadget, we will prepare to jump to sleep with the `$a0` value,
    which we have already set. Note that, in this gadget, `$t9` is getting the value
    from `$s0`, which we were able to control in the previous gadget:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个小工具中，我们将准备使用已经设置的`$a0`值跳转到`sleep`。请注意，在这个小工具中，`$t9`正在从我们在前一个小工具中能够控制的`$s0`中获取值：
- en: '![](img/f08807eb-ef79-4436-b0f1-d23f24259a9e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f08807eb-ef79-4436-b0f1-d23f24259a9e.png)'
- en: 'Once we have this gadget set, the next gadget will set the system argument
    (the address of the string command that we want to execute) and also allow us
    to jump to system. In this case, the argument is `$sp+24`, and `$t9` (which we
    want to set as system address) gets its value from `$s3`, which we were able to
    control in the very first gadget mentioned earlier:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们设置好这个小工具，下一个小工具将设置系统参数（我们要执行的字符串命令的地址），并允许我们跳转到系统。在这种情况下，参数是`$sp+24`，而`$t9`（我们要设置为系统地址）从`$s3`中获取其值，而我们在前面提到的第一个小工具中能够控制`$s3`。
- en: '![](img/78c5d533-c622-4599-a82d-a14c611d871d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78c5d533-c622-4599-a82d-a14c611d871d.png)'
- en: 'Once we have all the gadgets in place, the next step is to obviously calculate
    the various offsets to ensure that our ROP chain works. The overall ROP chain
    looks like the one shown in the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们把所有的小工具都放好，下一步显然是计算各种偏移量，以确保我们的ROP链能够正常工作。整个ROP链看起来就像下面截图中所示的那样：
- en: '![](img/3b7c6f10-29f5-449f-8cd6-9b912d0e83ed.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b7c6f10-29f5-449f-8cd6-9b912d0e83ed.png)'
- en: 'Next, place the individual arguments in the correct location, run the binary,
    and figure out the `libc` address from the `/proc/maps`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将各个参数放在正确的位置，运行二进制文件，并从`/proc/maps`中找出`libc`地址：
- en: '![](img/2cacb017-45cd-481d-a56a-c6f2a1d76709.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cacb017-45cd-481d-a56a-c6f2a1d76709.png)'
- en: 'Once you have the `libc` address identified correctly and the program running,
    you should be able to see that our arguments are now placed in the correct address
    during runtime, which can be confirmed using GDB:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦正确识别了`libc`地址并且程序运行起来，您应该能够看到我们的参数现在在运行时放在了正确的地址，可以使用GDB进行确认：
- en: '![](img/6e76df9c-cebc-4ad0-86bd-16a0b0beb754.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e76df9c-cebc-4ad0-86bd-16a0b0beb754.png)'
- en: In the preceding screenshot, `id` is the command that we wanted to execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，`id`就是我们想要执行的命令。
- en: 'To summarize, here is what our ROP chain in this case looks like:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总之，在这种情况下，我们的ROP链看起来是这样的：
- en: '![](img/52f3fe0b-b46e-4195-a08b-61663ed82c48.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52f3fe0b-b46e-4195-a08b-61663ed82c48.png)'
- en: That is all for ROP exploitation, where we went through examples for both ARM
    and MIPS. In real-world scenarios, the applications are the same-it might be the
    case that instead of just a few instructions, you will require a number of instructions
    to form your ROP chain.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是ROP利用的全部内容，我们将介绍ARM和MIPS的示例。在现实世界的场景中，应用是一样的——可能不仅仅是几条指令，你需要一些指令来形成你的ROP链。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can look at some of the automated tools which will help you during the
    process of ROP-based exploitation on various platforms. Some of the tools that
    are recommended you look at are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看一些自动化工具，这些工具将帮助您在各种平台上进行基于ROP的利用过程。建议您查看的一些工具如下：
- en: 'ROPGadget: [https://github.com/JonathanSalwan/ROPgadget](https://github.com/JonathanSalwan/ROPgadget)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ROPGadget: [https://github.com/JonathanSalwan/ROPgadget](https://github.com/JonathanSalwan/ROPgadget)'
- en: 'MoneyShot: [https://github.com/blasty/moneyshot](https://github.com/blasty/moneyshot)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MoneyShot: [https://github.com/blasty/moneyshot](https://github.com/blasty/moneyshot)'
- en: Chaining web security vulnerabilities
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接Web安全漏洞
- en: When adversaries target a type of IoT device, multiple vulnerabilities are often
    used in weaponizing an exploit. These vulnerabilities may be low in criticality
    by themselves; however, when combined, the exploit impact is much greater. It
    is not uncommon for a combination of low vulnerabilities to escalate into a critical
    vulnerability. This is especially important with regard to IoT devices. One critical
    bug discovered in an IoT device can compromise the integrity of the device. This
    recipe will cover how to chain web security vulnerabilities together to gain access
    to a Subaru-connected vehicle without a key fob, car keys, or credentials.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当对手针对某种IoT设备时，通常会利用多个漏洞来武装攻击。这些漏洞本身可能在严重性上较低；然而，当结合在一起时，攻击的影响就会更大。多个低级漏洞组合成一个严重漏洞并不罕见。这在IoT设备方面尤为重要。在IoT设备中发现的一个严重漏洞可能会危及设备的完整性。本文将介绍如何将Web安全漏洞链接在一起，以在没有钥匙、车钥匙或凭据的情况下访问Subaru连接的车辆。
- en: It is important that any vulnerability research stays within legal grounds.
    Performing unauthorized testing against MySubaru accounts and Subaru servers is
    illegal. All testing should take place in a controlled environment and should
    be rightfully owned. Although Subaru remote services do not control engine and
    drivetrain functions, testing outcomes are unknown. All critical vulnerabilities
    in this recipe have been reported and resolved by Subaru.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 任何漏洞研究都必须在合法范围内进行。对MySubaru账户和Subaru服务器进行未经授权的测试是非法的。所有测试都应该在受控环境中进行，并且应该是合法拥有的。尽管Subaru远程服务不能控制发动机和传动系统功能，但测试结果是未知的。本文中的所有严重漏洞都已被Subaru报告并解决。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The first step in performing any assessment is threat modeling; in this case,
    threat modeling a 2017 Subaru WRX STi connected vehicle from a black box perspective.
    Start with identifying entry points into a vehicle, which will provide an identified
    attack surface that can be built on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 进行任何评估的第一步是威胁建模；在这种情况下，从黑盒的角度对2017年Subaru WRX STi连接车辆进行威胁建模。首先确定车辆的入口点，这将提供一个已识别的攻击面，可以在此基础上构建。
- en: Step 1 - identifying assets and entry points
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤1 - 确定资产和入口点
- en: 'Every car is different with some models having more features than other models.
    Research the publicly available resources on Subaru-connected vehicles and the
    different features between models and years. For example, we know a connected
    vehicle have access to the internet via a cellar 4G/LTE connection, but others
    may gain internet access via tethering to a phone''s connection or other means
    such as Wi-Fi. Let''s start there and document what we know about the target vehicle
    before performing any active attack phases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每辆车都不同，有些型号比其他型号拥有更多的功能。研究Subaru连接车辆和不同型号和年份之间的功能之间的公开资源。例如，我们知道连接车辆可以通过蜂窝4G/LTE连接访问互联网，但其他车辆可能通过手机连接或其他方式（如Wi-Fi）获得互联网访问。让我们从这里开始，在执行任何主动攻击阶段之前记录我们对目标车辆的了解：
- en: '**Cellular connectivity**: The Subaru connected vehicles are connected to the
    internet via AT&T 4G LTE ([http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html](http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html)).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蜂窝连接**：Subaru连接车辆通过AT&T 4G LTE连接到互联网（[http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html](http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html)）。'
- en: '**Wi-Fi**: This is not available in the target Subaru vehicle.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wi-Fi**：目标Subaru车辆中没有Wi-Fi。'
- en: '**Bluetooth**: The infotainment system connects devices via Bluetooth to access
    media, device contact books, and messages.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙**：车载娱乐系统通过蓝牙连接设备，以访问媒体、设备通讯录和消息。'
- en: '**Key fobs**: To gain access and start this particular vehicle, the key fob
    is needed. The key fob transmits at the frequency range of 314.35-314.35 MHz ([https://fccid.io/HYQ14AHC](https://fccid.io/HYQ14AHC)).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**钥匙链**：要进入和启动这辆特定的车辆，需要钥匙链。钥匙链在314.35-314.35 MHz的频率范围内传输（[https://fccid.io/HYQ14AHC](https://fccid.io/HYQ14AHC)）。'
- en: '**USB connectivity**: The infotainment system uses USB to connect a device''s
    media as well as updates for GPS and the infotainment system itself.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB连接**：车载娱乐系统使用USB连接设备的媒体以及GPS和车载娱乐系统本身的更新。'
- en: '**SD card**: The infotainment system has a microSD card slot for GPS maps.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SD卡**：车载娱乐系统有一个microSD卡插槽用于GPS地图。'
- en: '**OBD II**: This is used to access the CAN bus for diagnostics and can flash
    ECU images on the vehicle for tuning or other performance modifications.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OBD II**：用于访问CAN总线进行诊断，并可以在车辆上刷写ECU图像以进行调整或其他性能修改。'
- en: '**CAN bus**: Every vehicle has one or multiple CAN buses for in-vehicle communication.
    The CAN bus is inherently vulnerable and can be sniffed using free tools.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAN总线**：每辆车都有一个或多个CAN总线用于车内通信。CAN总线本身是容易受到攻击的，可以使用免费工具进行嗅探。'
- en: '**Mobile applications**: Subaru''s Starlink in-vehicle technology connects
    to the MySubaru application which allows you to lock and unlock your vehicle remotely,
    access your horn and lights, view car health reports, and locate your vehicle
    on a map. To use these features, a subscription must be purchased.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动应用程序**：Subaru的Starlink车载技术连接到MySubaru应用程序，允许您远程锁定和解锁车辆，访问您的喇叭和灯光，查看车辆健康报告，并在地图上找到您的车辆。要使用这些功能，必须购买订阅。'
- en: '**Web application**: In addition to the MySubaru mobile application, Subaru''s
    Starlink in-vehicle technology connects to a web interface which allows you to
    lock and unlock your vehicle remotely, access your horn and lights, change user
    settings, schedule services, add authorized users, and locate your vehicle on
    a map. To use these features, a subscription must be purchased.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络应用程序**：除了MySubaru移动应用程序外，Subaru的Starlink车载技术连接到一个网络界面，允许您远程锁定和解锁车辆，访问您的喇叭和灯光，更改用户设置，安排服务，添加授权用户，并在地图上找到您的车辆。要使用这些功能，必须购买订阅。'
- en: Now that we have listed the entry points of a connected vehicle, we have a better
    idea as to what to target first. We can also gauge the level of effort based upon
    our skillset and comfortability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列出了连接车辆的入口点，我们对首要攻击目标有了更好的了解。我们还可以根据我们的技能和舒适度来评估努力的程度。
- en: Step 2 - finding the weakest link
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤2 - 找到最薄弱的环节
- en: There has been plenty of research on infotainment systems and CAN bus exploitation.
    Any protocol vulnerabilities discovered in Bluetooth, Wi-Fi, or the key fob might
    turn into a zero-day-like vulnerability and take quite a bit of time. Having said
    that, let's shift our attention to the MySubaru mobile apps and the web application.
    With mobile and web applications, vicinity to the car is not necessary. All that
    is needed is a STARLINK Safety Plus and Security Plus subscription, supported
    model, and credentials to a MySubaru account. This is great because we multitask
    and work on all three applications concurrently. In addition, Subaru has delegated
    unlocking, locking, honking the horn, and locating a vehicle via its mobile and
    web applications. The target applications are version 1.4.5 of the MySubaru Android
    and iOS apps. Any application-level bug discovered could have a high-level impact
    and may also pose a safety concern to Subaru owners.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对车载娱乐系统和CAN总线的研究已经很多。在蓝牙、Wi-Fi或钥匙链中发现的任何协议漏洞可能会变成一个零日漏洞，并需要相当长的时间。话虽如此，让我们把注意力转向MySubaru移动应用程序和网络应用程序。对于移动和网络应用程序，与车辆的接近并不是必要的。所需的只是一个STARLINK
    Safety Plus和Security Plus订阅，支持的车型和MySubaru账户的凭据。这很好，因为我们可以同时处理这三个应用程序。此外，Subaru已经委托通过其移动和网络应用程序解锁、锁定、按喇叭和定位车辆。目标应用程序是MySubaru
    Android和iOS应用程序的1.4.5版本。发现的任何应用程序级别的漏洞可能会产生高级别的影响，也可能对Subaru车主构成安全问题。
- en: Step 3 - reconnaissance
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤3 - 侦察
- en: Since we are focusing our efforts on the applications, we need to perform a
    level of recon on all three applications. Let's start with the mobile applications
    first and then move forward with the web application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将精力集中在应用程序上，我们需要对所有三个应用程序进行一定程度的侦察。让我们先从移动应用程序开始，然后再转向网络应用程序。
- en: Android application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓应用程序
- en: 'Android apps are simple to disassemble and analyze statically prior to performing
    dynamic tests. Some level of effort is required when reversing Android apps, but
    if we can discover the low hanging fruit, then we have an easy win. We first need
    to acquire the MySubaru app via a third-party marketplace and ensure it is the
    same as the Google Play version. Once this is verified, the following steps should
    be taken to perform a baseline level of recon on the MySubaru Android app:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行动态测试之前，Android应用程序很容易进行静态拆解和分析。反向Android应用程序需要一定程度的努力，但如果我们能发现低 hanging fruit，那么我们就能轻松获胜。我们首先需要通过第三方市场获取MySubaru应用程序，并确保它与Google
    Play版本相同。验证后，应采取以下步骤对MySubaru Android应用程序进行基线侦察：
- en: 'Disassemble the APK using MobSF or a similar tool:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MobSF或类似工具拆解APK：
- en: Analyze classes and methods
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析类和方法
- en: Identify third-party libraries
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别第三方库
- en: Identify whether the app is native or hybrid
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定应用程序是原生的还是混合的
- en: Look for hardcoded values
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找硬编码的值
- en: Look for potential secrets and environments
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找潜在的秘密和环境
- en: Install the app and monitor Android components
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装应用程序并监视Android组件
- en: Activities, services, and intents
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动、服务和意图
- en: Analyze data storage
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析数据存储
- en: SD card usage
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SD卡使用
- en: '`SharedPreferences.xml`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedPreferences.xml`'
- en: Cache
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: SQLite databases
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库
- en: Proxy all API requests from the Android app to the vehicle using Burp Suite
    or similar tools
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理Android应用程序到车辆的所有API请求，使用Burp Suite或类似工具。
- en: Login/Logout
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录/注销
- en: Unlock/lock
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁/锁定
- en: Honk the horn
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按喇叭
- en: Flash the lights
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁灯光
- en: Locate the vehicle
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到车辆
- en: View the vehicle health report
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看车辆健康报告
- en: Edit vehicle details
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑车辆详细信息
- en: Ensure color-coded highlights and notes are taken for Android communication.
    This will help when compiling the different API calls used to identify vulnerabilities
    for Android as well as the other Subaru applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为Android通信进行颜色编码的高亮显示和注释。这将有助于在编译用于识别Android漏洞的不同API调用时，以及其他Subaru应用程序时使用。
- en: iOS application
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS应用程序
- en: 'When reversing iOS apps, more time is required to obtain the IPA file, decrypt
    it, transfer the application binary to our host computer, and then work toward
    finding vulnerabilities. In this case, we must download the MySubaru application
    via the App Store and perform the decryption and binary transference to our host
    computer. Once this is complete, the following steps should be taken to perform
    a baseline level of recon on the iOS MySubaru app:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向iOS应用程序时，需要更多时间来获取IPA文件，解密它，将应用程序二进制文件传输到我们的主机计算机，然后努力找到漏洞。在这种情况下，我们必须通过App
    Store下载MySubaru应用程序，并执行解密和二进制传输到我们的主机计算机。完成后，应采取以下步骤对iOS MySubaru应用程序进行基线侦察：
- en: 'Disassemble the iOS binary using Hopper or similar tools:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hopper或类似工具拆解iOS二进制文件：
- en: Analyze classes and methods (use Class-dump-z)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析类和方法（使用Class-dump-z）
- en: Identity third-party libraries
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别第三方库
- en: Identify whether the app is native or hybrid
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定应用程序是原生的还是混合的
- en: Look for hardcoded values
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找硬编码的值
- en: Look for potential secrets and environment
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找潜在的秘密和环境
- en: 'Install the app and monitor iOS components:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装应用程序并监视iOS组件：
- en: IPC via URL schemes
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过URL schemes进行IPC
- en: 'Analyze data storage:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析数据存储：
- en: Plists
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Plists
- en: SQLite databases
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库
- en: Cache.db
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cache.db
- en: Localstorage
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储
- en: 'Proxy all API requests from the iOS app to the vehicle using Burp Suite or
    similar tools:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理iOS应用程序到车辆的所有API请求，使用Burp Suite或类似工具：
- en: Login/Logout
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录/注销
- en: Unlock/lock
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁/锁定
- en: Honk the horn
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按喇叭
- en: Flash the lights
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁灯光
- en: Locate the vehicle
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到车辆
- en: View the vehicle health report
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看车辆健康报告
- en: Edit vehicle details
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑车辆详细信息
- en: The differences between iOS and Android API calls should be noted. The storage
    of data should also be noted with an emphasis on personal details as well as credentials.
    Observations on potential roadblocks should be identified based upon the recon
    performed on both applications. For example, both mobile applications send remote
    service calls via a `POST` request with a `sessionId` parameter value, which is
    unique for every request.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意iOS和Android API调用之间的差异。数据存储也应该注意，重点放在个人详细信息和凭据上。应根据对两个应用程序执行的侦察来确定潜在的障碍。例如，两个移动应用程序都通过`POST`请求发送远程服务调用，其中包含一个`sessionId`参数值，对于每个请求都是唯一的。
- en: This may hinder our ability to forge remote service requests since this value
    is unique and not a hardcoded value. One key observation found in the iOS application
    is the caching of all HTTP requests and responses to a `Cache.db` SQLite database.
    All data in the `Cache.db` is in clear text with vehicle details, personal owner
    details, account tokens, and API requests can be extracted by attackers when backing
    up an iOS device or using free tools such as iFunbox.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会妨碍我们伪造远程服务请求的能力，因为这个值是唯一的，而不是硬编码的值。在iOS应用程序中发现的一个关键观察是将所有HTTP请求和响应缓存到`Cache.db`
    SQLite数据库中。`Cache.db`中的所有数据都是明文，包括车辆详细信息、个人所有者详细信息、帐户令牌和API请求，攻击者可以在备份iOS设备或使用iFunbox等免费工具时提取这些数据。
- en: 'The following screenshot shows a cached request with a `handoffToken` token
    in the URL:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了URL中带有`handoffToken`令牌的缓存请求：
- en: '![](img/67d4eb47-993a-4b9e-b148-443ab09c1158.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67d4eb47-993a-4b9e-b148-443ab09c1158.png)'
- en: Web application
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序
- en: 'Next, we will take a look at the MySubaru web application and inspect all HTTP
    requests and responses. The MySubaru web application contains additional options
    that the mobile applications do not have such as adding authorized users or changing
    the account pin number. Follow the same steps when proxying the web application
    traffic, but ensure all state configuration changes, such as the ones listed as
    follows, are clicked and analyzed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看MySubaru网络应用程序，并检查所有HTTP请求和响应。MySubaru网络应用程序包含移动应用程序没有的其他选项，例如添加授权用户或更改帐户PIN码。代理网络应用程序流量时，应确保点击和分析所有状态配置更改，例如以下列出的更改：
- en: Login/Logout
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录/注销
- en: Lock/Unlock
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定/解锁
- en: Honk the horn
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按喇叭
- en: Flash the lights
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁灯光
- en: Locate the vehicle
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到车辆
- en: View the vehicle health report
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看车辆健康报告
- en: Edit vehicle details
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑车辆详细信息
- en: Add a vehicle
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加车辆
- en: Add and remove authorized users
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和删除授权用户
- en: Change pin
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改PIN
- en: Change password
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改密码
- en: Change security questions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改安全问题
- en: Change personal account details
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改个人账户详情
- en: All differences between the web application and mobile applications should be
    noted. So far, a major difference between the web and mobile apps is how remote
    service API requests are sent to Subaru servers. The API endpoint remains the
    same for all applications, which can be useful if we uncover a vulnerability to
    exploit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意网络应用程序和移动应用程序之间的所有差异。到目前为止，网络应用程序和移动应用程序之间的一个主要区别是远程服务API请求如何发送到Subaru服务器。API端点对所有应用程序保持不变，如果我们发现漏洞可以利用，这将是有用的。
- en: 'The following screenshot displays the HTTP history in Burp Suite with color
    coding for all applications:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Burp Suite中所有应用程序的HTTP历史记录，并进行了颜色编码：
- en: '![](img/42b354f1-a899-4f38-96b3-b7318530ac8c.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42b354f1-a899-4f38-96b3-b7318530ac8c.png)'
- en: Step 4 - identifying vulnerabilities
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 识别漏洞
- en: 'With all application features and API calls noted in our web proxy, we can
    now start to identify vulnerabilities in the design and also test logic flaws
    for vulnerabilities. The following is a list of the observed vulnerabilities:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Web代理中记录了所有应用程序功能和API调用后，我们现在可以开始识别设计中的漏洞，并测试逻辑缺陷以寻找漏洞。以下是观察到的漏洞列表：
- en: The web application sends all remote service calls over the URL as a `GET` request
    while the mobile applications send remote service calls as a `POST` with the parameters
    in the body. There are no randomly generated `sessionIds` used to execute remote
    service calls for the web.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络应用程序通过URL发送所有远程服务调用，作为`GET`请求，而移动应用程序则将远程服务调用作为`POST`发送，参数在请求体中。在网络应用程序中没有随机生成的`sessionIds`用于执行远程服务调用。
- en: Certificate pinning and validation is not enforced for mobile applications.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动应用程序没有强制证书固定和验证。
- en: All requests and responses are cached for the iOS application.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: iOS应用程序的所有请求和响应都被缓存。
- en: Account configuration changes, such as editing the vehicle details or adding
    authorized users, do not contain anti-CSRF tokens.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户配置更改，如编辑车辆详情或添加授权用户，不包含反CSRF令牌。
- en: Owners are not notified when an authorized user is added.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当添加授权用户时，所有者不会收到通知。
- en: Updates to the account pin do not require knowledge of the previous set pin.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户PIN的更新不需要知道先前设置的PIN。
- en: Updates to security questions do not require re-authentication, do not have
    a minimum character length, and can all be the same value such as 1.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全问题的更新不需要重新身份验证，没有最小字符长度，并且可以都是相同的值，如1。
- en: Authorized users have full access to Subaru remote services and do not have
    a limit how many can be added.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权用户对Subaru远程服务拥有完全访问权限，并且没有添加限制。
- en: There are no concurrent login policies for all applications.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有应用程序都没有并发登录策略。
- en: 'The following is a screenshot of the pin and security question update profile
    section that does not require authentication or previous knowledge of the settings
    to make changes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不需要身份验证或先前了解设置即可进行更改的PIN和安全问题更新配置部分的屏幕截图：
- en: '![](img/6c7f1627-47fb-466e-ada1-a326df8db7e9.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c7f1627-47fb-466e-ada1-a326df8db7e9.png)'
- en: Now we can start changing configuration parameter values that reflect user input
    to the screen. Since we are not authorized to send malicious payloads in this
    case, all efforts will be manual, and parameters will be manually input via Burp
    Suite's repeater. With that in mind, we can try basic XSS payloads and observe
    whether any validation and/or encoding is in place. The first location that comes
    to mind which reflects our parameter values is the vehicle nickname. It appears
    that a vanilla `<script> alert(1)</script>` works and executes in the browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始更改反映用户输入到屏幕的配置参数值。由于我们未被授权在此情况下发送恶意有效负载，所有努力将是手动的，并且参数将通过Burp Suite的重放器手动输入。考虑到这一点，我们可以尝试基本的XSS有效负载，并观察是否存在任何验证和/或编码。首先想到的反映我们参数值的位置是车辆昵称。似乎一个普通的`<script>
    alert(1)</script>`可以在浏览器中执行。
- en: 'This is now an authenticated **cross-site scripting** (**XSS**) vulnerability
    that may be of use to us (Vulnerability #10). The following is a screenshot of
    the XSS:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在是一个经过身份验证的**跨站脚本**（**XSS**）漏洞，可能对我们有用（漏洞＃10）。以下是XSS的屏幕截图：
- en: '![](img/40887edf-f1ec-44d2-a32c-cd236099b297.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40887edf-f1ec-44d2-a32c-cd236099b297.png)'
- en: 'Next, we can check for other API logic flaws such as whether rate limiting
    is enforced or whether the API requests can be replayed without modification.
    This can be done by sending the HTTP requests to Burp Suite''s repeater and replay
    requests. We will find that there are no replay or rate limiting security controls
    enforced when making remote service calls (Vulnerability #11). Although there
    is a brief 5 second period that is needed in between API requests in order for
    the vehicle to execute requests.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以检查其他API逻辑缺陷，例如是否执行了速率限制，或者API请求是否可以在不修改的情况下重放。这可以通过将HTTP请求发送到Burp Suite的重放器并重放请求来完成。我们将发现在进行远程服务调用时没有重放或速率限制安全控制（漏洞＃11）。尽管在API请求之间需要一个短暂的5秒间隔，以便车辆执行请求。
- en: 'Another logical flaw to be tested is the login process between the mobile app
    and Subaru servers. Subaru passes user credentials via a `POST` body and then
    redirects users to their account dashboard after authenticating. During the login
    process and after the account credentials have successfully authenticated, a `GET`
    request is sent to Subaru''s servers with the username, handoffToken, and other
    parameters. This is the same HTTP request found in the `Cache.db` of the iOS application,
    but with a different token value. This `GET` request can be copied and pasted
    into a browser and be autologged into a MySubaru account without the need for
    a username or password (Vulnerability #12). In addition, the handoffToken never
    expires and will still be valid even if a MySubaru user logs out of the web and
    mobile applications. Even password changes do not expire this token. This is a
    great find as we can now gain persistent access to a MySubaru account without
    the owner knowing an attacker has access. Another issue related to the handoffToken
    is the fact that new tokens are created for new devices and authorized users who
    log into their MySubaru mobile applications. For example, an owner logs in to
    their MySubaru account with two iPhones and two Android devices. There are now
    four live handoffTokens for their account. This also applies to the authorized
    users. For instance, two authorized users (`carhackingemail@gmail.com` and `carhackingemail1@gmail.com`)
    log in to their MySubaru mobile applications with three devices. There are now
    six live tokens for the authorized users, which expands the attack surface to
    10 live tokens for one MySubaru account. The following is an example that shows
    two authorized user accounts, `carhackingemail@gmail.com` and `carhackingemail1@gmail.com`,
    that log in with three different mobile devices and get issued different handoffToken
    values:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要测试的逻辑缺陷是移动应用程序和Subaru服务器之间的登录过程。Subaru通过`POST`主体传递用户凭据，然后在验证后将用户重定向到其帐户仪表板。在登录过程中，账户凭据成功验证后，将向Subaru的服务器发送一个`GET`请求，其中包括用户名、handoffToken和其他参数。这是在iOS应用程序的`Cache.db`中找到的相同HTTP请求，但令牌值不同。这个`GET`请求可以被复制并粘贴到浏览器中，并且可以自动登录到MySubaru账户，而无需用户名或密码（漏洞＃12）。此外，handoffToken永远不会过期，即使MySubaru用户注销了网络和移动应用程序，它仍然有效。即使更改密码也不会使此令牌过期。这是一个很好的发现，因为我们现在可以在车主不知情的情况下持久访问MySubaru账户。与handoffToken相关的另一个问题是为新设备和已授权用户创建新令牌，这些用户登录其MySubaru移动应用程序。例如，所有者使用两部iPhone和两部Android设备登录其MySubaru账户。现在有四个活动的handoffToken。这也适用于已授权用户。例如，两个已授权用户（`carhackingemail@gmail.com`和`carhackingemail1@gmail.com`）使用三个设备登录其MySubaru移动应用程序。现在已授权用户有六个活动令牌，这扩大了对一个MySubaru账户的攻击面。以下是一个示例，显示了两个已授权用户账户`carhackingemail@gmail.com`和`carhackingemail1@gmail.com`，它们使用三个不同的移动设备并获得了不同的handoffToken值：
- en: '![](img/eb7d4b3d-7c46-45bc-bac5-bdcd343dfcdc.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb7d4b3d-7c46-45bc-bac5-bdcd343dfcdc.png)'
- en: Step 5 - Exploitation -- Chaining vulnerabilities
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5步-利用-链接漏洞
- en: At least 11 vulnerabilities have been identified through passive and active
    analysis. Some of the vulnerabilities can be directly exploited while others may
    be indirectly exploited because of the application's logic and design. With the
    goal of accessing a vehicle without a key fob, car keys, or credentials, we should
    have what we need.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过被动和主动分析已经确定了至少11个漏洞。一些漏洞可以直接利用，而其他一些可能间接利用，因为应用程序的逻辑和设计。为了访问车辆而无需钥匙、车钥匙或凭据，我们应该有所需的东西。
- en: 'Looking through the identified security bugs, user intervention will be needed
    to successfully exploit a MySubaru owner''s account and vehicle. There are several
    ways in which we can do this. We can try the following attack scenario which relies
    on a form of social engineering:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看已识别的安全漏洞，需要用户干预才能成功利用MySubaru所有者的账户和车辆。我们可以通过几种方式来做到这一点。我们可以尝试以下攻击场景，这依赖于一种社会工程学形式：
- en: Craft a malicious page that employs an XSS payload for the vehicle's nickname
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个恶意页面，其中包含用于车辆昵称的XSS有效负载
- en: Acquire a handoffToken to gain a valid session
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取handoffToken以获得有效的会话
- en: Add authorized users via CSRF
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CSRF添加已授权用户
- en: Forge unlock remote service calls to the target Subaru vehicle via CSRF
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CSRF伪造解锁远程服务调用目标Subaru车辆
- en: Change security questions
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改安全问题
- en: Change pin
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改PIN
- en: Profit $$
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赚钱$$
- en: 'The other attack scenarios that can be used to gain a valid `handoffToken`
    are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于获得有效的`handoffToken`的其他攻击场景包括：
- en: The victim logs in with the attacker device where the token can be extracted
    from the cache
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受害者使用攻击者设备登录，可以从缓存中提取令牌
- en: The victim backs up the mobile device (Android/iOS ) to the attacker's computer
    and the attacker restores the victim's backup to a test mobile device which contains
    the handoffToken
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受害者将移动设备（Android/iOS）备份到攻击者的计算机上，攻击者将受害者的备份还原到包含handoffToken的测试移动设备中
- en: The attacker steals the authorized user's token instead of the owner
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者窃取已授权用户的令牌而不是车主
- en: MITM victim traffic via a Wi-Fi hotspot or other means
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Wi-Fi热点或其他方式进行中间人攻击
- en: Obtain `Cache.db` via iFunBox (iOS)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过iFunBox获取`Cache.db`（iOS）
- en: The audit logs leak the handoffToken via `URL GET` requests, which can be acquired
    by system administrators of Subaru, admins of corporate networks that inspect
    network traffic, and wireless hotspots
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计日志通过`URL GET`请求泄漏handoffToken，可以被Subaru的系统管理员、检查网络流量的企业网络管理员和无线热点获取
- en: 'The attackers can not only gain unauthorized access to a vehicle but can also
    track an owner and put their safety at risk. Other post exploit scenarios can
    also be explored such as the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者不仅可以未经授权地访问车辆，还可以跟踪车主并将其安全置于危险之中。还可以探索其他后利用场景，例如以下内容：
- en: Steal contents inside the vehicle
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窃取车辆内的内容
- en: Sabotage the vehicle's engine
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏车辆的引擎
- en: Retain persistence to a MySubaru account which may have multiple vehicles provisioned
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持对MySubaru账户的持久性，该账户可能有多辆车辆
- en: Implant an out-of-band tracker
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植入带外跟踪器
- en: Implant a malicious Wi-Fi access point w/GSM for remote connection to exploit
    neighboring access points or vehicles
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植入恶意Wi-Fi接入点w/GSM，以远程连接来利用附近的接入点或车辆
- en: Replay remote service requests such as locking the vehicle to drain the battery
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重放远程服务请求，如锁定车辆以耗尽电池
- en: As you may have noticed, these are fundamental web security vulnerabilities
    and not ground breaking zero-day exploits. The impact for exploiting fundamental
    vulnerabilities are much higher for IoT-connected devices and vehicles.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些都是基本的网络安全漏洞，而不是突破性的零日漏洞利用。对于利用基本漏洞的影响，对于物联网连接的设备和车辆来说要高得多。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Visit the following web pages to read about the research discussed in this
    recipe:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下网页，阅读本配方中讨论的研究：
- en: '[https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/](https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/](https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/)'
- en: '[https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/](https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/](https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/)'
- en: '[http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970](http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970](http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970)'
- en: Configuring continuous integration testing for firmware
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为固件配置持续集成测试
- en: Building firmware written in C/C++ can be a challenge for legacy products with
    complex Makefiles. Nevertheless, all source code should be statically analyzed
    for security vulnerabilities prior to deploying production builds. This recipe
    will show how to configure basic C/C++ static analysis for firmware in a continuous
    integration environment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为C/C++编写的固件构建可能对具有复杂Makefile的传统产品构成挑战。然而，在部署生产构建之前，所有源代码都应该进行静态分析，以检测安全漏洞。本配方将展示如何在持续集成环境中为固件配置基本的C/C++静态分析。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use the following application and tools:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本配方，我们将使用以下应用程序和工具：
- en: '**Jenkins**: This is an open source build automation server that can be customized
    to run quality and security code analysis. Jenkins can be downloaded via the following
    link [https://jenkins.io/download/](https://jenkins.io/download/). There are various
    ways to install Jenkins depending on the operating system. For Debian and Ubuntu,
    the following commands can be used to install Jenkins:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：这是一个开源的构建自动化服务器，可以定制运行质量和安全代码分析。Jenkins可以通过以下链接[https://jenkins.io/download/](https://jenkins.io/download/)下载。根据操作系统的不同，有各种安装Jenkins的方法。对于Debian和Ubuntu，可以使用以下命令安装Jenkins：'
- en: '[PRE2]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following line to  `/etc/apt/sources.list`:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下行添加到`/etc/apt/sources.list`：
- en: '[PRE3]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Fuzzgoat**: This is a vulnerable C program that can be downloaded via the
    following GitHub repository [https://github.com/packttestaccount/fuzzgoat](https://github.com/packttestaccount/fuzzgoat).
    Clone the fuzzgoat application into your Jenkins build server using:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fuzzgoat**：这是一个易受攻击的C程序，可以通过以下GitHub存储库[https://github.com/packttestaccount/fuzzgoat](https://github.com/packttestaccount/fuzzgoat)下载。使用以下命令将fuzzgoat应用程序克隆到您的Jenkins构建服务器中：'
- en: '[PRE4]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Flawfinder**: This is a simple tool that analyzes C/C++ code for potential
    security vulnerabilities. Flawfinder can be downloaded via the following link
    [https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz](https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flawfinder**：这是一个简单的工具，用于分析C/C++代码中的潜在安全漏洞。Flawfinder可以通过以下链接[https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz](https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz)下载。'
- en: 'A simple way to install Flawfinder is via pip using the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过pip简单安装Flawfinder的方法如下：
- en: '[PRE5]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: To setup continuous integration testing of firmware, use the following steps
    to create your environment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置固件的持续集成测试，请使用以下步骤创建您的环境。
- en: 'Once Jenkins is installed, log in and click on New Item:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了Jenkins后，登录并单击“新建项目”：
- en: '![](img/aba628cc-7a9d-4a5d-8a1a-3e7dda6226be.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aba628cc-7a9d-4a5d-8a1a-3e7dda6226be.png)'
- en: Ensure your `JAVA_HOME` environment variable is configured. If there are multiple
    Java versions in use, make sure to configure the JDK via the Global Tool Configuration
    in Jenkins via `http://127.0.0.1:8080/configureTools/`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的`JAVA_HOME`环境变量已配置。如果使用了多个Java版本，请确保通过Jenkins的全局工具配置在`http://127.0.0.1:8080/configureTools/`中配置JDK。
- en: 'Enter a name and select the Freestyle project:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称并选择自由风格项目：
- en: '![](img/5648c9e9-2ea8-4210-8aae-c83954e4ae52.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5648c9e9-2ea8-4210-8aae-c83954e4ae52.png)'
- en: 'The configuration page will appear. Do not input any settings just yet as we
    are going to load a local project into a workspace that Jenkins will create after
    we build the project. The build will fail, which is okay because we just want
    Jenkins to create the directory and then we will copy our project files with C
    code into the workspace. This step will also be used in the following recipes
    to create workspaces:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置页面将出现。暂时不要输入任何设置，因为我们将在构建项目后加载一个本地项目到Jenkins将创建的工作空间中。构建将失败，这没关系，因为我们只是希望Jenkins创建目录，然后我们将把我们的C代码项目文件复制到工作空间中。这一步也将用于以下配方中创建工作空间：
- en: '![](img/def1200a-f377-42fb-8971-170b782f80de.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/def1200a-f377-42fb-8971-170b782f80de.png)'
- en: 'Once the Save button is clicked, Jenkins will redirect you to the project page
    where we will select Build Now:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击保存按钮后，Jenkins将重定向您到项目页面，我们将选择“立即构建”：
- en: '![](img/089dca88-628d-4283-a34e-9ed6a26bf8e2.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/089dca88-628d-4283-a34e-9ed6a26bf8e2.png)'
- en: Now, Jenkins has built our workspace where we can transfer our code files over.
    The directory structure differs depending on the operating system used. For Ubuntu,
    workspace files are located in `/var/lib/Jenkins/workspace/` and for OS X workspace
    files are located in `/Users/Shared/Jenkins/Home/workspace/`. Transfer the fuzzgoat
    files into the newly created workspace directory, which has the project name as
    the directory. In this case, it's `/var/lib/Jenkins/workspace/PacktTestFirmware/`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jenkins已经构建了我们的工作空间，我们可以在其中传输我们的代码文件。目录结构因所使用的操作系统而异。对于Ubuntu，工作空间文件位于`/var/lib/Jenkins/workspace/`，对于OS
    X，工作空间文件位于`/Users/Shared/Jenkins/Home/workspace/`。将fuzzgoat文件传输到新创建的工作空间目录中，该目录以项目名称命名。在这种情况下，它是`/var/lib/Jenkins/workspace/PacktTestFirmware/`。
- en: Ensure the Jenkins *Nix user has the proper file and folder permissions to scan
    anything in the `workspace` directory. This also includes permission for the tools
    to scan the relative directories.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Jenkins *Nix用户具有适当的文件和文件夹权限，以扫描`workspace`目录中的任何内容。这还包括工具扫描相关目录的权限。
- en: 'Now that fuzzgoat is within the Jenkins workspace directory, navigate back
    to the Jenkins build project and add a build step to execute a shell command,
    which will be executing `flawfinder` in our `workspace` directory:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在fuzzgoat在Jenkins工作空间目录中，返回Jenkins构建项目并添加一个构建步骤来执行一个shell命令，该命令将在我们的`workspace`目录中执行`flawfinder`：
- en: '![](img/5cf6a9c6-356e-4ffd-9eea-900ee77c4577.png)![](img/4228b997-8122-4ad3-82d7-6a7814dbc73f.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cf6a9c6-356e-4ffd-9eea-900ee77c4577.png)![](img/4228b997-8122-4ad3-82d7-6a7814dbc73f.png)'
- en: 'Add another build step to execute another shell command. This will execute
    the `make` command in the working directory which is based upon the Makefile fuzzgoat
    has supplied us with. Click on Save afterwards:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个构建步骤来执行另一个shell命令。这将在基于fuzzgoat提供给我们的Makefile的工作目录中执行`make`命令。之后单击保存：
- en: '![](img/dc55c928-9720-41f0-b89f-a42a27ab1622.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc55c928-9720-41f0-b89f-a42a27ab1622.png)'
- en: 'Select the Build Now option in the project page. Click on the permalink arrow
    and select Console Output, as shown in the following screenshot:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目页面中选择立即构建选项。单击永久链接箭头，然后选择控制台输出，如下图所示：
- en: '![](img/c9fef50d-f8a2-4110-92f2-399fee2c3313.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9fef50d-f8a2-4110-92f2-399fee2c3313.png)'
- en: 'The following page should appear with the build and `flawfinder` results:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的页面应该显示构建和`flawfinder`的结果：
- en: '![](img/6477d128-7fd5-44ce-befe-e6b47ac8c5f7.png)![](img/478cc1d4-8bec-4476-9263-7c90351f4105.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6477d128-7fd5-44ce-befe-e6b47ac8c5f7.png)![](img/478cc1d4-8bec-4476-9263-7c90351f4105.png)'
- en: Build steps can be customized to alert engineering or security managers to perform
    an action based upon the results. However, not all the hits from `flawfinder`
    are vulnerabilities, but they should be reviewed to ensure software security bugs
    are not introduced. Keep in mind, `flawfinder` is a simple tool that offers a
    minimum amount of checks for C/C++ code. It simply checks for common buffer overflow
    issues and other well-known problems such as the usage of banned functions. Commercial
    SAST tools include dependency graphs as well as call graphs to check for dependency
    software bugs and application data flow. In addition, many commercial SAST tools
    also include IDE plugins that check code in real time for software security bugs.
    There are free IDE plugins for C/C++ with XCode's Clang Static Analyzer; however,
    custom configurations are required in order to compile such code within an OS
    X environment. Clang will not analyze any files that cannot be compiled. In the
    configuring continuous integration testing for mobile applications section, we
    will discuss how to use an IDE plugin to statically analyze code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤可以定制以警报工程或安全经理根据结果执行操作。但是，并非所有来自`flawfinder`的命中都是漏洞，但应该对其进行审查，以确保没有引入软件安全漏洞。请记住，`flawfinder`是一个简单的工具，提供了最少量的C/C++代码检查。它只是检查常见的缓冲区溢出问题和其他众所周知的问题，比如使用被禁止的函数。商业SAST工具包括依赖图以及调用图，以检查依赖软件漏洞和应用程序数据流。此外，许多商业SAST工具还包括IDE插件，用于实时检查软件安全漏洞。对于C/C++，XCode的Clang静态分析器有免费的IDE插件；但是，在OS
    X环境中编译此类代码需要自定义配置。Clang不会分析无法编译的文件。在配置移动应用程序的持续集成测试部分，我们将讨论如何使用IDE插件来静态分析代码。
- en: See also
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on the Clang Static Analyzer, visit the following links:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Clang静态分析器的更多信息，请访问以下链接：
- en: '[https://clang-analyzer.llvm.org/](https://clang-analyzer.llvm.org/)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://clang-analyzer.llvm.org/](https://clang-analyzer.llvm.org/)'
- en: '[https://help.apple.com/xcode/mac/9.0/#/devb7babe820](https://help.apple.com/xcode/mac/9.0/#/devb7babe820)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://help.apple.com/xcode/mac/9.0/#/devb7babe820](https://help.apple.com/xcode/mac/9.0/#/devb7babe820)'
- en: 'For a list of more source code analysis tools for various programming languages,
    refer to the following URL:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有关各种编程语言的更多源代码分析工具列表，请参阅以下网址：
- en: '[https://www.owasp.org/index.php/Source_Code_Analysis_Tools](https://www.owasp.org/index.php/Source_Code_Analysis_Tools)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/Source_Code_Analysis_Tools](https://www.owasp.org/index.php/Source_Code_Analysis_Tools)'
- en: Configuring continuous integration testing for web applications
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Web应用程序配置持续集成测试
- en: Whether an IoT device uses a web application or web service for messaging, its
    code should be statically and dynamically analyzed for software security bugs.
    In this recipe, we will demonstrate how to configure dynamic scanning of web application
    builds prior to production deployments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 无论物联网设备使用Web应用程序还是Web服务进行消息传递，其代码都应该进行静态和动态分析，以查找软件安全漏洞。在这个示例中，我们将演示如何在生产部署之前配置Web应用程序构建的动态扫描。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use Jenkins as our automation build server and OWASP
    ZAP as our dynamic scanner. We will use the OWASP ZAP Jenkins plugin and the OWASP
    ZAP tool that can be downloaded via the following link:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Jenkins作为我们的自动化构建服务器，OWASP ZAP作为我们的动态扫描器。我们将使用OWASP ZAP Jenkins插件和可以通过以下链接下载的OWASP
    ZAP工具：
- en: '[https://github.com/zaproxy/zaproxy/wiki/Downloads](https://github.com/zaproxy/zaproxy/wiki/Downloads).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/zaproxy/zaproxy/wiki/Downloads](https://github.com/zaproxy/zaproxy/wiki/Downloads)。'
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To setup continuous integration testing for web applications, use the following
    steps to create your environment.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Web应用程序设置持续集成测试，请使用以下步骤创建您的环境。
- en: 'First, we need to download the OWASP ZAP plugin, which can be done via Jenkin''s
    plugin manager, as shown in the following screenshot:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载OWASP ZAP插件，可以通过Jenkin的插件管理器完成，如下截图所示：
- en: '![](img/20926133-8feb-44e6-906c-9799e3cc9938.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20926133-8feb-44e6-906c-9799e3cc9938.png)'
- en: OWASP ZAP plugin download
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP插件下载
- en: 'Jenkins will then restart. Log back into Jenkins and we will work towards configuring
    ZAP. There are two ways to use ZAP in Jenkins. One is to run ZAP with a loaded
    session and another is to set up Selenium to execute ZAP and persist a session
    afterwards. We will set up ZAP to run with a loaded session for our target build.
    To do so, we first need to configure ZAP settings and environmental variables
    via `http://127.0.0.1:8080/`configure in this case. Set the ZAP host and port
    number as seen in the following image:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后Jenkins将重新启动。重新登录Jenkins，我们将致力于配置ZAP。在Jenkins中使用ZAP有两种方法。一种是使用加载的会话运行ZAP，另一种是设置Selenium来执行ZAP并在之后保持会话。我们将设置ZAP以加载会话来运行我们的目标构建。为此，我们首先需要通过`http://127.0.0.1:8080/`configure配置ZAP设置和环境变量。在这种情况下，设置ZAP主机和端口号如下图所示：
- en: '![](img/26bd354b-cba8-4360-9e77-d850f2e52bc8.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26bd354b-cba8-4360-9e77-d850f2e52bc8.png)'
- en: Multiple ZAP hosts can be configured to allow multiple concurrent build scans.
    This can be configured in the build step of the individual projects, which overrides
    the system settings.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置多个ZAP主机以允许多个并发构建扫描。这可以在各个项目的构建步骤中配置，这将覆盖系统设置。
- en: 'Insert the default directory of ZAP according to the operating system ([https://github.com/zaproxy/zaproxy/wiki/FAQconfig](https://github.com/zaproxy/zaproxy/wiki/FAQconfig))
    in use. The following is the default directory ZAP uses for OS X:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据正在使用的操作系统（[https://github.com/zaproxy/zaproxy/wiki/FAQconfig](https://github.com/zaproxy/zaproxy/wiki/FAQconfig)），插入ZAP的默认目录。以下是ZAP在OS
    X上使用的默认目录：
- en: If you use the weekly version of ZAP, use `/Users/<user>/Library/Application\
    Support/ZAP_D/`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用ZAP的每周版本，请使用`/Users/<user>/Library/Application\ Support/ZAP_D/`。
- en: '![](img/411a6ca4-44f6-41e9-b74b-2c49d9b01221.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/411a6ca4-44f6-41e9-b74b-2c49d9b01221.png)'
- en: 'Now, create a Freestyle project, as we did in the previous recipe, and name
    it appropriately:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个自由风格项目，就像我们在之前的配方中所做的那样，并适当命名它：
- en: '![](img/dc296661-1e1e-44aa-bc65-4766b586f6b4.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc296661-1e1e-44aa-bc65-4766b586f6b4.png)'
- en: Save the project and select Build Now so that Jenkins creates our project workspace
    like the previous recipe.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目并选择立即构建，以便Jenkins创建我们的项目工作空间，就像之前的配方一样。
- en: 'Since we are going to execute ZAP with a loaded session, we must create a session
    and save it in the project workspace directory. To do that, navigate to the target
    application build that is running and proxy the application traffic through the
    browser to ZAP. Ensure to click on all links, and spider pages and perform application
    functions. In the following example, we are using The BodgeIT Store that is running
    locally on port `8888` and saving the session to the project workspace by navigating
    to File | Persist Session...:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用加载的会话执行ZAP，我们必须创建一个会话并将其保存在项目工作空间目录中。为此，请导航到正在运行的目标应用程序构建，并通过浏览器将应用程序流量代理到ZAP。确保点击所有链接，并爬行页面并执行应用程序功能。在以下示例中，我们正在使用在本地端口`8888`上运行的The
    BodgeIT Store，并通过导航到文件|持久会话...将会话保存到项目工作空间中：
- en: '![](img/f3e60316-e57c-4099-ad7b-88586770bc04.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3e60316-e57c-4099-ad7b-88586770bc04.png)'
- en: 'Save the session within the Jenkins workspace directory of our project. In
    this case, the PacktZAPscan in the workspace project directory as seen in the
    following screenshot:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的Jenkins工作空间目录中保存会话。在这种情况下，如下截图所示，在工作空间项目目录中的PacktZAPscan：
- en: '![](img/05038cb4-2588-458d-9ca6-254edd0c96b3.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05038cb4-2588-458d-9ca6-254edd0c96b3.png)'
- en: PacktZAPscan in the workspace project directory
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: PacktZAPscan在工作空间项目目录中
- en: 'While in ZAP, let''s configure ZAP''s API key. Navigate to the Tools menu and
    open the Options page. In Options, select the API section and insert the default
    `ZAPROXY-PLUGIN` key provided by the Jenkins plugin, as shown in the following
    screenshot:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ZAP中，让我们配置ZAP的API密钥。转到工具菜单并打开选项页面。在选项中，选择API部分，并插入由Jenkins插件提供的默认`ZAPROXY-PLUGIN`密钥，如下截图所示：
- en: '![](img/a8469828-810b-40d4-be41-b7dd2d4b872f.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8469828-810b-40d4-be41-b7dd2d4b872f.png)'
- en: Note, this API key can be disabled altogether, or changed via the ZAP plugin
    command line arguments section when creating a build step. If the API keys do
    not match the Jenkins plugin API key value, the scan will fail.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此API密钥可以完全禁用，或者在创建构建步骤时通过ZAP插件命令行参数部分进行更改。如果API密钥与Jenkins插件API密钥值不匹配，则扫描将失败。
- en: 'With our session saved in our workspace, navigate back to our project and select
    Configure. Insert the proper source code management settings, build environment,
    and any build scripts according to the application architecture. In the Build
    section, select Add build step | Execute ZAP:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了我们在工作空间中保存的会话，返回到我们的项目并选择配置。根据应用程序架构，插入适当的源代码管理设置，构建环境和任何构建脚本。在构建部分，选择添加构建步骤|执行ZAP：
- en: '![](img/df0020c4-d637-4f52-8684-2215312fb8ab.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df0020c4-d637-4f52-8684-2215312fb8ab.png)'
- en: 'Enter in the ZAP host settings and home directory path with the appropriate
    session that was saved. If the session is not saved in the project workspace folder,
    the session will not appear in the Load Session drop-down menu:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入ZAP主机设置和主目录路径，以及保存的适当会话。如果会话未保存在项目工作空间文件夹中，则会话将不会出现在加载会话下拉菜单中：
- en: '![](img/0d23107f-f887-40e2-af83-572889c22b69.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d23107f-f887-40e2-af83-572889c22b69.png)'
- en: 'Enter in session properties such as contexts and any authentication credentials.
    Context refers to the in-scope and out-of-scope targets for automated scanning.
    The context must be unique and not within the loaded session. We can use the build
    ID environment variable to iterate context numbers so they''re unique, as shown
    in the following screenshot:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入会话属性，如上下文和任何身份验证凭据。上下文指的是自动扫描的范围内和范围外的目标。上下文必须是唯一的，并且不能在加载的会话中。我们可以使用构建ID环境变量来迭代上下文编号，使它们是唯一的，如下面的屏幕截图所示：
- en: '![](img/a71cada9-19c3-483c-a4d5-e3f7a6b49324.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a71cada9-19c3-483c-a4d5-e3f7a6b49324.png)'
- en: 'The next session is the Attack Mode section. Here, we specify the target URL,
    scan settings, and any customized scan policies that might be configured and saved
    into the project workspace. In the upcoming example, the test URL is input with
    spidering selected and a customized XSS scan policy that has been configured.
    The default policy is used when no customized scan policy is specified. After
    configuring the attack settings, name the generated report, select the Format and
    any Export Report settings, then click on Save:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的部分是攻击模式部分。在这里，我们指定目标URL、扫描设置和可能配置并保存到项目工作区的任何自定义扫描策略。在即将到来的示例中，测试URL是输入的，选择了蜘蛛，并配置了一个自定义的XSS扫描策略。当没有指定自定义扫描策略时，将使用默认策略。配置攻击设置后，命名生成的报告，选择格式和任何导出报告设置，然后点击保存：
- en: '![](img/8f88244a-3aeb-4db1-9b03-a434895f42ef.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f88244a-3aeb-4db1-9b03-a434895f42ef.png)'
- en: Ensure that the permissions are properly set so that Jenkins and ZAP can scan
    your workspace directory.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 确保权限设置正确，以便Jenkins和ZAP可以扫描您的工作区目录。
- en: 'You will then be directed to the project page. Select Build Now and click on
    the build''s Console Output. This will show the build status and progress of the
    ZAP scan:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后您将被引导到项目页面。选择立即构建，然后点击构建的控制台输出。这将显示ZAP扫描的构建状态和进度：
- en: '![](img/e07979b7-96c9-45f9-8461-2974cce0b96d.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e07979b7-96c9-45f9-8461-2974cce0b96d.png)'
- en: 'The console output should look similar to the following image:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应该类似于以下图像：
- en: '![](img/35e46e51-cf77-4fb3-8512-d6b93f70179d.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e46e51-cf77-4fb3-8512-d6b93f70179d.png)'
- en: Console output
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出
- en: 'Once the build and scan are finished, a report is generated in the workspace
    project directory under the `reports` folder, as shown in the following screenshots:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和扫描完成后，在工作区项目目录下的`reports`文件夹中生成报告，如下面的屏幕截图所示：
- en: '![](img/4cd67bf2-8be2-4b83-90c7-3d15849b2eec.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cd67bf2-8be2-4b83-90c7-3d15849b2eec.png)'
- en: 'The XML and HTML versions of the report are available for review:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告的XML和HTML版本可供查看：
- en: '![](img/fdbccdc0-28ec-4715-bea3-e10f1ae9d71d.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdbccdc0-28ec-4715-bea3-e10f1ae9d71d.png)'
- en: ZAP scans and reported alerts can be heavily customized to only report on medium
    and/or high severity findings. Scans should be tailored to each application by
    creating contextual details and scan policies according to the application architecture.
    For example, if an application is running on an Apache web server, Apache Tomcat
    application server, and a MySQL database, the scan policies should be customized
    to run checks against the respective architecture environment. Running default
    scan policies are not recommended as unrelated attacks will be used, causing scan
    times to drag on for long periods of time and may even exhaust ZAP's internal
    database resources. Scanners are only as good as the configuration, rulesets,
    and policies they are given.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'ZAP扫描和报告的警报可以被大量定制，只报告中等和/或高严重性的发现。扫描应该根据应用程序的架构创建上下文细节和扫描策略。例如，如果一个应用程序在Apache
    web服务器、Apache Tomcat应用服务器和MySQL数据库上运行，扫描策略应该被定制为针对相应的架构环境运行检查。不建议运行默认扫描策略，因为将使用不相关的攻击，导致扫描时间过长，甚至可能耗尽ZAP的内部数据库资源。扫描器的好坏取决于给定的配置、规则集和策略。 '
- en: Automated scans are great for catching low hanging fruit and scalability but
    they should never replace manual web application security assessments. Automated
    scanners cannot perform contextual business logic tests or the intelligence to
    catch unreported findings that manual assessments can. A combination of automated
    and manual testing should be used.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化扫描非常适合捕捉低挂果和可扩展性，但它们不应该取代手动的Web应用程序安全评估。自动扫描程序无法执行上下文业务逻辑测试，也无法智能地捕捉手动评估可以发现的未报告的发现。应该使用自动化和手动测试的组合。
- en: See also
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'To learn more about the Jenkins OWASP ZAP plugin, refer to the following links:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Jenkins OWASP ZAP插件的更多信息，请参考以下链接：
- en: '[https://wiki.jenkins.io/display/JENKINS/zap+plugin](https://wiki.jenkins.io/display/JENKINS/zap+plugin)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.jenkins.io/display/JENKINS/zap+plugin](https://wiki.jenkins.io/display/JENKINS/zap+plugin)'
- en: '[https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP](https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP](https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP)'
- en: Configuring continuous integration testing for mobile applications
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动应用程序配置持续集成测试
- en: Following the same trend of automated analysis in the earlier recipes, this
    recipe will show how to configure dependency scans and dynamic analysis of Android
    application builds prior to production deployments.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，自动化分析的趋势相同，这个示例将展示如何在生产部署之前配置Android应用程序构建的依赖扫描和动态分析。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use a Jenkins automation build server and the following
    tools:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Jenkins自动化构建服务器和以下工具：
- en: '**Mobile Security Framework** (**MobSF**): This is an open source mobile application
    static and dynamic analysis tool. MobSF is actively being worked on and modified
    for the mobile security community. MobSF can be downloaded from the following
    link:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动安全框架**（**MobSF**）：这是一个开源的移动应用程序静态和动态分析工具。MobSF正在积极地为移动安全社区进行修改和开发。MobSF可以从以下链接下载：'
- en: '[https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip](https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip](https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip)'
- en: '**OWASP Dependency-Check**: This is a tool that detects publicly disclosed
    vulnerabilities within a project''s dependencies for multiple programming languages
    such as Java, NodeJS, Python, Ruby, and Swift to name a few. We will use the Jenkins OWASP
    Dependency-Check Plugin that can be downloaded via the Jenkins plugin manger,
    as shown in the following screenshot:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OWASP Dependency-Check**：这是一个工具，用于检测项目依赖项中公开披露的漏洞，适用于多种编程语言，如Java、NodeJS、Python、Ruby和Swift等。我们将使用Jenkins
    OWASP Dependency-Check插件，该插件可以通过Jenkins插件管理器下载，如下面的屏幕截图所示：'
- en: '![](img/e9f24b72-1ff4-4c9a-8608-674fd00e4af5.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9f24b72-1ff4-4c9a-8608-674fd00e4af5.png)'
- en: 'Dependency-Check can also be downloaded as a standalone tool using the methods
    described in the following link:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dependency-Check也可以作为一个独立的工具下载，使用以下链接中描述的方法：
- en: '[https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck)'
- en: How to do it...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To setup continuous integration testing for mobile applications, use the following
    steps to create your environment.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要为移动应用程序设置持续集成测试，请使用以下步骤创建您的环境。
- en: 'Let''s first start by creating a freestyle project with an appropriate name
    for the application build:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个自由风格的项目，为应用程序构建选择一个合适的名称：
- en: '![](img/4894f823-9ec9-419c-a587-04491fac48e6.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4894f823-9ec9-419c-a587-04491fac48e6.png)'
- en: Save and build the project so that our workspace is created as we did in the
    earlier recipes for the purpose of simplicity. Next, copy over your Android project
    files to the new workspace Jenkins created for us, as shown in the following screenshot.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并构建项目，以便我们的工作空间被创建，就像我们在早期的简单示例中所做的那样。接下来，将Android项目文件复制到Jenkins为我们创建的新工作空间中，如下面的屏幕截图所示。
- en: '![](img/ff1796ad-6e49-4759-a432-510295872968.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff1796ad-6e49-4759-a432-510295872968.png)'
- en: The path of our workspace in this instance is `/Users/Shared/Jenkins/Home/workspace/PacktTestAndroid`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们工作空间的路径是`/Users/Shared/Jenkins/Home/workspace/PacktTestAndroid`。
- en: 'Next, open the Configure option in your project and set up your build settings
    as shown in the following screenshot:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开项目的配置选项，并设置构建设置，如下面的屏幕截图所示：
- en: '![](img/7bd19abb-6f25-44d3-b0b5-570d96e31f01.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bd19abb-6f25-44d3-b0b5-570d96e31f01.png)'
- en: 'Input any necessary build scripts for your build environment:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的构建环境输入任何必要的构建脚本：
- en: '![](img/4307a089-e17e-4657-9610-3db10bd84a69.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4307a089-e17e-4657-9610-3db10bd84a69.png)'
- en: If this is an existing project, you might already know where the output APK
    will be placed after a build is complete. For new projects, ensure your build
    compiles to an APK. Knowing where the APK is stored when running builds is the
    key for the next sections of scanning the built APK.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个现有的项目，您可能已经知道构建完成后输出APK将被放置的位置。对于新项目，请确保您的构建编译为APK。知道在运行构建时APK存储的位置是扫描构建APK的下一步的关键。
- en: 'In a separate window, open a Terminal and navigate to the location where the
    MobSF is installed. Once in MobSF''s folder, run the following command:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的窗口中，打开一个终端并导航到MobSF安装的位置。一旦在MobSF的文件夹中，运行以下命令：
- en: '[PRE6]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Your Terminal should look like the following screenshot:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的终端应该看起来像下面的屏幕截图：
- en: '![](img/1ca88dee-ff56-49a9-b0c6-65371dc2b077.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ca88dee-ff56-49a9-b0c6-65371dc2b077.png)'
- en: Take note of MobSF's API key as we will need this to execute the REST API calls
    from our Jenkins build server.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意MobSF的API密钥，因为我们需要它来从Jenkins构建服务器执行REST API调用。
- en: The API key changes when all scans and MobSF database information is deleted
    via the `clean.sh` script MobSF supplies.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`clean.sh`脚本删除所有扫描和MobSF数据库信息时，API密钥会更改。
- en: 'Navigate back to the Jenkins configuration page of our Android project. Add
    a build step to execute a shell command:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回到我们Android项目的Jenkins配置页面。添加一个构建步骤来执行一个shell命令：
- en: '![](img/bda9bc10-a42c-407a-a841-adf581cc6a05.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bda9bc10-a42c-407a-a841-adf581cc6a05.png)'
- en: 'In the command area, we will execute REST API calls to upload our APK that
    is built over to MobSF. To do so, you will need to have your REST API key and
    the location where the APK is stored after a build. Use the following command
    and insert your API key as well as file path to your API like the `curl` command
    shown next:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令区域，我们将执行REST API调用来上传我们构建的APK到MobSF。为此，您需要拥有您的REST API密钥以及构建后APK存储的位置。使用以下命令并插入您的API密钥以及API文件路径，就像下面显示的`curl`命令一样：
- en: '[PRE7]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `curl` command uploads our freshly built APK in our workspace, which will
    then be scanned. MobSF creates a hash of the uploaded binary and this is something
    that will be needed to reference your specific binary for other API calls. The
    `awk` command just parses the JSON response data and inserts the hash value into
    a file that will be called in later MobSF API requests.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`curl`命令上传了我们的最新构建APK到我们的工作空间，然后将被扫描。MobSF创建了上传二进制文件的哈希值，这是其他API调用中需要引用您特定二进制文件的内容。`awk`命令只是解析JSON响应数据，并将哈希值插入一个文件中，以便在以后的MobSF
    API请求中调用。
- en: 'With our APK uploaded, add another build step to execute a shell command and
    insert the following command with your APK name and API key values to scan the
    build:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传了我们的APK后，添加另一个构建步骤来执行一个shell命令，并插入以下命令，包括您的APK名称和API密钥值以扫描构建：
- en: '[PRE8]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It takes a couple of minutes for MobSF to scan the APK, so let''s create another
    execute shell build set and insert the following `sleep` command:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MobSF扫描APK需要几分钟的时间，因此让我们创建另一个执行shell构建集，并插入以下`sleep`命令：
- en: '[PRE9]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `sleep` command can be changed according to how long MobSF takes to analyze
    your specific application. In this case, it's about two minutes. Bear in mind
    that if you do not wait long enough for MobSF to scan the APK and you try to download
    the report, it will be empty.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep`命令可以根据MobSF分析您特定应用程序所需的时间进行更改。在这种情况下，大约需要两分钟。请记住，如果您等待的时间不够长，MobSF无法扫描APK并尝试下载报告，那么报告将是空的。'
- en: 'Next, create another build step to generate and download the PDF that was just
    mentioned. Insert the following command with your respective API key:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建另一个构建步骤来生成并下载刚才提到的PDF。插入以下命令及您相应的API密钥：
- en: '[PRE10]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can choose to name the MobSF report however you like. To make the report
    unique, the build ID environment variable is used. Jenkins should now be able
    to upload, scan, generate, and download a MobSF report from our built APK.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择任何您喜欢的名称来命名MobSF报告。为了使报告唯一，使用了构建ID环境变量。Jenkins现在应该能够从我们构建的APK上传、扫描、生成和下载MobSF报告。
- en: 'Let''s also add a build step to invoke Dependency-Check, which scans our project''s
    dependencies for known vulnerabilities:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加一个构建步骤来调用Dependency-Check，扫描我们项目的依赖项以查找已知的漏洞：
- en: '![](img/90dc9351-907f-4714-aba9-da617647ad13.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90dc9351-907f-4714-aba9-da617647ad13.png)'
- en: 'The build step Path to scan for Dependency-Check should be empty as the project
    files in the workspace directory will be scanned and used to output results in
    the workspace as well:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dependency-Check的扫描路径构建步骤应为空，因为工作空间目录中的项目文件将被扫描并用于在工作空间中输出结果：
- en: '![](img/597283b6-d819-4d11-95ee-8bdeea28b55f.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/597283b6-d819-4d11-95ee-8bdeea28b55f.png)'
- en: Ensure permissions are properly set so that Jenkins and Dependency-Check can
    scan your workspace directory.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 确保权限正确设置，以便Jenkins和Dependency-Check可以扫描您的工作空间目录。
- en: 'Your project configuration build steps should look similar to the following
    screenshot:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的项目配置构建步骤应该类似于以下屏幕截图：
- en: '![](img/667cc64a-b858-4e55-9d59-b67ac1130115.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/667cc64a-b858-4e55-9d59-b67ac1130115.png)'
- en: Project configuration build steps
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 项目配置构建步骤
- en: 'Save the project configurations and build the Android application. View the
    Android application project''s console output to see the build progress. The first
    build step is to build the actual application APK, then perform MobSF scanning
    functions, and lastly scan the project''s dependencies with a Dependency-Check:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目配置并构建Android应用程序。查看Android应用程序项目的控制台输出以查看构建进度。第一个构建步骤是构建实际的应用程序APK，然后执行MobSF扫描功能，最后使用Dependency-Check扫描项目的依赖项：
- en: '![](img/69441c78-d460-4b65-94d4-81e8a9644df2.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69441c78-d460-4b65-94d4-81e8a9644df2.png)'
- en: Console output
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出
- en: 'The following screenshot shows the second and third build steps to upload as
    well as scan the APK:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了上传和扫描APK的第二和第三个构建步骤：
- en: '![](img/2724cfa3-0df8-4ea9-a304-7e3d02872dc7.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2724cfa3-0df8-4ea9-a304-7e3d02872dc7.png)'
- en: Build steps to upload and scan APK
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 上传和扫描APK的构建步骤
- en: 'The fourth, fifth, and sixth build steps follow next with executing a `sleep`
    command, generating a PDF of the MobSF scan results, and scanning the project''s
    dependencies:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是第四、第五和第六个构建步骤，分别执行`sleep`命令，生成MobSF扫描结果的PDF，并扫描项目的依赖项：
- en: '![](img/3860df4a-7dbf-4804-9110-ca17a73e84fa.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3860df4a-7dbf-4804-9110-ca17a73e84fa.png)'
- en: 'If you check your project workspace, there should now be a MobSF report as
    well as a Dependency-Check report:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您检查项目工作空间，现在应该有一个MobSF报告以及一个Dependency-Check报告：
- en: '![](img/9c3080d7-2d34-4238-919f-19d8c820eaa2.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c3080d7-2d34-4238-919f-19d8c820eaa2.png)'
- en: 'Clicking on the MobSF and Dependency-Check reports should open the output of
    the scans in their respective format (PDF for MobSF and HTML, JSON, XML for Dependency-Check),
    as shown in the following screenshots:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击MobSF和Dependency-Check报告应该打开其各自格式的扫描输出（MobSF的PDF格式，Dependency-Check的HTML、JSON、XML格式），如下图所示：
- en: '![](img/ad6e5830-b5b4-4658-a3ce-c356776f542f.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad6e5830-b5b4-4658-a3ce-c356776f542f.png)'
- en: Output of the scans
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描结果的输出
- en: 'The following image is the Dependency-Check HTML report:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图片是Dependency-Check的HTML报告：
- en: '![](img/d781cf55-ea8b-48df-80e0-b5ed5dc312d5.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d781cf55-ea8b-48df-80e0-b5ed5dc312d5.png)'
- en: These scan reports can be configured to be sent to a centralized reporting server
    as well as perform actions such as send an email alert or Jira ticket if certain
    severity findings are discovered for a build. Jenkins is highly customizable with
    more advanced features than those covered in this chapter. A great OWASP project
    that aids application security teams with increasing speed and automation of security
    testing is the OWASP AppSec Pipeline project ([https://www.owasp.org/index.php/OWASP_AppSec_Pipeline](https://www.owasp.org/index.php/OWASP_AppSec_Pipeline)).
    Various tools and design patterns for an AppSec pipeline are discussed to enable
    small security teams to be as scalable and efficient as possible given the speed
    of code being pushed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扫描报告可以配置为发送到集中的报告服务器，以及执行诸如发送电子邮件警报或Jira工单等操作，如果发现了某些严重性发现。Jenkins具有比本章介绍的更高级功能更高度的可定制性。一个伟大的OWASP项目，可以帮助应用程序安全团队提高安全测试的速度和自动化程度，是OWASP
    AppSec Pipeline项目([https://www.owasp.org/index.php/OWASP_AppSec_Pipeline](https://www.owasp.org/index.php/OWASP_AppSec_Pipeline))。讨论了AppSec管道的各种工具和设计模式，以使小型安全团队在代码推送速度的情况下尽可能具有可扩展性和高效性。
- en: See also
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The Dependency-Check Jenkins plugin also comes with a location to archive multiple
    application dependencies and the use of vulnerable components across applications
    called OWASP Dependency-Track. This can be configured via `http://JenkinsURL:8080/configure`
    in the OWASP Dependency-Track section. For more details on OWASP Dependency-Track,
    see the following link:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins插件Dependency-Check还配备了一个位置，用于存档多个应用程序依赖项以及跨应用程序使用的易受攻击组件，名为OWASP Dependency-Track。这可以通过`http://JenkinsURL:8080/configure`在OWASP
    Dependency-Track部分进行配置。有关OWASP Dependency-Track的更多详细信息，请参见以下链接：
- en: '[https://www.owasp.org/index.php/OWASP_Dependency_Track_Project](https://www.owasp.org/index.php/OWASP_Dependency_Track_Project).'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/OWASP_Dependency_Track_Project](https://www.owasp.org/index.php/OWASP_Dependency_Track_Project)。'
- en: For details about MobSF's REST API, visit their documentation page at [https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation).
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MobSF的REST API的详细信息，请访问其文档页面[https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation)。
