# 第八章：固件安全最佳实践

在本章中，我们将涵盖以下内容：

+   防止内存损坏漏洞

+   防止注入攻击

+   保护固件更新

+   保护敏感信息

+   加固嵌入式框架

+   保护第三方代码和组件

# 介绍

嵌入式软件是被认为是物联网的核心，尽管嵌入式应用安全通常不被视为嵌入式开发人员和物联网设备制造商的高优先级。这可能是由于缺乏安全编码知识或团队代码库之外的其他挑战。开发人员面临的其他挑战可能包括但不限于**原始设计制造商**（ODM）供应链、有限的内存、小堆栈以及安全地向端点推送固件更新的挑战。本章提供了开发人员可以在嵌入式固件应用中采用的实用最佳实践指南。根据 OWASP 的嵌入式应用安全项目（[`www.owasp.org/index.php/OWASP_Embedded_Application_Security`](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)），嵌入式最佳实践包括：

+   缓冲区和堆栈溢出保护

+   防止注入攻击

+   保护固件更新

+   保护敏感信息

+   身份管理控制

+   加固嵌入式框架和基于 C 的工具链

+   使用调试代码和接口

+   保护设备通信

+   数据收集和存储的使用

+   保护第三方代码

+   威胁建模

本章将讨论前述的几种最佳实践，主要针对 POSIX 环境，但原则上设计为平台无关。

# 防止内存损坏漏洞

在使用 C 等低级语言时，如果开发人员没有正确检查和验证边界，就有很高的可能性出现内存损坏错误。防止使用已知的危险函数和 API 有助于防止固件内的内存损坏漏洞。例如，已知的不安全 C 函数的非穷尽列表包括：`strcat`、`strcpy`、`sprintf`、`scanf`和`gets`。常见的内存损坏漏洞，如缓冲区溢出或堆溢出，可能包括堆栈或堆的溢出。利用这些特定的内存损坏漏洞的影响因操作系统平台而异。例如，商业 RTOS 平台如 QNX Neutrino 将每个进程及其堆栈与文件系统隔离，最小化攻击面。然而，对于常见的嵌入式 Linux 发行版可能并非如此。在嵌入式 Linux 中，缓冲区溢出可能导致恶意代码的任意执行和对操作系统的修改。在本教程中，我们将展示工具如何帮助检测易受攻击的 C 函数，并提供防止内存损坏漏洞的安全控制和最佳实践。

# 准备工作

对于这个教程，将使用以下工具：

+   **Flawfinder**：Flawfinder 是一个免费的 C/C++静态代码分析工具，报告潜在的安全漏洞。

# 操作方法...

常见的 Linux 实用工具对于搜索 C/C++代码文件非常有帮助。尽管商业上可用的源代码分析工具可以比常见实用工具更好地防止内存损坏漏洞，并且开发人员可以使用 IDE 插件。为了演示目的，我们将展示如何使用 grep 和 flawfinder 搜索代码文件中的预定义函数易受攻击的调用和规则。

1.  要发现不安全的 C 函数，有几种方法可以使用。最简单的形式是使用类似于以下示例的`grep`表达式：

```
$ grep -E '(strcpy|strcat|sprintf|strlen|memcpy|fopen|gets)' code.c

```

这个表达可以调整得更智能一些，或者包装成一个脚本，可以在每次构建时执行，或者按需执行。

1.  或者，可以使用`flawfinder`等免费工具来搜索易受攻击的函数，方法是调用`flawfinder`和代码片段的路径，如以下示例所示：

```
$ flawfinder fuzzgoat.c
Flawfinder version 1.31, (C) 2001-2014 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 169
Examining fuzzgoat.c

FINAL RESULTS:

fuzzgoat.c:1049: [4] (buffer) strcpy:
Does not check for buffer overflows when copying to destination (CWE-120).
Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
    fuzzgoat.c:368: [2] (buffer) memcpy:
    Does not check for buffer overflows when copying to destination        (CWE-120).
    Make sure destination can always hold the source data.
fuzzgoat.c:401: [2] (buffer) sprintf:
    Does not check for buffer overflows (CWE-120). Use sprintf_s, 
    snprintf, or vsnprintf. Risk is low because the source has a    
    constant maximum length.
    <SNIP>
fuzzgoat.c:1036: [2] (buffer) strcpy:
    Does not check for buffer overflows when copying to destination (CWE-120).
    Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is 
    easily
    misused). Risk is low because the source is a constant string.
fuzzgoat.c:1041: [2] (buffer) sprintf:
    Does not check for buffer overflows (CWE-120). Use sprintf_s, 
    snprintf, or vsnprintf. Risk is low because the source has a      
    constant maximum length.
fuzzgoat.c:1051: [2] (buffer) strcpy:
    Does not check for buffer overflows when copying to destination (CWE-120).
    Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is    
    easily misused). Risk is low because the source is a constant     
    string.
ANALYSIS SUMMARY:

Hits = 24
Lines analyzed = 1082 in approximately 0.02 seconds (59316 lines/second)
Physical Source Lines of Code (SLOC) = 765
Hits@level = [0] 0 [1] 0 [2] 23 [3] 0 [4] 1 [5] 0
Hits@level+ = [0+] 24 [1+] 24 [2+] 24 [3+] 1 [4+] 1 [5+] 0
Hits/KSLOC@level+ = [0+] 31.3725 [1+] 31.3725 [2+] 31.3725 [3+] 
1.30719 [4+] 1.30719 [5+] 0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming for Linux and Unix HOWTO'
(http://www.dwheeler.com/secure-programs) for more information.

```

1.  在发现正在使用的易受攻击的 C 函数时，必须合并安全替代方案。例如，以下易受攻击的代码使用不安全的`gets()`函数，不检查缓冲区长度：

```
#include <stdio.h> 
int main () { 
    char userid[8]; 
    int allow = 0; 
    printf external link("Enter your userID, please: "); 
    gets(userid);  
    if (grantAccess(userid)) { 
        allow = 1; 
    } 
    if (allow != 0) {  
        privilegedAction(); 
    } 
    return 0; 
} 
```

1.  `userid`可以使用超过`8`个字符的任意数量进行溢出，例如具有自定义执行函数的缓冲区溢出利用（BoF）有效负载。为了减轻缓冲区溢出的影响，可以使用`fgets()`函数作为安全的替代方法。以下示例代码显示了如何安全地使用`fgets()`并正确分配内存：

```
#include <stdio.h> 
#include <stdlib.h> 
#define LENGTH 8 
int main () { 
    char* userid, *nlptr; 
    int allow = 0; 

    userid = malloc(LENGTH * sizeof(*userid)); 
    if (!userid) 
        return EXIT_FAILURE; 
    printf external link("Enter your userid, please: "); 
    fgets(userid,LENGTH, stdin); 
    nlptr = strchr(userid, '\n'); 
    if (nlptr) *nlptr = '\0'; 

    if (grantAccess(userid)) { 
        allow = 1; 
    } 
    if (allow != 0) { 
        priviledgedAction(); 
    } 

    free(userid); 

    return 0; 
} 
```

可以使用相同的缓解措施来使用其他安全替代函数，如`snprintf()`，`strlcpy()`和`strlcat()`。根据操作系统平台的不同，某些安全替代方案可能不可用。重要的是要进行自己的研究，以确定特定架构和平台的安全替代方案。英特尔创建了一个名为`safestringlib`的开源跨平台库，以防止使用这些不安全的禁止函数；使用替代的安全替换函数。有关`safestringlib`的更多详细信息，请访问 GitHub 页面：[`github.com/01org/safestringlib`](https://github.com/01org/safestringlib)。

还可以使用其他内存安全控件来防止内存腐败漏洞，例如以下控件：

+   使用安全编译器标志，如-fPIE，-fstack-protector-all，-Wl，-z，noexecstack，-Wl，-z，noexecheap 等，这些可能取决于您特定的编译器版本。

+   首选包含内存管理单元（MMU）的系统芯片（SoC）和微控制器（MCU）。MMU 将线程和进程隔离，以减少攻击面，如果内存错误被利用。

+   首选包含内存保护单元（MPU）的系统芯片（SoC）和微控制器（MCU）。MPU 强制执行内存的访问规则，并分离进程，同时执行特权规则。

+   如果没有 MMU 或 MPU 可用，可以使用已知位来监视堆栈，以确定堆栈的多少被消耗掉。

+   在放置缓冲区和释放缓冲区位置后，要注意放置什么。

利用地址空间布局随机化（ASLR）和其他堆栈控件的内存漏洞需要攻击者付出大量努力才能利用。尽管在某些情况下仍然可能发生。确保代码具有弹性，并采用深度防御方法，以便将数据放置在内存中有助于嵌入式设备的安全姿态。

# 另请参阅

+   有关更安全的内存管理指南，请参考卡内基梅隆大学的安全 CERT C 编码标准（[`www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard`](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard)）。

+   有关更安全的内存管理指南，请参考卡内基梅隆大学的安全 CERT C++编码标准（[`www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637`](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637)）

# 预防注入攻击

注入攻击是任何 Web 应用程序中最严重的漏洞之一，尤其是在物联网系统中。事实上，自 2010 年以来，注入一直是 OWASP 十大漏洞中排名前两位。有许多类型的注入攻击，如**操作系统**（OS）命令注入、跨站脚本（例如 JavaScript 注入）、SQL 注入、日志注入，以及其他类型的表达式语言注入。在物联网和嵌入式系统中，最常见的注入攻击类型是操作系统命令注入；当应用程序接受不受信任的用户输入并将该值传递以执行 shell 命令而没有输入验证或适当的转义时，以及跨站脚本（XSS）。本文将向您展示如何通过确保所有不受信任的数据和用户输入都经过验证、经过清理，并使用替代安全函数来减轻命令注入攻击。

# 如何做...

当物联网设备运行时，注入攻击的静态和动态测试并不难。固件可以调用`system()`、`exec()`和类似的变体来执行操作系统命令，或者调用从解释语言（如 Lua）运行 OS 调用的外部脚本。命令注入漏洞也可能由缓冲区溢出引起。以下步骤和示例显示了易受命令注入攻击的代码，以及如何减轻命令注入攻击。之后，我们将列出常见的安全控制措施，以防止常见的注入攻击。

1.  以下代码片段调用危险的`system()` C 函数来删除`home`目录中的`.cfg`文件。如果攻击者能够控制该函数，则可以连接后续的 shell 命令来执行未经授权的操作。此外，攻击者可以操纵环境变量来删除任何以`.cfg`结尾的文件：

```
#include <stdlib.h> 

void func(void) { 
  system("rm ~/.cfg"); 
}
```

1.  为了减轻前面的易受攻击的代码，将使用`unlink()`函数而不是`system()`函数。`unlink()`函数不容易受到符号链接和命令注入攻击。`unlink()`函数删除符号链接，不会影响符号链接内容命名的文件或目录。这减少了`unlink()`函数易受符号链接攻击的可能性，但并不能完全阻止符号链接攻击；如果命名目录相同，也可能被删除。`unlink()`函数可以防止命令注入攻击，应该使用类似的上下文函数而不是执行操作系统调用：

```
#include <pwd.h> 
#include <unistd.h> 
#include <string.h> 
#include <stdlib.h> 
#include <stdio.h> 
void func(void) { 
  const char *file_format = "%s/.cfg"; 
  size_t len; 
  char *pathname; 
  struct passwd *pwd; 

  pwd = getpwuid(getuid()); 
  if (pwd == NULL) { 
    /* Handle error */ 
  } 

  len = strlen(pwd->pw_dir) + strlen(file_format) + 1; 
  pathname = (char *)malloc(len); 
  if (NULL == pathname) { 
    /* Handle error */ 
  } 
  int r = snprintf(pathname, len, file_format, pwd->pw_dir); 
  if (r < 0 || r >= len) { 
    /* Handle error */ 
  } 
  if (unlink(pathname) != 0) { 
    /* Handle error */ 
  } 

  free(pathname); 
} 
```

还有其他几种方法可以减轻注入攻击。以下是一些常见的防止注入攻击的最佳实践和控制措施的列表：

+   尽量避免直接调用操作系统调用。

+   如有需要，列出接受的命令并在执行之前验证输入值。

+   为用户驱动的字符串使用数字到命令字符串的查找映射，这些字符串可能会传递给操作系统，例如`{1:ping -c 5}`。

+   对代码库进行静态代码分析，并在使用 OS 命令（如`os.system()`）时发出警报。

+   将所有用户输入视为不受信任，并对返回给用户的数据进行输出编码（例如，`将&转换为&amp`，`将<转换为&lt`，`将>转换为&gt`等）。

+   对于 XSS，使用 HTTP 响应头，如 X-XSS-Protection 和 Content-Security-Policy，并配置适当的指令。

+   确保在生产固件版本中禁用带有命令执行的调试接口（例如，[`example.com/command.php`](http://example.com/command.php)）。

前面提到的控制措施在生产环境中使用固件之前都需要进行测试。在注入攻击中，设备和用户面临被攻击者接管的风险，以及流氓设备。我们在 2017 年看到了物联网 Reaper 和 Persirai 僵尸网络发生的事件。这只是开始。

# 另请参阅

+   有关进一步的注入预防指南和注意事项，请参考 OWASP 的嵌入式应用安全项目（[`www.owasp.org/index.php/OWASP_Embedded_Application_Security`](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)）和 OWASP XSS（跨站脚本）预防备忘单[`www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet`](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)。

# 保护固件更新

根据行业，只有来自制造商、供应商或企业的授权固件才能刷入设备。为确保这一点，必须在下载固件时使用强大的更新机制，并在适用时，用于更新与第三方软件或库相关的功能。所有固件都应使用加密签名，以便验证文件自开发者创建并签名以来未被修改或篡改。签名和验证过程使用公钥加密，很难在未获得私钥的情况下伪造数字签名（例如 PGP 签名）。使用公钥加密时，必须将其安全存储，并且不暴露给意外的第三方。如果私钥被泄露，软件开发人员必须撤销受损的密钥，并需要使用新密钥重新签署所有先前的固件版本。这已经成为许多物联网产品的问题，用户需要将设备送回或将牵引车辆送到服务商店。保护固件更新的实施因部署物联网设备的行业而异。例如，一些产品可能具有**空中**（**OTA**）更新，而其他产品可能需要通过 USB 手动更新或通过加载新的固件映像的界面进行更新。对于一些普通的消费级物联网设备来说，这可能不是一个大问题，但是如果未经授权的恶意固件加载到连接的车辆或医疗设备上，后果可能是致命的。本文将列出可用于保护固件更新的功能。

# 如何做到…

在为嵌入式物联网设备实施安全更新生态系统时，需要考虑许多变量和因素。某些架构、SoC 或引导加载程序可能无法执行所有必需的操作，以实现弹性固件更新系统。由于实施安全更新系统的复杂性和变化，我们将讨论制造商应该将哪些高级操作纳入其固件更新设计中。为简单起见，我们将以嵌入式 Linux 作为平台，并提供安全更新系统所需的要求。再次强调，并非所有以下要求都可能可行，但对于设备制造商来说，进行尽职调查并了解实施安全更新系统时的风险是很重要的。以下是用于保护固件更新的安全控制和要求。

1.  为引导加载程序实施安全启动或验证启动。

1.  使用安全硬件芯片（例如 TPM、HSM、安全元件）保护安全启动密钥。

1.  确保强大的更新机制利用加密签名的固件图像进行更新功能。

1.  下载和刷写图像后必须进行验证。

1.  确保更新是通过最新的安全 TLS 版本下载的（在撰写本文时，这是 TLS 1.2）：

+   确保更新验证更新服务器的公钥和证书链

1.  包括利用预定时间表的自动固件更新功能：

+   在高度脆弱的用例中强制更新

+   应考虑定期推送更新，以防止强制更新可能造成的问题，特别是对于某些设备，如医疗设备。

1.  确保固件版本清晰显示。

1.  确保固件更新包括包含安全相关漏洞的更改日志。

1.  在固件可用时通过电子邮件、应用程序通知或登录应用程序通知客户新的固件。

1.  确保采用反降级保护（反回滚）机制，以防设备被恢复到一个易受攻击的固件版本。

1.  考虑实施**完整性测量架构**（**IMA**），允许内核通过验证文件的哈希（称为标签）来检查文件是否未被更改。**扩展验证模块**（**EVM**）检查文件属性（包括扩展属性）。

有两种类型的标签可用：

+   不可变和签名

+   简单

1.  考虑实施一个只读的根文件系统，并为需要本地持久性的目录创建一个覆盖层。

一个安全的更新系统严重依赖于公钥密码学来签名和验证固件图像。这需要基础设施和管理来维护设备签名和验证密钥的生命周期。如果密钥被 compromise 或需要更新，应在生产部署之前进行测试，以防止设备变砖。话虽如此，有第三方公司提供**空中固件更新**（**FOTA**）服务，将责任转移到服务提供商。对于像连接车辆这样的产品来说，这可能会很昂贵，制造商需要支付网络数据费用。在选择更新机制时，应考虑一些框架，如 The Update Framework ([`theupdateframework.github.io/`](https://theupdateframework.github.io/))和 Uptane ([`uptane.github.io/`](https://uptane.github.io/))。

# 保护敏感信息

在有限的存储空间和薄利多销的情况下，保护敏感数据对于 IoT 设备来说可能是一个挑战。通常，敏感数据存储在客户端应用程序或设备上，以便 IoT 服务可以在没有互联网连接的情况下运行。在保护设备上的敏感数据时，应遵循一些安全原则。首先，永远不要将秘密硬编码到固件图像中，比如密码、用户名、令牌、私钥或类似的变体。这也包括写入磁盘的敏感数据。这些数据将在提取固件文件系统时对攻击者可见，也会在运行时访问操作系统时对攻击者可见。如果有硬件，如**安全元素**（**SE**）或**可信执行环境**（**TEE**）可用，建议在运行时使用这些功能来存储敏感数据。否则，应评估使用强大的密码学来保护数据，使用服务器端计算来弥补硬件限制。

如果可能，所有明文中的敏感数据应该是短暂的，并且只驻留在易失性内存中。这个配方将为您提供一些数据被不安全使用的场景，以及如何在 IoT 设备中减轻不安全的 C 代码。

# 如何做到...

使用编程示例，我们将展示数据如何被不安全地存储以及如何纠正存储漏洞。

1.  在以下示例中，敏感信息不安全地存储在由`key`引用的动态分配的内存中，然后被复制到动态分配的缓冲区`new_key`中，然后通过调用`free()`最终被处理和释放。由于内存没有被清除，它可能被重新分配到程序的另一个部分，其中存储在`new_key`中的信息可能会被意外泄露：

```
char *key; 

/* Initialize secret */ 

char *new_key; 
size_t size = strlen(key); 
if (size == SIZE_MAX) { 
  /* Handle error */ 
} 

new_key = (char *)malloc(size+1); 
if (!new_key) { 
  /* Handle error */ 
} 
strcpy(new_key, key); 

/* Process new_key... */ 

free(new_key); 
new_key = NULL; 
```

1.  为防止发生信息泄漏，包含敏感信息的动态内存在被释放之前应该进行消毒。消毒通常是通过用`'\0'`字符清除分配的空间来进行的，也被称为清零：

```
char *key; 

/* Initialize secret */ 

char *new_key; 
size_t size = strlen(key); 
if (size == SIZE_MAX) { 
  /* Handle error */ 
} 

/* Use calloc() to zero-out space */ 
new_key = (char *)calloc(size+1, sizeof(char)); 
if (!new_key) { 
  /* Handle error */ 
} 
strcpy(new_key, key); 

/* Process new_key... */ 

/* Sanitize memory  */ 
memset_s(new_key, '\0', size); 
free(new_secret); 
new_key = NULL; 
```

在设备没有硬件安全芯片用于分离操作系统进程和内存位置的情况下，可以使用上述示例。没有硬件安全芯片（例如 TPM 或 SE），或者 ARM 架构的 TEE 环境，对于嵌入式设备来说，安全存储数据是一个挑战。有时开发人员可能会将敏感数据存储在对平台操作系统不可用的不同存储分区中，但这也不是一个安全的存储位置。通常，闪存芯片可以从 PCB 板上取下，并带到离线位置进行审查或数据外泄。

正在创建新的框架和操作系统平台，以帮助解决存储敏感数据的问题。如果使用 ARM Mbed OS，则可以利用名为 uVisor 的设备安全层，通过硬件安全功能限制对内存的访问，从而隔离代码块。尽管 Mbed 还处于起步阶段，但它得到了大型半导体公司的大力支持，并包含了一个平台，不仅包括其操作系统，还包括云服务。

# 另请参阅

+   有关 uVisor 的详细信息可以在以下网站找到：

[`www.mbed.com/en/technologies/security/uvisor/`](https://www.mbed.com/en/technologies/security/uvisor/)

+   uVisor 的示例代码用法可以在 GitHub 存储库中找到，通过以下 URL：

[`github.com/ARMmbed/mbed-os-example-uvisor-number-store`](https://github.com/ARMmbed/mbed-os-example-uvisor-number-store)

+   有关 Mbed OS 的更多信息，请访问以下网址：

[`www.mbed.com`](https://www.mbed.com/)

# 加固嵌入式框架

设计和构建嵌入式固件可能会很复杂，因为它涉及所有的依赖关系和几十年未被触及的混乱 makefile。尽管存在这些常见的复杂性，但建立安全软件的基础始于加固平台和工具链。许多嵌入式 Linux 设备使用包含常见 GNU 实用程序的 BusyBox。对 BusyBox 需要进行某些配置，也需要进行更新。除了 BusyBox，嵌入式框架和工具链应该被修改为只包括在配置固件构建时使用的库和函数。RTOS 系统通常也有 POSIX 实用程序可用，但由 SoC、MCU 和芯片供应商进行配置，他们拥有修改版本的常见实用程序。嵌入式 Linux 构建系统，如 Buildroot、Yocto 等，执行设置和配置工具链环境的任务。删除已知的不安全库和协议，如 Telnet，不仅可以减少固件构建中的攻击入口点，还可以提供一种安全设计的方法来构建软件，以防范潜在的安全威胁。在本教程中，我们将展示如何使用 Buildroot 来选择和取消选择网络服务和配置。

# 准备工作

在本教程中，将使用 Buildroot 来演示加固。

**Buildroot**是通过交叉编译生成嵌入式 Linux 系统的工具。可以通过以下网站下载 Buildroot：

[`buildroot.uclibc.org/download.html`](https://buildroot.uclibc.org/download.html).

# 如何做...

我们将首先使用 Buildroot，并打开其菜单选项进行配置。

1.  下载 Buildroot 后，在 Buildroot 文件夹的根目录中运行以下命令，以显示 Buildroot 的配置选项：

```
    $ make menuconfig
```

根据偏好，还可以使用其他配置用户界面，如`xconfig`和`gconfig`。有关更多详细信息，请查阅 Buildroot 的用户手册：[`buildroot.uclibc.org/downloads/manual/manual.html`](https://buildroot.uclibc.org/downloads/manual/manual.html)。

1.  应该出现以下屏幕：

![](img/b940eca2-6c98-4eb7-bb84-81d5036264c8.png)

1.  在这里，可以对 Linux 固件映像进行配置。对于我们的目的，我们将向您展示如何选择安全的守护程序和安全的默认设置。

1.  接下来，转到工具链菜单，并启用堆栈保护支持，使用`-fstack-protector-all`构建标志：

![](img/98ad6f32-da38-4355-bcc3-5bf03a4093b2.png)

1.  转到主菜单屏幕，并进入系统配置菜单。选择密码编码，并选择 sha-512：

![](img/8429a2f7-cb90-4549-b4c2-af3060a1aeaf.png)

1.  在系统配置页面，我们可以为固件映像创建根密码。在这里，我们希望使用一个长的字母数字密码，就像屏幕截图中显示的那样：

![](img/02cc8e17-c5c0-4e6b-a11d-4f31a8229a4b.png)

1.  退出系统配置菜单，转到目标软件包菜单选项。在这里，我们可以指定要包含在固件映像中的工具、库、守护程序和第三方代码。根据设备的不同，可以选择许多选项，所以我们只使用一个示例。以下屏幕截图显示了选择 openssh 而不是 Telnet：

只有在要使用 TLS 时才启用 FTP。对于 Pure-FTPd，这需要通过传递`./configure --with-tls`进行自定义编译。

![](img/8d0fd502-8aa7-42d4-9f97-4fb750e13a5e.png)

1.  返回到目标软件包菜单，并选择 Shell 和实用程序子菜单。在这里，确保只选择一个 shell 解释器，以减少攻击面：

![](img/2ee86680-4a80-4eb3-9ea8-418ed861e5cb.png)

选择所有选项后，保存配置，并选择退出以离开 menuconfig 选项。然后，从 Buildroot 文件夹输入`make`来构建您的配置和工具链。

在使用 Yocto 构建系统时，可以采取类似的步骤，确保食谱已更新并配置为仅包含所需的软件包。还有其他几个配置可以用来加固 Linux 构建环境，包括以下内容：

1.  删除未使用的语言解释器，如 Perl、Python 和 Lua。

1.  从未使用的库函数中删除死代码。

1.  删除遗留的不安全守护程序，包括但不限于 Telnet、FTP 和 TFTP。

1.  从 Busybox 中删除未使用的 shell 实用程序，如 grep、awk、wget、curl 和 sed。

1.  加固库或服务以支持加密。

1.  确保构建所选的所有软件包和库都使用最新版本。

1.  使用最新的 Linux 内核。

1.  禁用 IPv4 转发

1.  禁用 IP 源路由

1.  禁用 ICMP

1.  忽略所有广播消息

1.  禁用 IPV6

1.  启用 TCP SYN Cookie 保护

1.  使用 Linux 安全模块（包括 SELinux）。

1.  在构建后使用免费工具，如 Lynis ([`raw.githubusercontent.com/CISOfy/lynis/master/lynis`](https://raw.githubusercontent.com/CISOfy/lynis/master/lynis))，以获得加固建议。

上述列表并不是详尽无遗的。与开发人员以及相关利益相关者一起进行迭代的威胁模型练习，以确保嵌入式设备上运行的软件不会引入易受攻击的过时软件等低挂果。

# 保护第三方代码和组件

在设置工具链之后，重要的是确保软件包和第三方上游库保持更新，以防止在物联网设备投入生产后出现已知的公开漏洞。黑盒第三方软件，如 RomPager、NetUSB 和嵌入式构建工具，如 Buildroot，也应该根据漏洞数据库以及它们的变更日志进行检查，以决定何时以及是否需要更新。使用上游 BSP 驱动程序并不是一件容易的事；在发布构建之前，开发团队应该测试库和上游 BSP 驱动程序的更改，因为更新可能会导致意想不到的依赖问题。

嵌入式项目和应用程序应该维护一个包含固件镜像中包含的第三方库和开源软件的清单（BOM）。这在世界某些受监管地区和 GPL 中有时是一个要求，同时维护 BOM 也有助于改善资产和库的管理。应该检查这个清单，以确认其中没有包含任何未修补的漏洞或已知问题的第三方软件。最新的漏洞信息可以通过**国家漏洞数据库**（**NVD**）、Open Hub 或类似的第三方网站找到。

在固件发布到所有市场细分之前，确保删除所有不必要的预生产构建代码，以及死代码和未使用的应用程序代码非常重要。这包括但不限于可能由**原始设计制造商**（**ODMs**）、供应商和第三方承包商留下的用于测试或客户支持目的的后门代码和根权限帐户。通常，这是**原始设备制造商**（**OEMs**）的职责，通过使用第三章中描述的方法对二进制文件进行逆向工程，即*分析和利用固件*。为了防止 OEMs 的额外劳动力开销，ODMs 应同意**主服务协议**（**MSAs**），确保不包括后门代码或用户帐户，并且所有代码都已经过审查，以查找软件安全漏洞，并追究第三方开发公司对大规模部署到市场上的设备的责任。此外，还要考虑要求 ODMs 有信息安全人员，并建立服务级别协议（SLA）来修复关键的安全漏洞。这个食谱将向您展示如何使用免费可用的工具来保护第三方代码和组件。

# 准备工作

这个食谱需要以下工具：

+   **RetireJS**：RetireJS 可以检测使用已知漏洞的 JavaScript 库。RetireJS 可以通过其 GitHub 存储库（[`github.com/RetireJS/retire.js`](https://github.com/RetireJS/retire.js)）或通过`npm`使用以下命令进行下载：

```
npm install -g retire

```

+   **Node Security Platform**（**NSP**）：NSP 可以检测项目中使用的已知有漏洞的 NodeJS 软件包。NSP 可以通过其 GitHub 存储库（[`github.com/nodesecurity/nsp`](https://github.com/nodesecurity/nsp)）或通过`npm`使用以下命令进行安装：

```
npm install -g nsp

```

+   **LibScanner**：LibScanner 是一个免费工具，用于对 Yocto 构建环境中使用的 RPM 或 SWID 软件包列表进行解析，并与 NVD 数据库进行比对。LibScanner 可以从其 GitHub 存储库下载，网址为[`github.com/DanBeard/LibScanner`](https://github.com/DanBeard/LibScanner)。

# 如何操作...

许多物联网设备运行各种 JavaScript 代码，以帮助减轻硬件资源消耗。有时，当设备需要作为某些用例的服务器时，这些代码也会在设备上运行。有一些很好的工具可以扫描项目目录，查找项目中使用的已知有漏洞的 JavaScript 版本。首先，我们来看一下 RetireJS。

1.  要运行 RetireJS，只需运行`retire`命令，并指定 JavaScript 目录如下：

```
$ retire path/to/js/
Loading from cache: https://raw.githubusercontent.com/RetireJS/retire.js/master/repository/jsrepository.json
    Loading from cache: https://raw.githubusercontent.com/RetireJS/retire.js/master/repository/npmrepository.json
    /static/js/lib/jquery-ui.js
      jquery-ui-dialog 1.8.17 has known vulnerabilities: severity: medium; bug: 6016, summary: Title cross-site scripting vulnerability; http://bugs.jqueryui.com/ticket/6016 severity: high; bug: 281, summary: XSS Vulnerability on closeText option; https://github.com/jquery/api.jqueryui.com/issues/281 https://snyk.io/vuln/npm:jquery-ui:20160721
      jquery-ui-autocomplete 1.8.17
    /static/js/lib/jquery.js
      jquery 1.7.1 has known vulnerabilities: severity: medium; bug: 11290, summary: Selector interpreted as HTML; http://bugs.jquery.com/ticket/11290 http://research.insecurelabs.org/jquery/test/ severity: medium; issue: 2432, summary: 3rd party CORS request may execute; https://github.com/jquery/jquery/issues/2432 http://blog.jquery.com/2016/01/08/jquery-2-2-and-1-12-released/

```

扫描发现项目中使用了两个有漏洞的 jQuery 库，以及相关的阅读和解释。这些发现可能会在未来打开设备的漏洞，但在生产之前发现这些问题要便宜得多。

1.  一个很好的 NodeJS 漏洞扫描工具是 NSP。与 RetireJS 一样，可以通过调用`nsp`并指定 NodeJS 项目目录或`packages.json`来执行 NSP，如下：

```
    $ nsp check /path/to/package.json 
    (+) 1 vulnerabilities found
    ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    │               │ Command Injection                                                                                                                                                                 │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Name          │ growl                                                                                                                                                                             │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ CVSS          │ 9.8 (Critical)                                                                                                                                                                    │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Installed     │ 1.1.0                                                                                                                                                                             │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Vulnerable    │ All                                                                                                                                                                               │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Patched       │ None                                                                                                                                                                              │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Path          │ stylus@0.22.4 > growl@1.1.0                                                                                                                                                       │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ More Info     │ https://nodesecurity.io/advisories/146                                                                                                                                            │
    └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

```

NSP 发现了一个有漏洞的库，可能会导致设备受到命令注入攻击，这是物联网中常见的漏洞。

1.  如果 IoT 设备的构建系统使用 Yocto，则可以使用免费的 LibScanner 工具来查询 NVD 数据库，以查找项目安装的软件包列表中已知的易受攻击的库。要开始使用 LibScanner，请通过运行以下命令更新漏洞数据库：

```
$ ./download_xml.sh 

```

1.  更新 NVD 数据库后，可以按照以下方式运行 LibScanner 来对 Yocto 的`installed-packages.txt`文件进行扫描：

```
$ ./cli.py  --format yocto "path/to/installed-packages.txt" dbs/  > cve_results.xml 

```

1.  执行后，请查看`cve_results.xml`文件，其中包含易受攻击文件的扫描结果以及 xUnit 格式的单元测试：

```
    $ cat cve_results.xml
    <failure> Medium (6.8) - Use-after-free vulnerability in libxml2 through 2.9.4, as used in Google Chrome before 52.0.2743.82, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the XPointer range-to function. 

     CVE Published on: 2016-07-23 https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-5131 </failure>
    </testcase>
    <testcase id="CVE-2016-9318" name="CVE-2016-9318" classname="libxml2 - 2.9.4" time="0">
    <failure> Medium (6.8) - libxml2 2.9.4 and earlier, as used in XMLSec 1.2.23 and earlier and other products, does not offer a flag directly indicating that the current document may be read but other files may not be opened, which makes it easier for remote attackers to conduct XML External Entity (XXE) attacks via a crafted document. 

     CVE Published on: 2016-11-15 https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-9318 </failure>
    </testcase>
    </testsuite>

```

在设备构建之前可以使用几种工具执行静态任务，或者在设备构建后和设备运行时执行动态检查。在之前的章节中，已经讨论了动态工具，比如用于 Web 应用程序测试的 OWASP ZAP，以及可以直接在设备命令行界面上运行的 Lynis 等工具。所有这些都可以加强设备的安全性，并最大程度地减少设备遭受成功攻击的可能性。

在本章中，我们讨论了在构建和编写固件中应该纳入的几种最佳实践。建议根据您的操作系统平台（即嵌入式 Linux、RTOS、Windows IoT 等）执行自己的尽职调查，以获取与您的 IoT 设备相关的特定安全控制。
