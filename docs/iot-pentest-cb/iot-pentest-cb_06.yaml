- en: IoT Device Hacking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网设备黑客
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Hardware exploitation versus software exploitation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件利用与软件利用
- en: Hardware hacking methodology
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件黑客方法论
- en: Hardware Reconnaissance techniques
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件侦察技术
- en: Electronics 101
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子学101
- en: Identifying buses and interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别总线和接口
- en: Serial interfacing for embedded devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备的串行接口
- en: NAND glitching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NAND故障
- en: JTAG debugging and exploitation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JTAG调试和利用
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The key central component of any **Internet of Things** (**IoT**) solution is
    the embedded device. It is the device that interacts with the physical environment
    and communicates with the web endpoints and other devices around it. Knowledge
    of how to exploit these hardware devices is extremely crucial for performing an
    IoT pen test.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何**物联网**（**IoT**）解决方案的关键中心组件是嵌入式设备。它是与物理环境互动并与网络端点和周围其他设备通信的设备。了解如何利用这些硬件设备对于进行物联网渗透测试非常关键。
- en: The type of device being used in an IoT solution might vary from product to
    product. In some cases, it could be a gateway, which allows various devices to
    interact with it, while also communicating with the web endpoints, or, it could
    be a medical device utility with the sole purpose of collecting data from a patient's
    body and showing it on a smartphone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网解决方案中使用的设备类型可能因产品而异。在某些情况下，它可能是一个网关，允许各种设备与其互动，同时与网络端点通信，或者它可能是一个医疗设备实用程序，其唯一目的是从患者的身体收集数据并在智能手机上显示。
- en: However, there exist certain specific security issues, which can affect any
    given hardware device, no matter what its category. This is what we will be focusing
    on in this chapter-to gain an in-depth understanding of various IoT device security
    issues, how to identify them, and how to exploit them, irrespective of the device
    type. But, before we get into actual hardware exploitation, let's have a look
    at how hardware exploitation differs from traditional software exploitation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在某些特定的安全问题，可能会影响任何给定的硬件设备，无论其类别如何。这就是我们将在本章中关注的内容-深入了解各种物联网设备安全问题，如何识别它们以及如何利用它们，无论设备类型如何。但是，在我们进行实际的硬件利用之前，让我们看看硬件利用与传统软件利用有何不同。
- en: Hardware exploitation versus software exploitation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件利用与软件利用
- en: The differences between hardware exploitation and software exploitation are
    quite significant, with the most important being that to find vulnerabilities
    and exploits in hardware, you will need to have the physical device with you.
    This means that unless you have possession of two or more devices, it is pretty
    complicated to pen test an IoT device's hardware effectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件利用与软件利用之间的差异非常显著，最重要的是，要找到硬件的漏洞和利用，你需要拥有物理设备。这意味着除非你拥有两个或更多的设备，否则要有效地对物联网设备的硬件进行渗透测试是相当复杂的。
- en: Another factor that increases the complexity of working with hardware security
    is the amount of resources publicly available around hardware security. For instance,
    in the case of a software that you are assessing, the chances are that you might
    be able to find the existing vulnerabilities in one of the components that the
    software is using or a common vulnerability, which is found in the type of software
    that you are working with. It does not mean that hardware exploitation is tougher,
    it simply means that if you are getting started, you might find hardware exploitation
    a bit more complicated compared to your previous software exploitation experiences
    due to a lack of in-depth, security-related information of a given component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 增加与硬件安全工作复杂性的另一个因素是围绕硬件安全公开可用的资源量。例如，在你正在评估的软件的情况下，你可能会发现软件正在使用的某个组件中存在现有的漏洞或者是你正在使用的软件类型中发现的常见漏洞的机会。这并不意味着硬件利用更加困难，只是意味着如果你刚开始，由于缺乏给定组件的深入的与安全相关的信息，你可能会发现硬件利用相对于以前的软件利用经验更加复杂。
- en: Another thing to note, in terms of hardware-based vulnerabilities, is that they
    are relatively tougher to patch and, in some cases, impossible without the complete
    replacement of the device for the end user. This means that if a hardware device
    ships with critical security issues in the hardware device itself, it would be
    the only option for the manufacturer for recall the devices and replace them with
    more secure ones.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于硬件的漏洞方面，还有一件事需要注意的是，它们相对更难修补，在某些情况下，甚至无法在不完全更换设备的情况下修补。这意味着如果硬件设备本身存在关键的安全问题，制造商唯一的选择就是召回设备并用更安全的设备替换它们。
- en: Finally, one of the most prominent differences for us as pen testers is that
    for hardware exploitation we would require a number of hardware tools and devices
    to assess and exploit the security of the end device effectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们作为渗透测试人员来说，最显著的区别之一是，对于硬件利用，我们需要一些硬件工具和设备来有效地评估和利用最终设备的安全性。
- en: However, don't get demotivated as we will be covering a number of tools and
    techniques for hardware exploitation, which will give you a very quick head start
    into the world of hardware hacking.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要感到沮丧，因为我们将涵盖许多硬件利用的工具和技术，这将让你迅速进入硬件黑客的世界。
- en: Hardware hacking methodology
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件黑客方法论
- en: 'The following are the steps involved in a Hardware hacking methodology methodology:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件黑客方法论涉及的步骤如下：
- en: Information gathering and recon
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息收集和侦察
- en: External and internal analysis of the device
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对设备进行外部和内部分析
- en: Identifying communication interfaces
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别通信接口
- en: Acquiring data using hardware communication techniques
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用硬件通信技术获取数据
- en: Software exploitation using hardware exploitation methods
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用硬件利用方法的软件利用
- en: Backdooring (optional)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后门设置（可选）
- en: Let's go into each of them, one by one, and understand each of these steps at
    a deeper level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个深入了解每一个步骤。
- en: Information gathering and recon
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息收集和侦察
- en: The first step in an embedded device hacking methodology is to gather as much
    information as possible about the target that we are working with. Now this may
    sound simple, but in the cases of embedded devices, this might be a bit more complicated
    than we might think. The information about a target device is usually limited-at
    least from a very high-level view-given the fact that in order to gain a relevant
    amount of information about the device, we will need access to the physical device
    itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备黑客方法论的第一步是尽可能收集关于我们正在处理的目标的信息。现在这可能听起来很简单，但在嵌入式设备的情况下，这可能比我们想象的要复杂一些。关于目标设备的信息通常是有限的-至少从一个非常高层次的视角来看-考虑到为了获得有关设备的相关信息，我们将需要访问物理设备本身。
- en: But even before doing so, there are a number of ways in which a pen tester can
    gather more information about a given target device. These include publicly available
    sources or the documentation, which the client has made available or through other
    resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使在这之前，渗透测试人员可以通过多种方式收集有关给定目标设备的更多信息。这些包括公开可用的来源或客户提供的文档，或通过其他资源。
- en: 'Some of the information that might be relevant at this stage would be:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段可能相关的一些信息包括：
- en: What is the embedded device based on?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备基于什么？
- en: The operating system it runs on
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它运行的操作系统
- en: What are the external peripherals that the device supports?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备支持哪些外部外围设备？
- en: What kind of chipsets is the device using?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备使用了什么样的芯片组件？
- en: Details about the storage and memory being used in the device
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于设备使用的存储和内存的详细信息
- en: Any other relevant technical information about the device
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于设备的任何其他相关技术信息
- en: Once we have this information, we can move to the next step, which is analyzing
    the device using both exterior and interior analysis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了这些信息，我们就可以进入下一步，即使用外部和内部分析来分析设备。
- en: External and internal analysis of the device
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备的外部和内部分析
- en: Once you have the information acquired from the previous step, the next step
    would be to start working with the device itself. Here, the goal would be to look
    at the device from an attacker's perspective and identify as much information
    as possible using visual inspection-both external and internal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从上一步获得了信息，下一步就是开始与设备本身进行交互。在这里，目标是从攻击者的角度查看设备，并通过视觉检查-包括外部和内部-尽可能多地识别信息。
- en: 'The exterior analysis is quite straightforward and can be performed by looking
    at the device and figuring out all the various components that you can see. Here,
    you may ask yourself the following questions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 外部分析非常直接，可以通过查看设备并找出所有你能看到的各种组件来进行。在这里，你可能会问自己以下问题：
- en: What are the various interfacing options with the device-does it have any USB
    ports, SD card slots, or an Ethernet port?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的各种接口选项是什么-它是否有任何USB端口、SD卡插槽或以太网端口？
- en: How is the device powered on-by batteries, PPoE, or adapter?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备是如何供电的-通过电池、PPoE还是适配器？
- en: Are there any labels on the device? If yes, what kind of information do they
    have?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备上有标签吗？如果有，它们包含什么样的信息？
- en: Once we have performed the external analysis, the next step is to move to internal
    analysis of the device. This requires you to open up the device and look at the
    **printed circuit board** (**PCB**). In this step, we will be identifying all
    the various chipsets present in the device, looking them up on the datasheet and
    understanding what each particular component does, along with noting down the
    various information that we find from its datasheet.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了外部分析，下一步就是进行设备的内部分析。这需要你打开设备，查看**印刷电路板**（**PCB**）。在这一步中，我们将识别设备中的各种芯片组件，查阅它们的数据表，并了解每个特定组件的功能，以及记录从数据表中找到的各种信息。
- en: At this stage, I also like to draw a basic block diagram of the various interconnections
    between components so as to have a much clearer understanding for the entire device
    internals.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我也喜欢绘制各种组件之间的基本连接的框图，以便更清楚地了解整个设备的内部情况。
- en: Identifying communication interfaces
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别通信接口
- en: Once we have looked at the PCB and have found enough information about the overall
    circuit and the various components involved in it, the next step is to look for
    all the possible options of interfacing with the device.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查看了PCB并找到了关于整个电路和其中涉及的各种组件的足够信息，下一步就是寻找与设备进行接口的所有可能选项。
- en: In some cases, it could be pretty evident and standing out in front of you,
    and in others it might be something tougher to identify, by being scattered across
    the board or, in some cases, where you will have to directly hook into the legs
    of a given chipset.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，它可能非常明显并且直接摆在你面前，而在其他情况下，可能更难以识别，可能分散在整个电路板上，或者在某些情况下，你将不得不直接连接到给定芯片组件的引脚上。
- en: Acquiring data using hardware communication techniques
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件通信技术获取数据
- en: Once we have identified the communication protocol/interface in use, we can
    use a specific set of tools to communicate with the target device over the given
    protocol and interact with the target or read/write information to the given chip.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了正在使用的通信协议/接口，我们可以使用一组特定的工具来通过给定的协议与目标设备通信，并与目标交互或读/写信息到给定的芯片。
- en: Depending on the interface under scrutiny, we will be using different techniques
    to connect to it and acquire useful data for pen testing. Some of the most commonly
    found interfaces are UART, JTAG, SPI, I2C, and 1-Wire.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据受审查的接口，我们将使用不同的技术来连接并获取有用的渗透测试数据。一些常见的接口包括UART、JTAG、SPI、I2C和1-Wire。
- en: Software exploitation using hardware exploitation methods
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件开发方法进行软件开发利用
- en: Once we have access to the target device over a given hardware interface, the
    next step would be to perform various software exploitation techniques via hardware
    exploitation. These involve performing things such as dumping the firmware, writing
    new content at a given memory region, performing modifications to running processes,
    and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过给定的硬件接口访问了目标设备，下一步将是通过硬件利用执行各种软件利用技术。这包括执行诸如转储固件、在给定的内存区域写入新内容、对运行进程进行修改等操作。
- en: As you might have understood by now, most exploitation's using hardware techniques
    would lead you to gain access to sensitive resources, which then could be exploited
    in a number of ways.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经了解的那样，大多数利用硬件技术的攻击将使你获得对敏感资源的访问，然后可以以多种方式进行利用。
- en: Now that we have an understanding of the overall hardware pen testing methodology,
    let's move deeper into how to perform reconnaissance on hardware devices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对整体硬件渗透测试方法论有了了解，让我们深入了解如何对硬件设备进行侦察。
- en: Hardware reconnaissance techniques
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件侦察技术
- en: Apart from the visual exterior analysis, reconnaissance consists of two steps-opening
    the device and looking at the various chips present, and finding information from
    its datasheet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视觉外部分析之外，侦察包括两个步骤-打开设备并查看各种芯片的存在，并从其数据表中获取信息。
- en: Let's get into each of them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一深入了解。
- en: Opening the device
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开设备
- en: The first step in a hardware reconnaissance process is to open up the device.
    This process's complexity can range from being extremely simple to highly complex
    depending on the device you are working with.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件侦察过程的第一步是打开设备。这个过程的复杂性取决于你所使用的设备，可以从非常简单到非常复杂不等。
- en: In some of the devices, you will find that the screws are hidden beneath rubber
    pads on the legs, while in other cases they will be largely exposed, and in others
    still, the two different sections might be welded together.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些设备中，你会发现螺丝隐藏在腿部的橡胶垫下，而在其他情况下，它们会大部分暴露出来，而在其他情况下，两个不同的部分可能会被焊在一起。
- en: Depending on how the device has been put together, use the appropriate tools
    to take apart the different sections. It is also recommended to have a good set
    of screwdrivers along with you for the entire hardware exploitation process, as
    varying devices will have many different kinds of screws used in them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备的组装方式，使用适当的工具拆卸不同的部分。建议在整个硬件利用过程中携带一套好的螺丝刀，因为不同的设备会使用许多不同种类的螺丝。
- en: Looking at various chips present
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看各种芯片的存在
- en: Once you have opened up the device, the next step is to look at the PCB and
    identify all the various chips present. To read the labels of the chip, use a
    USB microscope or your smartphone's flashlight while tilting the chip slightly.
    It is also recommended to have holders, which can hold the device steadily while
    you read the names of the various chips.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开了设备，下一步是查看PCB并识别所有各种芯片的存在。使用USB显微镜或智能手机的手电筒来读取芯片的标签，同时倾斜芯片。建议使用支架，可以在读取各种芯片的名称时稳定地固定设备。
- en: Once you have figured out the name of a chip, head over to Google and search
    for its manufacturer, followed by the model number and the word, "datasheet".
    This is also something we will do later on in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弄清楚了芯片的名称，就去谷歌搜索它的制造商，然后加上型号和“数据表”这个词。这也是我们将在本章后面做的事情。
- en: Once you have the datasheet with you, you can use the information present there
    to figure out all the various properties of the target chip, including the pinout,
    which would prove to be extremely useful during the hardware exploitation process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了数据表，你可以利用其中的信息来找出目标芯片的各种属性，包括引脚布局，在硬件利用过程中这将非常有用。
- en: Now that we know how to perform reconnaissance on our target device, we can
    move on to getting deeper into hardware exploitation. To ensure that we know our
    target very well and to ensure that our attacks succeed, we will need to get a
    finer understanding of electronics, which will make things easier and more understandable
    for us as we go into exploitation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何对目标设备进行侦察，我们可以继续深入硬件利用。为了确保我们非常了解我们的目标，并确保我们的攻击成功，我们需要更好地了解电子学，这将使我们在进行利用时更容易理解。
- en: Electronics 101
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子学101
- en: As mentioned, electronics is one of the most important things to understand
    if you want to get into hardware hacking. You might be able to catch some of the
    low-hanging vulnerabilities without an understanding of electronics; however,
    to be good at it, you will need to understand what is happening on the device
    and how a given component can be exploited. In this section, we will be looking
    at some of the foundational concepts in electronics, which will help you gain
    more confidence and understanding, once you start looking into embedded device
    internals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，电子学是要理解的最重要的事情之一，如果你想进行硬件黑客攻击。你可能能够在不了解电子学的情况下捕捉一些低悬漏洞；然而，要擅长这个领域，你需要了解设备上发生了什么，以及如何利用给定的组件。在本节中，我们将介绍一些电子学的基本概念，这将帮助你在开始研究嵌入式设备内部时获得更多的信心和理解。
- en: This may look absolutely basic to you; however, think of this section as a refresher
    to what you are about to see in the later sections, and in real life, as you start
    working with embedded devices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说可能看起来非常基础；然而，把这一节当作你将在后面的章节和实际生活中所看到的东西的一个复习，当你开始使用嵌入式设备时。
- en: Resistor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电阻
- en: Resistors are electronic components, which offer resistance against the current
    flow, or speaking at a deeper level, against the electrons' flow. Resistors, denoted
    by *R*, are passive components, which means that they don't generate any electricity
    at all, but rather reduce voltage and current by dissipating power in the form
    of heat.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器是电子元件，它们阻碍电流流动，或者更深层次地说，阻碍电子的流动。电阻器，用*R*表示，是被动元件，这意味着它们根本不产生任何电力，而是通过散热的方式降低电压和电流。
- en: The unit of resistance is ohms (Ω) and resistors are usually built using carbon
    or metal wire. You will also find the resistors being color-coded in order to
    help convey the value of resistance they offer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻的单位是欧姆（Ω），电阻通常使用碳或金属线制造。你还会发现电阻器被编码颜色，以帮助传达它们提供的电阻值。
- en: 'This is what a resistor looks like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是电阻器的样子：
- en: '![](img/c2aac831-cac2-4e0b-a47a-f4c01b8de34c.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2aac831-cac2-4e0b-a47a-f4c01b8de34c.jpg)'
- en: Now that you know what resistors are, it is also worth noting that there could
    be two different categories of resistors-fixed and variable. As the name implies,
    a fixed resistor is where the resistance is fixed and cannot be changed, whereas
    in a variable resistor, the resistance can be varied using certain techniques.
    One of the most popular examples of a variable resistor would be a **potentiometer**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了电阻器是什么，值得注意的是，电阻器可能有两种不同的类别-固定和可变。顾名思义，固定电阻器的电阻是固定的，不能改变，而在可变电阻器中，电阻可以使用某些技术进行变化。可变电阻器最流行的例子之一是**电位器**。
- en: Voltage
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电压
- en: Voltage in electronics is simply the potential energy difference between two
    different points of measurement. In most scenarios, you will find the reference
    point taken to measure the voltage of a given point is **ground** (**GND**), or
    the negative terminal of a battery or power supply. To put this in a real-life
    context, if you have used a 9V battery, this means that the potential difference
    between the two points would be 9 volts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子学中，电压简单地是两个不同测量点之间的电势能差。在大多数情况下，用来测量给定点电压的参考点是**地**（**GND**），或者电池或电源的负极。举个现实生活中的例子，如果你使用了一个9V电池，这意味着两点之间的电势差为9伏特。
- en: To go on to a deeper level, let's say that at the two ends of a conductor, such
    as copper wire, you have a huge amount of electrons (negative charge) and at the
    other end you have protons (positive charge). This means that there is a difference
    between the potentials of these two points ultimately leading to a flow of current.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解，让我们假设在导体的两端，比如铜线，你有大量的电子（负电荷），在另一端你有质子（正电荷）。这意味着这两点之间的电势存在差异，最终导致电流的流动。
- en: To measure voltage, we use a device called a **voltmeter**, which tells us about
    the potential difference between the two points it is connected to. For example,
    the positive end of the 9V battery will have a voltage of +9V, and the negative
    end of the battery will have a voltage of -9V.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量电压，我们使用一种叫做**电压表**的设备，它告诉我们它连接的两点之间的电势差。例如，9V电池的正极电压为+9V，负极电压为-9V。
- en: Current
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电流
- en: As we discussed in the previous scenario, the current flows (in the preceding
    case because of the medium being a copper conductor) when there is a difference
    in voltages and it will continue flowing until both the sides have equal amounts
    of electrons and protons.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的情景中讨论的，电流流动（在前述情况下是因为介质是铜导体）当两端的电压存在差异时，它将继续流动，直到两侧的电子和质子数量相等。
- en: A current could either be an **alternating current** (**AC**) or a **direct
    current** (**DC**), which simply means that if the current is flowing at a constant
    rate, such as in batteries, it would be a DC, whereas if it is alternating or
    changing with time, it is an AC. For example, in the United States, the default
    power that you get from a power outlet is 120V and 60Hz AC.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 电流可以是**交流**（**AC**）或**直流**（**DC**），这意味着如果电流以恒定速率流动，比如在电池中，它将是直流，而如果它是交变的或随时间变化的，它就是交流。例如，在美国，从电源插座获得的默认电力是120V和60Hz的交流电。
- en: Current is measured in **amperes** (**A**) and is denoted with the letter *I*
    in equations and formulas. The device used to measure the current is called an
    **ammeter**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 电流以**安培**（**A**）为单位进行测量，并在方程和公式中用字母*I*表示。用于测量电流的设备称为**安培表**。
- en: You might be thinking here that these three components-Current, voltage, and
    resistance seem to be dependent on each other. To put it all together, voltage
    causes the current to flow, and resistance opposes the current flow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这三个组件-电流、电压和电阻似乎是相互依赖的。总结一下，电压引起电流流动，电阻阻碍电流流动。
- en: The relation is what is famously known as **Ohm****'s Law**, which states that
    *Current (I) = Voltage (V)/Resistance(R)*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系就是著名的**欧姆定律**，它规定*电流（I）=电压（V）/电阻（R）*。
- en: This also confirms the fact that current is directly proportional to voltage,
    and indirectly proportional to resistance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也证实了电流与电压成正比，与电阻成反比的事实。
- en: Capacitor
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电容器
- en: Capacitors are one of the other most common components found in almost all embedded
    devices. As the name suggests, one of their primary tasks is to hold energy in
    the form of an electric charge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器是几乎所有嵌入式设备中最常见的组件之一。顾名思义，它们的主要任务之一是以电荷的形式储存能量。
- en: Inside a capacitor are two oppositely charged plates, which hold the electric
    charge when connected to a power source. Some of the other usages of a capacitor
    are acting as filters, reducing electrical noise affecting other chips on the
    device, separating AC and DC components (AC coupling), and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器内部有两个带有相反电荷的板，当连接到电源时，它们储存电荷。电容器的其他用途包括作为滤波器，减少影响设备上其他芯片的电噪声，分离交流和直流组件（交流耦合）等。
- en: 'The unit of capacitance is the faraday denoted with an *F*, and it is calculated
    using the following formula:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 电容的单位是法拉，用*F*表示，可以使用以下公式计算：
- en: '*C=Q/V*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*C=Q/V*'
- en: Here, *C* is the capacitance, *Q* is the electric charge, and *V* is the voltage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*C*是电容，*Q*是电荷，*V*是电压。
- en: All of the preceding values are measured in their standard units of faradays
    (*F*), coulombs (*C*), and volts (*V*).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述值都以法拉第（*F*）、库仑（*C*）和伏特（*V*）为标准单位进行测量。
- en: Transistor
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 晶体管
- en: Transistors are electronic components, which serve a number of purposes by acting
    as both switches and an amplifiers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管是电子元件，通过充当开关和放大器来发挥多种作用。
- en: As an amplifier, it can take in a small current and amplify it to produce a
    much bigger output current. One of the examples of this could be in a microphone
    connected to a loudspeaker, where the mic takes in a small sound input and amplifies
    it to produce a much louder sound when it comes out via the loudspeaker.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为放大器，它可以接收小电流并放大它以产生更大的输出电流。其中一个例子是麦克风连接到扬声器，麦克风接收到小声音输入并放大后通过扬声器输出更大的声音。
- en: Similarly, as a switch, it can take a small current input and use it to allow
    a much larger current to flow by activating the new current flow.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，作为开关，它可以接收小电流输入并用它来允许更大的电流流动，从而激活新的电流流动。
- en: 'This is what a transistor looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是晶体管的外观：
- en: '![](img/9d3cb606-5a66-4cc3-ada1-dddb67fc54b7.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3cb606-5a66-4cc3-ada1-dddb67fc54b7.png)'
- en: 'The following is how an NPN transistor (the other type is a PNP, where the
    arrow points at the base) is schematically represented:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是NPN晶体管（另一种类型是PNP，箭头指向基）的示意图：
- en: '![](img/6295c4b8-4e43-426e-8d6a-8f054feff39c.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6295c4b8-4e43-426e-8d6a-8f054feff39c.png)'
- en: Memory types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储器类型
- en: 'Some of the most important components in embedded devices are related to data
    storage, which can be used by the device for a number of purposes. This is where
    you will be able to find things such as the firmware and **application programming
    interface** (**API**) keys. The three primary categories of memory types in embedded
    devices, along with their subdivisions, are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备中一些最重要的组件与数据存储有关，可以被设备用于多种目的。这是您可以找到固件和应用程序编程接口（API）密钥等内容的地方。嵌入式设备中的三种主要存储器类型及其细分如下：
- en: '**Random Access Memory** (**RAM**)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机存取存储器（RAM）
- en: '**Static RAM** (**SRAM**)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态随机存取存储器（SRAM）
- en: '**Dynamic RAM** (**DRAM**)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态随机存取存储器（DRAM）
- en: '**Read Only Memory** (**ROM**)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读存储器（ROM）
- en: '**Programmable ROM** (**PROM**)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编程只读存储器（PROM）
- en: '**Erasable Programmable ROM** (**EPROM**)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可擦可编程只读存储器（EPROM）
- en: Hybrid
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: '**Electrically Erasable Programmable ROM** (**EEPROM**)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可擦可编程只读存储器（EEPROM）
- en: Flash
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪存
- en: The differentiation of the various kinds of memory types is made on the basis
    of a number of factors such as the ability to store data, time duration for which
    it can store the data, how the data can be erased and rewritten, and what the
    rewriting data process looks like.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 各种存储器类型的区分是基于一些因素，如存储数据的能力，存储数据的时间，数据如何被擦除和重写，以及重写数据的过程是什么样的。
- en: For instance, SRAM holds data for only as long as it receives a power supply,
    compared to DRAM, which stores each bit of data in an individual capacitor. Additionally,
    because of the primary fact that DRAM has refresh cycles (as the capacitors will
    eventually be discharged), SRAM is comparatively faster compared to DRAM.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SRAM只在接收到电源供应时保存数据，而DRAM将每个数据位存储在单独的电容器中。此外，由于DRAM具有刷新周期（因为电容器最终会被放电），因此SRAM相对于DRAM来说速度更快。
- en: Similarly, for ROM-based on how many times data can be written on it-it is classified
    as PROM or EPROM. For PROM, data once written can't be modified, whereas in EPROM,
    the data can be erased using a **ultraviolet** (**UV**) ray, which can reach the
    chip through a small window, erasing the chip by resetting it and bringing it
    to its initial state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，根据数据可以被写入的次数，ROM被分类为PROM或EPROM。对于PROM，一旦写入数据就无法修改，而在EPROM中，数据可以通过紫外线（UV）射线擦除，紫外线可以通过一个小窗口到达芯片，通过重置芯片并将其带到初始状态来擦除芯片。
- en: However, the two most important memory types that we will be encountering are
    EEPROM and Flash, or NOR and NAND Flash based on the differences in the read,
    write, and erase cycles-depending on whether the action can be performed on the
    entire block at once (Flash) and compared to whether it needs to be performed
    on a single bit at once (EEPROM).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将遇到的两种最重要的存储器类型是EEPROM和Flash，或者基于读取、写入和擦除周期的差异而言的NOR和NAND Flash-取决于是否可以一次在整个块上执行操作（Flash），以及是否需要一次在单个位上执行操作（EEPROM）。
- en: Serial and parallel communication
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行和并行通信
- en: Now that we have a basic understanding of some of the electronic components,
    let's move into the different kinds of communication mediums that are used in
    embedded devices.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对一些电子元件有了基本的了解，让我们进入嵌入式设备中使用的不同种类的通信介质。
- en: The two methods of data communication in embedded devices are serial and parallel
    communication. As the name suggests, serial communication sends data one bit at
    a time sequentially. This means that if 8 bits have to be transferred, it will
    send one bit after the other, and the data transfer will be complete only when
    all the 8 bits are received.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备中的数据通信方法有串行和并行通信。顾名思义，串行通信按顺序逐位发送数据。这意味着如果要传输8位，它将一个接一个地发送，只有当所有8位都接收到时，数据传输才完成。
- en: However, in cases of parallel communication, multiple bits would be transferred
    at the same time, thus making the data transfer process faster compared to its
    serial counterpart.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在并行通信的情况下，多个位将同时传输，因此使数据传输过程比其串行对应物更快。
- en: You might think that parallel communication would be much better and would be
    used predominantly everywhere because of faster data transfer rates. This, however,
    is not the case because we did not consider the amount of real estate on the circuit
    board it would require for a parallel communication.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为并行通信会更好，并且由于数据传输速率更快，它会被广泛使用。然而，这并不是事实，因为我们没有考虑并行通信在电路板上所需的实际空间。
- en: Embedded devices are extremely low in physical space. Thus, when it comes to
    data transfer, faster is not always the better option, when considering the fact
    that a parallel data transfer would require much more data lines compared with
    a serial data transfer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的物理空间非常有限。因此，在数据传输方面，更快并不总是更好的选择，尤其是考虑到并行数据传输需要比串行数据传输更多的数据线。
- en: Some of the examples of parallel data transfer communications are PCI and ATA,
    whereas a serial communication is undertaken using USB, UART, and SPI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些并行数据传输通信的示例是PCI和ATA，而串行通信是使用USB、UART和SPI进行的。
- en: In this book, we will be focusing on the serial communication mediums, as they
    are most widely found in all the hardware devices that you will come across.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点关注串行通信介质，因为它们在您将遇到的所有硬件设备中都是最常见的。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One of the things you could perform additionally at this point of time is to
    look at the circuit board of any given embedded device and try to identify what
    are the various components involves and what kind of communication mechanism they
    are using.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时您还可以执行的一项工作是查看任何给定嵌入式设备的电路板，并尝试识别涉及的各种组件以及它们使用的通信机制是什么样的。
- en: Identifying buses and interfaces
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别总线和接口
- en: Now that we have a good understanding of the different components present in
    an embedded device, let's have a look at how we can identify the different buses
    and interfaces present in a device.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对嵌入式设备中的不同组件有了很好的了解，让我们看看如何识别设备中存在的不同总线和接口。
- en: For this, the first step would be to open up the device and look at the PCB.
    Note that in this section, we will only be concerned with identifying what a particular
    pin, or header, or chip is for, rather than actually connecting to it, which is
    what we will cover in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，第一步是打开设备并查看PCB。请注意，在本节中，我们只关心识别特定引脚、标头或芯片的用途，而不是实际连接到它，这是我们将在下一节中介绍的内容。
- en: How to do it...We will start by looking for UART which is one of the hacker's
    favorite interface to get access to the device. We will start by looking at the
    internals of UART, moving to how to identify the pinouts and finally how to connect
    with the target device.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做...我们将首先寻找UART，这是黑客最喜欢用来访问设备的接口之一。我们将首先查看UART的内部结构，然后是如何识别引脚排列，最后是如何连接到目标设备。
- en: UART identification
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UART识别
- en: The first thing that we will look for in an embedded device is the **universal
    asynchronous receiver transmitter** (**UART**) interface. UART is one of the most
    common communication protocols found in embedded devices. UART essentially converts
    the parallel data that it receives into a serial bit stream of data, which could
    be easier to interact with.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备中，我们首先要寻找的是**通用异步收发器**（**UART**）接口。UART是嵌入式设备中最常见的通信协议之一。UART基本上将其接收到的并行数据转换为串行数据流，这样更容易进行交互。
- en: Since the other focus here is on reducing the number of lines, there is no clock
    present in a UART communication. Instead, UART relies on **baud rate**, which
    is the rate of data transfer. The two different components present in a UART communication
    will agree on a specified baudrate to ensure that the data is received in a proper
    format.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里的另一个重点是减少线路的数量，因此在UART通信中没有时钟。相反，UART依赖于**波特率**，即数据传输速率。UART通信中的两个不同组件将同意指定的波特率，以确保数据以正确的格式接收。
- en: 'Additionally, in a UART communication, another bit called the **parity bit**
    is also added to the communication to facilitate error detection. Thus, a typical
    UART communication would have the following bits in order:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在UART通信中，还会添加另一个称为**奇偶校验位**的位，以便进行错误检测。因此，典型的UART通信顺序如下：
- en: '**Start bit**: This indicates that this is the start of a UART communication.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始位**：表示这是UART通信的开始。'
- en: '**Data bits**: This is the actual data that needs to be transmitted.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据位**：这是需要传输的实际数据。'
- en: '**Parity bit**: This is used for error detection.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇偶校验位：这用于错误检测。
- en: '**Stop bit**: This is used to indicate the end of the UART data stream.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止位**：用于指示UART数据流的结束。'
- en: In case you would like to try this out by yourself and understand the UART data
    stream, you can use a logic analyzer and hook into the UART ports (which we will
    identify in a while) and view the results in the logic analyzer software. One
    of the popular logic analyzers that can be used is Salae Logic, which comes in
    both 8-channel and 16-channel options.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己尝试并了解UART数据流，可以使用逻辑分析仪并连接到UART端口（我们将在稍后识别），然后在逻辑分析仪软件中查看结果。可以使用的一种流行的逻辑分析仪是Salae
    Logic，它有8通道和16通道两种选项。
- en: 'The following screenshot shows what the data would look like in a logic analyzer:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了逻辑分析仪中数据的样子：
- en: '![](img/4a6075de-45dc-4f32-be02-5b5e948b0ecd.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a6075de-45dc-4f32-be02-5b5e948b0ecd.png)'
- en: 'Let''s go ahead and see what UART ports look like in real devices. The following
    are some examples of UART ports, which have been identified in devices. Note that
    for a UART communication to take place, two pins are essential-Transmit (Tx) and
    Receive (Rx). Additionally, in most of the cases, you will also find two more
    pins for ground (GND) and Vcc:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看实际设备中的UART端口是什么样子。以下是一些已在设备中识别出的UART端口的示例。请注意，要进行UART通信，两个引脚是必不可少的-发送（Tx）和接收（Rx）。此外，在大多数情况下，您还会发现另外两个引脚用于地线（GND）和Vcc：
- en: '![](img/8eac5a14-3ba3-49d9-b16f-2ba15691ae9e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8eac5a14-3ba3-49d9-b16f-2ba15691ae9e.png)'
- en: As you can see in the preceding image, there are four pins next to each other,
    which in this case are the UART pins. In the next section about acquiring and
    interfacing with serial communication, we will look at ways to identify the exact
    pinouts-which pins correspond to Tx, Rx, and GND, and also interface with these
    pins/ports to get access to the device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上图中所见，有四个相邻的引脚，这在这种情况下是UART引脚。在关于获取和接口化串行通信的下一节中，我们将看看如何识别确切的引脚布局-哪些引脚对应于Tx、Rx和GND，并且还要接口化这些引脚/端口以访问设备。
- en: SPI and I2C identification
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPI和I2C的识别
- en: SPI and I2C identification is similar to what we just saw in the UART communication
    identification. One of the ways of identifying that the communication protocol
    being used is SPI or I2C is by using a logic analyzer and looking at the various
    bits that have been transmitted in the communication.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SPI和I2C的识别类似于我们刚刚在UART通信识别中看到的。识别正在使用的通信协议是SPI还是I2C的一种方法是使用逻辑分析仪，并查看在通信中传输的各种位。
- en: Both SPI and I2C fall under serial communication, mostly used in Flash and EEPROM.
    One of the ways to correctly identify the exact protocol being used, along with
    further details, is to look at the chip name and get the information from the
    datasheet.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SPI和I2C都属于串行通信，主要用于Flash和EEPROM。正确识别正在使用的确切协议以及更多细节的一种方法是查看芯片名称并从数据表中获取信息。
- en: 'The following is what an SPI flash chip looks like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SPI闪存芯片的外观：
- en: '![](img/a0c2764c-d27e-40aa-a613-e7d51d3c2bf9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0c2764c-d27e-40aa-a613-e7d51d3c2bf9.png)'
- en: 'Image source: [https://cdn-shop.adafruit.com/1200x900/1564-00.jpg](https://cdn-shop.adafruit.com/1200x900/1564-00.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[https://cdn-shop.adafruit.com/1200x900/1564-00.jpg](https://cdn-shop.adafruit.com/1200x900/1564-00.jpg)
- en: The flash chip in the preceding image has the label, Winbond W25Q80BV, which
    means that now we can look up its datasheet and identify its various properties-even
    without knowing that it's an SPI flash chip.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的闪存芯片标签为Winbond W25Q80BV，这意味着现在我们可以查阅其数据表并识别其各种属性-即使不知道它是SPI闪存芯片。
- en: 'If we do a Google search for the chip number, the following is what we get:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索芯片编号，我们将得到以下结果：
- en: '![](img/fcba91d3-d9cc-49e1-ba1f-e59791a60444.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcba91d3-d9cc-49e1-ba1f-e59791a60444.png)'
- en: 'Let''s go ahead and open up any of the datasheet PDFs found in the search result.
    At the very start of the datasheet itself, we will find the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续打开搜索结果中找到的任何数据表PDF。在数据表的开头，我们将找到以下内容：
- en: '![](img/8d76b63c-e7db-4511-ac16-7aeaf2b278d5.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d76b63c-e7db-4511-ac16-7aeaf2b278d5.png)'
- en: 'This means that our chip is an SPI flash chip with 8 MB of storage. As we go
    further in the datasheet, we also find out its pinouts, as shown in the following
    screenshot, which tells us the exact pinouts of the given SPI flash chip:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的芯片是一颗带有8MB存储空间的SPI闪存芯片。随着我们在数据表中的进一步了解，我们还发现了其引脚布局，如下截图所示，告诉我们给定SPI闪存芯片的确切引脚布局：
- en: '![](img/b8f9c959-1bdf-46b8-9b0e-7e961068da02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8f9c959-1bdf-46b8-9b0e-7e961068da02.png)'
- en: Thus, we have been able to correctly identify what that chip is meant for, what
    its properties are, and what are its pinouts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经能够正确识别芯片的用途、其属性以及其引脚布局。
- en: Once we have this information, we can connect to the SPI flash chip using Attify
    Badge, which is a tool for working with various hardware protocols and standards
    such as UART, JTAG, SPI, and I2C. Alternatively, you can also use the FTDI MPSSE
    cable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以使用Attify Badge连接到SPI闪存芯片，这是一种用于处理各种硬件协议和标准（如UART、JTAG、SPI和I2C）的工具。或者，您也可以使用FTDI
    MPSSE电缆。
- en: Connect the **data out** (**DO**) and **data in** (**DI**) to the MOSI and MISO
    respectively in the Attify Badge or, if you are using the FTDI cable, then the
    DI from the chip goes to the DO (yellow) and the DO of the chip goes to the DI
    (green) of the cable. Additionally, also connect the Vcc, GND, WP, and CS of the
    cable to the same pins on the chip.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将**数据输出**（**DO**）和**数据输入**（**DI**）分别连接到Attify Badge的MOSI和MISO，或者，如果您使用FTDI电缆，则芯片的DI连接到电缆的DO（黄色），芯片的DO连接到电缆的DI（绿色）。此外，还将电缆的Vcc、GND、WP和CS连接到芯片上的相同引脚。
- en: 'The table in the following figure will help you make the connections at this
    stage:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下图中的表格将帮助您在此阶段进行连接：
- en: '![](img/8190c765-09ec-4302-a59a-84cd0aea9ba0.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8190c765-09ec-4302-a59a-84cd0aea9ba0.png)'
- en: 'Once the connections are made, all we have to do is run the `spiflash.py` utility
    from the LibMPSSE library located at [https://github.com/devttys0/libmpsse](https://github.com/devttys0/libmpsse).
    This is also shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 连接完成后，我们只需从位于[https://github.com/devttys0/libmpsse](https://github.com/devttys0/libmpsse)的LibMPSSE库中运行`spiflash.py`实用程序。以下截图也显示了这一点：
- en: '![](img/0a0d4fb8-9c0c-4dfc-a71c-0ab86c27b599.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a0d4fb8-9c0c-4dfc-a71c-0ab86c27b599.png)'
- en: The size in the preceding syntax was obtained from the datasheet of the flash
    chip, and the entire content of the flash chip was put into a file called `new.bin`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法中的大小是从闪存芯片的数据表中获取的，并且闪存芯片的整个内容被放入名为`new.bin`的文件中。
- en: Thus, now you can look at a SPI flash chip, find out its pinouts, and dump data
    from it, which could be firmware, hardcoded keys, or other sensitive information,
    depending on the device that you are working with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您可以查看SPI闪存芯片，找出其引脚布局，并从中转储数据，这可能是固件、硬编码密钥或其他敏感信息，具体取决于您正在使用的设备。
- en: JTAG identification
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JTAG识别
- en: The last thing that we will look for in order to identify interesting exposed
    interfaces on the device is a **Joint Test Action Group** (**JTAG**).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别设备上有趣的暴露接口，我们将寻找的最后一件事是**联合测试动作组**（**JTAG**）。
- en: JTAG is a simplified way of testing pins and debugging them compared to the
    previous way of bed-of-nails testing. It allows device developers and testers
    to ensure that each of the pins in the various chips on the device are functional,
    interconnected, and operational as intended.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的针床测试相比，JTAG是一种更简化的测试引脚和调试引脚的方式。它使设备开发人员和测试人员能够确保设备上各个芯片中的每个引脚都能够按预期功能、互连和正常运行。
- en: For penetration testers, JTAG serves a number of purposes, ranging from giving
    us the ability to read/write data and even debug running processes, and modifying
    the program execution flow.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渗透测试人员来说，JTAG有很多用途，从使我们能够读/写数据，甚至调试运行中的进程，到修改程序执行流程。
- en: The four most important pins when we are looking for JTAG are **test data in**
    (**TDI**), **test data out** (**TDO**), **test clock** (**TCK**), and **test mode
    select** (**TMS**). However, even before identifying these individual pinouts,
    which we will do in the next section, we must first identify where  the JTAG headers
    are located on the device.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们寻找JTAG时，最重要的四个焊盘是**测试数据输入**（**TDI**）、**测试数据输出**（**TDO**）、**测试时钟**（**TCK**）和**测试模式选择**（**TMS**）。然而，在识别这些单独的焊盘之前，我们必须首先确定设备上JTAG头部的位置。
- en: 'To make things easier, JTAG comes in a couple of standard interface options
    such as 13 pins, 14 pins, 20 pins, and so on. The following are some of the images
    of JTAG interfaces in real-world devices:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，JTAG有几种标准接口选项，如13针、14针、20针等。以下是一些真实设备中JTAG接口的图像：
- en: '![](img/a571cc13-8bb0-4fd7-99c0-224c36bd5d79.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a571cc13-8bb0-4fd7-99c0-224c36bd5d79.png)'
- en: 'Image source: https://www.dd-wrt.com/wiki/images/thumb/9/99/DLINK-DIR632_Board.png/500px-DLINK-DIR632_Board.png'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：https://www.dd-wrt.com/wiki/images/thumb/9/99/DLINK-DIR632_Board.png/500px-DLINK-DIR632_Board.png
- en: 'Following is the JTAG interface on an Experia v8 Box with the headers for JTAG
    soldered:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Experia v8 Box上的JTAG接口，带有焊接的JTAG头部：
- en: '![](img/e5f1935f-f04b-41bd-8ca6-17c5f62c3b78.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5f1935f-f04b-41bd-8ca6-17c5f62c3b78.png)'
- en: 'Image source: http://www.alfredklomp.com/technology/experia-v8/'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：http://www.alfredklomp.com/technology/experia-v8/
- en: Another important point to note here is that, even though you might be able
    to find the JTAG laid out in the standard header format, in some of the real-world
    devices, you will find the JTAG pins scattered all across the board instead of
    being at a single location. In these cases, you will need to solder headers/jumpers
    on them and connect them to a JTAGulator to be able to identify if they are JTAG
    pinouts, and which pin corresponds to what JTAG pin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还要注意的一点是，即使你可能能够在标准的头部格式中找到JTAG，但在一些真实设备中，你会发现JTAG焊盘分散在整个电路板上，而不是集中在一个位置。在这种情况下，你需要在焊盘上焊接排针/跳线，并将它们连接到JTAGulator上，以便确定它们是否是JTAG焊盘，以及哪个焊盘对应于哪个JTAG焊盘。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from the interfaces and protocols mentioned earlier, there could be many
    other hardware communication protocols that your target device might be using.
    Some of the other popular communication techniques are CAN, PCI, 1-Wire, and so
    on. It would be recommended for you to look into more hardware communication protocols
    to gain a much wider understanding of ways in which you can analyze a protocol.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了之前提到的接口和协议，你的目标设备可能还使用许多其他硬件通信协议。一些其他流行的通信技术包括CAN、PCI、1-Wire等。建议你研究更多的硬件通信协议，以更广泛地了解你可以分析协议的方式。
- en: Serial interfacing for embedded devices
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式设备的串行接口
- en: Since we have already covered the basics of UART in the previous section, let's
    jump into how we can interface with UART interfaces.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在前一节中介绍了UART的基础知识，让我们直接进入如何与UART接口进行交互。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: We will start by looking at how to identify the pins once we have located the
    UART pinouts on a device.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接好，我们将看看如何在设备上找到UART焊盘后如何识别这些焊盘。
- en: 'The four pins that we are trying to find are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的四个焊盘如下：
- en: Tx
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tx
- en: Rx
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rx
- en: GND
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND
- en: Vcc
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vcc
- en: For this, we will use a **multimeter**, which can measure both voltage and current,
    thus acting as both a voltmeter and ammeter, hence the name, multimeter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用**万用表**，它可以测量电压和电流，因此既可以作为电压表又可以作为电流表，因此得名为万用表。
- en: 'The following is what a multimeter looks like. Connect the probes as shown
    in the following image:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是万用表的外观。按照以下图像所示连接探针：
- en: '![](img/f061597a-b724-4541-a1e5-c3ea6437dfd7.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f061597a-b724-4541-a1e5-c3ea6437dfd7.png)'
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once connected, let's go ahead and find the different UART pinouts as described
    in the upcoming steps.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 连接好后，让我们继续找到不同的UART焊盘，就像下面的步骤描述的那样。
- en: 'Make sure that the pointer on the multimeter points to the speaker symbol,
    as shown in the following image:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保万用表上的指针指向扬声器符号，就像下面的图像中所示的那样：
- en: '![](img/b06d22e4-8cd9-4ac9-a6a5-9caa1e456c1c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b06d22e4-8cd9-4ac9-a6a5-9caa1e456c1c.png)'
- en: Ensure that your device is turned off. Place the black probe on a ground surface-this
    could be any metallic surface on the device.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的设备已关闭。将黑色探针放在一个接地表面上——这可以是设备上的任何金属表面。
- en: Place the red probe on each of the four pads, which you think are the UART's,
    individually. Reiterate with the other pads until you hear a beep/buzz sound.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将红色探针分别放在你认为是UART的四个焊盘上。再用其他焊盘重复此操作，直到听到蜂鸣声。
- en: The place where you hear a *BEEP* sound is the GND pin on the device. This test
    is also known as the continuity test, as we just checked for continuity between
    two GND pins-one known and one unknown.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你听到蜂鸣声的地方是设备上的GND焊盘。这个测试也被称为连续性测试，因为我们刚刚检查了两个GND焊盘之间的连续性——一个已知的和一个未知的。
- en: Now that we have identified the GND pin, let's go ahead and identify the other
    remaining pins.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了GND焊盘，让我们继续确定其他剩下的焊盘。
- en: Put the multimeter pointer to the V - 20 position, as now we are going to measure
    the voltage. Keep the black probe to GND and move your red probe over the other
    pins of the UART (other than the GND).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将万用表指针放到V - 20位置，因为现在我们要测量电压。将黑色探针放在GND上，将红色探针移动到UART的其他焊盘上（除了GND）。
- en: At this stage, power cycle the device and turn it on. At the pin where you see
    a constant high voltage is our Vcc pin.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，重新启动设备并打开它。在您看到恒定高电压的引脚处是我们的Vcc引脚。
- en: Next, reboot the device again and measure the voltage between the remaining
    pads and GND (other than the Vcc and GND identified in the previous steps). Due
    to the significant amount of data transfer initially made during boot up, you
    will notice a huge fluctuation in the voltage value on one of the pins during
    the initial 10-15 seconds. This pin will be our Tx pin.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次重新启动设备，并测量除了在前面步骤中确定的Vcc和GND之外的其他引脚与GND之间的电压。由于在启动过程中最初进行的大量数据传输，您将在最初的10-15秒内注意到其中一个引脚上电压值的巨大波动。这个引脚将是我们的Tx引脚。
- en: Rx can be determined by the pin that has the lowest voltage fluctuation and
    the lowest overall value during the entire process.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rx可以通过在整个过程中具有最低电压波动和最低整体值的引脚来确定。
- en: Thus, we have identified all the pins required for a UART communication-Tx and
    Rx, as well as GND and Vcc.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经确定了UART通信所需的所有引脚-Tx和Rx，以及GND和Vcc。
- en: Once you have identified the pinouts of the device, the next step would be to
    connect the device's UART pins to Attify Badge. You can also use other devices
    in place of Attify Badge here, such as a USB-TTL or Adafruit FT232H.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您确定了设备的引脚布局，下一步将是将设备的UART引脚连接到Attify Badge。在这里，您也可以使用其他设备代替Attify Badge，例如USB-TTL或Adafruit
    FT232H。
- en: The pins on Attify Badge that we will be concerned with at this point in time
    are D0 and D1, which correspond to Transmit and Receive respectively.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将关注Attify Badge上的引脚D0和D1，分别对应于发送和接收。
- en: The target device's **Transmit** (**Tx**) would go to Attify Badge's Rx (D0)
    and the Rx of the target device will go to the Tx (D1) of Attify Badge. The GND
    of the IP camera would be connected to the Attify Badge's GND.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 目标设备的**发送**（**Tx**）将连接到Attify Badge的Rx（D0），并且目标设备的Rx将连接到Attify Badge的Tx（D1）。IP摄像头的GND将连接到Attify
    Badge的GND。
- en: Once we have made all the connections, the next step is to figure out the baudrate
    on which the device operates. Connect the Attify Badge to the system and power
    on the target device.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有连接，下一步就是找出设备运行的波特率。将Attify Badge连接到系统并启动目标设备。
- en: To identify the baudrate, we will use the `baudrate.py` utility available at
    [https://github.com/devttys0/baudrate/blob/master/baudrate.py](https://github.com/devttys0/baudrate/blob/master/baudrate.py).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别波特率，我们将使用[https://github.com/devttys0/baudrate/blob/master/baudrate.py](https://github.com/devttys0/baudrate/blob/master/baudrate.py)上可用的`baudrate.py`实用程序。
- en: 'This could be run using the following command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过以下命令运行：
- en: '[PRE0]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you are in the baudrate, screen, you can use the up and down arrow keys
    to switch baudrates. At the baudrate if you are able to see readable characters,
    that is the correct baudrate for your target device. It should look something
    like the following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您进入波特率、屏幕，您可以使用上下箭头键切换波特率。在波特率处，如果您能够看到可读字符，那就是您目标设备的正确波特率。它应该看起来像以下屏幕截图：
- en: '![](img/a58f2f84-6507-4277-b250-cfd6e0db41b7.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a58f2f84-6507-4277-b250-cfd6e0db41b7.png)'
- en: 'Next, hit *Ctrl* + *C*, which will take you to the minicom utility using the
    identified settings. Hitting *Enter* here would grant you shell access, given
    that your target device has a UART-based shell:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按下*Ctrl* + *C*，这将使用已识别的设置将您带到minicom实用程序。在这里按下*Enter*将授予您shell访问权限，前提是您的目标设备具有基于UART的shell：
- en: '![](img/b6fd8d08-8df1-4b6c-9b30-58929f0a3a49.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6fd8d08-8df1-4b6c-9b30-58929f0a3a49.png)'
- en: Thus, we were able to exploit the exposed UART interface, figure out the pinouts
    and interface with it, and finally get a root shell.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够利用暴露的UART接口，找出引脚和接口，并最终获得root shell。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Now that you have access to the UART interface of your target device, you can
    also perform additional exploitation techniques such as backdooring and dumping
    the entire file system over **trivial file transfer protocol** (**TFTP**). This,
    however, would vary from device to device and would be dependent on the current
    privileges you have on the device that you have compromised.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在您已经可以访问目标设备的UART接口，还可以执行其他利用技术，例如后门和通过**微不足道的文件传输协议**（**TFTP**）转储整个文件系统。但是，这将因设备而异，并取决于您在已经受到攻击的设备上拥有的当前特权。
- en: NAND glitching
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NAND故障
- en: One of the other things which you can perform on embedded devices to bypass
    security measures (such as no root shell on UART console) is to take advantage
    of glitching-based attacks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以在嵌入式设备上执行的另一件事情是利用基于故障的攻击来绕过安全措施（例如UART控制台上没有root shell）。 '
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Glitching, as the name suggests, is a way of introducing faults in the system
    that you are working with. This could be done in a number of various ways and
    there are separate books and research papers written solely on this topic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 故障，顾名思义，是一种在您正在使用的系统中引入故障的方法。这可以通过多种方式完成，有专门的书籍和研究论文专门讨论这个主题。
- en: For now, we will be looking at a very basic glitching-based attack overview.
    The goal of this is to be able to access the bootloader, which will allow us to
    change sensitive parameters such as the boot up args, where we can define our
    own arguments to tell the system to launch the UART console with a login prompt/shell
    or boot the system in a single user mode bypassing authentication.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要介绍基于故障的攻击概述。这样做的目的是能够访问引导加载程序，这将允许我们更改敏感参数，例如启动参数，我们可以定义自己的参数，告诉系统启动UART控制台并带有登录提示/
    shell或以单用户模式启动系统，绕过身份验证。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The glitch that we will look at here is called **NAND glitching**, where we
    will short one of the I/O pins of our device's NAND flash to a GND pin. Note that
    this shorting has to be performed at the very moment when the bootloader has booted
    and the kernel is about to boot up.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里看一下的故障称为**NAND故障**，在这种故障中，我们将把设备的NAND闪存的一个I/O引脚短接到GND引脚。请注意，这种短接必须在引导加载程序启动并内核即将启动的那一刻执行。
- en: Consequently, if the shorting works, the kernel will fail to boot, thus causing
    you to drop to the default bootloader prompt, enabling you to change the bootloader
    parameters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果短接成功，内核将无法启动，从而导致您陷入默认的引导加载程序提示，使您能够更改引导加载程序参数。
- en: 'To give an example of what you can do with bootloader access, adding `single`
    to the boot up args will enable you to log in to the single user mode, thus bypassing
    the requirements of authentication on some systems. This is also shown in the
    following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举个例子，通过在启动参数中添加`single`，您将能够登录到单用户模式，从而绕过某些系统上的身份验证要求。这也在下面的屏幕截图中显示：
- en: '![](img/fc3295d7-d0ed-4124-ad13-1a57b0c43016.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc3295d7-d0ed-4124-ad13-1a57b0c43016.png)'
- en: 'Image source: http://console-cowboys.blogspot.com/2013/01/swann-song-dvr-insecurity.html'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：http://console-cowboys.blogspot.com/2013/01/swann-song-dvr-insecurity.html
- en: 'Similarly, performing the same NAND glitch on Wink Hub will result in dropping
    to the bootloader (discovered by the team at `Exploitee.rs` ), where you can change
    the arguments as shown in the following screenshot:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在Wink Hub上执行相同的NAND故障将导致陷入引导加载程序（由`Exploitee.rs`团队发现），您可以更改参数，如下面的屏幕截图所示：
- en: '![](img/36dc0849-e954-4ec8-816c-f2570c056ed4.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36dc0849-e954-4ec8-816c-f2570c056ed4.png)'
- en: 'Once you modify the boot arguments, you will be able to gain access to the
    root shell on the next boot via UART, as shown in the following screenshot:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改引导参数后，您将能够在下一次引导时通过UART访问根shell，如下面的屏幕截图所示：
- en: '![](img/e2c2773f-5ddc-47bb-aab9-dce2f3da4455.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c2773f-5ddc-47bb-aab9-dce2f3da4455.png)'
- en: 'Image source: http://www.brettlischalk.com/assets/WinkHack/WinkRootShell.png'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：http://www.brettlischalk.com/assets/WinkHack/WinkRootShell.png
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: NAND glitching is one of the techniques where we take advantage of glitching-based
    attacks. However, you can also use power and voltage glitching techniques to perform
    things such as bypassing crypto and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: NAND故障是利用故障攻击的技术之一。然而，您也可以使用电源和电压故障技术来执行诸如绕过加密等操作。
- en: 'Some additional useful resources are mentioned as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他有用的资源：
- en: '[https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf](https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf](https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf)'
- en: '[https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf](https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf](https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf)'
- en: '[https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf](https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf](https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf)'
- en: JTAG debugging and exploitation
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JTAG调试和利用
- en: Now that we have covered various exploitation techniques on hardware devices,
    it is time to cover one of the most important methods to compromise a device-JTAG.
    We have already seen what JTAG is and what JTAG pins usually look like.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了硬件设备上的各种利用技术，是时候介绍一种最重要的妥协设备的方法-JTAG了。我们已经看到了JTAG是什么，JTAG引脚通常是什么样子。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's get started with identifying the JTAG pinouts on our given target device.
    For this, we will use JTAGulator, which is a hardware tool built by *Joe Grande*
    to identify JTAG pinouts.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始识别给定目标设备上的JTAG引脚。为此，我们将使用JTAGulator，这是由*Joe Grande*制作的硬件工具，用于识别JTAG引脚。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Once you have connected all the JTAGulator channels to the expected JTAG pinouts
    on the target device, additionally connecting the GND to GND.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将所有JTAGulator通道连接到目标设备上预期的JTAG引脚，另外连接GND到GND。
- en: 'Launch the screen using the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码启动屏幕：
- en: '[PRE1]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you will be granted with a JTAGulator prompt, as shown in the following
    screenshot:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将获得一个JTAGulator提示，如下面的屏幕截图所示：
- en: '![](img/d2dbcf43-e00d-454e-b5a9-f6420da6a08a.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2dbcf43-e00d-454e-b5a9-f6420da6a08a.png)'
- en: 'The first thing that we will do here is set our target device''s voltage, which
    in the current scenario is 3.3\. To do this, simply type `V` followed by `3.3`
    as shown in the following screenshot:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置目标设备的电压，在当前情况下是3.3。要做到这一点，只需在屏幕上输入`V`，然后输入`3.3`，如下面的屏幕截图所示：
- en: '![](img/bca14d5f-2b80-419d-b111-fb0a303d5508.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bca14d5f-2b80-419d-b111-fb0a303d5508.png)'
- en: Once we have set the target voltage, we can then run a bypass scan by hitting
    *B* to figure out the JTAG pins in our current connection.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置目标电压后，我们可以通过按下*B*来运行一个旁路扫描，以找出当前连接中的JTAG引脚。
- en: '![](img/a8d393cf-f317-4ead-b8cb-a44647eb262c.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8d393cf-f317-4ead-b8cb-a44647eb262c.png)'
- en: As you can see, JTAGulator was able to identify the JTAG pinouts and tell us
    what the individual pins correspond to.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，JTAGulator能够识别JTAG引脚，并告诉我们各个引脚对应的是什么。
- en: 'Now that we have identified the pinouts, the next step is to connect the pinouts
    to Attify Badge (or FTDI C232HM MPSSE cable) as shown next:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经确定了引脚布局，下一步是将引脚布局连接到Attify Badge（或FTDI C232HM MPSSE电缆），如下所示：
- en: The TDI of the target goes to the D1(TDI) of Attify Badge (or the Yellow of
    the FTDI cable)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标的TDI连接到Attify Badge（或FTDI电缆的黄色）的D1（TDI）
- en: The TDO of the target goes to the D2 (TDO) of Attify Badge (or the Green of
    the FTDI cable)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标的TDO连接到Attify Badge（或FTDI电缆的绿色）的D2（TDO）
- en: The TMS of the target goes to the D3 (TMS) of Attify Badge (or the Brown of
    the FTDI cable)
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标的TMS连接到Attify Badge（或FTDI电缆的棕色）的D3（TMS）
- en: The TCK of the target goes to the D0 (TCK) of Attify Badge (or the Orange of
    the FTDI cable)
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标的TCK连接到Attify Badge（或FTDI电缆的橙色）的D0（TCK）
- en: Once you have made the required connections, the next step is to run OpenOCD
    using the configuration files for Attify Badge (or the FTDI C232HM MPSSE cable)
    and the target device's chip. The configuration files can be obtained from the
    `OpenOCD` directory after installation and are located at `openocd/tcl/target`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您完成了所需的连接，下一步就是使用Attify Badge（或FTDI C232HM MPSSE电缆）的配置文件以及目标设备的芯片运行OpenOCD。配置文件可以在安装后从`OpenOCD`目录中获取，并位于`openocd/tcl/target`。
- en: 'OpenOCD can be run as shown in the following screenshot:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenOCD可以按照以下截图所示运行：
- en: '![](img/ba0145d1-6b71-450e-8049-bf31a89c68fc.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0145d1-6b71-450e-8049-bf31a89c68fc.png)'
- en: 'As you can see, OpenOCD has identified both the devices in the chain and it
    has also enabled Telnet on port `4444`, which we can now connect to, as shown
    in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，OpenOCD已经识别出链中的两个设备，并且还在端口`4444`上启用了Telnet，我们现在可以连接到该端口，如下截图所示：
- en: '![](img/2dce679f-6465-47d2-b18d-15a826d1e49b.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dce679f-6465-47d2-b18d-15a826d1e49b.png)'
- en: At this step, you can perform all the various OpenOCD commands, as well as the
    commands specific to your given chip, in order to compromise the device.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，您可以执行各种OpenOCD命令，以及针对您的特定芯片的命令，以便妥协设备。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Some of the things you can do with the ability to access a device over JTAG
    are reading data from a given memory location using the `mdw` command as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`mdw`命令从给定内存位置读取数据，您可以利用通过JTAG访问设备的能力做一些事情，如下所示：
- en: '![](img/b6c226f3-a33f-4f3d-b158-9c9fe9fb65cb.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6c226f3-a33f-4f3d-b158-9c9fe9fb65cb.png)'
- en: Another example would be to connect to GDB to debug running processes by connecting
    to the running instance over port `3333`, and performing ARM/MIPS exploitation
    using the skills we have learned in the previous chapters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是通过连接到端口`3333`上运行的实例，使用我们在前几章学到的技能来连接到GDB以调试运行中的进程，并进行ARM/MIPS利用。
